boolean isReadOnly ( ) { return hasOption ( "ro" ) ; }
public TdApi . SuggestedAction [ ] getSuggestedActions ( ) { synchronized ( dataLock ) { return suggestedActions . toArray ( new TdApi . SuggestedAction [ 0 ] ) ; } }
public float getBottomRightCutSizeDp ( ) { return pxToDp ( getBottomRightCutSize ( ) ) ; }
public static void setPackageNameForResDir ( String packageName , String resDir ) { synchronized ( sResDirPackageNames ) { sResDirPackageNames . put ( resDir , packageName ) ; } }
public static String formatTime ( Date date ) { return time_sdf . get ( ) . format ( date ) ; }
public String [ ] otherTonesForEmoji ( String emojiCode ) { String [ ] otherTones = otherColors . get ( emojiCode ) ; return otherTones == null || otherTones . length == 0 ? null : otherTones ; }
public Builder setController ( java . lang . String value ) { if ( value == null ) { throw new NullPointerException ( ) ; } bitField0_ |= 0x00000001 ; controller_ = value ; onChanged ( ) ; return this ; }
public void updateIdentityProvider ( IdentityProviderModel identityProvider ) { runOnRealm ( session , this , ( session ) -> { session . identityProviders ( ) . update ( identityProvider ) ; return null ; } ) ; }
public LinkedHashMap < K , V > data ( ) { return _data ; }
public RemoteViewsFactory onGetViewFactory ( Intent intent ) { return ( new TodoWidgetRemoteViewsFactory ( getApplicationContext ( ) , intent ) ) ; }
private void moveAsk ( final ArrayList < MessageTarget > result , boolean undo ) { if ( result . size ( ) == 0 ) return ; if ( undo ) { moveUndo ( result ) ; return ; } String key = ( result . size ( ) == 1 ? "move_1_confirmed" : "move_n_confirmed" ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( getContext ( ) ) ; if ( prefs . getBoolean ( key , false ) ) { moveUndo ( result ) ; return ; } Bundle aargs = new Bundle ( ) ; aargs . putString ( "notagain" , key ) ; aargs . putParcelableArrayList ( "result" , result ) ; FragmentMoveAsk ask = new FragmentMoveAsk ( ) ; ask . setArguments ( aargs ) ; ask . setTargetFragment ( FragmentMessages . this , REQUEST_ASKED_MOVE ) ; ask . show ( getParentFragmentManager ( ) , "messages:move" ) ; }
public String getErrorMessage ( ) { return errorMessage ; }
protected static int nativeGetResourceValue ( long ptr , @ AnyRes int resid , short density , @ Nonnull TypedValue typed_value , boolean resolve_references ) { return PerfStatsCollector . getInstance ( ) . measure ( "binary nativeGetResourceValue" , ( ) -> { CppAssetManager2 assetmanager = AssetManagerFromLong ( ptr ) ; final Ref < Res_value > value = new Ref < > ( null ) ; final Ref < ResTable_config > selected_config = new Ref < > ( null ) ; final Ref < Integer > flags = new Ref < > ( 0 ) ; ApkAssetsCookie cookie = assetmanager . GetResource ( resid , false , density , value , selected_config , flags ) ; if ( cookie . intValue ( ) == kInvalidCookie ) { return ApkAssetsCookieToJavaCookie ( K_INVALID_COOKIE ) ; } final Ref < Integer > ref = new Ref < > ( resid ) ; if ( resolve_references ) { cookie = assetmanager . ResolveReference ( cookie , value , selected_config , flags , ref ) ; if ( cookie . intValue ( ) == kInvalidCookie ) { return ApkAssetsCookieToJavaCookie ( K_INVALID_COOKIE ) ; } } return CopyValue ( cookie , value . get ( ) , ref . get ( ) , flags . get ( ) , selected_config . get ( ) , typed_value ) ; } ) ; }
private void setWatermarkConfig ( Properties properties ) { String watermarkTxt = properties . getProperty ( "watermark.txt" , WatermarkConfigConstants . DEFAULT_WATERMARK_TXT ) ; String watermarkXSpace = properties . getProperty ( "watermark.x.space" , WatermarkConfigConstants . DEFAULT_WATERMARK_X_SPACE ) ; String watermarkYSpace = properties . getProperty ( "watermark.y.space" , WatermarkConfigConstants . DEFAULT_WATERMARK_Y_SPACE ) ; String watermarkFont = properties . getProperty ( "watermark.font" , WatermarkConfigConstants . DEFAULT_WATERMARK_FONT ) ; String watermarkFontsize = properties . getProperty ( "watermark.fontsize" , WatermarkConfigConstants . DEFAULT_WATERMARK_FONTSIZE ) ; String watermarkColor = properties . getProperty ( "watermark.color" , WatermarkConfigConstants . DEFAULT_WATERMARK_COLOR ) ; String watermarkAlpha = properties . getProperty ( "watermark.alpha" , WatermarkConfigConstants . DEFAULT_WATERMARK_ALPHA ) ; String watermarkWidth = properties . getProperty ( "watermark.width" , WatermarkConfigConstants . DEFAULT_WATERMARK_WIDTH ) ; String watermarkHeight = properties . getProperty ( "watermark.height" , WatermarkConfigConstants . DEFAULT_WATERMARK_HEIGHT ) ; String watermarkAngle = properties . getProperty ( "watermark.angle" , WatermarkConfigConstants . DEFAULT_WATERMARK_ANGLE ) ; WatermarkConfigConstants . setWatermarkTxtValue ( watermarkTxt ) ; WatermarkConfigConstants . setWatermarkXSpaceValue ( watermarkXSpace ) ; WatermarkConfigConstants . setWatermarkYSpaceValue ( watermarkYSpace ) ; WatermarkConfigConstants . setWatermarkFontValue ( watermarkFont ) ; WatermarkConfigConstants . setWatermarkFontsizeValue ( watermarkFontsize ) ; WatermarkConfigConstants . setWatermarkColorValue ( watermarkColor ) ; WatermarkConfigConstants . setWatermarkAlphaValue ( watermarkAlpha ) ; WatermarkConfigConstants . setWatermarkWidthValue ( watermarkWidth ) ; WatermarkConfigConstants . setWatermarkHeightValue ( watermarkHeight ) ; WatermarkConfigConstants . setWatermarkAngleValue ( watermarkAngle ) ; }
public static Logger getLogger ( Class < ? > clazz ) { return CACHE . computeIfAbsent ( clazz , Logger :: new ) ; }
public A setToConditions ( int index , V1Condition item ) { if ( this . conditions == null ) { this . conditions = new ArrayList ( ) ; } V1ConditionBuilder builder = new V1ConditionBuilder ( item ) ; if ( index < 0 || index >= conditions . size ( ) ) { _visitables . get ( "conditions" ) . add ( builder ) ; conditions . add ( builder ) ; } else { _visitables . get ( "conditions" ) . add ( builder ) ; conditions . set ( index , builder ) ; } return ( A ) this ; }
public final AlterSequenceImpl < T > noMinvalue ( ) { this . noMinvalue = true ; return this ; }
private static XWPFRun createHyperlink ( XWPFRun run , String url ) { XWPFParagraphWrapper paragraph = new XWPFParagraphWrapper ( ( XWPFParagraph ) run . getParent ( ) ) ; XWPFRun hyperlink = paragraph . insertNewHyperLinkRun ( run , url ) ; StyleUtils . styleRun ( hyperlink , run ) ; run . setText ( "" , 0 ) ; return hyperlink ; }
public void setOrderDate ( Date orderDate ) { this . orderDate = orderDate ; }
public String toString ( ) { return this . getClass ( ) . getSimpleName ( ) + " " + Bytes . toStringBinary ( this . prefix ) ; }
public RoaringBitmap RoaringWithRun ( BenchmarkState benchmarkState ) { RoaringBitmap answer = RoaringBitmap . or ( benchmarkState . rc . iterator ( ) ) ; return answer ; }
public void setProgressCornerRadius ( int radius ) { this . mCornerRadius = DensityUtils . dp2px ( getContext ( ) , radius ) ; refreshTheView ( ) ; }
public SiteBody tlsDisabled ( Boolean tlsDisabled ) { this . tlsDisabled = tlsDisabled ; return this ; }
public ImportResult getDryrunResult ( ) { return dryrunResult ; }
public void setRelateType ( String relateType ) { this . relateType = relateType ; }
public int compareTo ( ScenarioResult sr ) { if ( sr == null ) { return 1 ; } int delta = scenario . getLine ( ) - sr . scenario . getLine ( ) ; if ( delta != 0 ) { return delta ; } return scenario . getExampleIndex ( ) - sr . scenario . getExampleIndex ( ) ; }
public boolean canToggleContentProtection ( long chatId ) { return haveCreatorRights ( chatId ) ; }
public Integer getConfigLabelId ( ) { return configLabelId ; }
public static Collection createCollection ( Class targetClass ) { if ( targetClass . isInterface ( ) ) { if ( targetClass == List . class || targetClass == Collection . class ) { return new ArrayList < > ( ) ; } if ( targetClass == Set . class ) { return new HashSet < > ( ) ; } if ( targetClass == SortedSet . class ) { return new LinkedHashSet < > ( ) ; } if ( targetClass == Queue . class || targetClass == Deque . class ) { return new LinkedList < > ( ) ; } } else if ( Collection . class . isAssignableFrom ( targetClass ) ) { if ( targetClass == ArrayList . class ) { return new ArrayList < > ( ) ; } if ( targetClass == LinkedList . class ) { return new LinkedList ( ) ; } if ( targetClass == HashSet . class ) { return new HashSet < > ( ) ; } if ( targetClass == LinkedHashSet . class ) { return new LinkedHashSet < > ( ) ; } if ( ! Modifier . isAbstract ( targetClass . getModifiers ( ) ) ) { try { Constructor sizeCt = null ; for ( Constructor ct : targetClass . getConstructors ( ) ) { switch ( ct . getParameterCount ( ) ) { case 0 : return ( Collection ) ct . newInstance ( ) ; case 1 : if ( ct . getParameterTypes ( ) [ 0 ] == int . class ) { sizeCt = ct ; } break ; default : } } if ( sizeCt != null ) { return ( Collection ) sizeCt . newInstance ( 16 ) ; } } catch ( Exception ignored ) { } } } throw new IllegalArgumentException ( "Unsupported collection type: " + targetClass . getName ( ) ) ; }
public void setAutoIncrement ( boolean autoIncrement ) { this . autoIncrement = autoIncrement ; }
public void register ( Application application ) { if ( application == null ) { return ; } application . registerActivityLifecycleCallbacks ( this ) ; }
float getYFloat ( ) ; VectorInterface transform ( Transform tr ) ; VectorInterface add ( VectorInterface a ) ; VectorInterface div ( int d ) ; VectorFloat mul ( float m ) ; VectorInterface sub ( VectorInterface a ) ; VectorFloat norm ( ) ; Vector round ( ) ; VectorFloat toFloat ( ) ; float len ( ) ; VectorInterface getOrthogonal ( ) ; default float scalar ( VectorInterface v ) { return getXFloat ( ) * v . getXFloat ( ) + getYFloat ( ) * v . getYFloat ( ) ; }
public void onCheckedChanged ( CompoundButton compoundButton , boolean isChecked ) { rule . other_blocked = isChecked ; updateRule ( context , rule , true , listAll ) ; }
public int getColumnCount ( ) throws SQLException { return _totalColumns ; }
private static String getDataPath ( Properties props ) { String returnPath = props . getProperty ( "coref.data" , "/u/nlp/data/coref/conll-2012/" ) ; if ( ! returnPath . endsWith ( "/" ) ) { returnPath += "/" ; } return returnPath ; }
public int getCropDirection ( ) { return arcHeightPx > 0 ? CROP_OUTSIDE : CROP_INSIDE ; }
public Limit getLimit ( ) { return limit ; }
private static boolean isCpu64Bit ( ) { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) { for ( String abi : Build . SUPPORTED_ABIS ) { if ( abi . contains ( "64" ) ) return true ; } } return false ; }
default long size ( ) { return writes ( ) - reads ( ) ; }
public static String getPrefFilterAllEpisodes ( ) { return prefs . getString ( PREF_FILTER_ALL_EPISODES , "" ) ; }
public boolean onInterceptTouchEvent ( MotionEvent ev ) { if ( ! enableDrag ) return super . onInterceptTouchEvent ( ev ) ; boolean result = dragHelper . shouldInterceptTouchEvent ( ev ) ; return dragHelper . shouldInterceptTouchEvent ( ev ) || canIntercept ; }
static FromArrayBuiltinVectorNode build ( ) { return FromArrayBuiltinVectorNodeGen . create ( ) ; }
public Builder setNamespace ( java . lang . String value ) { if ( value == null ) { throw new NullPointerException ( ) ; } bitField0_ |= 0x00000004 ; namespace_ = value ; onChanged ( ) ; return this ; }
public static SearchFailureBuilder builder ( Throwable reason ) { return new SearchFailureBuilder ( reason ) ; }
private void upgradeToV10 ( ) { log . info ( "Upgrading to v10: Adding downloaderProgress column to history table" ) ; try ( Statement stmt = connection . createStatement ( ) ) { stmt . executeUpdate ( "ALTER TABLE history ADD COLUMN downloaderProgress DOUBLE NULL" ) ; } catch ( SQLException e ) { log . warn ( "Failed to add downloaderProgress column (may already exist): {}" , e . getMessage ( ) ) ; } }
public long inverseCumProb ( double cumProb ) { return ( long ) ( start + ( totalCount - 1 ) * cumProb ) ; }
private List < Descriptor > buildAllDescriptorsForDescriptorFile ( byte [ ] descriptorFile ) throws IOException , DescriptorValidationException { FileDescriptorSet fileDescriptorSet = FileDescriptorSet . parseFrom ( descriptorFile ) ; List < FileDescriptor > fileDescriptorsWithDependencies = new ArrayList < > ( ) ; for ( FileDescriptorProto protoDescriptorFile : fileDescriptorSet . getFileList ( ) ) { FileDescriptor fd = FileDescriptor . buildFrom ( protoDescriptorFile , fileDescriptorsWithDependencies . toArray ( new FileDescriptor [ fileDescriptorsWithDependencies . size ( ) ] ) ) ; fileDescriptorsWithDependencies . add ( fd ) ; } return fileDescriptorsWithDependencies . stream ( ) . flatMap ( desc -> desc . getMessageTypes ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) ; }
public void mouseMoved ( MouseEvent e ) { lastX = e . getX ( ) + getX ( ) ; lastY = e . getY ( ) + getY ( ) ; float oldOpacity = getOpacity ( ) ; setOpacity ( 0 ) ; if ( SystemInfo . isMacOS ) robot . delay ( 20 ) ; Color color = robot . getPixelColor ( lastX , lastY ) ; setOpacity ( oldOpacity ) ; hover ( color ) ; magnifier . update ( lastX , lastY , color ) ; }
protected void onExecuted ( Bundle args , Void data ) { FragmentDialogSync sync = new FragmentDialogSync ( ) ; sync . setArguments ( args ) ; sync . show ( getParentFragmentManager ( ) , "folder:months" ) ; }
@ Override public void onCompleted ( ) { for ( EventListener listener : this ) { listener . onCompleted ( ) ; } }
public Object get ( Object obj ) throws IllegalArgumentException { return Boolean . valueOf ( getBoolean ( obj ) ) ; }
public HashMap < String , String > getParams ( ) { insertWheres ( ) ; insertOrders ( ) ; System . out . println ( params . toString ( ) ) ; return super . getParams ( ) ; }
private int peek ( ) { if ( stackSize == 0 ) { throw new IllegalStateException ( "JsonWriter is closed." ) ; } return stack [ stackSize - 1 ] ; }
public static String getClassName ( Class < ? > clazz , boolean isSimple ) { if ( null == clazz ) { return null ; } return isSimple ? clazz . getSimpleName ( ) : clazz . getName ( ) ; }
public int getCount ( ) { return mData . size ( ) ; }
List < RowMetaAndData > getTestRowMetaAndData ( int count , Integer [ ] nulls ) { List < RowMetaAndData > list = new ArrayList < RowMetaAndData > ( ) ; RowMetaInterface rm = new RowMeta ( ) ; rm . addValueMeta ( new ValueMetaString ( KEY1 ) ) ; rm . addValueMeta ( new ValueMetaInteger ( KEY2 ) ) ; rm . addValueMeta ( new ValueMetaNumber ( KEY3 ) ) ; rm . addValueMeta ( new ValueMetaBigNumber ( KEY4 ) ) ; Object [ ] row = new Object [ 4 ] ; List < Integer > nullsList = Arrays . asList ( nulls ) ; for ( int i = 0 ; i < count ; i ++ ) { if ( nullsList . contains ( i ) ) { for ( int j = 0 ; j < row . length ; j ++ ) { row [ j ] = null ; } } else { row [ 0 ] = "" ; row [ 1 ] = 1L ; row [ 2 ] = 2.0 ; row [ 3 ] = new BigDecimal ( 3 ) ; } list . add ( new RowMetaAndData ( rm , row ) ) ; } return list ; }
public void beforeRender ( DhApiCancelableEventParam < DhApiRenderParam > event ) { if ( ShadowRenderingState . areShadowsCurrentlyBeingRendered ( ) && ( ! getInstance ( ) . shouldOverrideShadow ) ) { event . cancelEvent ( ) ; } }
public static < T > T loadFactory ( Class < T > clazz ) { T factory = loadFactoryOrNull ( clazz ) ; if ( factory == null ) { throw new IllegalStateException ( "Cannot find META-INF/services/" + clazz . getName ( ) + " on classpath" ) ; } return factory ; }
private boolean hasContextId ( JSONObject params ) { try { params . getInt ( PARAM_CONTEXT_ID ) ; } catch ( JSONException ex ) { return false ; } return true ; }
TemporalColumn < T > emptyCopy ( ) ; default LongColumn differenceInMilliseconds ( TemporalColumn < T > column2 ) { return difference ( column2 , ChronoUnit . MILLIS ) ; }
public TableListing build ( ) { return new TableListing ( columns . toArray ( new Column [ 0 ] ) , showHeader , wrapWidth ) ; }
public void showLoading ( ) { super . showLoading ( ) ; if ( itemsList != null ) { animateHideRecyclerViewAllowingScrolling ( itemsList ) ; } }
public void getIconPacks ( @ NonNull RunnableData < List < Settings . IconPack > > callback ) { fetchCloudSettings ( callback , "#icons" , ( ) -> Settings . instance ( ) . getIconPack ( ) , Settings . IconPack :: new , Settings . IconPack :: new ) ; }
public int lengthOfDecimal ( ) { return object ( ) + 2 * primitive2 ( ) + lengthOfBigInteger ( ) ; }
public boolean insert ( String xml ) { try { m_config = DefaultSaxParser . parse ( xml ) ; boolean result = storeConfig ( ) ; return result ; } catch ( Exception e ) { Cat . logError ( e ) ; m_logger . error ( e . getMessage ( ) , e ) ; return false ; } }
protected TableMeta getTableMeta ( String tableName ) { if ( tableMeta != null ) { return tableMeta ; } ConnectionProxy connectionProxy = statementProxy . getConnectionProxy ( ) ; tableMeta = TableMetaCacheFactory . getTableMetaCache ( connectionProxy . getDbType ( ) ) . getTableMeta ( connectionProxy . getTargetConnection ( ) , tableName , connectionProxy . getDataSourceProxy ( ) . getResourceId ( ) ) ; return tableMeta ; }
public boolean valueSizeOffsetInit ( ) { return ( this . valueSizeOffset ) != ( - 1 ) ; }
public String getNameEn ( ) { return nameEn ; }
static FormattingTuple format ( final String messagePattern , @ Nullable Object argA , @ Nullable Object argB ) { return arrayFormat ( messagePattern , new Object [ ] { argA , argB } ) ; }
public long getInstanceCount ( ) { return instanceCount ; }
public void setSiteMail ( String siteMail ) { this . siteMail = siteMail ; }
public void setVideoBytesReceived ( BigInteger videoBytesReceivedDelta ) { this . videoBytesReceived = videoBytesReceivedDelta ; }
Lexeme pollFirst ( ) { if ( this . size == 1 ) { Lexeme first = this . head . lexeme ; this . head = null ; this . tail = null ; this . size -- ; return first ; } else if ( this . size > 1 ) { Lexeme first = this . head . lexeme ; this . head = this . head . next ; this . size -- ; return first ; } else { return null ; } }
public com . google . protobuf . ByteString getHostnameBytes ( ) { java . lang . Object ref = hostname_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; hostname_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } }
public void setContactAddress ( String contactAddress ) { if ( ! initialized ) init ( ) ; contactAddressField . setText ( contactAddress ) ; }
public boolean dispatchKeyShortcutEvent ( @ NonNull KeyEvent event ) { return mDialog . dispatchKeyShortcutEvent ( event ) ; }
public static boolean isAsciiEncoding ( final String encoding ) { return "US_ASCII" . equals ( STD_CHARSETS . get ( encoding ) ) ; }
public boolean isKingBase ( ) { return isKingBase ( gainSQLDatabase ( ) ) ; }
default void read ( FileSourceSplit split , Collector < SeaTunnelRow > output ) throws IOException , FileConnectorException { read ( split . getFilePath ( ) , split . getTableId ( ) , output ) ; }
public io . kubernetes . client . proto . V1Networking . NetworkPolicyPort getDefaultInstanceForType ( ) { return DEFAULT_INSTANCE ; }
private static ErrorHandling getErrorHandlingAnnotation ( AnnotatedElement element ) { ErrorHandling annotation = element . getAnnotation ( ErrorHandling . class ) ; if ( annotation == null ) { for ( Annotation metaAnnotation : element . getAnnotations ( ) ) { annotation = metaAnnotation . annotationType ( ) . getAnnotation ( ErrorHandling . class ) ; if ( annotation != null ) { break ; } } } return annotation ; }
public void setServerSocketFactory ( ServerSocketFactory factory ) { if ( factory == null ) { _serverSocketFactory_ = __DEFAULT_SERVER_SOCKET_FACTORY ; } else { _serverSocketFactory_ = factory ; } }
public void setShipCity ( String shipCity ) { this . shipCity = shipCity ; }
public synchronized int maxClusterInterBrokerPartitionMovements ( ) { return _requestedClusterInterBrokerPartitionMovementConcurrency == null ? _defaultClusterInterBrokerPartitionMovementConcurrency : _requestedClusterInterBrokerPartitionMovementConcurrency ; }
private ProxyExcludedDomainsTableModel getProxyExcludedDomainsTableModel ( ) { if ( proxyExcludedDomainsTableModel == null ) { proxyExcludedDomainsTableModel = new ProxyExcludedDomainsTableModel ( ) ; } return proxyExcludedDomainsTableModel ; }
public Map < String , Object > getMappedConfig ( ) { return mappedConfig ; }
public void setParentProjectPath ( @ Nullable String parentProjectPath ) { this . parentProjectPath = parentProjectPath ; }
List < String > getIncludes ( ) { return includes ; }
public boolean absolute ( int row ) throws SQLException { throw new SQLException ( "ResultSet is TYPE_FORWARD_ONLY" ) ; }
public static ChangelogDialog create ( ) { return new ChangelogDialog ( ) ; }
public String apiFileFolder ( ) { String pkgPath = apiPackage ( ) . replace ( '.' , File . separatorChar ) ; return pythonSrcOutputFolder ( ) + pkgPath ; }
public static DiscardCompressedFileInfo discardCompressedFileInfoFromResultSet ( ResultSet rs ) throws SQLException { return DiscardCompressedFileInfo . newBuilder ( ) . setFilePath ( rs . getString ( "file_path" ) ) . setTablePath ( rs . getString ( "table_path" ) ) . setPartitionDesc ( rs . getString ( "partition_desc" ) ) . setTimestamp ( rs . getLong ( "timestamp" ) ) . setTDate ( rs . getString ( "t_date" ) ) . build ( ) ; }
public void onYearChange ( int year ) { mTextMonthDay . setText ( String . valueOf ( year ) ) ; }
public int hashCode ( ) { if ( memoizedHashCode != 0 ) { return memoizedHashCode ; } int hash = 41 ; hash = ( 19 * hash ) + getDescriptor ( ) . hashCode ( ) ; if ( hasPath ( ) ) { hash = ( 37 * hash ) + PATH_FIELD_NUMBER ; hash = ( 53 * hash ) + getPath ( ) . hashCode ( ) ; } if ( hasPathType ( ) ) { hash = ( 37 * hash ) + PATHTYPE_FIELD_NUMBER ; hash = ( 53 * hash ) + getPathType ( ) . hashCode ( ) ; } if ( hasBackend ( ) ) { hash = ( 37 * hash ) + BACKEND_FIELD_NUMBER ; hash = ( 53 * hash ) + getBackend ( ) . hashCode ( ) ; } hash = ( 29 * hash ) + unknownFields . hashCode ( ) ; memoizedHashCode = hash ; return hash ; }
public DraftSearchVariableValue setValue ( String value ) { this . value = value ; return this ; }
public static SQLiteDatabase openDatabase ( String path , char [ ] password , CursorFactory factory , int flags , SQLiteDatabaseHook hook , DatabaseErrorHandler errorHandler ) { byte [ ] keyMaterial = getBytes ( password ) ; return openDatabase ( path , keyMaterial , factory , flags , hook , errorHandler ) ; }
static byte [ ] loadZip ( File file , String path ) throws IOException { try ( JarFile jarFile = new JarFile ( file ) ) { JarEntry entry = jarFile . getJarEntry ( path ) ; if ( entry != null ) { try ( InputStream inputStream = jarFile . getInputStream ( entry ) ) { return IOUtils . toByteArray ( inputStream ) ; } } } return null ; }
protected void paintComponent ( Graphics g ) { super . paintComponent ( g ) ; g . drawImage ( image , 0 , 0 , null ) ; }
public Builder clearIngress ( ) { if ( ingressBuilder_ == null ) { ingress_ = java . util . Collections . emptyList ( ) ; bitField0_ = ( bitField0_ & ~ 0x00000002 ) ; onChanged ( ) ; } else { ingressBuilder_ . clear ( ) ; } return this ; }
static void serialize ( ByteStream . Output buffer , Object o , ObjectInspector oi , boolean invert , byte nullMarker , byte notNullMarker ) throws SerDeException { if ( o == null ) { writeByte ( buffer , nullMarker , invert ) ; return ; } writeByte ( buffer , notNullMarker , invert ) ; switch ( oi . getCategory ( ) ) { case PRIMITIVE : { PrimitiveObjectInspector poi = ( PrimitiveObjectInspector ) oi ; switch ( poi . getPrimitiveCategory ( ) ) { case VOID : { return ; } case BOOLEAN : { boolean v = ( ( BooleanObjectInspector ) poi ) . get ( o ) ; writeByte ( buffer , ( byte ) ( v ? 2 : 1 ) , invert ) ; return ; } case BYTE : { ByteObjectInspector boi = ( ByteObjectInspector ) poi ; byte v = boi . get ( o ) ; writeByte ( buffer , ( byte ) ( v ^ 0x80 ) , invert ) ; return ; } case SHORT : { ShortObjectInspector spoi = ( ShortObjectInspector ) poi ; short v = spoi . get ( o ) ; serializeShort ( buffer , v , invert ) ; return ; } case INT : { IntObjectInspector ioi = ( IntObjectInspector ) poi ; int v = ioi . get ( o ) ; serializeInt ( buffer , v , invert ) ; return ; } case LONG : { LongObjectInspector loi = ( LongObjectInspector ) poi ; long v = loi . get ( o ) ; serializeLong ( buffer , v , invert ) ; return ; } case FLOAT : { FloatObjectInspector foi = ( FloatObjectInspector ) poi ; serializeFloat ( buffer , foi . get ( o ) , invert ) ; return ; } case DOUBLE : { DoubleObjectInspector doi = ( DoubleObjectInspector ) poi ; serializeDouble ( buffer , doi . get ( o ) , invert ) ; return ; } case STRING : { StringObjectInspector soi = ( StringObjectInspector ) poi ; Text t = soi . getPrimitiveWritableObject ( o ) ; serializeBytes ( buffer , t . getBytes ( ) , t . getLength ( ) , invert ) ; return ; } case CHAR : { HiveCharObjectInspector hcoi = ( HiveCharObjectInspector ) poi ; HiveCharWritable hc = hcoi . getPrimitiveWritableObject ( o ) ; Text t = hc . getStrippedValue ( ) ; serializeBytes ( buffer , t . getBytes ( ) , t . getLength ( ) , invert ) ; return ; } case VARCHAR : { HiveVarcharObjectInspector hcoi = ( HiveVarcharObjectInspector ) poi ; HiveVarcharWritable hc = hcoi . getPrimitiveWritableObject ( o ) ; Text t = hc . getTextValue ( ) ; serializeBytes ( buffer , t . getBytes ( ) , t . getLength ( ) , invert ) ; return ; } case BINARY : { BinaryObjectInspector baoi = ( BinaryObjectInspector ) poi ; BytesWritable ba = baoi . getPrimitiveWritableObject ( o ) ; byte [ ] toSer = new byte [ ba . getLength ( ) ] ; System . arraycopy ( ba . getBytes ( ) , 0 , toSer , 0 , ba . getLength ( ) ) ; serializeBytes ( buffer , toSer , ba . getLength ( ) , invert ) ; return ; } case DATE : { DateObjectInspector doi = ( DateObjectInspector ) poi ; int v = doi . getPrimitiveWritableObject ( o ) . getDays ( ) ; serializeInt ( buffer , v , invert ) ; return ; } case TIMESTAMP : { TimestampObjectInspector toi = ( TimestampObjectInspector ) poi ; TimestampWritableV2 t = toi . getPrimitiveWritableObject ( o ) ; serializeTimestampWritable ( buffer , t , invert ) ; return ; } case TIMESTAMPLOCALTZ : { TimestampLocalTZObjectInspector toi = ( TimestampLocalTZObjectInspector ) poi ; TimestampLocalTZWritable t = toi . getPrimitiveWritableObject ( o ) ; serializeTimestampTZWritable ( buffer , t , invert ) ; return ; } case INTERVAL_YEAR_MONTH : { HiveIntervalYearMonthObjectInspector ioi = ( HiveIntervalYearMonthObjectInspector ) poi ; HiveIntervalYearMonth intervalYearMonth = ioi . getPrimitiveJavaObject ( o ) ; serializeHiveIntervalYearMonth ( buffer , intervalYearMonth , invert ) ; return ; } case INTERVAL_DAY_TIME : { HiveIntervalDayTimeObjectInspector ioi = ( HiveIntervalDayTimeObjectInspector ) poi ; HiveIntervalDayTime intervalDayTime = ioi . getPrimitiveJavaObject ( o ) ; serializeHiveIntervalDayTime ( buffer , intervalDayTime , invert ) ; return ; } case DECIMAL : { HiveDecimalObjectInspector boi = ( HiveDecimalObjectInspector ) poi ; HiveDecimal dec = boi . getPrimitiveJavaObject ( o ) ; serializeHiveDecimal ( buffer , dec , invert ) ; return ; } default : { throw new RuntimeException ( "Unrecognized type: " + poi . getPrimitiveCategory ( ) ) ; } } } case LIST : { ListObjectInspector loi = ( ListObjectInspector ) oi ; ObjectInspector eoi = loi . getListElementObjectInspector ( ) ; int size = loi . getListLength ( o ) ; for ( int eid = 0 ; eid < size ; eid ++ ) { writeByte ( buffer , ( byte ) 1 , invert ) ; serialize ( buffer , loi . getListElement ( o , eid ) , eoi , invert , nullMarker , notNullMarker ) ; } writeByte ( buffer , ( byte ) 0 , invert ) ; return ; } case MAP : { MapObjectInspector moi = ( MapObjectInspector ) oi ; ObjectInspector koi = moi . getMapKeyObjectInspector ( ) ; ObjectInspector voi = moi . getMapValueObjectInspector ( ) ; Map < ? , ? > map = moi . getMap ( o ) ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { writeByte ( buffer , ( byte ) 1 , invert ) ; serialize ( buffer , entry . getKey ( ) , koi , invert , nullMarker , notNullMarker ) ; serialize ( buffer , entry . getValue ( ) , voi , invert , nullMarker , notNullMarker ) ; } writeByte ( buffer , ( byte ) 0 , invert ) ; return ; } case STRUCT : { StructObjectInspector soi = ( StructObjectInspector ) oi ; List < ? extends StructField > fields = soi . getAllStructFieldRefs ( ) ; for ( int i = 0 ; i < fields . size ( ) ; i ++ ) { serialize ( buffer , soi . getStructFieldData ( o , fields . get ( i ) ) , fields . get ( i ) . getFieldObjectInspector ( ) , invert , nullMarker , notNullMarker ) ; } return ; } case UNION : { UnionObjectInspector uoi = ( UnionObjectInspector ) oi ; byte tag = uoi . getTag ( o ) ; writeByte ( buffer , tag , invert ) ; serialize ( buffer , uoi . getField ( o ) , uoi . getObjectInspectors ( ) . get ( tag ) , invert , nullMarker , notNullMarker ) ; return ; } default : { throw new RuntimeException ( "Unrecognized type: " + oi . getCategory ( ) ) ; } } }
protected void actionPerformed ( final ActionEvent e , final NodeModel node ) { pasteFormat ( node ) ; }
protected Surface getSurface ( ) { Preconditions . checkState ( getVideoSource ( ) == MediaRecorder . VideoSource . SURFACE , "getSurface can only be called when setVideoSource is set to SURFACE" ) ; Preconditions . checkState ( state == STATE_PREPARED || state == STATE_RECORDING , "getSurface must be called after prepare() and before stop()" ) ; if ( recordingSurface == null ) { recordingSurfaceTexture = new SurfaceTexture ( 0 ) ; recordingSurface = new Surface ( recordingSurfaceTexture ) ; } return recordingSurface ; }
default long getLong ( String name ) { return getLong ( name , 0 ) ; }
public String getDefaultAppKey ( ) { return authenticationConfig . getTokenDefaultAppKey ( ) ; }
public SerializedType serializedType ( ) { return serializedObject . getType ( ) ; }
public static CurrencyPair adaptCurrencyPair ( String symbol ) { String [ ] split = symbol . split ( "-" ) ; if ( split . length != 2 ) { throw new ExchangeException ( "Invalid kucoin symbol: " + symbol ) ; } return new CurrencyPair ( split [ 0 ] , split [ 1 ] ) ; }
public void closeQueryHashLookupSearchNextPosDependants ( ) { this . closeKeySearch ( ) ; }
default int insert ( UserBuyRecord record ) { return MyBatis3Utils . insert ( this :: insert , record , userBuyRecord , c -> c . map ( id ) . toProperty ( "id" ) . map ( userId ) . toProperty ( "userId" ) . map ( bookId ) . toProperty ( "bookId" ) . map ( bookName ) . toProperty ( "bookName" ) . map ( bookIndexId ) . toProperty ( "bookIndexId" ) . map ( bookIndexName ) . toProperty ( "bookIndexName" ) . map ( buyAmount ) . toProperty ( "buyAmount" ) . map ( createTime ) . toProperty ( "createTime" ) ) ; }
public void setWindowsModeFtp ( Boolean windowsModeFtp ) { this . windowsModeFtp = windowsModeFtp ; }
public static boolean ipv4Output ( ) { return gPrefs . getBoolean ( IP4_OUTPUT , true ) ; }
public RandomDataInput bytes ( ) { CompiledMapQueryContext . this . checkOnEachPublicOperation ( ) ; return wrappedValueBytes ( ) . bytesStore ( ) ; }
public Builder artifactId ( @ Nullable String artifactId ) { this . artifactId = artifactId ; return this ; }
public Table getTable ( String tableName ) { return new H2Table ( jdbcTemplate , database , this , tableName ) ; }
public int getKeyIndexAndNearbyCodes ( int x , int y , @ Nullable int [ ] allKeys ) { final Keyboard . Key [ ] keys = getKeys ( ) ; final int touchX = getTouchX ( x ) ; final int touchY = getTouchY ( y ) ; int closestKeyIndex = AnyKeyboardViewBase . NOT_A_KEY ; int closestKeyDist = ( y < 0 ) ? mSlideAllowanceSquareTop : mSlideAllowanceSquare ; final int keyCount = keys . length ; for ( int i = 0 ; i < keyCount ; i ++ ) { final Keyboard . Key key = keys [ i ] ; int dist = key . squaredDistanceFrom ( touchX , touchY ) ; if ( dist < closestKeyDist ) { closestKeyIndex = i ; closestKeyDist = dist ; } } if ( allKeys != null && closestKeyIndex != AnyKeyboardViewBase . NOT_A_KEY ) { final Keyboard . Key key = keys [ closestKeyIndex ] ; allKeys [ 0 ] = key . getCodeAtIndex ( 0 , isKeyShifted ( key ) ) ; } return closestKeyIndex ; }
public void onScrolled ( @ NonNull RecyclerView recyclerView , int dx , int dy ) { super . onScrolled ( recyclerView , dx , dy ) ; if ( ! canScrollVertically ( - 1 ) ) { if ( mLinkageEvent != null ) { mLinkageEvent . onContentScrollToTop ( LinkageRecyclerView . this ) ; } } if ( ! canScrollVertically ( 1 ) ) { if ( mLinkageEvent != null ) { mLinkageEvent . onContentScrollToBottom ( LinkageRecyclerView . this ) ; } } if ( mLinkageEvent != null ) { mLinkageEvent . onContentScroll ( LinkageRecyclerView . this ) ; } }
public String uniqueSuffix ( long id ) { return accountId + "." + options . authorizationDate + "." + id ; }
void setClosedCallback ( Callback callback ) { closedCallback = Callback . dummyIfNull ( callback ) ; }
public UUID getObjectId ( ) { return objectId ; }
public void setTimeAfter ( int secs ) { waitAfter = secs ; }
private boolean existsByJobName ( String jobName ) { return this . lambdaQuery ( ) . eq ( FlinkApplication :: getJobName , jobName ) . exists ( ) ; }
public int getConditionsCount ( ) { return conditions_ . size ( ) ; }
public boolean isPending ( ) { return ! signal . isCanceled ( ) ; }
public boolean equals ( Object o ) { if ( o instanceof ATNState ) return stateNumber == ( ( ATNState ) o ) . stateNumber ; return false ; }
public T callWithException ( Object ... params ) throws Throwable { try { return ( T ) this . method . invoke ( null , params ) ; } catch ( InvocationTargetException e ) { if ( e . getCause ( ) != null ) { throw e . getCause ( ) ; } throw e ; } }
public void stateChanged ( javax . swing . event . ChangeEvent e ) { Object src = e . getSource ( ) ; if ( src instanceof JSlider ) { JSlider source = ( JSlider ) e . getSource ( ) ; int val = ( int ) source . getValue ( ) ; setSimilarity ( ( double ) val / 100 ) ; } else if ( src instanceof JSpinner ) { JSpinner source = ( JSpinner ) e . getSource ( ) ; int val = ( Integer ) source . getValue ( ) ; setNumMatches ( val ) ; } }
public Vector filterUp ( double threshold ) { IntFloatVector [ ] newPartitions = new IntFloatVector [ partitions . length ] ; for ( int i = 0 ; i < partitions . length ; i ++ ) { newPartitions [ i ] = ( IntFloatVector ) partitions [ i ] . filterUp ( threshold ) ; } return new CompIntFloatVector ( matrixId , rowId , clock , dim , newPartitions , subDim ) ; }
private AndroidManifest merge ( Map < BundleModuleName , AndroidManifest > manifests ) { AndroidManifest baseManifest = manifests . get ( BASE_MODULE_NAME ) ; List < AndroidManifest > featureManifests = manifests . entrySet ( ) . stream ( ) . filter ( entry -> ! BASE_MODULE_NAME . equals ( entry . getKey ( ) ) ) . sorted ( Comparator . comparing ( entry -> entry . getKey ( ) . getName ( ) ) ) . map ( Map . Entry :: getValue ) . collect ( toImmutableList ( ) ) ; if ( featureManifests . isEmpty ( ) ) { return baseManifest ; } return mergeManifests ( baseManifest , featureManifests ) ; }
FilterRegistrationBean authenticatedRequestFilter ( ) { val frb = new FilterRegistrationBean ( new AuthenticatedRequestFilter ( true ) ) ; frb . setOrder ( Ordered . LOWEST_PRECEDENCE ) ; return frb ; }
public void clear ( ) { cart = new Cart ( ) ; workingItemId = null ; }
public boolean eq ( DateType val ) { return val != null && eq ( val . name ( ) ) ; }
public static Item asDuration ( Object code , int months , int count , long price , int selectedMonths , String currency , boolean needDivider ) { Item item = new Item ( HOLDER_TYPE_DURATION , months == selectedMonths ) ; item . intValue = months ; item . intValue2 = count ; item . longValue = price ; item . boolValue = needDivider ; item . text = currency ; item . object = code ; return item ; }
public J visitUnion ( JS . Union union , RpcSendQueue q ) { q . getAndSendList ( union , el -> el . getPadding ( ) . getTypes ( ) , el -> el . getElement ( ) . getId ( ) , el -> visitRightPadded ( el , q ) ) ; q . getAndSend ( union , el -> asRef ( el . getType ( ) ) , el -> visitType ( getValueNonNull ( el ) , q ) ) ; return union ; }
public Builder addConditions ( int index , io . kubernetes . client . proto . Meta . Condition value ) { if ( conditionsBuilder_ == null ) { if ( value == null ) { throw new NullPointerException ( ) ; } ensureConditionsIsMutable ( ) ; conditions_ . add ( index , value ) ; onChanged ( ) ; } else { conditionsBuilder_ . addMessage ( index , value ) ; } return this ; }
private void withChat ( RunnableLong callback ) { tdlib . awaitInitialization ( ( ) -> { tdlib . incrementJobReferenceCount ( ) ; if ( chatId != 0 ) { callback . runWithLong ( chatId ) ; tdlib . decrementJobReferenceCount ( ) ; } else { tdlib . client ( ) . send ( new TdApi . SearchPublicChat ( channelUsername ) , chatResult -> { switch ( chatResult . getConstructor ( ) ) { case TdApi . Chat . CONSTRUCTOR : { chatId = ( ( TdApi . Chat ) chatResult ) . id ; break ; } case TdApi . Error . CONSTRUCTOR : { Log . e ( "Unable to get resources channel @%s: %s" , channelUsername , TD . toErrorString ( chatResult ) ) ; break ; } } callback . runWithLong ( chatId ) ; tdlib . decrementJobReferenceCount ( ) ; } ) ; } } ) ; }
private String injectAbortWatcher ( String script ) { return "Thread.new(){\n" + "  runner = org.sikuli.support.ide.Runner.getRunner(\"" + NAME + "\")\n" + "  while runner.isRunning()\n" + "    sleep(0.1)\n" + "    if runner.isAborted()\n" + "      exit!\n" + "    end\n" + "  end\n" + "}\n" + script ; }
public long nonce ( ) { return nonce ; }
public void closeOnCompletion ( ) throws SQLException { if ( closed ) throw new SQLException ( "statement is closed" ) ; closeOnCompletion = true ; }
private List < List < String > > processObjects ( List < Map < String , Object > > objects , String commonParentPath , JsonPath [ ] paths ) { List < List < String > > results = initializeResults ( paths . length , objects . size ( ) ) ; for ( int objIndex = 0 ; objIndex < objects . size ( ) ; objIndex ++ ) { Map < String , Object > obj = objects . get ( objIndex ) ; ReadContext objContext = JsonPath . parse ( obj ) ; for ( int pathIndex = 0 ; pathIndex < paths . length ; pathIndex ++ ) { String fieldPath = paths [ pathIndex ] . getPath ( ) ; String relativePath = getRelativePath ( commonParentPath , fieldPath ) ; String value = extractValue ( objContext , relativePath ) ; results . get ( pathIndex ) . add ( value ) ; } } return dataFlip ( results ) ; }
private boolean isEven ( ) { return nstage . getNumber ( ) % 2 == 0 ; }
private void updateRule ( Context context , Rule rule , boolean root , List < Rule > listAll ) { SharedPreferences wifi = context . getSharedPreferences ( "wifi" , Context . MODE_PRIVATE ) ; SharedPreferences other = context . getSharedPreferences ( "other" , Context . MODE_PRIVATE ) ; SharedPreferences apply = context . getSharedPreferences ( "apply" , Context . MODE_PRIVATE ) ; SharedPreferences screen_wifi = context . getSharedPreferences ( "screen_wifi" , Context . MODE_PRIVATE ) ; SharedPreferences screen_other = context . getSharedPreferences ( "screen_other" , Context . MODE_PRIVATE ) ; SharedPreferences roaming = context . getSharedPreferences ( "roaming" , Context . MODE_PRIVATE ) ; SharedPreferences lockdown = context . getSharedPreferences ( "lockdown" , Context . MODE_PRIVATE ) ; SharedPreferences notify = context . getSharedPreferences ( "notify" , Context . MODE_PRIVATE ) ; if ( rule . wifi_blocked == rule . wifi_default ) wifi . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else wifi . edit ( ) . putBoolean ( rule . packageName , rule . wifi_blocked ) . apply ( ) ; if ( rule . other_blocked == rule . other_default ) other . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else other . edit ( ) . putBoolean ( rule . packageName , rule . other_blocked ) . apply ( ) ; if ( rule . apply ) apply . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else apply . edit ( ) . putBoolean ( rule . packageName , rule . apply ) . apply ( ) ; if ( rule . screen_wifi == rule . screen_wifi_default ) screen_wifi . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else screen_wifi . edit ( ) . putBoolean ( rule . packageName , rule . screen_wifi ) . apply ( ) ; if ( rule . screen_other == rule . screen_other_default ) screen_other . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else screen_other . edit ( ) . putBoolean ( rule . packageName , rule . screen_other ) . apply ( ) ; if ( rule . roaming == rule . roaming_default ) roaming . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else roaming . edit ( ) . putBoolean ( rule . packageName , rule . roaming ) . apply ( ) ; if ( rule . lockdown ) lockdown . edit ( ) . putBoolean ( rule . packageName , rule . lockdown ) . apply ( ) ; else lockdown . edit ( ) . remove ( rule . packageName ) . apply ( ) ; if ( rule . notify ) notify . edit ( ) . remove ( rule . packageName ) . apply ( ) ; else notify . edit ( ) . putBoolean ( rule . packageName , rule . notify ) . apply ( ) ; rule . updateChanged ( context ) ; Log . i ( TAG , "Updated " + rule ) ; List < Rule > listModified = new ArrayList < > ( ) ; for ( String pkg : rule . related ) { for ( Rule related : listAll ) if ( related . packageName . equals ( pkg ) ) { related . wifi_blocked = rule . wifi_blocked ; related . other_blocked = rule . other_blocked ; related . apply = rule . apply ; related . screen_wifi = rule . screen_wifi ; related . screen_other = rule . screen_other ; related . roaming = rule . roaming ; related . lockdown = rule . lockdown ; related . notify = rule . notify ; listModified . add ( related ) ; } } List < Rule > listSearch = ( root ? new ArrayList < > ( listAll ) : listAll ) ; listSearch . remove ( rule ) ; for ( Rule modified : listModified ) listSearch . remove ( modified ) ; for ( Rule modified : listModified ) updateRule ( context , modified , false , listSearch ) ; if ( root ) { notifyDataSetChanged ( ) ; NotificationManagerCompat . from ( context ) . cancel ( rule . uid ) ; ServiceSinkhole . reload ( "rule changed" , context , false ) ; } }
private boolean includeHeader ( String header ) { return ! this . ignoredHeaders . contains ( header . toLowerCase ( ) ) ; }
public void markTableSyncable ( String table , String deletedTable ) { if ( ! isOpen ( ) ) { throw new SQLiteException ( "database not open" ) ; } markTableSyncable ( table , "_id" , table , deletedTable ) ; }
public Schema < Double > newDoubleSchema ( ) { return new DoubleSchema ( ) ; }
public Builder addItems ( int index , io . kubernetes . client . proto . V1Networking . NetworkPolicy value ) { if ( itemsBuilder_ == null ) { if ( value == null ) { throw new NullPointerException ( ) ; } ensureItemsIsMutable ( ) ; items_ . add ( index , value ) ; onChanged ( ) ; } else { itemsBuilder_ . addMessage ( index , value ) ; } return this ; }
private StoredDirectoryHelper loadMainStorage ( @ StringRes int prefKey , String tag ) { String path = mPrefs . getString ( getString ( prefKey ) , null ) ; if ( path == null || path . isEmpty ( ) ) return null ; if ( path . charAt ( 0 ) == File . separatorChar ) { Log . i ( TAG , "Old save path style present: " + path ) ; path = "" ; mPrefs . edit ( ) . putString ( getString ( prefKey ) , "" ) . apply ( ) ; } try { return new StoredDirectoryHelper ( this , Uri . parse ( path ) , tag ) ; } catch ( Exception e ) { Log . e ( TAG , "Failed to load the storage of " + tag + " from " + path , e ) ; Toast . makeText ( this , R . string . no_available_dir , Toast . LENGTH_LONG ) . show ( ) ; } return null ; }
public NumberExpression < Double > area ( ) { if ( area == null ) { area = Expressions . numberOperation ( Double . class , SpatialOps . AREA , mixin ) ; } return area ; }
public long getEndTime ( ) { return endTime ; }
public ThreadPoolExecutor unwrap ( Object executor ) { return ( ThreadPoolExecutor ) ReflectUtil . getFieldValue ( executor , FIELD_NAME ) ; }
private static byte [ ] concatToDER ( byte [ ] jwsSignature ) throws ArrayIndexOutOfBoundsException { int rawLen = jwsSignature . length / 2 ; int i = rawLen ; while ( ( i > 0 ) && ( jwsSignature [ rawLen - i ] == 0 ) ) { i -- ; } int j = i ; if ( jwsSignature [ rawLen - i ] < 0 ) { j += 1 ; } int k = rawLen ; while ( ( k > 0 ) && ( jwsSignature [ 2 * rawLen - k ] == 0 ) ) { k -- ; } int l = k ; if ( jwsSignature [ 2 * rawLen - k ] < 0 ) { l += 1 ; } int len = 2 + j + 2 + l ; if ( len > 255 ) { throw new JWTException ( "Invalid ECDSA signature format" ) ; } int offset ; final byte [ ] derSignature ; if ( len < 128 ) { derSignature = new byte [ 2 + 2 + j + 2 + l ] ; offset = 1 ; } else { derSignature = new byte [ 3 + 2 + j + 2 + l ] ; derSignature [ 1 ] = ( byte ) 0x81 ; offset = 2 ; } derSignature [ 0 ] = 48 ; derSignature [ offset ++ ] = ( byte ) len ; derSignature [ offset ++ ] = 2 ; derSignature [ offset ++ ] = ( byte ) j ; System . arraycopy ( jwsSignature , rawLen - i , derSignature , ( offset + j ) - i , i ) ; offset += j ; derSignature [ offset ++ ] = 2 ; derSignature [ offset ++ ] = ( byte ) l ; System . arraycopy ( jwsSignature , 2 * rawLen - k , derSignature , ( offset + l ) - k , k ) ; return derSignature ; }
public void onDestroy ( ) { synchronized ( lock ) { if ( serviceHandler == null ) { throw new IllegalStateException ( "serviceHandler not set, did you override onCreate() but forget to call super.onCreate()?" ) ; } serviceHandler . getLooper ( ) . quit ( ) ; } super . onDestroy ( ) ; }
public static boolean fixLeak ( ) { return gPrefs . getBoolean ( FIX_START_LEAK , false ) ; }
private void resetWires ( @ NotNull final ChronicleQueue queue ) { WireType wireType = queue . wireType ( ) ; { Wire oldw = this . wire ; this . wire = store == null ? null : createWire ( wireType ) ; assert wire != oldw || wire == null ; releaseBytesFor ( oldw ) ; } { Wire old = this . wireForIndex ; this . wireForIndex = store == null ? null : createWire ( wireType ) ; assert wireForIndex != old || wireForIndex == null ; releaseBytesFor ( old ) ; } }
public CharSequence buildRestrictionText ( TdApi . Chat chat , @ RightId int rightId , @ StringRes int defaultRes , @ StringRes int specificRes , @ StringRes int specificUntilRes ) { return buildRestrictionText ( chat , rightId , defaultRes , specificRes , specificUntilRes , R . string . UserDisabledMessages , 0 ) ; }
protected MappingsBuilder createMultiEntityMappingsBuilder ( ConfigurationProvider configProvider ) { EntityIndexConfiguration entityIndexConfig = configProvider . getElasticSearch ( ) . getEntityIndex ( ) ; log . info ( "Creating MultiEntityMappingsBuilder bean" ) ; try { return new MultiEntityMappingsBuilder ( entityIndexConfig ) ; } catch ( IOException e ) { log . error ( "Failed to initialize MultiEntityMappingsBuilder" , e ) ; throw new RuntimeException ( "Failed to initialize MultiEntityMappingsBuilder" , e ) ; } }
protected void configureBuses ( ) { super . configureBuses ( ) ; if ( killbillFeatures . isBusOptimizationOn ( ) ) { this . bind ( BusOptimizer . class ) . to ( BusOptimizerOn . class ) . asEagerSingleton ( ) ; this . bind ( BusDispatcherOptimizer . class ) . to ( BusDispatcherOptimizerOn . class ) . asEagerSingleton ( ) ; } else { this . bind ( BusOptimizer . class ) . to ( BusOptimizerNoop . class ) . asEagerSingleton ( ) ; this . bind ( BusDispatcherOptimizer . class ) . to ( BusDispatcherOptimizerNoop . class ) . asEagerSingleton ( ) ; } }
public void setType ( int type ) { mType = type ; }
public boolean containsIssuerSerial ( ) { return this . lengthIssuerSerial ( ) > 0 ; }
public static Builder linkBuilder ( ) { return new Builder ( ) ; }
public static String formatUTC ( final Date date , final String pattern ) { return format ( date , pattern , UTC_TIME_ZONE , null ) ; }
static boolean isXiaomi ( ) { return "Xiaomi" . equalsIgnoreCase ( Build . MANUFACTURER ) ; }
public void setNumNulls ( long nulls ) { num_nulls = nulls ; }
default IconProvider getDirectoryIconProvider ( @ Nonnull Workspace workspace , @ Nonnull WorkspaceResource resource , @ Nonnull FileBundle bundle , @ Nonnull String directoryName ) { return emptyProvider ( ) ; }
public void truncateDirty ( long offsetToTruncate ) throws RocksDBException { correctMaxPyhOffset ( offsetToTruncate ) ; Function < OffsetEntry , Boolean > predicate = entry -> { if ( entry . type == OffsetEntryType . MINIMUM ) { return false ; } return entry . commitLogOffset >= offsetToTruncate ; } ; Consumer < OffsetEntry > fn = entry -> { try { truncateDirtyOffset ( entry . topic , entry . queueId ) ; } catch ( RocksDBException e ) { log . error ( "Failed to truncate maximum offset of consume queue[topic={}, queue-id={}]" , entry . topic , entry . queueId , e ) ; } } ; forEach ( predicate , fn ) ; }
public io . kubernetes . client . proto . V1Networking . ServiceCIDRSpec . Builder getSpecBuilder ( ) { bitField0_ |= 0x00000002 ; onChanged ( ) ; return getSpecFieldBuilder ( ) . getBuilder ( ) ; }
private void prepareMalwareList ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ServiceSinkhole . this ) ; boolean malware = prefs . getBoolean ( "filter" , false ) && prefs . getBoolean ( "malware" , false ) ; File file = new File ( getFilesDir ( ) , "malware.txt" ) ; if ( ! malware || ! file . exists ( ) || ! file . canRead ( ) ) { Log . i ( TAG , "Malware use=" + malware + " exists=" + file . exists ( ) ) ; lock . writeLock ( ) . lock ( ) ; mapMalware . clear ( ) ; lock . writeLock ( ) . unlock ( ) ; return ; } boolean changed = ( file . lastModified ( ) != last_malware_modified ) ; if ( ! changed && mapMalware . size ( ) > 0 ) { Log . i ( TAG , "Malware unchanged" ) ; return ; } last_malware_modified = file . lastModified ( ) ; lock . writeLock ( ) . lock ( ) ; mapMalware . clear ( ) ; int count = 0 ; BufferedReader br = null ; try { br = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { int hash = line . indexOf ( '#' ) ; if ( hash >= 0 ) line = line . substring ( 0 , hash ) ; line = line . trim ( ) ; if ( line . length ( ) > 0 ) { String [ ] words = line . split ( "\\s+" ) ; if ( words . length > 1 ) { count ++ ; mapMalware . put ( words [ 1 ] , true ) ; } else Log . i ( TAG , "Invalid malware file line: " + line ) ; } } Log . i ( TAG , count + " malware read" ) ; } catch ( IOException ex ) { Log . e ( TAG , ex . toString ( ) + "\n" + Log . getStackTraceString ( ex ) ) ; } finally { if ( br != null ) try { br . close ( ) ; } catch ( IOException exex ) { Log . e ( TAG , exex . toString ( ) + "\n" + Log . getStackTraceString ( exex ) ) ; } } lock . writeLock ( ) . unlock ( ) ; }
public void writeNewEntry ( long pos , Data < ? > key ) { initPos ( pos ) ; initKeySize ( key . size ( ) ) ; Bytes segmentBytes = this . segmentBytesForWriteGuarded ( ) ; segmentBytes . writePosition ( keySizeOffset ( ) ) ; this . h ( ) . keySizeMarshaller . writeSize ( segmentBytes , keySize ( ) ) ; initKeyOffset ( segmentBytes . writePosition ( ) ) ; key . writeTo ( this . segmentBS ( ) , keyOffset ( ) ) ; }
private Properties createCacheManagerProperties ( ObjectProvider < JCachePropertiesCustomizer > cachePropertiesCustomizers ) { Properties properties = new Properties ( ) ; cachePropertiesCustomizers . orderedStream ( ) . forEach ( ( customizer ) -> customizer . customize ( properties ) ) ; return properties ; }
public < X > Octet < A , B , C , D , E , F , G , X > setAt7 ( final X value ) { return new Octet < A , B , C , D , E , F , G , X > ( this . val0 , this . val1 , this . val2 , this . val3 , this . val4 , this . val5 , this . val6 , value ) ; }
public int getSerializedSize ( ) { int size = memoizedSize ; if ( size != - 1 ) return size ; size = 0 ; { int dataSize = 0 ; for ( int i = 0 ; i < hosts_ . size ( ) ; i ++ ) { dataSize += computeStringSizeNoTag ( hosts_ . getRaw ( i ) ) ; } size += dataSize ; size += 1 * getHostsList ( ) . size ( ) ; } if ( ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { size += com . google . protobuf . GeneratedMessageV3 . computeStringSize ( 2 , secretName_ ) ; } size += unknownFields . getSerializedSize ( ) ; memoizedSize = size ; return size ; }
public QuorumAuthServer getQuorumAuthServer ( ) { return ( self == null ) ? null : self . authServer ; }
public void windowOpened ( WindowEvent e ) { dialogOpened ( ) ; }
public int getItemViewType ( int position ) { return ( position == items . size ( ) ) ? VIEW_TYPE_FOOTER : VIEW_TYPE_CELL ; }
public String getId ( ) { return ID ; }
public ConnectorPageSink createPageSink ( ConnectorTransactionHandle transactionHandle , ConnectorSession session , ConnectorOutputTableHandle outputTableHandle , PageSinkContext pageSinkContext ) { checkArgument ( ! pageSinkContext . isCommitRequired ( ) , "Mongo connector does not support page sink commit" ) ; MongoOutputTableHandle handle = ( MongoOutputTableHandle ) outputTableHandle ; return new MongoPageSink ( config , mongoSession , session , handle . getSchemaTableName ( ) , handle . getColumns ( ) ) ; }
protected void writeWordSeparator ( ) throws IOException { try { xhtml . characters ( getWordSeparator ( ) ) ; } catch ( SAXException e ) { throw new IOException ( "Unable to write a space character" , e ) ; } }
public void processOpts ( ) { super . processOpts ( ) ; if ( additionalProperties . containsKey ( CodegenConstants . PACKAGE_NAME ) ) { setPackageName ( ( String ) additionalProperties . get ( CodegenConstants . PACKAGE_NAME ) ) ; } else { setPackageName ( "APIClient" ) ; additionalProperties . put ( CodegenConstants . PACKAGE_NAME , packageName ) ; } if ( additionalProperties . containsKey ( "exportModels" ) ) { setExportModels ( Boolean . parseBoolean ( ( String ) additionalProperties . get ( "exportModels" ) ) ) ; } additionalProperties . put ( "exportModels" , exportModels ) ; if ( additionalProperties . containsKey ( "exportOperations" ) ) { setExportModels ( Boolean . parseBoolean ( ( String ) additionalProperties . get ( "exportOperations" ) ) ) ; } additionalProperties . put ( "exportOperations" , exportModels ) ; additionalProperties . put ( "apiDocPath" , apiDocPath ) ; additionalProperties . put ( "modelDocPath" , modelDocPath ) ; supportingFiles . add ( new SupportingFile ( "client.mustache" , srcPath , packageName + ".jl" ) ) ; supportingFiles . add ( new SupportingFile ( "modelincludes.mustache" , srcPath , "modelincludes.jl" ) ) ; }
public io . kubernetes . client . proto . V1Networking . HTTPIngressRuleValueOrBuilder getHttpOrBuilder ( ) { return http_ == null ? io . kubernetes . client . proto . V1Networking . HTTPIngressRuleValue . getDefaultInstance ( ) : http_ ; }
public int getSettingSuggestionCount ( ) { synchronized ( dataLock ) { int count = 0 ; for ( TdApi . SuggestedAction action : suggestedActions ) { if ( isSettingSuggestion ( action ) ) { count ++ ; } } return count ; } }
public void close ( ) throws Exception { if ( this . nativeIOReader != null ) { this . nativeIOReader . close ( ) ; this . nativeIOReader = null ; } if ( this . nativeWriter != null ) { this . nativeWriter . close ( ) ; this . nativeWriter = null ; } if ( beginTime > 0 ) { LOG . info ( "Task {}, time taken {}" , taskId , System . currentTimeMillis ( ) - beginTime ) ; beginTime = 0 ; } }
public static io . kubernetes . client . proto . V1Networking . ParentReference parseFrom ( byte [ ] data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
default ChannelAction < ForumChannel > createCopy ( ) { return createCopy ( getGuild ( ) ) ; }
protected void insertModelBefore ( EpoxyModel < ? > modelToInsert , EpoxyModel < ? > modelToInsertBefore ) { int targetIndex = getModelPosition ( modelToInsertBefore ) ; if ( targetIndex == - 1 ) { throw new IllegalStateException ( "Model is not added: " + modelToInsertBefore ) ; } pauseModelListNotifications ( ) ; models . add ( targetIndex , modelToInsert ) ; resumeModelListNotifications ( ) ; notifyItemInserted ( targetIndex ) ; }
public JavaContainerBuilder addToClasspath ( Path ... otherFiles ) throws IOException { return addToClasspath ( Arrays . asList ( otherFiles ) ) ; }
protected ServerAuthenticationEntryPointFailureHandler getFailureHandler ( ) { ServerAuthenticationEntryPointFailureHandler failureHandler = new ServerAuthenticationEntryPointFailureHandler ( serverAuthenticationEntryPoint ) ; failureHandler . setRethrowAuthenticationServiceException ( false ) ; return failureHandler ; }
default int updateByPrimaryKeySelective ( User record ) { return update ( c -> c . set ( username ) . equalToWhenPresent ( record :: getUsername ) . set ( password ) . equalToWhenPresent ( record :: getPassword ) . set ( nickName ) . equalToWhenPresent ( record :: getNickName ) . set ( userPhoto ) . equalToWhenPresent ( record :: getUserPhoto ) . set ( userSex ) . equalToWhenPresent ( record :: getUserSex ) . set ( accountBalance ) . equalToWhenPresent ( record :: getAccountBalance ) . set ( status ) . equalToWhenPresent ( record :: getStatus ) . set ( createTime ) . equalToWhenPresent ( record :: getCreateTime ) . set ( updateTime ) . equalToWhenPresent ( record :: getUpdateTime ) . where ( id , isEqualTo ( record :: getId ) ) ) ; }
public io . kubernetes . client . proto . Meta . LabelSelectorOrBuilder getNamespaceSelectorOrBuilder ( ) { return namespaceSelector_ == null ? io . kubernetes . client . proto . Meta . LabelSelector . getDefaultInstance ( ) : namespaceSelector_ ; }
public Boolean isLdapEnabled ( ) { return ldapEnabled ; }
public static String readImagesJson ( ) throws IOException { byte [ ] bytes = Files . readAllBytes ( BING_HTML_IMAGES_JSON ) ; return new String ( bytes ) ; }
public void run ( ) { LOG . info ( "Setting up container launch container for containerid=" + container . getId ( ) + " with shellid=" + shellId ) ; Map < String , LocalResource > localResources = new HashMap < String , LocalResource > ( ) ; if ( ! scriptPath . isEmpty ( ) ) { Path renamedScriptPath = null ; if ( Shell . WINDOWS ) { renamedScriptPath = new Path ( scriptPath + ".bat" ) ; } else { renamedScriptPath = new Path ( scriptPath + ".sh" ) ; } try { renameScriptFile ( renamedScriptPath ) ; } catch ( Exception e ) { LOG . error ( "Not able to add suffix (.bat/.sh) to the shell script filename" , e ) ; numCompletedContainers . incrementAndGet ( ) ; numFailedContainers . incrementAndGet ( ) ; return ; } URL yarnUrl = null ; try { yarnUrl = URL . fromURI ( new URI ( renamedScriptPath . toString ( ) ) ) ; } catch ( URISyntaxException e ) { LOG . error ( "Error when trying to use shell script path specified" + " in env, path=" + renamedScriptPath , e ) ; numCompletedContainers . incrementAndGet ( ) ; numFailedContainers . incrementAndGet ( ) ; return ; } LocalResource shellRsrc = LocalResource . newInstance ( yarnUrl , LocalResourceType . FILE , LocalResourceVisibility . APPLICATION , shellScriptPathLen , shellScriptPathTimestamp ) ; localResources . put ( Shell . WINDOWS ? EXEC_BAT_SCRIPT_STRING_PATH : EXEC_SHELL_STRING_PATH , shellRsrc ) ; shellCommand = Shell . WINDOWS ? windows_command : linux_bash_command ; } if ( localizableFiles . size ( ) > 0 ) { FileSystem fs ; try { fs = FileSystem . get ( conf ) ; } catch ( IOException e ) { numCompletedContainers . incrementAndGet ( ) ; numFailedContainers . incrementAndGet ( ) ; throw new UncheckedIOException ( "Cannot get FileSystem" , e ) ; } localizableFiles . stream ( ) . forEach ( fileName -> { try { String relativePath = getRelativePath ( appName , appId . toString ( ) , fileName ) ; Path dst = new Path ( homeDirectory , relativePath ) ; FileStatus fileStatus = fs . getFileStatus ( dst ) ; LocalResource localRes = LocalResource . newInstance ( URL . fromURI ( dst . toUri ( ) ) , LocalResourceType . FILE , LocalResourceVisibility . APPLICATION , fileStatus . getLen ( ) , fileStatus . getModificationTime ( ) ) ; LOG . info ( "Setting up file for localization: " + dst ) ; localResources . put ( fileName , localRes ) ; } catch ( IOException e ) { numCompletedContainers . incrementAndGet ( ) ; numFailedContainers . incrementAndGet ( ) ; throw new UncheckedIOException ( "Error during localization setup" , e ) ; } } ) ; } Vector < CharSequence > vargs = new Vector < CharSequence > ( 5 ) ; vargs . add ( shellCommand ) ; if ( ! scriptPath . isEmpty ( ) ) { vargs . add ( Shell . WINDOWS ? EXEC_BAT_SCRIPT_STRING_PATH : EXEC_SHELL_STRING_PATH ) ; } vargs . add ( shellArgs ) ; vargs . add ( "1>" + ApplicationConstants . LOG_DIR_EXPANSION_VAR + "/stdout" ) ; vargs . add ( "2>" + ApplicationConstants . LOG_DIR_EXPANSION_VAR + "/stderr" ) ; StringBuilder command = new StringBuilder ( ) ; for ( CharSequence str : vargs ) { command . append ( str ) . append ( " " ) ; } List < String > commands = new ArrayList < String > ( ) ; commands . add ( command . toString ( ) ) ; Map < String , String > myShellEnv = new HashMap < String , String > ( shellEnv ) ; myShellEnv . put ( YARN_SHELL_ID , shellId ) ; ContainerRetryContext containerRetryContext = ContainerRetryContext . newInstance ( containerRetryPolicy , containerRetryErrorCodes , containerMaxRetries , containrRetryInterval , containerFailuresValidityInterval ) ; ContainerLaunchContext ctx = ContainerLaunchContext . newInstance ( localResources , myShellEnv , commands , null , allTokens . duplicate ( ) , null , containerRetryContext ) ; containerListener . addContainer ( container . getId ( ) , container ) ; nmClientAsync . startContainerAsync ( container , ctx ) ; }
public final IntDefault < R > intType ( ) { return intBuilder ( ) . endInt ( ) ; }
private void showLicenseDialog ( ) { Billing billing = Billing . newInstance ( this ) ; LayoutInflater inflater = getLayoutInflater ( ) ; final View content = inflater . inflate ( R . layout . license_dialog , null ) ; String instId = billing . getInstallationId ( ) ; TextView instIdText = content . findViewById ( R . id . installation_id ) ; instIdText . setText ( instId ) ; mDialogClosing = false ; final View showQr = content . findViewById ( R . id . show_qr_code ) ; showQr . setOnClickListener ( v -> showQrCode ( content , instId ) ) ; if ( Utils . isTv ( this ) && ! billing . isPurchased ( Billing . SUPPORTER_SKU ) ) { instIdText . setOnClickListener ( v -> Utils . shareText ( this , getString ( R . string . installation_id ) , instId ) ) ; showQrCode ( content , instId ) ; } TextView validationRc = content . findViewById ( R . id . validation_rc ) ; EditText licenseCode = content . findViewById ( R . id . license_code ) ; licenseCode . setText ( billing . getLicense ( ) ) ; Utils . setTextUrls ( ( content . findViewById ( R . id . paid_features_msg ) ) , R . string . access_paid_features_msg , MainActivity . PAID_FEATURES_URL ) ; content . findViewById ( R . id . copy_id ) . setOnClickListener ( v -> Utils . copyToClipboard ( this , instId ) ) ; mLicenseDialog = new AlertDialog . Builder ( this ) . setView ( content ) . setPositiveButton ( R . string . ok , ( dialog , whichButton ) -> { boolean was_valid = billing . isPurchased ( Billing . SUPPORTER_SKU ) ; billing . setLicense ( licenseCode . getText ( ) . toString ( ) ) ; if ( ! was_valid && billing . isPurchased ( Billing . SUPPORTER_SKU ) ) Utils . showToastLong ( this , R . string . paid_features_unlocked ) ; } ) . setOnDismissListener ( dialog -> { mDialogClosing = true ; mLicenseDialog = null ; stopQrExecutor ( ) ; } ) . setNeutralButton ( R . string . validate , ( dialog , which ) -> { } ) . create ( ) ; mLicenseDialog . show ( ) ; mLicenseDialog . getButton ( AlertDialog . BUTTON_NEUTRAL ) . setOnClickListener ( v -> { boolean valid = billing . isValidLicense ( licenseCode . getText ( ) . toString ( ) ) ; validationRc . setText ( valid ? R . string . valid : R . string . invalid ) ; validationRc . setTextColor ( ContextCompat . getColor ( this , valid ? R . color . ok : R . color . danger ) ) ; } ) ; mLicenseDialog . getWindow ( ) . setLayout ( LinearLayout . LayoutParams . MATCH_PARENT , LinearLayout . LayoutParams . WRAP_CONTENT ) ; }
public void setBackupItem ( @ NonNull BackupItems . BackupItem backupItem ) { mBackupItem = backupItem ; mRelativeDir = backupItem . getRelativeDir ( ) ; }
public boolean canClearHistoryOnlyForSelf ( long chatId ) { return chatId != 0 && canClearHistoryOnlyForSelf ( chat ( chatId ) ) ; }
public String operationRef ( ) { return operationRef ; }
public static int getValueCountThreshold ( Configuration configuration ) { return configuration . getInt ( PAGE_VALUE_COUNT_THRESHOLD , ParquetProperties . DEFAULT_PAGE_VALUE_COUNT_THRESHOLD ) ; }
public void doLaunch ( Context context , View v ) { SharedPreferences settingPrefs = PreferenceManager . getDefaultSharedPreferences ( v . getContext ( ) ) ; boolean callContactOnClick = settingPrefs . getBoolean ( "call-contact-on-click" , false ) ; if ( callContactOnClick ) { launchCall ( context , v , pojo . phone ) ; } else { launchContactView ( context , v ) ; } }
public long getFeedId ( ) { return feedId ; }
private String buildCharset ( TableColumn column , HiveColumnTypeEnum type ) { if ( ! type . getColumnType ( ) . isSupportCharset ( ) || StringUtils . isEmpty ( column . getCharSetName ( ) ) ) { return "" ; } return StringUtils . join ( "CHARACTER SET " , column . getCharSetName ( ) ) ; }
public ForeignExe versionRegex ( Pattern versionRegex ) { this . versionRegex = Objects . requireNonNull ( versionRegex ) ; return this ; }
public void setRefreshTokenMaxReuse ( int refreshTokenMaxReuse ) { getDelegateForUpdate ( ) ; updated . setRefreshTokenMaxReuse ( refreshTokenMaxReuse ) ; }
public boolean isDetectOriginalLineSeparator ( ) { return detectOriginalLineSeparator ; }
private void publishContainerStartEvent ( final TimelineClient timelineClient , final Container container , String domainId , UserGroupInformation ugi ) { final TimelineEntity entity = new TimelineEntity ( ) ; entity . setEntityId ( container . getId ( ) . toString ( ) ) ; entity . setEntityType ( DSEntity . DS_CONTAINER . toString ( ) ) ; entity . setDomainId ( domainId ) ; entity . addPrimaryFilter ( USER_TIMELINE_FILTER_NAME , ugi . getShortUserName ( ) ) ; entity . addPrimaryFilter ( APPID_TIMELINE_FILTER_NAME , container . getId ( ) . getApplicationAttemptId ( ) . getApplicationId ( ) . toString ( ) ) ; TimelineEvent event = new TimelineEvent ( ) ; event . setTimestamp ( System . currentTimeMillis ( ) ) ; event . setEventType ( DSEvent . DS_CONTAINER_START . toString ( ) ) ; event . addEventInfo ( "Node" , container . getNodeId ( ) . toString ( ) ) ; event . addEventInfo ( "Resources" , container . getResource ( ) . toString ( ) ) ; entity . addEvent ( event ) ; try { processTimelineResponseErrors ( putContainerEntity ( timelineClient , container . getId ( ) . getApplicationAttemptId ( ) , entity ) ) ; } catch ( YarnException | IOException | ProcessingException e ) { LOG . error ( "Container start event could not be published for " + container . getId ( ) . toString ( ) , e ) ; } }
public TxnOffsetCommitRequest build ( short version ) { if ( version < 3 && groupMetadataSet ( ) ) { throw new UnsupportedVersionException ( "Broker doesn't support group metadata commit API on version " + version + ", minimum supported request version is 3 which requires brokers to be on version 2.5 or above." ) ; } if ( ! isTransactionV2Enabled ) { version = ( short ) Math . min ( version , LAST_STABLE_VERSION_BEFORE_TRANSACTION_V2 ) ; } return new TxnOffsetCommitRequest ( data , version ) ; }
public CompletableFuture < byte [ ] > get ( final String path , final long timeoutMs ) { CompletableFuture < byte [ ] > future = get ( path ) ; TimerTask timerTask = getTimerTask ( timeoutMs , future , "GET" ) ; retryTimer . newTimeout ( timerTask , timeoutMs + 1 , TimeUnit . MILLISECONDS ) ; return future ; }
@ Override float getFloat ( byte [ ] array , long offset ) { return Float . intBitsToFloat ( Integer . reverseBytes ( super . getInt ( array , offset ) ) ) ; }
private void pause ( ) throws InterruptedException { if ( ponderFactor == 0 ) return ; TimeUnit . MILLISECONDS . sleep ( rand . nextInt ( ponderFactor * 250 ) ) ; }
public boolean isObjectReuse ( ) { return isObjectReuse ; }
public Cell getNext ( ) { return this . next ; }
public static boolean hasQueueSuffix ( @ NotNull File file ) { return InternalFileUtil . hasQueueSuffix ( file ) ; }
public void setRemote ( Protocol remote ) { this . remote = remote ; }
public UsingReturnValue usingReturnValue ( ) { return this . usingReturnValue ; }
public Clob createClob ( ) throws SQLException { throw new SQLFeatureNotSupportedException ( ) ; }
public boolean equals ( Object obj ) { if ( obj == null ) return false ; if ( this == obj ) return true ; if ( ! ( obj instanceof PackageWidgetDescription ) ) return false ; PackageWidgetDescription widget = ( PackageWidgetDescription ) obj ; return position . equals ( widget . position ) ; }
public Builder setIngressClassName ( java . lang . String value ) { if ( value == null ) { throw new NullPointerException ( ) ; } bitField0_ |= 0x00000001 ; ingressClassName_ = value ; onChanged ( ) ; return this ; }
public long roundFloor ( long instant ) { instant = iChronology . weekOfWeekyear ( ) . roundFloor ( instant ) ; int wow = iChronology . getWeekOfWeekyear ( instant ) ; if ( wow > 1 ) { instant -= ( ( long ) DateTimeConstants . MILLIS_PER_WEEK ) * ( wow - 1 ) ; } return instant ; }
private CharSequence generateCodecStateTransitionForWrapping ( final FieldPrecedenceModel fieldPrecedenceModel ) { if ( null == fieldPrecedenceModel ) { return "" ; } if ( fieldPrecedenceModel . versionCount ( ) == 1 ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( "#if defined(" ) . append ( precedenceChecksFlagName ) . append ( ")\n" ) . append ( TWO_INDENT ) . append ( "codecState(" ) . append ( qualifiedStateCase ( fieldPrecedenceModel . latestVersionWrappedState ( ) ) ) . append ( ");\n" ) . append ( "#endif\n" ) ; return sb ; } return generateAccessOrderListenerCall ( fieldPrecedenceModel , TWO_INDENT , "onWrapped" , "actingVersion" ) ; }
private boolean checkSize ( Bitmap bitmap , BitmapFactory . Options options ) { int bitmapSize = bitmap != null ? bitmap . getByteCount ( ) : 0 ; if ( bitmapSize > MAX_BITMAP_SIZE ) { options . inSampleSize *= 2 ; return true ; } return false ; }
public boolean getAlwaysAsId ( ) { return _alwaysAsId ; }
public boolean isCompleted ( ) { return BitwiseUtils . hasFlag ( flags , FLAG_COMPLETED ) ; }
public int getPeerEurekaNodesUpdateIntervalMs ( ) { return peerEurekaNodesUpdateIntervalMs ; }
public String getType ( ) { return TYPE ; }
private void handleAttributeSubscribeRequest ( TbCoapClientState clientState , CoapExchange exchange , Request request ) { String attrSubToken = getTokenFromRequest ( request ) ; if ( ! clients . registerAttributeObservation ( clientState , attrSubToken , exchange ) ) { log . warn ( "[{}] Received duplicate attribute subscribe request for token: {}" , clientState . getDeviceId ( ) , attrSubToken ) ; } }
public void assertHasSizeLessThan ( AssertionInfo info , char [ ] actual , int boundary ) { arrays . assertHasSizeLessThan ( info , actual , boundary ) ; }
public String toString ( ) { StringBuilder os = new StringBuilder ( ) ; os . append ( "{" ) ; if ( DO_PRONOUN ) os . append ( "DO_PRONOUN" ) ; if ( USE_INCOMPATIBLES ) os . append ( ", USE_INCOMPATIBLES" ) ; if ( USE_iwithini ) os . append ( ", USE_iwithini" ) ; if ( USE_APPOSITION ) os . append ( ", USE_APPOSITION" ) ; if ( USE_PREDICATENOMINATIVES ) os . append ( ", USE_PREDICATENOMINATIVES" ) ; if ( USE_ACRONYM ) os . append ( ", USE_ACRONYM" ) ; if ( USE_RELATIVEPRONOUN ) os . append ( ", USE_RELATIVEPRONOUN" ) ; if ( USE_ROLEAPPOSITION ) os . append ( ", USE_ROLEAPPOSITION" ) ; if ( USE_EXACTSTRINGMATCH ) os . append ( ", USE_EXACTSTRINGMATCH" ) ; if ( USE_NAME_MATCH ) os . append ( ", USE_NAME_MATCH" ) ; if ( USE_INCLUSION_HEADMATCH ) os . append ( ", USE_INCLUSION_HEADMATCH" ) ; if ( USE_RELAXED_HEADMATCH ) os . append ( ", USE_RELAXED_HEADMATCH" ) ; if ( USE_INCOMPATIBLE_MODIFIER ) os . append ( ", USE_INCOMPATIBLE_MODIFIER" ) ; if ( USE_DEMONYM ) os . append ( ", USE_DEMONYM" ) ; if ( USE_WORDS_INCLUSION ) os . append ( ", USE_WORDS_INCLUSION" ) ; if ( USE_ROLE_SKIP ) os . append ( ", USE_ROLE_SKIP" ) ; if ( USE_RELAXED_EXACTSTRINGMATCH ) os . append ( ", USE_RELAXED_EXACTSTRINGMATCH" ) ; if ( USE_ATTRIBUTES_AGREE ) os . append ( ", USE_ATTRIBUTES_AGREE" ) ; if ( USE_WN_HYPERNYM ) os . append ( ", USE_WN_HYPERNYM" ) ; if ( USE_WN_SYNONYM ) os . append ( ", USE_WN_SYNONYM" ) ; if ( USE_DIFFERENT_LOCATION ) os . append ( ", USE_DIFFERENT_LOCATION" ) ; if ( USE_NUMBER_IN_MENTION ) os . append ( ", USE_NUMBER_IN_MENTION" ) ; if ( USE_PROPERHEAD_AT_LAST ) os . append ( ", USE_PROPERHEAD_AT_LAST" ) ; if ( USE_ALIAS ) os . append ( ", USE_ALIAS" ) ; if ( USE_SLOT_MATCH ) os . append ( ", USE_SLOT_MATCH" ) ; if ( USE_DISCOURSEMATCH ) os . append ( ", USE_DISCOURSEMATCH" ) ; if ( USE_DISTANCE ) os . append ( ", USE_DISTANCE" ) ; if ( USE_NUMBER_ANIMACY_NE_AGREE ) os . append ( ", USE_NUMBER_ANIMACY_NE_AGREE" ) ; if ( USE_COREF_DICT ) os . append ( ", USE_COREF_DICT" ) ; os . append ( "}" ) ; return os . toString ( ) ; }
public void cancel ( ) { mDialog . cancel ( ) ; }
public void state ( StreamState state ) { this . state = state ; }
IndexedSeq < T > drop ( int n ) ; @ Override IndexedSeq < T > dropUntil ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropWhile ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropRight ( int n ) ; @ Override IndexedSeq < T > dropRightUntil ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropRightWhile ( @ NonNull Predicate < ? super T > predicate ) ; @ Override default boolean endsWith ( @ NonNull Seq < ? extends T > that ) { Objects . requireNonNull ( that , "that is null" ) ; if ( that instanceof IndexedSeq ) { int i = length ( ) - 1 ; int j = that . length ( ) - 1 ; if ( j > i ) { return false ; } else { while ( j >= 0 ) { if ( ! Objects . equals ( this . get ( i ) , that . get ( j ) ) ) { return false ; } i -- ; j -- ; } return true ; } } else { return Seq . super . endsWith ( that ) ; } }
public boolean contains ( Object k ) { return AbstractChronicleMap . this . containsKey ( k ) ; }
public QuorumPacket getQuorumPacket ( ) { return packet ; }
public int andNotBitmapContainerVSBitmapContainer ( BenchmarkState benchmarkState ) { return benchmarkState . ac1 . andNot ( benchmarkState . ac2 ) . getCardinality ( ) ; }
protected void compactWindow ( ) { if ( eventsSinceLastExpiry . incrementAndGet ( ) >= EXPIRE_EVENTS_THRESHOLD ) { scanEvents ( false ) ; } }
public void setOnShowListener ( DialogInterface . OnShowListener listener ) { mDialog . setOnShowListener ( listener ) ; }
public ObjectInspector getObjectInspector ( ) throws SerDeException { return rowObjectInspector ; }
public ConfigBuilder setSearchers ( int searchers ) { this . searchers = searchers ; return this ; }
private void _parse ( XHTMLContentHandler xhtml ) throws TikaException , SAXException , IOException , ChunkNotFoundException { msg . setReturnNullOnMissingChunk ( true ) ; if ( msg . has7BitEncodingStrings ( ) ) { guess7BitEncoding ( msg ) ; } Map < String , String [ ] > headers = normalizeHeaders ( msg . getHeaders ( ) ) ; handleFromTo ( headers , parentMetadata ) ; handleMessageInfo ( msg , headers , parentMetadata ) ; ExtendedMetadataExtractor . extract ( msg , parentMetadata ) ; try { for ( String recipientAddress : msg . getRecipientEmailAddressList ( ) ) { if ( recipientAddress != null ) { parentMetadata . add ( Metadata . MESSAGE_RECIPIENT_ADDRESS , recipientAddress ) ; } } } catch ( ChunkNotFoundException e ) { } for ( Map . Entry < String , String [ ] > e : headers . entrySet ( ) ) { String headerKey = e . getKey ( ) ; for ( String headerValue : e . getValue ( ) ) { parentMetadata . add ( Metadata . MESSAGE_RAW_HEADER_PREFIX + headerKey , headerValue ) ; } } handleGeneralDates ( msg , headers , parentMetadata ) ; writeSelectHeadersInBody ( parentMetadata , msg , xhtml ) ; Chunk htmlChunk = null ; Chunk rtfChunk = null ; Chunk textChunk = null ; for ( Chunk chunk : msg . getMainChunks ( ) . getChunks ( ) ) { if ( chunk . getChunkId ( ) == MAPIProperty . BODY_HTML . id ) { htmlChunk = chunk ; } if ( chunk . getChunkId ( ) == MAPIProperty . RTF_COMPRESSED . id ) { rtfChunk = chunk ; } if ( chunk . getChunkId ( ) == MAPIProperty . BODY . id ) { textChunk = chunk ; } } Set < String > contentIdNames = new HashSet < > ( ) ; handleBodyChunks ( htmlChunk , rtfChunk , textChunk , xhtml , contentIdNames ) ; for ( AttachmentChunks attachment : msg . getAttachmentFiles ( ) ) { Metadata attachMetadata = Metadata . newInstance ( context ) ; updateAttachmentMetadata ( attachment , attachMetadata , contentIdNames ) ; String filename = null ; if ( ! StringUtils . isBlank ( attachMetadata . get ( MAPI . ATTACH_LONG_FILE_NAME ) ) ) { filename = attachMetadata . get ( MAPI . ATTACH_LONG_FILE_NAME ) ; } else if ( ! StringUtils . isBlank ( attachMetadata . get ( MAPI . ATTACH_DISPLAY_NAME ) ) ) { filename = attachMetadata . get ( MAPI . ATTACH_DISPLAY_NAME ) ; } else if ( ! StringUtils . isBlank ( attachMetadata . get ( MAPI . ATTACH_FILE_NAME ) ) ) { filename = attachMetadata . get ( MAPI . ATTACH_FILE_NAME ) ; } String mimeType = attachMetadata . get ( MAPI . ATTACH_MIME ) ; if ( attachment . getAttachData ( ) != null ) { handleEmbeddedResource ( TikaInputStream . get ( attachment . getAttachData ( ) . getValue ( ) ) , attachMetadata , filename , null , null , mimeType , xhtml , true ) ; } if ( attachment . getAttachmentDirectory ( ) != null ) { handleEmbeddedOfficeDoc ( attachment . getAttachmentDirectory ( ) . getDirectory ( ) , attachMetadata , filename , xhtml , true ) ; } } }
private void reloadOption ( String name ) { send ( new TdApi . GetOption ( name ) , ( value , error ) -> { if ( value != null ) { sendFakeUpdate ( new TdApi . UpdateOption ( name , value ) ) ; } } ) ; }
public boolean canAddWebPagePreviews ( TdApi . Chat chat ) { return getRestrictionStatus ( chat , RightId . EMBED_LINKS ) == null ; }
public boolean lessThanOrEqual ( XObject obj2 ) throws javax . xml . transform . TransformerException { if ( obj2 . getType ( ) == XObject . CLASS_NODESET ) return obj2 . greaterThanOrEqual ( this ) ; return this . num ( ) <= obj2 . num ( ) ; }
public BitArray getBlackRow ( int y , BitArray row ) throws NotFoundException { return binarizer . getBlackRow ( y , row ) ; }
public void updateDisplay ( Import anImport , int pos ) { DB_SOURCE . setText ( anImport . getDbSource ( ) ) ; RAT . setText ( anImport . getRadioAccessTechnology ( ) ) ; MCC . setText ( valueOf ( anImport . getMobileCountryCode ( ) ) ) ; MNC . setText ( valueOf ( anImport . getMobileNetworkCode ( ) ) ) ; LAC . setText ( valueOf ( anImport . getLocationAreaCode ( ) ) ) ; CID . setText ( valueOf ( anImport . getCellId ( ) ) ) ; PSC . setText ( valueOf ( anImport . getPrimaryScramblingCode ( ) ) ) ; GPS_LAT . setText ( valueOf ( anImport . getGpsLocation ( ) . getLatitude ( ) ) ) ; GPS_LON . setText ( valueOf ( anImport . getGpsLocation ( ) . getLongitude ( ) ) ) ; IS_GPS_EXACT . setText ( valueOf ( anImport . isGpsExact ( ) ) ) ; AVG_RANGE . setText ( valueOf ( anImport . getAvgRange ( ) ) ) ; AVG_SIGNAL . setText ( valueOf ( anImport . getAvgSignal ( ) ) ) ; SAMPLES . setText ( valueOf ( anImport . getSamples ( ) ) ) ; DateFormat df = DateFormat . getDateTimeInstance ( ) ; TIME_FIRST . setText ( df . format ( anImport . getTimeFirst ( ) ) ) ; TIME_LAST . setText ( df . format ( anImport . getTimeLast ( ) ) ) ; REJ_CAUSE . setText ( valueOf ( anImport . getRejCause ( ) ) ) ; mRecordId . setText ( valueOf ( pos ) ) ; }
public int hashCode ( ) { return Objects . hash ( desc , date , url ) ; }
public void handleTouchEvent ( MotionEvent ev , int downX , int downY , int lastY , OnFastScrollStateChangeListener stateChangeListener ) { int action = ev . getAction ( ) ; int y = ( int ) ev . getY ( ) ; switch ( action ) { case MotionEvent . ACTION_DOWN : if ( isNearPoint ( downX , downY ) ) { mTouchOffset = downY - mThumbPosition . y ; } break ; case MotionEvent . ACTION_MOVE : if ( ! mIsDragging && isNearPoint ( downX , downY ) && Math . abs ( y - downY ) > mTouchSlop ) { mRecyclerView . getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; mIsDragging = true ; mTouchOffset += ( lastY - downY ) ; mPopup . animateVisibility ( true ) ; if ( stateChangeListener != null ) { stateChangeListener . onFastScrollStart ( ) ; } if ( mThumbInactiveState ) { mThumb . setColor ( mThumbActiveColor ) ; } } if ( mIsDragging ) { if ( mLastY == 0 || Math . abs ( mLastY - y ) >= mTouchSlop ) { mLastY = y ; int top = 0 ; int bottom = mRecyclerView . getHeight ( ) - mThumbHeight ; float boundedY = ( float ) Math . max ( top , Math . min ( bottom , y - mTouchOffset ) ) ; String sectionName = mRecyclerView . scrollToPositionAtProgress ( ( boundedY - top ) / ( bottom - top ) ) ; mPopup . setSectionName ( sectionName ) ; mPopup . animateVisibility ( ! sectionName . isEmpty ( ) ) ; mRecyclerView . invalidate ( mPopup . updateFastScrollerBounds ( mRecyclerView , mThumbPosition . y ) ) ; } } break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : mTouchOffset = 0 ; mLastY = 0 ; if ( mIsDragging ) { mIsDragging = false ; mPopup . animateVisibility ( false ) ; if ( stateChangeListener != null ) { stateChangeListener . onFastScrollStop ( ) ; } } if ( mThumbInactiveState ) { mThumb . setColor ( mThumbInactiveColor ) ; } break ; } }
public static io . kubernetes . client . proto . V1Networking . NetworkPolicyPeer parseFrom ( com . google . protobuf . ByteString data , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data , extensionRegistry ) ; }
protected TraceEvent < TraceModule , Void > getAddedType ( ) { return TraceEvents . MODULE_ADDED ; }
public HRESULT GetLibAttr ( PointerByReference ppTLibAttr ) { return ( HRESULT ) this . _invokeNativeObject ( 7 , new Object [ ] { this . getPointer ( ) , ppTLibAttr } , HRESULT . class ) ; }
public boolean isDatabend ( ) { return isDatabend ( gainSQLDatabase ( ) ) ; }
public static int getHardwarePreviousButton ( ) { return Integer . parseInt ( prefs . getString ( PREF_HARDWARE_PREVIOUS_BUTTON , String . valueOf ( KeyEvent . KEYCODE_MEDIA_REWIND ) ) ) ; }
public String getRemoteInstanceUris ( ) { return remoteInstanceUris ; }
public int [ ] getAcceptableTokens ( ) { return new int [ ] { TokenTypes . CLASS_DEF , TokenTypes . INTERFACE_DEF , TokenTypes . ENUM_DEF , TokenTypes . ANNOTATION_DEF , TokenTypes . RECORD_DEF , } ; }
String appendSpanIds ( List < Span > spans , StringBuilder message ) { message . append ( "[" ) ; int i = 0 ; Iterator < Span > iterator = spans . iterator ( ) ; while ( iterator . hasNext ( ) && i ++ < 3 ) { message . append ( idString ( iterator . next ( ) ) ) ; if ( iterator . hasNext ( ) ) message . append ( ", " ) ; } if ( iterator . hasNext ( ) ) message . append ( "..." ) ; return message . append ( "]" ) . toString ( ) ; }
public void setOwnerActivity ( @ NonNull Activity activity ) { mDialog . setOwnerActivity ( activity ) ; }
public PStyle getStyle ( ) { return getStyle ( null ) ; }
public void setParent ( PApplet parent ) { this . parent = parent ; smooth = parent . sketchSmooth ( ) ; pixelDensity = parent . sketchPixelDensity ( ) ; }
public void actionPerformed ( java . awt . event . ActionEvent e ) { if ( chkShowPassword . isSelected ( ) ) { txtProxyChainPassword . setEchoChar ( ( char ) 0 ) ; } else { txtProxyChainPassword . setEchoChar ( '*' ) ; } }
@ Override public Request transformRequest ( Request request ) { return request ; }
private static DateTimeFormatter basicDateTime ( ) { if ( bdt == null ) { return new DateTimeFormatterBuilder ( ) . append ( basicDate ( ) ) . append ( basicTTime ( ) ) . toFormatter ( ) ; } return bdt ; }
public void setCurrentItem ( int item ) { setCurrentItem ( item , true ) ; }
public AnnotationVisitor visitAnnotation ( final String name , final String desc ) { ++ size ; if ( named ) { bv . putShort ( cw . newUTF8 ( name ) ) ; } bv . put12 ( '@' , cw . newUTF8 ( desc ) ) . putShort ( 0 ) ; return new AnnotationWriter ( cw , true , bv , bv , bv . length - 2 ) ; }
public static SpringdocRouteBuilder route ( ) { return new SpringdocRouteBuilder ( ) ; }
public static void glFlushMappedBufferRange ( @ NativeType ( "GLenum" ) int target , @ NativeType ( "GLintptr" ) long offset , @ NativeType ( "GLsizeiptr" ) long length ) { GL30C . glFlushMappedBufferRange ( target , offset , length ) ; }
public JSONObject getByURI ( final String domainURI ) { try { final JSONObject ret = domainRepository . getByURI ( domainURI ) ; if ( null == ret ) { return null ; } if ( Domain . DOMAIN_STATUS_C_VALID != ret . optInt ( Domain . DOMAIN_STATUS ) ) { return null ; } String description = ret . optString ( Domain . DOMAIN_DESCRIPTION ) ; String descriptionText = ret . optString ( Domain . DOMAIN_TITLE ) ; if ( StringUtils . isNotBlank ( description ) ) { description = Markdowns . toHTML ( description ) ; ret . put ( Domain . DOMAIN_DESCRIPTION , description ) ; descriptionText = Jsoup . parse ( description ) . text ( ) ; } final String domainTitle = ret . optString ( Domain . DOMAIN_TITLE ) ; if ( StringUtils . isBlank ( ret . optString ( Domain . DOMAIN_SEO_TITLE ) ) ) { ret . put ( Domain . DOMAIN_SEO_TITLE , domainTitle ) ; } if ( StringUtils . isBlank ( ret . optString ( Domain . DOMAIN_SEO_DESC ) ) ) { ret . put ( Domain . DOMAIN_SEO_DESC , descriptionText ) ; } if ( StringUtils . isBlank ( ret . optString ( Domain . DOMAIN_SEO_KEYWORDS ) ) ) { ret . put ( Domain . DOMAIN_SEO_KEYWORDS , domainTitle ) ; } return ret ; } catch ( final RepositoryException e ) { LOGGER . log ( Level . ERROR , "Gets domain [URI=" + domainURI + "] failed" , e ) ; return null ; } }
void addDataArtifacts ( List < DataArtifact > dataArtifacts ) { ingestModuleExecutor . addDataArtifacts ( dataArtifacts ) ; }
default LeftProjection < L , R > left ( ) { return new LeftProjection < > ( this ) ; }
public V1GCEPersistentDiskVolumeSource pdName ( @ jakarta . annotation . Nonnull String pdName ) { this . pdName = pdName ; return this ; }
public double getNailThickness ( StringBounder stringBounder ) { return getTetris ( stringBounder ) . getHeight ( ) ; }
public void setLatitude ( Double latitude ) { this . latitude = latitude ; }
private boolean isNetscape ( ) { if ( block . length < NETSCAPE . length ) { return false ; } for ( int i = 0 , N = NETSCAPE . length ; i < N ; i ++ ) { if ( NETSCAPE [ i ] != ( char ) block [ i ] ) { return false ; } } return true ; }
public Class < ? > getSupportedType ( ) { return ReadableInterval . class ; }
public long timeSinceLastCaughtUpMs ( ) { return timeSinceLastCaughtUpMs ; }
public void setClientRegistrationConverter ( Converter < RegisteredClient , OidcClientRegistration > clientRegistrationConverter ) { Assert . notNull ( clientRegistrationConverter , "clientRegistrationConverter cannot be null" ) ; this . clientRegistrationConverter = clientRegistrationConverter ; }
public CompletableFuture < GetLiteTopicInfoResponseBody > getLiteTopicInfoAsync ( String addr , String parentTopic , String liteTopic , long timeoutMillis ) { GetLiteTopicInfoRequestHeader requestHeader = new GetLiteTopicInfoRequestHeader ( ) ; requestHeader . setParentTopic ( parentTopic ) ; requestHeader . setLiteTopic ( liteTopic ) ; RemotingCommand request = RemotingCommand . createRequestCommand ( RequestCode . GET_LITE_TOPIC_INFO , requestHeader ) ; return this . getRemotingClient ( ) . invoke ( addr , request , timeoutMillis ) . thenApply ( response -> { if ( ResponseCode . SUCCESS == response . getCode ( ) ) { try { return GetLiteTopicInfoResponseBody . decode ( response . getBody ( ) , GetLiteTopicInfoResponseBody . class ) ; } catch ( Exception e ) { throw new CompletionException ( e ) ; } } else { throw new CompletionException ( new MQBrokerException ( response . getCode ( ) , response . getRemark ( ) ) ) ; } } ) ; }
public ObjectParser < T , M , L > gainObjectParser ( ) { return objectParser ; }
public final LongDefault < R > longType ( ) { return longBuilder ( ) . endLong ( ) ; }
public static io . kubernetes . client . proto . V1Networking . IngressRuleValue parseFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
public void setAddTime ( LocalDateTime addTime ) { this . addTime = addTime ; }
public static PublicKey loadPublicKey ( File publicKeyFile ) throws IOException , GeneralSecurityException { String publicKey = new String ( Files . readAllBytes ( publicKeyFile . toPath ( ) ) , US_ASCII ) ; return loadPublicKey ( publicKey ) ; }
private void notifyReceivedBackgroundToJS ( ) { try { Bundle bundle = mNotificationProps . asBundle ( ) ; mJsIOHelper . sendEventToJS ( NOTIFICATION_RECEIVED_BACKGROUND_EVENT_NAME , bundle , mAppLifecycleFacade . getRunningReactContext ( ) ) ; } catch ( NullPointerException ex ) { Log . e ( LOGTAG , "notifyReceivedBackgroundToJS: Null pointer exception" ) ; } }
private void showOverflowMenu ( @ NonNull View anchorView , @ NonNull InputDeviceProfile device ) { List < PopUpMenuItem > items = new ArrayList < > ( ) ; items . add ( new PopUpMenuItem . Builder ( context ) . setTitle ( app . getString ( R . string . shared_string_rename ) ) . setIcon ( getContentIcon ( R . drawable . ic_action_edit_outlined ) ) . setOnClickListener ( v -> { controller . askRenameDevice ( device ) ; } ) . create ( ) ) ; items . add ( new PopUpMenuItem . Builder ( context ) . setTitle ( app . getString ( R . string . shared_string_duplicate ) ) . setIcon ( getContentIcon ( R . drawable . ic_action_copy ) ) . setOnClickListener ( v -> { controller . duplicateDevice ( device ) ; } ) . create ( ) ) ; items . add ( new PopUpMenuItem . Builder ( context ) . setTitle ( app . getString ( R . string . shared_string_remove ) ) . setIcon ( getContentIcon ( R . drawable . ic_action_delete_outlined ) ) . showTopDivider ( true ) . setOnClickListener ( v -> { controller . askRemoveDevice ( device ) ; } ) . create ( ) ) ; PopUpMenuDisplayData displayData = new PopUpMenuDisplayData ( ) ; displayData . anchorView = anchorView ; displayData . menuItems = items ; displayData . nightMode = isNightMode ( ) ; displayData . layoutId = R . layout . simple_popup_menu_item ; PopUpMenu . show ( displayData ) ; }
public void addUnknownElement ( Element element ) { appendSelf ( element ) ; addReturnToSelf ( ) ; }
private void initCustomConstructor ( ) throws ClassNotFoundException , NoSuchMethodException { String aic = mApplicationInfo . className ; Class < ? > psc = mPlgClassLoader . loadClass ( aic ) ; mApplicationConstructor = psc . getConstructor ( ) ; }
public Boolean getOldValue ( ChunkData data ) { return null ; }
public boolean isHttpCheck ( ) { return httpCheck ; }
public Reader createReader ( ) { return new QRCodeReader ( ) ; }
public static String formatForJavaKeyword ( final String value ) { if ( ValidationUtil . isJavaKeyword ( value ) ) { final String keywordAppendToken = System . getProperty ( SbeTool . KEYWORD_APPEND_TOKEN ) ; if ( null == keywordAppendToken ) { throw new IllegalStateException ( "Invalid property name='" + value + "' please correct the schema or consider setting system property: " + SbeTool . KEYWORD_APPEND_TOKEN ) ; } return value + keywordAppendToken ; } return value ; }
private void updateSuggestedPostInfo ( TdApi . UpdateMessageSuggestedPostInfo update ) { }
private boolean isSearchEditBlank ( ) { return isBlank ( getSearchEditString ( ) ) ; }
public boolean isRead ( ) { return read ; }
public R endBytes ( ) { return super . end ( ) ; }
public static Bitmap resize ( Bitmap bitmap , int maxWidth , int maxHeight ) { if ( maxHeight <= 0 || maxWidth <= 0 ) { return bitmap ; } float maxRatio = ( float ) maxWidth / maxHeight ; float ratio = ( float ) bitmap . getWidth ( ) / bitmap . getHeight ( ) ; int width = maxWidth ; int height = maxHeight ; if ( maxRatio > 1 ) { width = ( int ) ( ( float ) maxHeight * ratio ) ; } else { height = ( int ) ( ( float ) maxWidth / ratio ) ; } return Bitmap . createScaledBitmap ( bitmap , width , height , true ) ; }
public T5 getT5 ( ) { return t5 ; }
public static Pair < ByteBuffer , ByteBuffer > getOffsetByteBufferPair ( ) { ByteBuffer offsetKey = ByteBuffer . allocateDirect ( RocksDBConsumeQueueStore . MAX_KEY_LEN ) ; ByteBuffer offsetValue = ByteBuffer . allocateDirect ( OFFSET_VALUE_LENGTH ) ; return new Pair < > ( offsetKey , offsetValue ) ; }
public static String format ( Date date ) { return format ( date , false , TIMEZONE_UTC ) ; }
public void clearRecents ( ) { Settings . instance ( ) . clearEmojiRecents ( ) ; recents = new ArrayList < > ( ) ; fillDefaultRecents ( ) ; }
public boolean isIconVisible ( ) { return _prefs . getBoolean ( "pref_show_icons" , true ) ; }
public void assertHasSizeGreaterThan ( AssertionInfo info , char [ ] actual , int boundary ) { arrays . assertHasSizeGreaterThan ( info , actual , boundary ) ; }
public static ContentType validateContentType ( String contentType ) throws IllegalArgumentException { if ( contentType == null || ! GRPC_GCP_CONTENT_TYPES . containsKey ( contentType ) ) { throw new IllegalArgumentException ( "This content type is not used for grpc-web: " + contentType ) ; } return getContentType ( contentType ) ; }
public int getPage ( ) { return mPage ; }
public ChecksumsImpl getChecksums ( ) { return checksums ; }
static Integer getBatteryLevel ( Context context ) { try { BatteryManager bm = Helper . getSystemService ( context , BatteryManager . class ) ; if ( bm == null ) return null ; return bm . getIntProperty ( BatteryManager . BATTERY_PROPERTY_CAPACITY ) ; } catch ( Throwable ex ) { Log . e ( ex ) ; return null ; } }
SortedMap < K , V > dropRight ( int n ) ; @ Override SortedMap < K , V > dropUntil ( @ NonNull Predicate < ? super Tuple2 < K , V > > predicate ) ; @ Override SortedMap < K , V > dropWhile ( @ NonNull Predicate < ? super Tuple2 < K , V > > predicate ) ; @ Override SortedMap < K , V > filter ( @ NonNull Predicate < ? super Tuple2 < K , V > > predicate ) ; @ Override SortedMap < K , V > reject ( @ NonNull Predicate < ? super Tuple2 < K , V > > predicate ) ; @ Override SortedMap < K , V > filter ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override SortedMap < K , V > reject ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override SortedMap < K , V > filterKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override SortedMap < K , V > rejectKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override SortedMap < K , V > filterValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override SortedMap < K , V > rejectValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeAll ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override < K2 , V2 > SortedMap < K2 , V2 > flatMap ( @ NonNull BiFunction < ? super K , ? super V , ? extends Iterable < Tuple2 < K2 , V2 > > > mapper ) ; @ Override < C > Map < C , ? extends SortedMap < K , V > > groupBy ( @ NonNull Function < ? super Tuple2 < K , V > , ? extends C > classifier ) ; @ Override Iterator < ? extends SortedMap < K , V > > grouped ( int size ) ; @ Override SortedMap < K , V > init ( ) ; @ Override Option < ? extends SortedMap < K , V > > initOption ( ) ; @ Override default boolean isOrdered ( ) { return true ; }
public void expr ( ) { term ( ) ; while ( true ) { Token < ? > opToken = this . lookahead ; if ( expectChar ( '+' ) ) { move ( true ) ; term ( ) ; getCodeGeneratorWithTimes ( ) . onAdd ( opToken ) ; } else if ( expectChar ( '-' ) ) { move ( true ) ; term ( ) ; getCodeGeneratorWithTimes ( ) . onSub ( opToken ) ; } else { break ; } } }
public static InvocationHandlerAdapter toField ( String name , FieldLocator . Factory fieldLocatorFactory ) { return new ForField ( name , CACHED , UNPRIVILEGED , RETURNING , Assigner . DEFAULT , fieldLocatorFactory ) ; }
public static < T > List < T > loadFactories ( Class < T > clazz ) { return loadFactories ( clazz , null ) ; }
public boolean autoArchiveAvailable ( ) { return options . canArchiveAndMuteNewChatsFromUnknownUsers ; }
public void info ( String text ) { console . getUnderlyingConsole ( ) . print ( text + System . lineSeparator ( ) , ConsoleViewContentType . NORMAL_OUTPUT ) ; }
public void runOnTdlibThread ( @ NonNull Runnable runnable ) { runOnTdlibThread ( runnable , 0 , true ) ; }
public static boolean isRun ( boolean val ) { gPrefs . edit ( ) . putBoolean ( RUN_NOTIFICATION , val ) . commit ( ) ; return val ; }
public int getUniformLocation ( String name ) { if ( ! isInitialized ( ) ) { throw new IllegalStateException ( "Initialize the program first!" ) ; } Integer loc = uniformLocations . get ( name ) ; if ( loc == null ) { throw new IllegalArgumentException ( "Name of uniform " + name + " was not added before init" ) ; } return loc ; }
public long getLastModified ( ) { return 1L ; }
public OpenLocalBlockResponse call ( ) throws Exception { checkState ( mRequest == null ) ; mRequest = request ; if ( mBlockLock . isPresent ( ) ) { LOG . warn ( "Lock block {} without releasing previous block lock {}." , mRequest . getBlockId ( ) , mBlockLock ) ; throw new InvalidWorkerStateException ( MessageFormat . format ( "session {0,number,#} is not closed." , mBlockLock ) ) ; } mSessionId = IdUtils . createSessionId ( ) ; Optional < BlockMeta > meta = mLocalBlockStore . getVolatileBlockMeta ( mRequest . getBlockId ( ) ) ; if ( ! meta . isPresent ( ) ) { throw new BlockDoesNotExistRuntimeException ( mRequest . getBlockId ( ) ) ; } try { TieredBlockStore . validateBlockIntegrityForRead ( meta . get ( ) ) ; } catch ( IllegalStateException validationError ) { throw new BlockDoesNotExistRuntimeException ( mRequest . getBlockId ( ) , validationError ) ; } if ( mRequest . getPromote ( ) ) { BlockStoreLocation dst = BlockStoreLocation . anyDirInTier ( WORKER_STORAGE_TIER_ASSOC . getAlias ( 0 ) ) ; if ( ! meta . get ( ) . getBlockLocation ( ) . belongsTo ( dst ) ) { mLocalBlockStore . moveBlock ( mSessionId , mRequest . getBlockId ( ) , AllocateOptions . forMove ( dst ) ) ; meta = mLocalBlockStore . getVolatileBlockMeta ( mRequest . getBlockId ( ) ) ; } } mBlockLock = mLocalBlockStore . pinBlock ( mSessionId , mRequest . getBlockId ( ) ) ; mLocalBlockStore . accessBlock ( mSessionId , mRequest . getBlockId ( ) ) ; DefaultBlockWorker . Metrics . WORKER_ACTIVE_CLIENTS . inc ( ) ; return OpenLocalBlockResponse . newBuilder ( ) . setPath ( meta . get ( ) . getPath ( ) ) . build ( ) ; }
public static boolean authorizeUsingAccessExpression ( final IExpressionContext context , final String accessExpression , final Authentication authentication ) { Validate . notNull ( context , "Context cannot be null" ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( "[THYMELEAF][{}] Checking authorization using access expression \"{}\" for user \"{}\"." , new Object [ ] { TemplateEngine . threadIndex ( ) , accessExpression , ( authentication == null ? null : authentication . getName ( ) ) } ) ; } final boolean authorized = ( SpringVersionSpecificUtils . isWebFluxContext ( context ) ) ? WebFluxAuthUtils . authorizeUsingAccessExpressionWebFlux ( context , accessExpression , authentication ) : MvcAuthUtils . authorizeUsingAccessExpressionMvc ( context , accessExpression , authentication ) ; if ( authorized ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "[THYMELEAF][{}] Checked authorization using access expression \"{}\" for user \"{}\". Access GRANTED." , new Object [ ] { TemplateEngine . threadIndex ( ) , accessExpression , ( authentication == null ? null : authentication . getName ( ) ) } ) ; } return true ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( "[THYMELEAF][{}] Checked authorization using access expression \"{}\" for user \"{}\". Access DENIED." , new Object [ ] { TemplateEngine . threadIndex ( ) , accessExpression , ( authentication == null ? null : authentication . getName ( ) ) } ) ; } return false ; }
protected List < LogFile > getOrderedLogsFromScn ( OracleConnectorConfig config , Scn sinceScn , OracleConnection connection ) throws SQLException { final LogFileCollector collector = new LogFileCollector ( config , connection ) ; return collector . getLogs ( sinceScn ) . stream ( ) . sorted ( Comparator . comparing ( LogFile :: getSequence ) ) . collect ( Collectors . toList ( ) ) ; }
public RouterFunctions . Builder resources ( String pattern , Resource location ) { builder . resources ( pattern , location ) ; return this ; }
public void setLoadAsync ( boolean loadAsync ) { this . loadAsync = loadAsync ; }
public String getField ( ) { return delegate . getField ( ) ; }
int sendOutOfBandData ( byte b ) throws IOException { synchronized ( writeLock ) { ensureWriteOpen ( ) ; int n = 0 ; try { begin ( ) ; synchronized ( stateLock ) { if ( ! isOpen ( ) ) return 0 ; writerThread = NativeThread . current ( ) ; } for ( ; ; ) { n = sendOutOfBandData ( fd , b ) ; if ( ( n == IOStatus . INTERRUPTED ) && isOpen ( ) ) continue ; return IOStatus . normalize ( n ) ; } } finally { writerCleanup ( ) ; end ( ( n > 0 ) || ( n == IOStatus . UNAVAILABLE ) ) ; synchronized ( stateLock ) { if ( ( n <= 0 ) && ( ! isOutputOpen ) ) throw new AsynchronousCloseException ( ) ; } assert IOStatus . check ( n ) ; } } }
public void setupPreference ( boolean nightMode , SliderPreferenceListener listener ) { this . nightMode = nightMode ; this . listener = listener ; isSliderVisible = listener . getValue ( ) > 0 ; }
public MojoExecution getMojoExecution ( ) { return mojoExecution ; }
public Object printVersionHelpMessage ( CommandLine commandLine ) { commandLine . printVersionHelp ( System . out ) ; return null ; }
public Result filter ( final Logger logger , final Level level , final Marker marker , final String msg , final Object p0 , final Object p1 , final Object p2 , final Object p3 , final Object p4 , final Object p5 , final Object p6 , final Object p7 ) { return Result . DENY ; }
private ConnectionPool getReplicationConnectionPool ( MaxwellBootstrapUtilityConfig config ) throws SQLException { String connectionURI = config . getReplicationConnectionURI ( ) ; return new C3P0ConnectionPool ( connectionURI , config . replicationMysql . user , config . replicationMysql . password ) ; }
private static Value getDbObjectSize ( DbObject object , boolean total , boolean approximate ) { long size = 0L ; if ( object instanceof Table ) { size = ( ( Table ) object ) . getDiskSpaceUsed ( total , approximate ) ; } else if ( object instanceof Index ) { size = ( ( Index ) object ) . getDiskSpaceUsed ( approximate ) ; } return ValueBigint . get ( size ) ; }
public void add ( final int ... dat ) { this . addN ( dat , 0 , dat . length ) ; }
abstract void restoreState ( ByteBuf buf ) ; abstract void persistState ( ByteBuf buf ) ; public void addReturnData ( Map < String , String > returnData ) { }
public Long getTerm ( ) { return term ; }
public void draw ( @ NonNull Canvas canvas ) { canvas . save ( ) ; canvas . translate ( 0 , dp ( 1 ) ) ; verifiedDrawable . setBounds ( getBounds ( ) ) ; verifiedDrawable . draw ( canvas ) ; canvas . restore ( ) ; }
public void setLineWidth ( int lineWidth ) { this . mLineWidth = lineWidth ; invalidate ( ) ; }
public List < Exception > getVersionRangeViolations ( ) { return versionRangeViolations == null ? Collections . emptyList ( ) : Collections . unmodifiableList ( versionRangeViolations ) ; }
public String createFailover ( FailoverType failoverType , String group , String serviceId , String failoverValue ) { RuleEntity ruleEntity = getRemoteRuleEntity ( group , serviceId ) ; createFailover ( failoverType , ruleEntity , failoverValue ) ; updateRemoteRuleEntity ( group , serviceId , ruleEntity ) ; return configResource . fromRuleEntity ( ruleEntity ) ; }
public static io . kubernetes . client . proto . V1Networking . IngressTLS parseFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
public Builder fragmentsByName ( Map < String , FragmentDefinition > fragmentsByName ) { this . fragmentsByName = fragmentsByName ; return this ; }
public Status read ( String table , String key , Set < String > fields , Map < String , ByteIterator > result ) { try { PrimaryKeyColumn [ ] primaryKeyColumns = new PrimaryKeyColumn [ 1 ] ; primaryKeyColumns [ 0 ] = new PrimaryKeyColumn ( primaryKeyName , PrimaryKeyValue . fromString ( key ) ) ; PrimaryKey primaryKey = new PrimaryKey ( primaryKeyColumns ) ; SingleRowQueryCriteria singleRowQueryCriteria = new SingleRowQueryCriteria ( table , primaryKey ) ; singleRowQueryCriteria . setMaxVersions ( maxVersions ) ; if ( fields != null ) { singleRowQueryCriteria . addColumnsToGet ( fields . toArray ( new String [ 0 ] ) ) ; } GetRowRequest getRowRequest = new GetRowRequest ( ) ; getRowRequest . setRowQueryCriteria ( singleRowQueryCriteria ) ; GetRowResponse getRowResponse = client . getRow ( getRowRequest ) ; setResult ( fields , result , getRowResponse . getRow ( ) ) ; return Status . OK ; } catch ( TableStoreException e ) { return dealWithTableStoreException ( e ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; return Status . ERROR ; } }
public Schema < byte [ ] > newBytesSchema ( ) { return new BytesSchema ( ) ; }
private synchronized void maybeSetInactive ( ) { lockCount -- ; if ( lockCount == 0 ) { cache . removeFromActive ( this ) ; readWriteLock = null ; } }
public String getFieldManager ( ) { return fieldManager ; }
protected StringBldr < R > self ( ) { return this ; }
public double readDouble ( boolean exception ) { try { return Double . longBitsToDouble ( readInt64 ( exception ) ) ; } catch ( Exception e ) { if ( exception ) { throw new RuntimeException ( "read double error" , e ) ; } else { if ( BuildVars . LOGS_ENABLED ) { FileLog . e ( "read double error" ) ; FileLog . e ( e ) ; } } } return 0 ; }
public UpdateSet getUpdateSet ( int index ) { return updateSets . get ( index ) ; }
public Integer getVisible ( ) { return visible ; }
public io . kubernetes . client . proto . V1Networking . NetworkPolicyPeer . Builder getToBuilder ( int index ) { return getToFieldBuilder ( ) . getBuilder ( index ) ; }
public < E extends Expression > E getWhere ( Class < E > type ) { return type . cast ( getWhere ( ) ) ; }
public GenericDraweeHierarchyBuilder setRetryImage ( int resourceId ) { mRetryImage = mResources . getDrawable ( resourceId ) ; return this ; }
public void deserialize ( ByteBuf buf ) { super . deserialize ( buf ) ; int size = buf . readInt ( ) ; vector = VFactory . sparseDoubleVector ( ( int ) ( splitContext . getPartKey ( ) . getEndCol ( ) - splitContext . getPartKey ( ) . getStartCol ( ) ) , size ) ; for ( int i = 0 ; i < size ; i ++ ) { ( ( IntDoubleVector ) vector ) . set ( buf . readInt ( ) , buf . readDouble ( ) ) ; } }
public String toString ( ) { return "JavaMelodyConfigurationProperties [enabled=" + enabled + ", excludedDatasources=" + excludedDatasources + ", initParameters=" + initParameters + "]" ; }
protected T getFirstLeft ( List < T > sets ) { for ( T dataSet : sets ) { if ( dataSet . getAxisDependency ( ) == AxisDependency . LEFT ) return dataSet ; } return null ; }
public final void onResult ( T result , @ Nullable TdApi . Error error ) { if ( isPending ( ) ) { act ( result , error ) ; } }
public boolean needAvatarPreviewAnimation ( TdApi . MessageSender sender ) { return senderPremium ( sender ) ; }
private FlinkRemotePerJobBuildRequest buildFlinkRemotePerJobBuildRequest ( @ Nonnull FlinkApplication app , String mainClass , String flinkUserJar , FlinkEnv flinkEnv ) { return new FlinkRemotePerJobBuildRequest ( app . getJobName ( ) , app . getLocalAppHome ( ) , mainClass , flinkUserJar , app . isFlinkJar ( ) , app . getDeployModeEnum ( ) , app . getJobTypeEnum ( ) , flinkEnv . getFlinkVersion ( ) , getMergedDependencyInfo ( app ) ) ; }
public String getDescription ( ) { return translate ( "filter.xfl" ) . replace ( "%version%" , v . applicationName ( ) ) ; }
protected ArrayList < MessageTarget > onExecute ( Context context , Bundle args ) { long aid = args . getLong ( "account" ) ; String thread = args . getString ( "thread" ) ; long id = args . getLong ( "id" ) ; String type = args . getString ( "type" ) ; boolean move_thread_sent = args . getBoolean ( "move_thread_sent" ) ; boolean filter_archive = args . getBoolean ( "filter_archive" ) ; ArrayList < MessageTarget > result = new ArrayList < > ( ) ; DB db = DB . getInstance ( context ) ; try { db . beginTransaction ( ) ; EntityAccount account = db . account ( ) . getAccount ( aid ) ; if ( account == null ) return result ; EntityFolder targetFolder = db . folder ( ) . getFolderByType ( aid , type ) ; if ( targetFolder == null ) return result ; List < EntityMessage > messages = db . message ( ) . getMessagesByThread ( aid , thread , threading ? null : id , null ) ; for ( EntityMessage threaded : messages ) { EntityFolder sourceFolder = db . folder ( ) . getFolder ( threaded . folder ) ; if ( sourceFolder != null && ! sourceFolder . read_only && ! targetFolder . id . equals ( threaded . folder ) && ( ! filter_archive || ! EntityFolder . ARCHIVE . equals ( sourceFolder . type ) ) && ! EntityFolder . DRAFTS . equals ( sourceFolder . type ) && ! EntityFolder . OUTBOX . equals ( sourceFolder . type ) && ! ( EntityFolder . SENT . equals ( sourceFolder . type ) && EntityFolder . ARCHIVE . equals ( targetFolder . type ) ) && ! ( EntityFolder . SENT . equals ( sourceFolder . type ) && EntityFolder . JUNK . equals ( targetFolder . type ) ) && ( ! EntityFolder . SENT . equals ( sourceFolder . type ) || ! EntityFolder . TRASH . equals ( targetFolder . type ) || move_thread_sent ) && ! EntityFolder . TRASH . equals ( sourceFolder . type ) && ! EntityFolder . JUNK . equals ( sourceFolder . type ) ) result . add ( new MessageTarget ( context , threaded , account , sourceFolder , account , targetFolder ) ) ; } db . setTransactionSuccessful ( ) ; } finally { db . endTransaction ( ) ; } return result ; }
protected void colorCalcARGB ( int argb , float alpha ) { if ( alpha == colorModeA ) { calcAi = ( argb > > 24 ) & 0xff ; calcColor = argb ; } else { calcAi = ( int ) ( ( ( argb > > 24 ) & 0xff ) * PApplet . constrain ( ( alpha / colorModeA ) , 0 , 1 ) ) ; calcColor = ( calcAi << 24 ) | ( argb & 0xFFFFFF ) ; } calcRi = ( argb > > 16 ) & 0xff ; calcGi = ( argb > > 8 ) & 0xff ; calcBi = argb & 0xff ; calcA = calcAi / 255.0f ; calcR = calcRi / 255.0f ; calcG = calcGi / 255.0f ; calcB = calcBi / 255.0f ; calcAlpha = ( calcAi != 255 ) ; }
private Box meteor$createHitbox ( Box original , Entity entity , float tickProgress , boolean inLocalServer ) { double v = Modules . get ( ) . get ( Hitboxes . class ) . getEntityValue ( entity ) ; if ( v == 0 ) return original ; return original . expand ( v ) ; }
public static int getScreenWidth ( ) { return getScreenWidth ( App . get ( ) ) ; }
public void commitText ( final CharSequence text , final int newCursorPosition ) { if ( DEBUG_BATCH_NESTING ) checkBatchEdit ( ) ; if ( DEBUG_PREVIOUS_TEXT ) checkConsistencyForDebug ( ) ; if ( DebugFlags . DEBUG_ENABLED ) Log . d ( TAG , "committing " + text . length ( ) + " characters" ) ; mCommittedTextBeforeComposingText . append ( text ) ; mExpectedSelStart += text . length ( ) - mComposingText . length ( ) ; mExpectedSelEnd = mExpectedSelStart ; mComposingText . setLength ( 0 ) ; if ( isConnected ( ) ) { mTempObjectForCommitText . clear ( ) ; mTempObjectForCommitText . append ( text ) ; final CharacterStyle [ ] spans = mTempObjectForCommitText . getSpans ( 0 , text . length ( ) , CharacterStyle . class ) ; for ( final CharacterStyle span : spans ) { final int spanStart = mTempObjectForCommitText . getSpanStart ( span ) ; final int spanEnd = mTempObjectForCommitText . getSpanEnd ( span ) ; final int spanFlags = mTempObjectForCommitText . getSpanFlags ( span ) ; if ( 0 < spanEnd && spanEnd < mTempObjectForCommitText . length ( ) ) { final char spanEndChar = mTempObjectForCommitText . charAt ( spanEnd - 1 ) ; final char nextChar = mTempObjectForCommitText . charAt ( spanEnd ) ; if ( UnicodeSurrogate . isLowSurrogate ( spanEndChar ) && UnicodeSurrogate . isHighSurrogate ( nextChar ) ) { mTempObjectForCommitText . setSpan ( span , spanStart , spanEnd + 1 , spanFlags ) ; } } } mIC . commitText ( mTempObjectForCommitText , newCursorPosition ) ; } }
public long tell ( ) throws IOException { return getChannel ( ) . position ( ) ; }
public void start ( boolean sync ) { doStart ( sync ) ; }
public long lookupTerm ( BytesRef key ) throws IOException { SeekStatus status = termsEnum . seekCeil ( key ) ; switch ( status ) { case FOUND : return termsEnum . ord ( ) ; case NOT_FOUND : case END : default : return - 1L - termsEnum . ord ( ) ; } }
public static String shortHex ( byte [ ] data ) { byte [ ] bytes = ByteUtil . stripLeadingZeroes ( data ) ; String hexValue = Hex . toHexString ( bytes ) . toUpperCase ( ) ; return "0x" + hexValue . replaceFirst ( "^0+(?!$)" , "" ) ; }
public void loadContacts ( ) { setAdapter ( ) ; loadData ( ) ; }
public static TaskStatus match ( String val , TaskStatus def ) { return Stream . of ( values ( ) ) . parallel ( ) . filter ( item -> item . name ( ) . equalsIgnoreCase ( val ) ) . findAny ( ) . orElse ( def ) ; }
private static String removeOptionalDescription ( String line ) { return line . replaceAll ( ":.*" , "" ) ; }
public TdApi . Usernames chatUsernames ( long chatId ) { if ( chatId == 0 ) { return null ; } switch ( ChatId . getType ( chatId ) ) { case TdApi . ChatTypeBasicGroup . CONSTRUCTOR : { return null ; } case TdApi . ChatTypePrivate . CONSTRUCTOR : { long userId = ChatId . toUserId ( chatId ) ; return cache ( ) . userUsernames ( userId ) ; } case TdApi . ChatTypeSecret . CONSTRUCTOR : { int secretChatId = ChatId . toSecretChatId ( chatId ) ; TdApi . SecretChat secretChat = cache ( ) . secretChat ( secretChatId ) ; if ( secretChat != null ) { return cache ( ) . userUsernames ( secretChat . userId ) ; } return null ; } case TdApi . ChatTypeSupergroup . CONSTRUCTOR : { long supergroupId = ChatId . toSupergroupId ( chatId ) ; return cache ( ) . supergroupUsernames ( supergroupId ) ; } default : { Td . assertChatType_e562ec7d ( ) ; throw new UnsupportedOperationException ( Long . toString ( chatId ) ) ; } } }
public MapMarkPointType getMapMarkPointType ( ) { return this . mapMarkPointType ; }
private static Entry getIndexEntry ( CompositeIndexType index , IndexRecordEntry [ ] record , JanusGraphElement element , Serializer serializer , TypeInspector typeInspector , EdgeSerializer edgeSerializer ) { List < Entry > inlineProperties = getInlineProperties ( element , index , typeInspector , edgeSerializer ) ; int inlinePropertiesSize = getInlinePropertiesSize ( inlineProperties ) ; final DataOutput out = serializer . getDataOutput ( 1 + 8 + 8 * record . length + 4 * 8 + inlinePropertiesSize ) ; out . putByte ( FIRST_INDEX_COLUMN_BYTE ) ; if ( index . getCardinality ( ) != Cardinality . SINGLE ) { if ( element instanceof JanusGraphVertex ) { IDHandler . writeVertexId ( out , element . id ( ) , true ) ; } else { assert element instanceof JanusGraphRelation ; assert ( ( JanusGraphRelation ) element ) . longId ( ) == ( ( RelationIdentifier ) element . id ( ) ) . getRelationId ( ) ; VariableLong . writePositive ( out , ( ( JanusGraphRelation ) element ) . longId ( ) ) ; } if ( index . getCardinality ( ) != Cardinality . SET ) { for ( final IndexRecordEntry re : record ) { VariableLong . writePositive ( out , re . getRelationId ( ) ) ; } } } final int valuePosition = out . getPosition ( ) ; if ( element instanceof JanusGraphVertex ) { IDHandler . writeVertexId ( out , element . id ( ) , true ) ; writeInlineProperties ( inlineProperties , out ) ; } else { assert element instanceof JanusGraphRelation ; final RelationIdentifier rid = ( RelationIdentifier ) element . id ( ) ; VariableLong . writePositive ( out , rid . getRelationId ( ) ) ; IDHandler . writeVertexId ( out , rid . getOutVertexId ( ) , true ) ; VariableLong . writePositive ( out , rid . getTypeId ( ) ) ; if ( rid . getInVertexId ( ) != null ) { IDHandler . writeVertexId ( out , rid . getInVertexId ( ) , true ) ; } } return new StaticArrayEntry ( out . getStaticBuffer ( ) , valuePosition ) ; }
@ Override void putLong ( byte [ ] array , long offset , long l ) { super . putLong ( array , offset , Long . reverseBytes ( l ) ) ; }
public SarifLogBuilder addConfigurationError ( Report . ConfigurationError error ) { AssociatedRule associatedRule = AssociatedRule . builder ( ) . id ( error . rule ( ) . getName ( ) ) . build ( ) ; Message message = Message . builder ( ) . text ( error . issue ( ) ) . build ( ) ; ToolConfigurationNotification toolConfigurationNotification = ToolConfigurationNotification . builder ( ) . associatedRule ( associatedRule ) . message ( message ) . build ( ) ; toolConfigurationNotifications . add ( toolConfigurationNotification ) ; return this ; }
public View getView ( int position , @ Nullable View convertView , @ NonNull ViewGroup parent ) { if ( convertView == null ) convertView = mLayoutInflater . inflate ( R . layout . blacklist_item , parent , false ) ; Context ctx = parent . getContext ( ) ; BlacklistDescriptor bl = getItem ( position ) ; TextView label = convertView . findViewById ( R . id . label ) ; label . setText ( bl . label ) ; TextView status = convertView . findViewById ( R . id . status ) ; status . setText ( bl . getStatusLabel ( ctx ) ) ; status . setTextColor ( bl . getStatusColor ( ctx ) ) ; status . setVisibility ( CaptureService . isServiceActive ( ) ? View . VISIBLE : View . INVISIBLE ) ; ( ( TextView ) convertView . findViewById ( R . id . type ) ) . setText ( String . format ( ctx . getString ( R . string . blacklist_type ) , bl . getTypeLabel ( ctx ) ) ) ; ( ( TextView ) convertView . findViewById ( R . id . rules ) ) . setText ( String . format ( ctx . getString ( R . string . n_rules ) , Utils . formatIntShort ( bl . num_rules ) ) ) ; ( ( TextView ) convertView . findViewById ( R . id . last_update ) ) . setText ( String . format ( ctx . getString ( R . string . last_update_val ) , Utils . formatEpochMin ( ctx , bl . getLastUpdate ( ) / 1000 ) ) ) ; return convertView ; }
public String getMappedKey ( String paramKey ) { if ( this . mapperRules . containsKey ( paramKey ) ) { return this . mapperRules . get ( paramKey ) ; } else { return paramKey ; } }
public void error ( String message ) { error ( "%s" , message ) ; }
public void doCloseCachedWrappedValue ( ) { this . cachedWrappedValueRead = false ; }
public String on ( ) { return "#" ; }
public @ Override void readSettings ( WizardDescriptor settings ) { reloadData ( ) ; }
public NullValueCheckStrategyGem getNullValueCheckStrategy ( ) { return NullValueCheckStrategyGem . valueOf ( mapper . nullValueCheckStrategy ( ) . getDefaultValue ( ) ) ; }
public void remove ( String package_name ) { mRules . remove ( package_name ) ; save ( ) ; }
public boolean shrink ( ) { return shrink ( 240 ) ; }
public boolean onPrepareOptionsMenu ( Menu menu ) { PackageManager pm = getPackageManager ( ) ; menu . findItem ( R . id . menu_export ) . setEnabled ( getIntentExport ( ) . resolveActivity ( pm ) != null ) ; return super . onPrepareOptionsMenu ( menu ) ; }
static String getUiModeType ( Context context ) { try { UiModeManager uimm = Helper . getSystemService ( context , UiModeManager . class ) ; int uiModeType = uimm . getCurrentModeType ( ) ; switch ( uiModeType & Configuration . UI_MODE_TYPE_MASK ) { case Configuration . UI_MODE_TYPE_UNDEFINED : return "undefined" ; case Configuration . UI_MODE_TYPE_NORMAL : return "normal" ; case Configuration . UI_MODE_TYPE_DESK : return "desk" ; case Configuration . UI_MODE_TYPE_CAR : return "car" ; case Configuration . UI_MODE_TYPE_TELEVISION : return "television" ; case Configuration . UI_MODE_TYPE_APPLIANCE : return "appliance" ; case Configuration . UI_MODE_TYPE_WATCH : return "watch" ; case Configuration . UI_MODE_TYPE_VR_HEADSET : return "vr headset" ; default : return Integer . toString ( uiModeType ) ; } } catch ( Throwable ex ) { Log . w ( ex ) ; return null ; } }
Builder stageFunction ( String fromColumn , AggregateFunctions function ) { checkNothingStaged ( ) ; Preconditions . checkNotNull ( fromColumn ) ; Preconditions . checkNotNull ( function ) ; this . stagedFromColumn = fromColumn ; this . stagedAggregateFunction = function ; return this ; }
private OkHttpResponse sendPostRequest ( ) { OkHttpRequestHeaders okHttpRequestHeaders = new OkHttpRequestHeaders ( ) ; okHttpRequestHeaders . setHeaders ( headerParams ) ; okHttpRequestHeaders . setOkHttpRequestHeaderContentType ( contentType ) ; Map < String , Object > requestBody = Collections . unmodifiableMap ( bodyParams ) ; log . info ( "sending http alert post request, url: {}, header: {}, requestBody: {}, contentType: {}" , url , headerParams , requestBody , contentType . getValue ( ) ) ; return OkHttpUtils . post ( url , okHttpRequestHeaders , null , requestBody , timeout , timeout , timeout ) ; }
public static TypeBuilder < Schema > builder ( String namespace ) { return new TypeBuilder < > ( new SchemaCompletion ( ) , new NameContext ( ) . namespace ( namespace ) ) ; }
public void setAttributePrice ( String attributePrice ) { this . attributePrice = attributePrice ; }
public static void openMainFragment ( final FragmentManager fragmentManager ) { InfoCache . getInstance ( ) . trimCache ( ) ; fragmentManager . popBackStackImmediate ( null , FragmentManager . POP_BACK_STACK_INCLUSIVE ) ; defaultTransaction ( fragmentManager ) . replace ( R . id . fragment_holder , new MainFragment ( ) ) . addToBackStack ( MAIN_FRAGMENT_TAG ) . commit ( ) ; }
public String getFormatText ( ) { return "<biome>[,<biome>,...]" ; }
public void createBranch ( String branchName , String tagName ) { branchManager ( ) . createBranch ( branchName , tagName ) ; }
public int getDisplayHeight ( ) { return getHeight ( ) ; }
public void setKeyId ( String keyId ) { this . keyId = keyId == null ? null : keyId . trim ( ) ; }
public void removeMarginPageTransformer ( ) { mBannerManager . removeMarginPageTransformer ( ) ; }
void setScanResult ( final ScanResult scanResult ) { super . setScanResult ( scanResult ) ; if ( this . typeSignature != null ) { this . typeSignature . setScanResult ( scanResult ) ; } if ( this . typeDescriptor != null ) { this . typeDescriptor . setScanResult ( scanResult ) ; } if ( this . annotationInfo != null ) { for ( final AnnotationInfo ai : this . annotationInfo ) { ai . setScanResult ( scanResult ) ; } } }
public SiteBody allowed2faMethodYubi ( Boolean allowed2faMethodYubi ) { this . allowed2faMethodYubi = allowed2faMethodYubi ; return this ; }
public static AliasConfiguredTarget create ( RuleContext ruleContext , ConfiguredTarget actual , NestedSet < PackageGroupContents > visibility ) { return createWithOverrides ( ruleContext , actual , visibility , ImmutableClassToInstanceMap . of ( ) ) ; }
public long getPeerRecoveryRetentionLeaseRetainingSeqNo ( DiscoveryNode node ) { assert node != null ; final String retentionLeaseId = ReplicationTracker . getPeerRecoveryRetentionLeaseId ( node . getId ( ) ) ; return peerRecoveryRetentionLeases . stream ( ) . filter ( lease -> lease . id ( ) . equals ( retentionLeaseId ) ) . mapToLong ( RetentionLease :: retainingSequenceNumber ) . findFirst ( ) . orElse ( - 1L ) ; }
public ParagraphBuilder indentFirstLine ( double lineChars ) { if ( null == this . paragraphStyle ) { this . paragraphStyle = ParagraphStyle . builder ( ) . withIndentFirstLineChars ( lineChars ) . build ( ) ; } else { this . paragraphStyle . setIndentFirstLineChars ( lineChars ) ; } return this ; }
static String getFileMoveErrorMessage ( String from , String to ) { return getFileDualOperationErrorMessage ( "move" , from , to ) ; }
public T head ( Class < ? > clazz ) { parameter ( ) . setClazz ( clazz ) ; return self ( ) ; }
public String getPartition ( ) { return partition ; }
private static AccessControlType parseAclType ( String type ) { if ( "other" . equalsIgnoreCase ( type ) || "o" . equalsIgnoreCase ( type ) ) { return AccessControlType . OTHER ; } else if ( "user" . equalsIgnoreCase ( type ) || "u" . equalsIgnoreCase ( type ) ) { return AccessControlType . USER ; } throw new IllegalArgumentException ( type + " is not a valid access control type" ) ; }
public io . kubernetes . client . proto . V1Networking . Ingress . Builder addItemsBuilder ( ) { return getItemsFieldBuilder ( ) . addBuilder ( io . kubernetes . client . proto . V1Networking . Ingress . getDefaultInstance ( ) ) ; }
public boolean isStateFocused ( ) { return stateFocused ; }
private synchronized VideoDecoderFactory getFactory ( ) { if ( factory == null ) { factory = new SoftwareVideoDecoderFactory ( ) ; } return factory ; }
public void maybeSetThrottleTimeMs ( int throttleTimeMs ) { data . setThrottleTimeMs ( throttleTimeMs ) ; }
protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; getSupportFragmentManager ( ) . beginTransaction ( ) . replace ( android . R . id . content , new SettingsFragment ( ) ) . commit ( ) ; }
public DirectedGraph < K , V > findNode ( K key ) { return getChild ( key ) ; }
public static int addressLength ( final byte resType ) { switch ( resType ) { case RES_TYPE_NAME_TO_IP4_MD : return ADDRESS_LENGTH_IP4 ; case RES_TYPE_NAME_TO_IP6_MD : return ADDRESS_LENGTH_IP6 ; } throw new IllegalStateException ( "unknown RES_TYPE=" + resType ) ; }
public void reconfigure ( InetSocketAddress addr ) { LOG . info ( "binding to port {}, {}" , addr , localAddress ) ; if ( addr != null && localAddress != null ) { if ( addr . equals ( localAddress ) || ( addr . getAddress ( ) . isAnyLocalAddress ( ) && localAddress . getAddress ( ) . isAnyLocalAddress ( ) && addr . getPort ( ) == localAddress . getPort ( ) ) ) { LOG . info ( "address is the same, skip rebinding" ) ; return ; } } Channel oldChannel = parentChannel ; try { parentChannel = bootstrap . bind ( addr ) . syncUninterruptibly ( ) . channel ( ) ; localAddress = ( InetSocketAddress ) parentChannel . localAddress ( ) ; LOG . info ( "bound to port {}" , getLocalPort ( ) ) ; } catch ( Exception e ) { LOG . error ( "Error while reconfiguring" , e ) ; } finally { oldChannel . close ( ) ; } }
private String convertToRegexPattern ( final String pathPattern ) { return TEMPLATE_PATTERN . matcher ( pathPattern ) . replaceAll ( TEMPLATE_REGEX ) ; }
public Point [ ] getCropPoints ( ) { return mCropPoints ; }
public void refreshPins ( ) { pinsPanel . load ( ) ; }
public Integer getUdfType ( ) { return udfType ; }
void writeTime ( int pos , TimeData value , int precision ) ; void writeVariant ( int pos , Variant variant ) ; void complete ( ) ; static void write ( BinaryWriter writer , int pos , Object o , DataType type , TypeSerializer < ? > serializer ) { switch ( type . getTypeRoot ( ) ) { case BOOLEAN : writer . writeBoolean ( pos , ( boolean ) o ) ; break ; case TINYINT : writer . writeByte ( pos , ( byte ) o ) ; break ; case SMALLINT : writer . writeShort ( pos , ( short ) o ) ; break ; case INTEGER : writer . writeInt ( pos , ( int ) o ) ; break ; case DATE : if ( o instanceof DateData ) { writer . writeDate ( pos , ( DateData ) o ) ; } else { writer . writeInt ( pos , ( int ) o ) ; } break ; case TIME_WITHOUT_TIME_ZONE : if ( o instanceof TimeData ) { writer . writeTime ( pos , ( TimeData ) o , ( ( TimeType ) type ) . getPrecision ( ) ) ; } else { writer . writeInt ( pos , ( int ) o ) ; } break ; case BIGINT : writer . writeLong ( pos , ( long ) o ) ; break ; case TIMESTAMP_WITHOUT_TIME_ZONE : TimestampType timestampType = ( TimestampType ) type ; writer . writeTimestamp ( pos , ( TimestampData ) o , timestampType . getPrecision ( ) ) ; break ; case TIMESTAMP_WITH_LOCAL_TIME_ZONE : LocalZonedTimestampType lzTs = ( LocalZonedTimestampType ) type ; writer . writeLocalZonedTimestamp ( pos , ( LocalZonedTimestampData ) o , lzTs . getPrecision ( ) ) ; break ; case TIMESTAMP_WITH_TIME_ZONE : ZonedTimestampType zTs = ( ZonedTimestampType ) type ; writer . writeZonedTimestamp ( pos , ( ZonedTimestampData ) o , zTs . getPrecision ( ) ) ; break ; case FLOAT : writer . writeFloat ( pos , ( float ) o ) ; break ; case DOUBLE : writer . writeDouble ( pos , ( double ) o ) ; break ; case CHAR : case VARCHAR : writer . writeString ( pos , ( StringData ) o ) ; break ; case DECIMAL : DecimalType decimalType = ( DecimalType ) type ; writer . writeDecimal ( pos , ( DecimalData ) o , decimalType . getPrecision ( ) ) ; break ; case ARRAY : if ( serializer instanceof NullableSerializerWrapper ) { serializer = ( ( NullableSerializerWrapper ) serializer ) . getWrappedSerializer ( ) ; } writer . writeArray ( pos , ( ArrayData ) o , ( ArrayDataSerializer ) serializer ) ; break ; case MAP : if ( serializer instanceof NullableSerializerWrapper ) { serializer = ( ( NullableSerializerWrapper ) serializer ) . getWrappedSerializer ( ) ; } writer . writeMap ( pos , ( MapData ) o , ( MapDataSerializer ) serializer ) ; break ; case ROW : writer . writeRecord ( pos , ( RecordData ) o , ( TypeSerializer < RecordData > ) serializer ) ; break ; case BINARY : case VARBINARY : writer . writeBinary ( pos , ( byte [ ] ) o ) ; break ; case VARIANT : writer . writeVariant ( pos , ( Variant ) o ) ; break ; default : throw new UnsupportedOperationException ( "Not support type: " + type ) ; } }
private synchronized void initSSL ( ChannelPipeline p , boolean supportPlaintext ) throws X509Exception , SSLException { String authProviderProp = System . getProperty ( x509Util . getSslAuthProviderProperty ( ) ) ; SslContext nettySslContext ; if ( authProviderProp == null ) { nettySslContext = x509Util . createNettySslContextForServer ( new ZKConfig ( ) ) ; } else { X509AuthenticationProvider authProvider = ( X509AuthenticationProvider ) ProviderRegistry . getProvider ( System . getProperty ( x509Util . getSslAuthProviderProperty ( ) , "x509" ) ) ; if ( authProvider == null ) { LOG . error ( "Auth provider not found: {}" , authProviderProp ) ; throw new SSLContextException ( "Could not create SSLContext with specified auth provider: " + authProviderProp ) ; } nettySslContext = x509Util . createNettySslContextForServer ( new ZKConfig ( ) , authProvider . getKeyManager ( ) , authProvider . getTrustManager ( ) ) ; } if ( supportPlaintext ) { p . addLast ( "ssl" , new DualModeSslHandler ( nettySslContext ) ) ; LOG . debug ( "dual mode SSL handler added for channel: {}" , p . channel ( ) ) ; } else { p . addLast ( "ssl" , nettySslContext . newHandler ( p . channel ( ) . alloc ( ) ) ) ; LOG . debug ( "SSL handler added for channel: {}" , p . channel ( ) ) ; } }
public void dismiss ( ) { dismiss ( null ) ; }
public int getColor ( Object key ) { return mColors . get ( Math . abs ( key . hashCode ( ) ) % mColors . size ( ) ) ; }
protected void setMaxFileSize ( long max_filesize_bytes ) { maxFileSize = max_filesize_bytes ; }
public void onDetach ( ) { mContext = null ; super . onDetach ( ) ; }
public void setMaxFailureWaitSeconds ( int val ) { getDelegateForUpdate ( ) ; updated . setMaxFailureWaitSeconds ( val ) ; }
public final void accept ( Context < ? > ctx ) { if ( ifExists && ! supportsIfExists ( ctx ) ) tryCatch ( ctx , DDLStatementType . ALTER_SEQUENCE , c -> accept0 ( c ) ) ; else accept0 ( ctx ) ; }
public void setRemark ( String remark ) { this . remark = remark ; }
public void setInstanceId ( String instanceId ) { this . instanceId = instanceId ; }
public String buildModifyColumn ( TableColumn tableColumn ) { if ( EditStatus . DELETE . name ( ) . equals ( tableColumn . getEditStatus ( ) ) ) { return StringUtils . join ( "DROP COLUMN `" , tableColumn . getName ( ) + "`" ) ; } if ( EditStatus . ADD . name ( ) . equals ( tableColumn . getEditStatus ( ) ) ) { return StringUtils . join ( "ADD COLUMNS (" , buildCreateColumnSql ( tableColumn ) , ")" ) ; } if ( EditStatus . MODIFY . name ( ) . equals ( tableColumn . getEditStatus ( ) ) ) { if ( ! StringUtils . equalsIgnoreCase ( tableColumn . getOldName ( ) , tableColumn . getName ( ) ) ) { return StringUtils . join ( "CHANGE COLUMN `" , tableColumn . getOldName ( ) , "` " , buildCreateColumnSql ( tableColumn ) ) ; } else { return StringUtils . join ( "CHANGE `" , tableColumn . getOldName ( ) , "` " , buildCreateColumnSql ( tableColumn ) ) ; } } return "" ; }
protected String getStringAttribute ( ObjectName objectName , String attribute ) { try { return ( String ) mbeanServer . getAttribute ( objectName , attribute ) ; } catch ( Exception e ) { return ERROR_ATTRIBUTE ; } }
private boolean isFullLeft ( ) { return offset == 0 ; }
public Integer getStatusCode ( ) { return statusCode ; }
public final Type getType ( ) { return Type . FAST ; }
private void unlinkFromSegmentContextsChain ( ) { LocksInterface prevContext = rootContextLockedOnThisSegment ; while ( true ) { LocksInterface nextNode = prevContext . nextNode ( ) ; if ( ( nextNode == ( this ) ) || ( nextNode == null ) ) break ; prevContext = nextNode ; } verifyInnermostContext ( ) ; prevContext . setNextNode ( null ) ; }
public void setMandatory ( Boolean mandatory ) { if ( mandatory == null ) { protocolMapper . getConfig ( ) . remove ( MANDATORY ) ; } else { protocolMapper . getConfig ( ) . put ( MANDATORY , String . valueOf ( mandatory ) ) ; } }
public void refresh ( ) { setEntries ( true ) ; }
public void addResultMap ( ResultMap rm ) { resultMaps . put ( rm . getId ( ) , rm ) ; checkLocallyForDiscriminatedNestedResultMaps ( rm ) ; checkGloballyForDiscriminatedNestedResultMaps ( rm ) ; }
protected String getDefaultCategoryName ( ) { return getString ( R . string . shared_string_none ) ; }
public void setFloat4 ( String name , FloatBuffer buffer ) { setFloat4 ( name , buffer , false ) ; }
public @ Nullable ImageFile chatAvatar ( long chatId ) { return chatAvatar ( chatId , ChatView . getDefaultAvatarCacheSize ( ) ) ; }
public byte [ ] toTronAddress ( ) { byte [ ] ret = new byte [ 21 ] ; ret [ 0 ] = DecodeUtil . addressPreFixByte ; System . arraycopy ( data , 12 , ret , 1 , 20 ) ; return ret ; }
public int hashCode ( ) { return Objects . hash ( super . hashCode ( ) , routing , toCollect , maxRowGranularity , where , ignoreUnavailableIndex , distributionInfo , nodePageSizeHint , orderBy ) ; }
public Document processing ( File inputPdf , GrobidAnalysisConfig config ) throws Exception { return processing ( inputPdf , null , config ) ; }
public void processPage ( PDPage page ) throws IOException { try { super . processPage ( page ) ; } catch ( IOException e ) { handleCatchableIOE ( e ) ; endPage ( page ) ; } }
public void lights ( ) { showMethodWarning ( "lights" ) ; }
protected List < Table > processTables ( String rese , List < LayoutToken > tokenizations , Document doc , int startTableID ) { List < Table > results = new ArrayList < > ( ) ; TaggingTokenClusteror clusteror = new TaggingTokenClusteror ( FULLTEXT , rese , tokenizations , true ) ; int tableId = startTableID ; for ( TaggingTokenCluster cluster : Iterables . filter ( clusteror . cluster ( ) , new TaggingTokenClusteror . LabelTypePredicate ( TaggingLabels . TABLE ) ) ) { List < LayoutToken > tokenizationTable = cluster . concatTokens ( ) ; List < Table > localResults = parsers . getTableParser ( ) . processing ( tokenizationTable , cluster . getFeatureBlock ( ) ) ; for ( Table result : localResults ) { List < LayoutToken > localTokenizationTable = result . getLayoutTokens ( ) ; SortedSet < Integer > blockPtrs = new TreeSet < > ( ) ; for ( LayoutToken lt : localTokenizationTable ) { if ( ! LayoutTokensUtil . spaceyToken ( lt . t ( ) ) && ! LayoutTokensUtil . newLineToken ( lt . t ( ) ) ) { blockPtrs . add ( lt . getBlockPtr ( ) ) ; } } result . setBlockPtrs ( blockPtrs ) ; for ( LayoutToken lt : localTokenizationTable ) { if ( ! LayoutTokensUtil . spaceyToken ( lt . t ( ) ) && ! LayoutTokensUtil . newLineToken ( lt . t ( ) ) ) { result . setPage ( lt . getPage ( ) ) ; break ; } } results . add ( result ) ; result . setId ( String . valueOf ( tableId ) ) ; tableId ++ ; } } doc . setTables ( results ) ; doc . postProcessTables ( ) ; return results ; }
public byte [ ] getNoEndZeroesData ( ) { return ByteUtil . stripEndingZeroes ( data ) ; }
private void showFolderList ( TreePath path ) { List < TreeItem > items = new ArrayList < > ( getCurrentTree ( ) . getFullModel ( ) . getAllChildren ( ( TreeItem ) path . getLastPathComponent ( ) ) ) ; folderListPanel . setItems ( path , items ) ; showCard ( CARDFOLDERLISTPANEL ) ; }
public static void unhookLayout ( String resDir , int id , XC_LayoutInflated callback ) { HashMap < String , CopyOnWriteSortedSet < XC_LayoutInflated > > inner ; synchronized ( sLayoutCallbacks ) { inner = sLayoutCallbacks . get ( id ) ; if ( inner == null ) return ; } CopyOnWriteSortedSet < XC_LayoutInflated > callbacks ; synchronized ( inner ) { callbacks = inner . get ( resDir ) ; if ( callbacks == null ) return ; } callbacks . remove ( callback ) ; }
public long getTaskId ( ) { return this . mTaskId ; }
private void householding ( Intent intent ) { DatabaseHelper . getInstance ( ServiceSinkhole . this ) . cleanupLog ( new Date ( ) . getTime ( ) - 3 * 24 * 3600 * 1000L ) ; DatabaseHelper . getInstance ( ServiceSinkhole . this ) . cleanupDns ( ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ServiceSinkhole . this ) ; if ( ! Util . isPlayStoreInstall ( ServiceSinkhole . this ) && Util . hasValidFingerprint ( ServiceSinkhole . this ) && prefs . getBoolean ( "update_check" , true ) ) checkUpdate ( ) ; }
public void onClick ( View v ) { if ( isPlaying || isRecording ) { return ; } Intent intent = new Intent ( ) ; intent . setClass ( SmartPlayer . this , RecorderManager . class ) ; intent . putExtra ( "RecoderDir" , recDir ) ; startActivity ( intent ) ; }
public BannerViewPager < T > setIndicatorView ( IIndicator customIndicator ) { if ( customIndicator instanceof View ) { isCustomIndicator = true ; mIndicatorView = customIndicator ; } return this ; }
public ShapeAppearanceModel getItemActiveIndicatorShapeAppearance ( ) { return menuView . getItemActiveIndicatorShapeAppearance ( ) ; }
private String getCreateWorkflowDefsIndexTableStatement ( ) { return SchemaBuilder . createTable ( properties . getKeyspace ( ) , TABLE_WORKFLOW_DEFS_INDEX ) . ifNotExists ( ) . addPartitionKey ( WORKFLOW_DEF_INDEX_KEY , DataType . text ( ) ) . addClusteringColumn ( WORKFLOW_DEF_NAME_VERSION_KEY , DataType . text ( ) ) . addColumn ( WORKFLOW_DEF_INDEX_VALUE , DataType . text ( ) ) . getQueryString ( ) ; }
public io . kubernetes . client . proto . V1Networking . IngressClass . Builder addItemsBuilder ( ) { return getItemsFieldBuilder ( ) . addBuilder ( io . kubernetes . client . proto . V1Networking . IngressClass . getDefaultInstance ( ) ) ; }
private void indexWithRetry ( final BulkRequest request , final String operationDescription , String docType ) { try { long startTime = Instant . now ( ) . toEpochMilli ( ) ; retryTemplate . execute ( context -> elasticSearchClient . bulk ( request , RequestOptions . DEFAULT ) ) ; long endTime = Instant . now ( ) . toEpochMilli ( ) ; logger . debug ( "Time taken {} for indexing object of type: {}" , endTime - startTime , docType ) ; Monitors . recordESIndexTime ( "index_object" , docType , endTime - startTime ) ; Monitors . recordWorkerQueueSize ( "indexQueue" , ( ( ThreadPoolExecutor ) executorService ) . getQueue ( ) . size ( ) ) ; Monitors . recordWorkerQueueSize ( "logQueue" , ( ( ThreadPoolExecutor ) logExecutorService ) . getQueue ( ) . size ( ) ) ; } catch ( Exception e ) { Monitors . error ( className , "index" ) ; logger . error ( "Failed to index {} for request type: {}" , request , docType , e ) ; } }
int nextInt ( ) throws IOException { int c ; do { c = readByte ( ) ; } while ( c <= ' ' && c != - 1 ) ; boolean neg = false ; if ( c == '-' ) { neg = true ; c = readByte ( ) ; } int val = 0 ; while ( c > ' ' && c != - 1 ) { val = val * 10 + ( c - '0' ) ; c = readByte ( ) ; } return neg ? - val : val ; }
public void setCopyBehavior ( CopyBehavior copyBehavior ) { _prefs . edit ( ) . putInt ( "pref_current_copy_behavior" , copyBehavior . ordinal ( ) ) . apply ( ) ; }
public String referencedName ( ) { return referencedName ; }
public boolean offerFirst ( T t ) { throw new UnsupportedOperationException ( ) ; }
public static io . kubernetes . client . proto . V1Networking . IngressTLS parseFrom ( java . io . InputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input ) ; }
public BytesRef binaryValue ( ) throws IOException { bytesSlice . readBytes ( ( long ) disi . index ( ) * length , bytes . bytes , 0 , length ) ; return bytes ; }
public int getSerializedSize ( ) { int size = memoizedSize ; if ( size != - 1 ) return size ; size = 0 ; if ( ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { size += com . google . protobuf . CodedOutputStream . computeMessageSize ( 1 , getMetadata ( ) ) ; } for ( int i = 0 ; i < items_ . size ( ) ; i ++ ) { size += com . google . protobuf . CodedOutputStream . computeMessageSize ( 2 , items_ . get ( i ) ) ; } size += unknownFields . getSerializedSize ( ) ; memoizedSize = size ; return size ; }
public static Set < Class < ? > > scanPackage ( ) { return ClassScanner . scanPackage ( ) ; }
public static int ruleTextSize ( int val ) { gPrefs . edit ( ) . putInt ( "ruleTextSize" , val ) . commit ( ) ; return val ; }
protected void onStop ( ) { stopQrExecutor ( ) ; super . onStop ( ) ; }
public @ Mode int getMode ( ) { return mode ; }
private boolean isFullPath ( ) { return ! patternPartialPath . hasWildcard ( ) ; }
public void setInitialOrgId ( Long initialOrgId ) { this . initialOrgId = initialOrgId ; }
public int getShortcuts ( ) { return routingCHGraph . getShortcuts ( ) ; }
public long randomLong ( final long startInclusive , final long endExclusive ) { Validate . isTrue ( endExclusive >= startInclusive , "Start value must be smaller or equal to end value." ) ; Validate . isTrue ( startInclusive >= 0 , "Both range values must be non-negative." ) ; if ( startInclusive == endExclusive ) { return startInclusive ; } return startInclusive + randomLong ( endExclusive - startInclusive ) ; }
public void doCloseWrappedValueBytesStore ( ) { if ( ! ( this . wrappedValueBytesStoreInit ( ) ) ) return ; wrappedValueBytesStore = null ; if ( ( next ) != null ) next . closeWrappedValueBytesStore ( ) ; }
public boolean isMarkerInCenter ( ) { return mMarkerInCenter ; }
public static io . kubernetes . client . proto . V1Networking . IPAddressSpec parseDelimitedFrom ( java . io . InputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input ) ; }
public void scrollContentToTop ( ) { LinkageRecyclerView . this . scrollToPosition ( 0 ) ; }
public void run ( ) { if ( ! isComplete && console != null ) { System . out . println ( "" ) ; System . out . println ( "Exiting monitor.  Bootstrap will continue in the background." ) ; System . out . println ( "To abort, run maxwell-bootstrap --abort " + rowId ) ; System . out . println ( "To resume monitoring, run maxwell-bootstrap --monitor " + rowId ) ; } }
public void dispose ( ) { upstream . cancel ( ) ; upstream = SubscriptionHelper . CANCELLED ; }
public void score ( int size , float [ ] freqs , long [ ] norms , float [ ] scores ) { for ( int i = 0 ; i < size ; ++ i ) { scores [ i ] = scorer . score ( freqs [ i ] , norms [ i ] ) ; } }
public void setCategory ( final CategoryValue categoryValue ) { categoryValueRefAttribute . setReferenceTargetElement ( this , categoryValue ) ; }
public void setProtocolMapper ( String protocolMapper ) { this . protocolMapper . setProtocolMapper ( protocolMapper ) ; }
public Builder addItems ( io . kubernetes . client . proto . V1Networking . IPAddress . Builder builderForValue ) { if ( itemsBuilder_ == null ) { ensureItemsIsMutable ( ) ; items_ . add ( builderForValue . build ( ) ) ; onChanged ( ) ; } else { itemsBuilder_ . addMessage ( builderForValue . build ( ) ) ; } return this ; }
public void setProductAttributeWeight ( BigDecimal productAttributeWeight ) { this . productAttributeWeight = productAttributeWeight ; }
public void handleQuitRequestWith ( QuitEvent event , QuitResponse response ) { if ( base . handleQuit ( ) ) { response . performQuit ( ) ; } else { response . cancelQuit ( ) ; } }
public Criteria andIdIsNull ( ) { addCriterion ( "id is null" ) ; return ( Criteria ) this ; }
public com . google . protobuf . ExtensionRegistry assignDescriptors ( com . google . protobuf . Descriptors . FileDescriptor root ) { descriptor = root ; return null ; }
private String getOwner ( String path ) throws IOException { PosixFileAttributes attr = Files . readAttributes ( Paths . get ( path ) , PosixFileAttributes . class ) ; return attr . owner ( ) . getName ( ) ; }
long entrySize ( ) { return ( ( checksumStrategy . extraEntryBytes ( ) ) + ( entryEnd ( ) ) ) - ( keySizeOffset ( ) ) ; }
public void runTool ( String ... args ) throws SQLException { boolean tcpStart = false , pgStart = false , webStart = false ; boolean browserStart = false ; boolean tcpShutdown = false , tcpShutdownForce = false ; String tcpPassword = "" ; String tcpShutdownServer = "" ; boolean startDefaultServers = true ; for ( int i = 0 ; args != null && i < args . length ; i ++ ) { String arg = args [ i ] ; if ( arg == null ) { } else if ( "-?" . equals ( arg ) || "-help" . equals ( arg ) ) { showUsage ( ) ; return ; } else if ( arg . startsWith ( "-web" ) ) { if ( "-web" . equals ( arg ) ) { startDefaultServers = false ; webStart = true ; } else if ( "-webAllowOthers" . equals ( arg ) ) { } else if ( "-webExternalNames" . equals ( arg ) ) { i ++ ; } else if ( "-webDaemon" . equals ( arg ) ) { } else if ( "-webSSL" . equals ( arg ) ) { } else if ( "-webPort" . equals ( arg ) ) { i ++ ; } else if ( "-webAdminPassword" . equals ( arg ) ) { if ( fromCommandLine ) { throwUnsupportedOption ( arg ) ; } i ++ ; } else { showUsageAndThrowUnsupportedOption ( arg ) ; } } else if ( "-browser" . equals ( arg ) ) { startDefaultServers = false ; browserStart = true ; } else if ( arg . startsWith ( "-tcp" ) ) { if ( "-tcp" . equals ( arg ) ) { startDefaultServers = false ; tcpStart = true ; } else if ( "-tcpAllowOthers" . equals ( arg ) ) { } else if ( "-tcpDaemon" . equals ( arg ) ) { } else if ( "-tcpSSL" . equals ( arg ) ) { } else if ( "-tcpPort" . equals ( arg ) ) { i ++ ; } else if ( "-tcpPassword" . equals ( arg ) ) { tcpPassword = args [ ++ i ] ; } else if ( "-tcpShutdown" . equals ( arg ) ) { startDefaultServers = false ; tcpShutdown = true ; tcpShutdownServer = args [ ++ i ] ; } else if ( "-tcpShutdownForce" . equals ( arg ) ) { tcpShutdownForce = true ; } else { showUsageAndThrowUnsupportedOption ( arg ) ; } } else if ( arg . startsWith ( "-pg" ) ) { if ( "-pg" . equals ( arg ) ) { startDefaultServers = false ; pgStart = true ; } else if ( "-pgAllowOthers" . equals ( arg ) ) { } else if ( "-pgDaemon" . equals ( arg ) ) { } else if ( "-pgPort" . equals ( arg ) ) { i ++ ; } else { showUsageAndThrowUnsupportedOption ( arg ) ; } } else if ( "-properties" . equals ( arg ) ) { i ++ ; } else if ( "-trace" . equals ( arg ) ) { } else if ( "-ifExists" . equals ( arg ) ) { } else if ( "-ifNotExists" . equals ( arg ) ) { } else if ( "-baseDir" . equals ( arg ) ) { i ++ ; } else if ( "-key" . equals ( arg ) ) { i += 2 ; } else { showUsageAndThrowUnsupportedOption ( arg ) ; } } verifyArgs ( args ) ; if ( startDefaultServers ) { tcpStart = true ; pgStart = true ; webStart = true ; browserStart = true ; } if ( tcpShutdown ) { out . println ( "Shutting down TCP Server at " + tcpShutdownServer ) ; shutdownTcpServer ( tcpShutdownServer , tcpPassword , tcpShutdownForce , false ) ; } try { if ( tcpStart ) { tcp = createTcpServer ( args ) ; tcp . start ( ) ; out . println ( tcp . getStatus ( ) ) ; tcp . setShutdownHandler ( this ) ; } if ( pgStart ) { pg = createPgServer ( args ) ; pg . start ( ) ; out . println ( pg . getStatus ( ) ) ; } if ( webStart ) { web = createWebServer ( args ) ; web . setShutdownHandler ( this ) ; SQLException result = null ; try { web . start ( ) ; } catch ( Exception e ) { result = DbException . toSQLException ( e ) ; } out . println ( web . getStatus ( ) ) ; if ( browserStart ) { try { openBrowser ( web . getURL ( ) ) ; } catch ( Exception e ) { out . println ( e . getMessage ( ) ) ; } } if ( result != null ) { throw result ; } } else if ( browserStart ) { out . println ( "The browser can only start if a web server is started (-web)" ) ; } } catch ( SQLException e ) { stopAll ( ) ; throw e ; } }
public static io . kubernetes . client . proto . V1Networking . NetworkPolicyList parseFrom ( java . nio . ByteBuffer data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public io . kubernetes . client . proto . V1Networking . ServiceCIDRSpec getDefaultInstanceForType ( ) { return DEFAULT_INSTANCE ; }
public Criteria andAddTimeNotBetween ( LocalDateTime value1 , LocalDateTime value2 ) { addCriterion ( "add_time not between" , value1 , value2 , "addTime" ) ; return ( Criteria ) this ; }
Object getPartitionKey ( Uri uri , String virtualHost , ProxyServer proxyServer ) ; enum PerHostChannelPoolPartitioning implements ChannelPoolPartitioning { INSTANCE ; @ Override public Object getPartitionKey ( Uri uri , @ Nullable String virtualHost , @ Nullable ProxyServer proxyServer ) { String targetHostBaseUrl = uri . getBaseUrl ( ) ; if ( proxyServer == null ) { if ( virtualHost == null ) { return targetHostBaseUrl ; } else { return new CompositePartitionKey ( targetHostBaseUrl , virtualHost , null , 0 , null ) ; } } else { return new CompositePartitionKey ( targetHostBaseUrl , virtualHost , proxyServer . getHost ( ) , uri . isSecured ( ) && proxyServer . getProxyType ( ) . isHttp ( ) ? proxyServer . getSecuredPort ( ) : proxyServer . getPort ( ) , proxyServer . getProxyType ( ) ) ; } } }
protected void onFinishInflate ( ) { super . onFinishInflate ( ) ; mMonthView = findViewById ( R . id . vp_month ) ; mWeekPager = findViewById ( R . id . vp_week ) ; if ( getChildCount ( ) > 0 ) { mCalendarView = ( CalendarView ) getChildAt ( 0 ) ; } mContentView = findViewById ( mContentViewId ) ; mYearView = findViewById ( R . id . selectLayout ) ; }
public void popupMenuCanceled ( final PopupMenuEvent e ) { listener . popupMenuCanceled ( newEvent ( ) ) ; }
public XMLString xstr ( ) { return XMLStringFactoryImpl . getFactory ( ) . newstr ( str ( ) ) ; }
public String routeServer ( List < String > values , String key ) { int size = values . size ( ) ; if ( size == 0 ) { throw new CIMException ( StatusEnum . SERVER_NOT_AVAILABLE ) ; } this . values = values ; int offset = ThreadLocalRandom . current ( ) . nextInt ( size ) ; return values . get ( offset ) ; }
public IPersistentMap getAliases ( ) { return aliases . get ( ) ; }
public SearchRequest addAggregation ( Aggregation agg ) { size = null ; _source = false ; if ( aggs == null ) aggs = new LinkedHashMap < > ( ) ; aggs . put ( agg . field , agg ) ; return this ; }
public List < ChainingInterface > contextChain ( ) { return this . contextChain ; }
public boolean equals ( Object o ) { if ( o instanceof Hit ) { return compareTo ( ( Hit ) o ) == 0 ; } return false ; }
private LongValues getDirectReaderInstance ( RandomAccessInput slice , int bitsPerValue , long offset , long numValues ) { if ( merging ) { return DirectReader . getMergeInstance ( slice , bitsPerValue , offset , numValues ) ; } else { return DirectReader . getInstance ( slice , bitsPerValue , offset ) ; } }
public void onDecorativeObjectSpawned ( DecorativeObjectSpawned event ) { DecorativeObject decorativeObject = event . getDecorativeObject ( ) ; if ( PohIcons . getIcon ( decorativeObject . getId ( ) ) != null ) { pohObjects . put ( decorativeObject , event . getTile ( ) ) ; } }
public long lengthFor ( String string ) { return lengthForStringOfLength ( string . length ( ) ) ; }
private void updatePrivacySettingRules ( TdApi . UpdateUserPrivacySettingRules update ) { listeners . updatePrivacySettingRules ( update . setting , update . rules ) ; }
boolean isJSONType ( @ NotNull SQLConfig < T , M , L > config , ResultSetMetaData rsmd , int position , String label ) ; Connection getConnection ( @ NotNull SQLConfig < T , M , L > config ) throws Exception ; default Statement getStatement ( @ NotNull SQLConfig < T , M , L > config ) throws Exception { return getStatement ( config , null ) ; }
AnnotatedMethodMap collect ( TypeResolutionContext tc , JavaType mainType , List < JavaType > superTypes , Class < ? > primaryMixIn ) { Map < MemberKey , MethodBuilder > methods = new LinkedHashMap < > ( ) ; _addMemberMethods ( tc , mainType . getRawClass ( ) , methods , primaryMixIn ) ; for ( JavaType type : superTypes ) { Class < ? > mixin = ( _mixInResolver == null ) ? null : _mixInResolver . findMixInClassFor ( type . getRawClass ( ) ) ; _addMemberMethods ( new TypeResolutionContext . Basic ( _config . getTypeFactory ( ) , type . getBindings ( ) ) , type . getRawClass ( ) , methods , mixin ) ; } boolean checkJavaLangObject = false ; if ( _mixInResolver != null ) { Class < ? > mixin = _mixInResolver . findMixInClassFor ( Object . class ) ; if ( mixin != null ) { _addMethodMixIns ( tc , mainType . getRawClass ( ) , methods , mixin ) ; checkJavaLangObject = true ; } } if ( checkJavaLangObject && ( _intr != null ) && ! methods . isEmpty ( ) ) { for ( Map . Entry < MemberKey , MethodBuilder > entry : methods . entrySet ( ) ) { MemberKey k = entry . getKey ( ) ; if ( ! "hashCode" . equals ( k . getName ( ) ) || ( 0 != k . argCount ( ) ) ) { continue ; } try { Method m = Object . class . getDeclaredMethod ( k . getName ( ) ) ; MethodBuilder b = entry . getValue ( ) ; b . annotations = collectDefaultAnnotations ( b . annotations , m . getDeclaredAnnotations ( ) ) ; b . method = m ; } catch ( Exception e ) { } } } if ( methods . isEmpty ( ) ) { return new AnnotatedMethodMap ( ) ; } Map < MemberKey , AnnotatedMethod > actual = new LinkedHashMap < > ( methods . size ( ) ) ; for ( Map . Entry < MemberKey , MethodBuilder > entry : methods . entrySet ( ) ) { AnnotatedMethod am = entry . getValue ( ) . build ( ) ; if ( am != null ) { actual . put ( entry . getKey ( ) , am ) ; } } return new AnnotatedMethodMap ( actual ) ; }
public static File getEmojiPackDirectory ( ) { return new File ( UI . getAppContext ( ) . getFilesDir ( ) , "emoji" ) ; }
public static List < String > readLines ( String path , Charset charset ) { List < String > strList = new ArrayList < > ( ) ; ClassPathResource classPathResource = new ClassPathResource ( path ) ; try ( InputStreamReader in = new InputStreamReader ( classPathResource . getInputStream ( ) , charset ) ; BufferedReader reader = new BufferedReader ( in ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) { strList . add ( line ) ; } } catch ( IOException e ) { throw new RuntimeException ( "file read error" , e ) ; } return strList ; }
public static Boolean isFingerprintEnabled ( ) { return gPrefs . getBoolean ( FINGERPRINT_ENABLED , false ) ; }
public void registerTokenTypes ( TokenTypes tokenTypes ) { this . tokenTypes = tokenTypes ; tokenTypes . updateData ( this ) ; }
public ResultHandler < TdApi . Ok > typedOkHandler ( ) { return ( ok , error ) -> { if ( error != null ) { UI . showError ( error ) ; } } ; }
public void setRoleSign ( String roleSign ) { this . roleSign = roleSign ; }
public void replaceButtonActionPerformed ( List < TreeItem > items ) { replace ( items , false ) ; }
public static void alcGetInteger64vSOFT ( @ NativeType ( "ALCdevice *" ) long device , @ NativeType ( "ALCenum" ) int pname , @ NativeType ( "ALCint64SOFT *" ) long [ ] values ) { long __functionAddress = ALC . getICD ( ) . alcGetInteger64vSOFT ; if ( CHECKS ) { check ( __functionAddress ) ; } invokePPV ( device , pname , values . length , values , __functionAddress ) ; }
public void afterTextChanged ( Editable editable ) { if ( ignoreOnCardChange ) { return ; } EditText phoneField = inputFields [ FIELD_CARD ] ; int start = phoneField . getSelectionStart ( ) ; String phoneChars = "0123456789" ; String str = phoneField . getText ( ) . toString ( ) ; if ( characterAction == 3 ) { str = str . substring ( 0 , actionPosition ) + str . substring ( actionPosition + 1 ) ; start -- ; } StringBuilder builder = new StringBuilder ( str . length ( ) ) ; for ( int a = 0 ; a < str . length ( ) ; a ++ ) { String ch = str . substring ( a , a + 1 ) ; if ( phoneChars . contains ( ch ) ) { builder . append ( ch ) ; } } ignoreOnCardChange = true ; String hint = null ; int maxLength = 100 ; if ( builder . length ( ) > 0 ) { String currentString = builder . toString ( ) ; for ( int a = 0 ; a < 3 ; a ++ ) { String [ ] checkArr ; String resultHint ; int resultMaxLength ; switch ( a ) { case 0 : checkArr = PREFIXES_16 ; resultMaxLength = 16 ; resultHint = "xxxx xxxx xxxx xxxx" ; break ; case 1 : checkArr = PREFIXES_15 ; resultMaxLength = 15 ; resultHint = "xxxx xxxx xxxx xxx" ; break ; case 2 : default : checkArr = PREFIXES_14 ; resultMaxLength = 14 ; resultHint = "xxxx xxxx xxxx xx" ; break ; } for ( int b = 0 ; b < checkArr . length ; b ++ ) { String prefix = checkArr [ b ] ; if ( currentString . length ( ) <= prefix . length ( ) ) { if ( prefix . startsWith ( currentString ) ) { hint = resultHint ; maxLength = resultMaxLength ; break ; } } else { if ( currentString . startsWith ( prefix ) ) { hint = resultHint ; maxLength = resultMaxLength ; break ; } } } if ( hint != null ) { break ; } } if ( builder . length ( ) > maxLength ) { builder . setLength ( maxLength ) ; } } if ( hint != null ) { if ( builder . length ( ) == maxLength ) { inputFields [ FIELD_EXPIRE_DATE ] . requestFocus ( ) ; } phoneField . setTextColor ( getThemedColor ( Theme . key_windowBackgroundWhiteBlackText ) ) ; for ( int a = 0 ; a < builder . length ( ) ; a ++ ) { if ( a < hint . length ( ) ) { if ( hint . charAt ( a ) == ' ' ) { builder . insert ( a , ' ' ) ; a ++ ; if ( start == a && characterAction != 2 && characterAction != 3 ) { start ++ ; } } } else { builder . insert ( a , ' ' ) ; if ( start == a + 1 && characterAction != 2 && characterAction != 3 ) { start ++ ; } break ; } } } else { } if ( ! builder . toString ( ) . equals ( editable . toString ( ) ) ) { editable . replace ( 0 , editable . length ( ) , builder ) ; } if ( start >= 0 ) { phoneField . setSelection ( Math . min ( start , phoneField . length ( ) ) ) ; } ignoreOnCardChange = false ; }
private List < String > getListDiff ( final List < String > preList , final List < String > lastList ) { if ( CollectionUtils . isEmpty ( lastList ) ) { return Collections . emptyList ( ) ; } if ( CollectionUtils . isEmpty ( preList ) ) { return lastList ; } Map < String , Integer > map = preList . stream ( ) . distinct ( ) . collect ( Collectors . toMap ( Function . identity ( ) , source -> 1 ) ) ; return lastList . stream ( ) . filter ( item -> ! map . containsKey ( item ) ) . collect ( Collectors . toList ( ) ) ; }
public void ifLanguageChanged ( ProjectDescription current , BiConsumer < Language , Language > consumer ) { if ( ! Objects . equals ( this . original . getLanguage ( ) , current . getLanguage ( ) ) ) { consumer . accept ( this . original . getLanguage ( ) , current . getLanguage ( ) ) ; } }
public void onCreate ( final Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setHasOptionsMenu ( true ) ; PreferenceManager . getDefaultSharedPreferences ( activity ) . registerOnSharedPreferenceChangeListener ( this ) ; }
public SignerHelper tsretrywait ( int tsretrywait ) { this . tsretrywait = tsretrywait ; return this ; }
public void setMaxWarcNovelBytes ( long maxWarcNovelBytes ) { this . maxWarcNovelBytes = maxWarcNovelBytes ; }
public void param ( String name , String value ) { }
public SysUserVo selectUserByOpenId ( String openId ) { return baseMapper . selectUserByOpenId ( openId ) ; }
public Integer getShardId ( ) { return shardId ; }
protected void onDisplayImage ( Context context , ImageView imageView , GroupMember groupMember ) { Glide . with ( context ) . load ( groupMember . getPortraitUri ( ) ) . centerCrop ( ) . into ( imageView ) ; }
public static AccessControlProvider getInstance ( ) { return GlobalStateMgr . getCurrentState ( ) . getAuthorizer ( ) . accessControlProvider ; }
public int getOrderId ( ) { return orderId ; }
public IBinder onBind ( Intent intent ) { if ( BIND_LISTENER_INTENT_ACTION . equals ( intent . getAction ( ) ) ) { return listener . asBinder ( ) ; } return null ; }
public void notify ( String methodName , Object ... values ) { try ( ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; JsonWriter jsonWriter = JsonWriter . toStream ( outputStream ) ) { jsonWriter . writeArray ( values , JsonWriter :: writeUntyped ) . flush ( ) ; notifyWithSerializedObject ( methodName , outputStream . toString ( StandardCharsets . UTF_8 ) ) ; } catch ( IOException ex ) { throw new UncheckedIOException ( ex ) ; } }
public static XC_LayoutInflated . Unhook hookSystemWideLayout ( int id , XC_LayoutInflated callback ) { if ( id >= 0x7f000000 ) throw new IllegalArgumentException ( "ids >= 0x7f000000 are app specific and cannot be set for the framework" ) ; return hookLayoutInternal ( null , id , getSystemResourceNames ( id ) , callback ) ; }
public String getNewCreatorId ( ) { return this . newCreatorId ; }
public String toString ( ) { return "BINARY_AS_SIGNED_INTEGER_COMPARATOR" ; }
public TypeMirror getTypeBound ( TypeMirror typeMirror ) { if ( typeMirror . getKind ( ) == TypeKind . WILDCARD ) { WildcardType wildCardType = ( WildcardType ) typeMirror ; if ( wildCardType . getExtendsBound ( ) != null ) { return wildCardType . getExtendsBound ( ) ; } if ( wildCardType . getSuperBound ( ) != null ) { return wildCardType . getSuperBound ( ) ; } String wildCardName = wildCardType . toString ( ) ; if ( "?" . equals ( wildCardName ) ) { return elementUtils . getTypeElement ( Object . class . getCanonicalName ( ) ) . asType ( ) ; } } else if ( typeMirror . getKind ( ) == TypeKind . TYPEVAR ) { TypeVariable typeVariableType = ( TypeVariable ) typeMirror ; if ( typeVariableType . getUpperBound ( ) != null ) { return typeVariableType . getUpperBound ( ) ; } if ( typeVariableType . getLowerBound ( ) != null ) { return typeVariableType . getLowerBound ( ) ; } } return typeMirror ; }
public double [ ] kg ( double [ ] x , double [ ] y ) { return new double [ ] { k ( x , y ) } ; }
public int reverseAndNotBitmapContainerVSRunContainerContainer ( BenchmarkState benchmarkState ) { if ( benchmarkState . rc2 . serializedSizeInBytes ( ) > benchmarkState . ac2 . serializedSizeInBytes ( ) ) throw new RuntimeException ( "Can't expect run containers to win if they are larger." ) ; return benchmarkState . rc2 . andNot ( benchmarkState . ac1 ) . getCardinality ( ) ; }
public static boolean isAllowedUpload ( String file ) { String fileType = suffixFromFileName ( file ) ; for ( String type : ConfigConstants . getProhibit ( ) ) { if ( type . equals ( fileType ) ) { return false ; } } return ! ObjectUtils . isEmpty ( fileType ) ; }
public void onError ( Throwable t ) { for ( Processor < T , T > w : windows ) { w . onError ( t ) ; } windows . clear ( ) ; error = t ; done = true ; drain ( ) ; }
private void serializeParams ( Map < ParamType , Object > params , DataOutputPlus out , int version ) throws IOException { out . writeUnsignedVInt32 ( params . size ( ) ) ; for ( Map . Entry < ParamType , Object > kv : params . entrySet ( ) ) { ParamType type = kv . getKey ( ) ; out . writeUnsignedVInt32 ( type . id ) ; IVersionedSerializer serializer = type . serializer ; Object value = kv . getValue ( ) ; int length = Ints . checkedCast ( serializer . serializedSize ( value , version ) ) ; out . writeUnsignedVInt32 ( length ) ; serializer . serialize ( value , out , version ) ; } }
public double getProgress ( ) { return progress ; }
public java . lang . String getHost ( ) { java . lang . Object ref = host_ ; if ( ref instanceof java . lang . String ) { return ( java . lang . String ) ref ; } else { com . google . protobuf . ByteString bs = ( com . google . protobuf . ByteString ) ref ; java . lang . String s = bs . toStringUtf8 ( ) ; if ( bs . isValidUtf8 ( ) ) { host_ = s ; } return s ; } }
private static byte [ ] getWriteHeader ( Schema schema ) { try { byte [ ] fp = SchemaNormalization . parsingFingerprint ( "CRC-64-AVRO" , schema ) ; byte [ ] ret = new byte [ V1_HEADER . length + fp . length ] ; System . arraycopy ( V1_HEADER , 0 , ret , 0 , V1_HEADER . length ) ; System . arraycopy ( fp , 0 , ret , V1_HEADER . length , fp . length ) ; return ret ; } catch ( NoSuchAlgorithmException e ) { throw new AvroRuntimeException ( e ) ; } }
private Document getCompatSdkConfig ( BundleModule repackagedModule ) { Document compatSdkConfig ; try { compatSdkConfig = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; } catch ( ParserConfigurationException e ) { throw new IllegalStateException ( e ) ; } compatSdkConfig . appendChild ( createCompatConfigXmlNode ( compatSdkConfig , repackagedModule ) ) ; return compatSdkConfig ; }
protected boolean isEmptyDiscovery ( ) { return discoverySet == null || ! discoverySet . iterator ( ) . hasNext ( ) ; }
public static io . kubernetes . client . proto . V1Networking . ServiceCIDRSpec parseFrom ( byte [ ] data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public MessageStream < QueryResponseMessage > query ( @ Nonnull QueryMessage query , @ Nullable ProcessingContext context ) { shutdownLatch . ifShuttingDown ( "Cannot dispatch new queries as this bus is being shut down" ) ; try ( ShutdownLatch . ActivityHandle queryInTransit = shutdownLatch . registerActivity ( ) ) { ResultStream < QueryResponse > resultStream = connection . queryChannel ( ) . query ( QueryConverter . convertQueryMessage ( query , clientId , componentName ) ) ; return new QueryResponseMessageStream ( resultStream ) . onClose ( queryInTransit :: end ) ; } }
private static void addDirectedEdge ( Map < Integer , List < Edge > > graph , int from , int to , int cost ) { List < Edge > list = graph . get ( from ) ; if ( list == null ) { list = new ArrayList < Edge > ( ) ; graph . put ( from , list ) ; } list . add ( new Edge ( from , to , cost ) ) ; }
public void onTransitionAnimationEnd ( boolean isOpen , boolean backward ) { if ( isOpen && ! backward ) { if ( webView != null ) { if ( currentStep != STEP_CHECKOUT ) { if ( paymentFormMethod != null ) { webView . loadUrl ( webViewUrl = paymentFormMethod . url ) ; } else { webView . loadUrl ( webViewUrl = paymentForm . url ) ; } } } else if ( currentStep == STEP_PAYMENT_INFO ) { AndroidUtilities . runOnUIThread ( ( ) -> { inputFields [ FIELD_CARD ] . requestFocus ( ) ; AndroidUtilities . showKeyboard ( inputFields [ FIELD_CARD ] ) ; } , 100 ) ; } else if ( currentStep == STEP_CONFIRM_PASSWORD ) { inputFields [ FIELD_SAVEDPASSWORD ] . requestFocus ( ) ; AndroidUtilities . showKeyboard ( inputFields [ FIELD_SAVEDPASSWORD ] ) ; } else if ( currentStep == STEP_CHECKOUT ) { if ( inputFields != null ) { inputFields [ 0 ] . requestFocus ( ) ; } } else if ( currentStep == STEP_SET_PASSWORD_EMAIL ) { if ( ! waitingForEmail ) { inputFields [ FIELD_ENTERPASSWORD ] . requestFocus ( ) ; AndroidUtilities . showKeyboard ( inputFields [ FIELD_ENTERPASSWORD ] ) ; } } } }
public void set ( ByteBuffer bytes ) { if ( ! hasKey ) { key = ( bytes == null ) ? null : codec . decodeKey ( bytes ) ; hasKey = true ; return ; } Object value = ( bytes == null ) ? null : codec . decodeValue ( bytes ) ; output . put ( key , value ) ; key = null ; hasKey = false ; }
public void close ( ) throws IOException { out . close ( ) ; int size = stackSize ; if ( size > 1 || ( size == 1 && stack [ size - 1 ] != NONEMPTY_DOCUMENT ) ) { throw new IOException ( "Incomplete document" ) ; } stackSize = 0 ; }
public static Config getOperatorConfig ( Context < ? > context ) { return context . managedWorkflowAndDependentResourceContext ( ) . getMandatory ( OPERATOR_CONFIG_KEY , Config . class ) ; }
public Message < T > build ( ) { if ( verb == null ) throw new IllegalArgumentException ( ) ; if ( from == null ) throw new IllegalArgumentException ( ) ; if ( payload == null ) throw new IllegalArgumentException ( ) ; if ( epoch == null ) epoch = epochSupplier . get ( ) ; return new Message < > ( new Header ( hasId ? id : nextId ( ) , epoch , verb , from , createdAtNanos , expiresAtNanos , flags , params ) , payload ) ; }
public final AlterSequenceImpl < T > startWith ( Field < T > startWith ) { this . startWith = startWith ; return this ; }
public T apply ( Integer index ) { return get ( index ) ; }
public Q filter ( Filter filter ) { if ( filters . isEmpty ( ) ) { this . filter = filter ; filters = Collections . singletonList ( filter ) ; } else { this . filter = null ; if ( filters . size ( ) == 1 ) { filters = new ArrayList < Filter > ( ) ; } filters . add ( filter ) ; } return ( Q ) this ; }
public OutputCommitter getBaseOutputCommitter ( ) { return committer ; }
public Schema < GenericRecord > newAutoConsumeSchema ( ) { return new AutoConsumeSchema ( ) ; }
protected void afterExpired ( Session session ) { if ( isDeleteInvalidSessions ( ) ) { delete ( session ) ; } }
public List < Edge > getEdges ( ) { List < Edge > ret = new LinkedList < Edge > ( ) ; if ( edge != null ) { ret . add ( edge ) ; } CallChain current = next ; while ( current != null ) { ret . add ( current . edge ) ; current = current . next ; } return ret ; }
public void dispatchCallBarsCount ( final int callId , final int barsCount ) { ui ( ) . sendMessage ( ui ( ) . obtainMessage ( MSG_ACTION_CALL_BARS , callId , barsCount ) ) ; }
private void internalPrepareBitmap ( @ Nullable CloseableReference < CloseableImage > newResult ) { if ( newResult == null || ! newResult . isValid ( ) ) { return ; } final CloseableImage closeableImage = newResult . get ( ) ; if ( closeableImage == null || closeableImage . isClosed ( ) ) { return ; } if ( closeableImage instanceof CloseableStaticBitmap ) { final CloseableStaticBitmap staticBitmap = ( CloseableStaticBitmap ) closeableImage ; final Bitmap bitmap = staticBitmap . getUnderlyingBitmap ( ) ; if ( bitmap == null ) { return ; } final int bitmapByteCount = bitmap . getRowBytes ( ) * bitmap . getHeight ( ) ; if ( bitmapByteCount < mMinBitmapSizeBytes ) { return ; } if ( bitmapByteCount > mMaxBitmapSizeBytes ) { return ; } bitmap . prepareToDraw ( ) ; } }
public boolean onInterceptTouchEvent ( MotionEvent ev ) { boolean result = dragHelper . shouldInterceptTouchEvent ( ev ) ; if ( ev . getPointerCount ( ) > 1 && ev . getAction ( ) == MotionEvent . ACTION_MOVE ) return false ; if ( isTopOrBottomEnd ( ) && isVertical ) return true ; return result && isVertical ; }
public void setNeedsContext ( boolean needsContext ) { this . needsContext = needsContext ; }
private void checkConfiguration ( ) { String agentName = getConf ( ) . get ( "http.agent.name" ) ; if ( agentName == null || agentName . trim ( ) . length ( ) == 0 ) { String message = "Fetcher: No agents listed in 'http.agent.name'" + " property." ; LOG . error ( message ) ; throw new IllegalArgumentException ( message ) ; } }
public boolean isOpen ( ) { return ! isClosed . get ( ) ; }
public Builder extension ( org . springdoc . core . fn . builders . extension . Builder extensionBuilder ) { this . extensions = ArrayUtils . add ( this . extensions , extensionBuilder . build ( ) ) ; return this ; }
public void setErrorMessage ( String errorMessage ) { this . errorMessage = errorMessage ; }
public void setUseFormat ( String useFormat ) { this . useFormat = useFormat ; }
@ Override void putShort ( byte [ ] array , long offset , short s ) { super . putShort ( array , offset , Short . reverseBytes ( s ) ) ; }
public boolean isUserInputEnabled ( ) { return userInputEnabled ; }
protected void textLineAlignImpl ( char [ ] buffer , int start , int stop , float x , float y ) { if ( textAlign == CENTER ) { x -= textWidthImpl ( buffer , start , stop ) / 2f ; } else if ( textAlign == RIGHT ) { x -= textWidthImpl ( buffer , start , stop ) ; } textLineImpl ( buffer , start , stop , x , y ) ; }
public void sendFakeUpdate ( TdApi . Update update ) { clientHolder ( ) . sendFakeUpdate ( update ) ; }
public long subtract ( long instant , long value ) { if ( value == Long . MIN_VALUE ) { throw new ArithmeticException ( "Long.MIN_VALUE cannot be negated" ) ; } return add ( instant , - value ) ; }
public void setStatus ( Integer status ) { this . status = status ; }
protected Supplier < View > getListHeaderSupplier ( ) { return null ; }
public Builder addPorts ( int index , io . kubernetes . client . proto . V1Networking . NetworkPolicyPort . Builder builderForValue ) { if ( portsBuilder_ == null ) { ensurePortsIsMutable ( ) ; ports_ . add ( index , builderForValue . build ( ) ) ; onChanged ( ) ; } else { portsBuilder_ . addMessage ( index , builderForValue . build ( ) ) ; } return this ; }
@ Override public IgniteUuid id ( ) { return id ; }
public static long getUpdateInterval ( ) { return Integer . parseInt ( prefs . getString ( PREF_UPDATE_INTERVAL_MINUTES , "720" ) ) ; }
public BigInteger value ( ) { return new BigInteger ( 1 , data ) ; }
public void setProductAttributePrice ( BigDecimal productAttributePrice ) { this . productAttributePrice = productAttributePrice ; }
public BundleRevision getResource ( ) { throw new UnsupportedOperationException ( ) ; }
public void setLatestExportTimeNow ( ) { _prefs . edit ( ) . putLong ( "pref_export_latest" , new Date ( ) . getTime ( ) ) . apply ( ) ; setIsBackupReminderNeeded ( false ) ; }
public boolean restorePersistentState ( SharedPreferences sp , String prefix ) throws IllegalStateException { boolean ok = doRestorePersistentState ( sp , prefix ) ; if ( ! ok ) { mEditHistory . clear ( ) ; } return ok ; }
public io . kubernetes . client . proto . V1Networking . IngressSpec build ( ) { io . kubernetes . client . proto . V1Networking . IngressSpec result = buildPartial ( ) ; if ( ! result . isInitialized ( ) ) { throw newUninitializedMessageException ( result ) ; } return result ; }
public static void trainJNI ( String modelName , File trainingData , File outputModel ) { try { LOGGER . info ( "Train DeLFT classification model " + modelName + "..." ) ; GrobidProperties . getInstance ( ) ; JEPThreadPoolClassifier . getInstance ( ) . run ( new TrainTask ( modelName , trainingData , GrobidProperties . getModelPath ( ) ) ) ; } catch ( InterruptedException e ) { LOGGER . error ( "Train DeLFT classification model " + modelName + " task failed" , e ) ; } }
public io . kubernetes . client . proto . V1Networking . IPBlockOrBuilder getIpBlockOrBuilder ( ) { return ipBlock_ == null ? io . kubernetes . client . proto . V1Networking . IPBlock . getDefaultInstance ( ) : ipBlock_ ; }
public boolean isLogIdentityHeaders ( ) { return logIdentityHeaders ; }
private static ServiceContainer currentServiceContainer ( ) { if ( System . getSecurityManager ( ) == null ) { return CurrentServiceContainer . getServiceContainer ( ) ; } return AccessController . doPrivileged ( CurrentServiceContainer . GET_ACTION ) ; }
private void populateColumns ( ) { trades . forEach ( t -> { colTradeId . addRow ( t . getTradeId ( ) ) ; colCreateDate . addRow ( t . getDate ( ) ) ; colMarket . addRow ( toMarket . apply ( t ) ) ; colPrice . addRow ( t . getTradePrice ( ) ) ; colAmount . addRow ( t . getTradeAmountAsLong ( ) ) ; colMixedAmount . addRow ( t . getTradeVolume ( ) ) ; colCurrency . addRow ( toPaymentCurrencyCode . apply ( t ) ) ; colPaymentMethod . addRow ( t . getOffer ( ) . getPaymentMethodShortName ( ) ) ; colRole . addRow ( t . getRole ( ) ) ; } ) ; }
public void start ( @ NonNull Context context , @ NonNull Fragment fragment ) { start ( context , fragment , REQUEST_CROP ) ; }
public Integer getPort ( ) { return port ; }
public AutoModRuleData putResponses ( @ Nonnull AutoModResponse ... responses ) { Checks . noneNull ( responses , "Responses" ) ; for ( AutoModResponse response : responses ) { AutoModResponse . Type type = response . getType ( ) ; Checks . check ( type != AutoModResponse . Type . UNKNOWN , "Cannot create response with unknown response type" ) ; actions . put ( type , response ) ; } return this ; }
public final boolean onlyHasEpsilonTransitions ( ) { return epsilonOnlyTransitions ; }
public EnvelopeResponse < DataResult < List < SegmentPartitionResponse > > > getMultiPartitions ( @ PathVariable ( value = "model_name" ) String modelAlias , @ RequestParam ( value = "project" ) String project , @ RequestParam ( "segment_id" ) String segId , @ RequestParam ( value = "status" , required = false ) List < String > status , @ RequestParam ( value = "page_offset" , required = false , defaultValue = "0" ) Integer pageOffset , @ RequestParam ( value = "page_size" , required = false , defaultValue = "10" ) Integer pageSize , @ RequestParam ( value = "sort_by" , required = false , defaultValue = "last_modify_time" ) String sortBy , @ RequestParam ( value = "reverse" , required = false , defaultValue = "true" ) Boolean reverse ) { checkNonNegativeIntegerArg ( "page_offset" , pageOffset ) ; checkNonNegativeIntegerArg ( "page_size" , pageSize ) ; String projectName = checkProjectName ( project ) ; String modelId = modelService . getModel ( modelAlias , project ) . getId ( ) ; return segmentController . getMultiPartition ( modelId , projectName , segId , status , pageOffset , pageSize , sortBy , reverse ) ; }
public void onDestroy ( ) { owner . getLifecycle ( ) . removeObserver ( this ) ; }
public void addJob ( JobDetail jobDetail , boolean replace , boolean storeNonDurableWhileAwaitingScheduling ) throws SchedulerException { try { getRemoteScheduler ( ) . addJob ( jobDetail , replace , storeNonDurableWhileAwaitingScheduling ) ; } catch ( RemoteException re ) { throw invalidateHandleCreateException ( "Error communicating with remote scheduler." , re ) ; } }
void closeWrappedValueBytes ( ) { if ( ! ( this . wrappedValueBytesInit ( ) ) ) return ; this . closeWrappedValueBytesDependants ( ) ; wrappedValueBytes . bytesStore ( BytesStore . empty ( ) , 0 , 0 ) ; wrappedValueBytesUsed = false ; }
public CIDKeyedType2CharString getType2CharString ( int cid ) throws IOException { CIDKeyedType2CharString type2 = charStringCache . get ( cid ) ; if ( type2 == null ) { int gid = getCharset ( ) . getGIDForCID ( cid ) ; byte [ ] bytes = charStrings [ gid ] ; if ( bytes == null ) { bytes = charStrings [ 0 ] ; } List < Object > type2seq = getParser ( ) . parse ( bytes , globalSubrIndex , getLocalSubrIndex ( gid ) ) ; type2 = new CIDKeyedType2CharString ( reader , getName ( ) , cid , gid , type2seq , getDefaultWidthX ( gid ) , getNominalWidthX ( gid ) ) ; charStringCache . put ( cid , type2 ) ; } return type2 ; }
public String toString ( ) { return "LicensesMetadata{" + "license=" + license + ", trialVersion=" + trialLicenseVersion + '}' ; }
public static PayloadMode getPayloadMode ( String pref ) { switch ( pref ) { case PAYLOAD_MODE_MINIMAL : return PayloadMode . MINIMAL ; case PAYLOAD_MODE_FULL : return PayloadMode . FULL ; default : return PayloadMode . NONE ; } }
public void dispatch ( final InstanceHierarchyRelation source ) { InstanceHierarchyRelationTraffic traffic = new InstanceHierarchyRelationTraffic ( ) ; traffic . setInstanceId ( source . getInstanceId ( ) ) ; traffic . setServiceLayer ( source . getServiceLayer ( ) ) ; traffic . setRelatedInstanceId ( source . getRelatedInstanceId ( ) ) ; traffic . setRelatedServiceLayer ( source . getRelatedServiceLayer ( ) ) ; traffic . setTimeBucket ( source . getTimeBucket ( ) ) ; MetricsStreamProcessor . getInstance ( ) . in ( traffic ) ; }
public static boolean isProLicenseValid ( ) { LicenseServiceFactory licenseServiceFactory = Scope . getCurrentScope ( ) . getSingleton ( LicenseServiceFactory . class ) ; if ( licenseServiceFactory == null ) { return false ; } LicenseService licenseService = licenseServiceFactory . getLicenseService ( ) ; if ( licenseService == null ) { return false ; } return licenseService . licenseIsValid ( "Liquibase Pro" ) ; }
private void computeContents ( ) { subpanel . removeAll ( ) ; final var m = model ; if ( m != null ) { for ( ToolbarItem item : m . getItems ( ) ) { subpanel . add ( new ToolbarButton ( this , item ) ) ; } subpanel . add ( Box . createGlue ( ) ) ; } revalidate ( ) ; }
public boolean hasKind ( ) { return this . kind != null ; }
public long getEpochToPropose ( long sid , long lastAcceptedEpoch ) throws InterruptedException , IOException { synchronized ( connectingFollowers ) { if ( ! waitingForNewEpoch ) { return epoch ; } if ( lastAcceptedEpoch >= epoch ) { epoch = lastAcceptedEpoch + 1 ; } if ( isParticipant ( sid ) ) { connectingFollowers . add ( sid ) ; } QuorumVerifier verifier = self . getQuorumVerifier ( ) ; if ( connectingFollowers . contains ( self . getMyId ( ) ) && verifier . containsQuorum ( connectingFollowers ) ) { waitingForNewEpoch = false ; self . setAcceptedEpoch ( epoch ) ; connectingFollowers . notifyAll ( ) ; } else { long start = Time . currentElapsedTime ( ) ; if ( sid == self . getMyId ( ) ) { timeStartWaitForEpoch = start ; } long cur = start ; long end = start + self . getInitLimit ( ) * self . getTickTime ( ) ; while ( waitingForNewEpoch && cur < end && ! quitWaitForEpoch ) { connectingFollowers . wait ( end - cur ) ; cur = Time . currentElapsedTime ( ) ; } if ( waitingForNewEpoch ) { throw new InterruptedException ( "Timeout while waiting for epoch from quorum" ) ; } } return epoch ; } }
public String getPid ( ) { return getDealId ( ) ; }
public static boolean isPcapdroidMetadataEnabled ( SharedPreferences p ) { return ( p . getBoolean ( PREF_DUMP_EXTENSIONS , false ) ) ; }
private StringBuffer appendNewLineAndIndent ( int numberOfSpacesToIndent , StringBuffer output ) { return output . append ( NEW_LINE ) . append ( Strings . padStart ( "" , numberOfSpacesToIndent , ' ' ) ) ; }
public void setUserLockoutTries ( Integer userLockoutTries ) { this . userLockoutTries = userLockoutTries ; }
public void setBroadcasterClass ( String broadcasterClass ) { this . broadcasterClass = broadcasterClass ; }
public Interval getInterval ( ) { return interval ; }
private void escapeOperationIds ( OperationsMap operations ) { for ( CodegenOperation _op : operations . getOperations ( ) . getOperation ( ) ) { ExtendedCodegenOperation op = ( ExtendedCodegenOperation ) _op ; String param = op . operationIdCamelCase + "Request" ; if ( op . imports . contains ( param ) ) { op . operationIdCamelCase += "Operation" ; op . operationIdLowerCase += "operation" ; op . operationIdSnakeCase += "_operation" ; } } }
public void onActionModeStarted ( ActionMode mode ) { mDialog . onActionModeStarted ( mode ) ; }
public File getH2DataDirectory ( ) throws IOException { final String h2Test = getString ( Settings . KEYS . H2_DATA_DIRECTORY ) ; final File path ; if ( h2Test != null && ! h2Test . isEmpty ( ) ) { path = getDataFile ( Settings . KEYS . H2_DATA_DIRECTORY ) ; } else { path = getDataFile ( Settings . KEYS . DATA_DIRECTORY ) ; } if ( path != null && ( path . exists ( ) || path . mkdirs ( ) ) ) { return path ; } throw new IOException ( String . format ( "Unable to create the h2 data directory '%s'" , ( path == null ) ? "unknown" : path . getAbsolutePath ( ) ) ) ; }
public static RawPrivateTransaction decode ( final String hexTransaction ) { final byte [ ] transaction = Numeric . hexStringToByteArray ( hexTransaction ) ; final TransactionType transactionType = getPrivateTransactionType ( transaction ) ; if ( transactionType == TransactionType . EIP1559 ) { return decodePrivateTransaction1559 ( transaction ) ; } return decodeLegacyPrivateTransaction ( transaction ) ; }
public void shutdown ( ) { LOG . info ( "Shutting down" ) ; next . shutdown ( ) ; }
public boolean isAsync ( ) { return false ; }
public static void openBrowser ( String url ) throws Exception { try { String osName = StringUtils . toLowerEnglish ( Utils . getProperty ( "os.name" , "linux" ) ) ; Runtime rt = Runtime . getRuntime ( ) ; String browser = Utils . getProperty ( SysProperties . H2_BROWSER , null ) ; if ( browser == null ) { try { browser = System . getenv ( "BROWSER" ) ; } catch ( SecurityException se ) { } } if ( browser != null ) { if ( browser . startsWith ( "call:" ) ) { browser = browser . substring ( "call:" . length ( ) ) ; Utils . callStaticMethod ( browser , url ) ; } else if ( browser . contains ( "%url" ) ) { String [ ] args = StringUtils . arraySplit ( browser , ',' , false ) ; for ( int i = 0 ; i < args . length ; i ++ ) { args [ i ] = StringUtils . replaceAll ( args [ i ] , "%url" , url ) ; } rt . exec ( args ) ; } else if ( osName . contains ( "windows" ) ) { rt . exec ( new String [ ] { "cmd.exe" , "/C" , browser , url } ) ; } else { rt . exec ( new String [ ] { browser , url } ) ; } return ; } try { Class < ? > desktopClass = Class . forName ( "java.awt.Desktop" ) ; Boolean supported = ( Boolean ) desktopClass . getMethod ( "isDesktopSupported" ) . invoke ( null , new Object [ 0 ] ) ; URI uri = new URI ( url ) ; if ( supported ) { Object desktop = desktopClass . getMethod ( "getDesktop" ) . invoke ( null ) ; desktopClass . getMethod ( "browse" , URI . class ) . invoke ( desktop , uri ) ; return ; } } catch ( Exception e ) { } if ( osName . contains ( "windows" ) ) { rt . exec ( new String [ ] { "rundll32" , "url.dll,FileProtocolHandler" , url } ) ; } else if ( osName . contains ( "mac" ) || osName . contains ( "darwin" ) ) { Runtime . getRuntime ( ) . exec ( new String [ ] { "open" , url } ) ; } else { String [ ] browsers = { "xdg-open" , "chromium" , "google-chrome" , "firefox" , "mozilla-firefox" , "mozilla" , "konqueror" , "netscape" , "opera" , "midori" } ; boolean ok = false ; for ( String b : browsers ) { try { rt . exec ( new String [ ] { b , url } ) ; ok = true ; break ; } catch ( Exception e ) { } } if ( ! ok ) { throw new Exception ( "Browser detection failed, and java property 'h2.browser' " + "and environment variable BROWSER are not set to a browser executable." ) ; } } } catch ( Exception e ) { throw new Exception ( "Failed to start a browser to open the URL " + url + ": " + e . getMessage ( ) ) ; } }
default boolean isOpen ( ) { return ! isClosed ( ) ; }
public boolean hasIngressRuleValue ( ) { return ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) ; }
private void initComponents ( ) { java . awt . GridBagConstraints gridBagConstraints ; jPanel1 = new javax . swing . JPanel ( ) ; jLabel1 = new javax . swing . JLabel ( ) ; rootNameLabel = new javax . swing . JLabel ( ) ; setTitle ( "Closure Border" ) ; getContentPane ( ) . setLayout ( new java . awt . GridBagLayout ( ) ) ; jPanel1 . setLayout ( new java . awt . GridBagLayout ( ) ) ; jLabel1 . setText ( "Closure-Border of " ) ; gridBagConstraints = new java . awt . GridBagConstraints ( ) ; gridBagConstraints . gridx = 1 ; gridBagConstraints . gridy = 1 ; jPanel1 . add ( jLabel1 , gridBagConstraints ) ; rootNameLabel . setText ( "jLabel2" ) ; gridBagConstraints = new java . awt . GridBagConstraints ( ) ; gridBagConstraints . gridx = 2 ; gridBagConstraints . gridy = 1 ; gridBagConstraints . anchor = java . awt . GridBagConstraints . WEST ; gridBagConstraints . weightx = 1.0 ; jPanel1 . add ( rootNameLabel , gridBagConstraints ) ; gridBagConstraints = new java . awt . GridBagConstraints ( ) ; gridBagConstraints . gridx = 1 ; gridBagConstraints . gridy = 1 ; gridBagConstraints . fill = java . awt . GridBagConstraints . BOTH ; gridBagConstraints . weightx = 1.0 ; gridBagConstraints . weighty = 1.0 ; gridBagConstraints . insets = new java . awt . Insets ( 4 , 2 , 0 , 2 ) ; getContentPane ( ) . add ( jPanel1 , gridBagConstraints ) ; pack ( ) ; }
public Field fromString ( String string ) { return FieldFactory . parseField ( string ) ; }
public int addedShareableChatFolderCountMax ( ) { return options . addedShareableChatFolderCountMax ; }
public void setServerStateManager ( ServerStatisticManager serverStateManager ) { m_serverStateManager = serverStateManager ; }
public boolean canReportChatSpam ( TdApi . Chat chat ) { return chat != null && chat . canBeReported ; }
public void writeUTFBytes ( String value ) { dataOutput . writeUTFBytes ( value ) ; }
public int getIngressCount ( ) { if ( ingressBuilder_ == null ) { return ingress_ . size ( ) ; } else { return ingressBuilder_ . getCount ( ) ; } }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } AddressEntity that = ( AddressEntity ) o ; return Objects . equals ( code , that . code ) && Objects . equals ( name , that . name ) ; }
public ComponentModel addComponentModel ( ComponentModel model ) { getDelegateForUpdate ( ) ; executeEvictions ( model ) ; return updated . addComponentModel ( model ) ; }
static < T > ArrayType < T > ofPrimitive ( Class < T > type ) { if ( boolean . class == type ) { return ( ArrayType < T > ) BooleanArrayType . INSTANCE ; } else if ( byte . class == type ) { return ( ArrayType < T > ) ByteArrayType . INSTANCE ; } else if ( char . class == type ) { return ( ArrayType < T > ) CharArrayType . INSTANCE ; } else if ( double . class == type ) { return ( ArrayType < T > ) DoubleArrayType . INSTANCE ; } else if ( float . class == type ) { return ( ArrayType < T > ) FloatArrayType . INSTANCE ; } else if ( int . class == type ) { return ( ArrayType < T > ) IntArrayType . INSTANCE ; } else if ( long . class == type ) { return ( ArrayType < T > ) LongArrayType . INSTANCE ; } else if ( short . class == type ) { return ( ArrayType < T > ) ShortArrayType . INSTANCE ; } else { throw new IllegalArgumentException ( String . valueOf ( type ) ) ; } }
SortedMap < K , V > filterKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override SortedMap < K , V > rejectKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override SortedMap < K , V > filterValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override SortedMap < K , V > rejectValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeAll ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override < K2 , V2 > SortedMap < K2 , V2 > flatMap ( @ NonNull BiFunction < ? super K , ? super V , ? extends Iterable < Tuple2 < K2 , V2 > > > mapper ) ; @ Override < C > Map < C , ? extends SortedMap < K , V > > groupBy ( @ NonNull Function < ? super Tuple2 < K , V > , ? extends C > classifier ) ; @ Override Iterator < ? extends SortedMap < K , V > > grouped ( int size ) ; @ Override SortedMap < K , V > init ( ) ; @ Override Option < ? extends SortedMap < K , V > > initOption ( ) ; @ Override default boolean isOrdered ( ) { return true ; }
private static DateTimeFormatter tTimeNoMillis ( ) { if ( ttx == null ) { return new DateTimeFormatterBuilder ( ) . append ( literalTElement ( ) ) . append ( timeNoMillis ( ) ) . toFormatter ( ) ; } return ttx ; }
public Uploader startPut ( final String url , final Iterable < Header > headers ) { final HttpEntityEnclosingRequestBase request = new HttpPut ( url ) ; return this . execute ( url , headers , request ) ; }
public void setAccess ( long id , int block ) { lock . writeLock ( ) . lock ( ) ; try { SQLiteDatabase db = this . getWritableDatabase ( ) ; db . beginTransactionNonExclusive ( ) ; try { ContentValues cv = new ContentValues ( ) ; cv . put ( "block" , block ) ; cv . put ( "allowed" , - 1 ) ; if ( db . update ( "access" , cv , "ID = ?" , new String [ ] { Long . toString ( id ) } ) != 1 ) Log . e ( TAG , "Set access failed" ) ; db . setTransactionSuccessful ( ) ; } finally { db . endTransaction ( ) ; } } finally { lock . writeLock ( ) . unlock ( ) ; } notifyAccessChanged ( ) ; }
public final Field < T > $maxvalue ( ) { return maxvalue ; }
protected void assignChildElement ( Object parent , String nodeName , Object child ) { Edge abs = ( Edge ) parent ; if ( child instanceof Point ) { abs . getWaypoint ( ) . add ( ( Point ) child ) ; } else { super . assignChildElement ( abs , nodeName , child ) ; } }
void initialize ( LoadPojos < T > loader ) { cancelInitialize ( ) ; start = System . currentTimeMillis ( ) ; Log . i ( TAG , "Starting provider: " + this . getClass ( ) . getSimpleName ( ) ) ; loader . setProvider ( this ) ; this . pojoScheme = loader . getPojoScheme ( ) ; this . loader = ( LoadPojos < T > ) loader . executeOnExecutor ( AsyncTask . THREAD_POOL_EXECUTOR ) ; }
public boolean equals ( Object o ) { if ( o == null ) return false ; if ( this . getClass ( ) != o . getClass ( ) ) return false ; boolean result = super . equals ( o ) ; ExtendedCodegenModel that = ( ExtendedCodegenModel ) o ; return result && isEntity == that . isEntity && hasReturnPassthroughVoid == that . hasReturnPassthroughVoid && Objects . equals ( returnPassthrough , that . returnPassthrough ) && Objects . equals ( modelImports , that . modelImports ) ; }
public S output ( DatagenMod mod , String id ) { return output ( 1 , mod . asResource ( id ) , 1 ) ; }
public List < InputSlice > assign ( final StageDefinition stageDef , final InputSpec inputSpec , final Int2IntMap stageWorkerCountMap , final InputSpecSlicer slicer , final int maxInputFilesPerSlice , final long maxInputBytesPerSlice ) { if ( slicer . canSliceDynamic ( inputSpec ) ) { return slicer . sliceDynamic ( inputSpec , stageDef . getMaxWorkerCount ( ) , maxInputFilesPerSlice , maxInputBytesPerSlice ) ; } else { final IntSet inputStages = stageDef . getInputStageNumbers ( ) ; final OptionalInt maxInputStageWorkerCount = inputStages . intStream ( ) . map ( stageWorkerCountMap ) . max ( ) ; final int workerCount = Math . min ( stageDef . getMaxWorkerCount ( ) , maxInputStageWorkerCount . orElse ( 1 ) ) ; return slicer . sliceStatic ( inputSpec , workerCount ) ; } }
public String info ( ) { return Base64 . getEncoder ( ) . encodeToString ( JsonUtils . toJson ( secretProperties ) . getBytes ( ) ) ; }
public String toString ( ) { return simplePlan . toString ( ) ; }
public void setLongitude ( Double longitude ) { this . longitude = longitude ; }
public static io . kubernetes . client . proto . V1Networking . ParentReference parseDelimitedFrom ( java . io . InputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
private OutputStream openFile ( ) throws IOException { final FileOutputStream file = new FileOutputStream ( destFile , append ) ; final FileChannel fc = file . getChannel ( ) ; int retries = 0 ; while ( true ) { try { fc . lock ( ) ; return file ; } catch ( final OverlappingFileLockException e ) { if ( retries ++ > LOCK_RETRY_COUNT ) { throw e ; } } try { Thread . sleep ( LOCK_RETRY_WAIT_TIME_MS ) ; } catch ( final InterruptedException e ) { throw new InterruptedIOException ( ) ; } } }
public void setDownloadUri ( String downloadUri ) { this . downloadUri = downloadUri ; }
protected String getGroup ( HttpServletRequest request ) { String groupName = request . getParameter ( Constants . GROUP_NAME ) ; if ( StringUtils . isBlank ( groupName ) ) { groupName = request . getParameter ( com . alibaba . nacos . api . common . Constants . GROUP ) ; } return StringUtils . isBlank ( groupName ) ? StringUtils . EMPTY : groupName ; }
public int getSerializedSize ( ) { int size = memoizedSize ; if ( size != - 1 ) return size ; size = 0 ; if ( ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { size += com . google . protobuf . GeneratedMessageV3 . computeStringSize ( 1 , name_ ) ; } if ( ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) ) { size += com . google . protobuf . CodedOutputStream . computeInt32Size ( 2 , number_ ) ; } size += unknownFields . getSerializedSize ( ) ; memoizedSize = size ; return size ; }
public boolean equals ( java . lang . Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } Contact contact = ( Contact ) o ; return Objects . equals ( this . name , contact . name ) && Objects . equals ( this . url , contact . url ) && Objects . equals ( this . email , contact . email ) && Objects . equals ( this . extensions , contact . extensions ) ; }
public long getElementByteSize ( ) { return this . elementByteSize ; }
public Point getWidthAndHeight ( ) { return new Point ( getBufferedImage ( ) . getWidth ( ) , getBufferedImage ( ) . getHeight ( ) ) ; }
public EventDefinitionEntity findLatestEventDefinitionByKeyAndTenantId ( String eventDefinitionKey , String tenantId ) { Map < String , Object > params = new HashMap < > ( 2 ) ; params . put ( "eventDefinitionKey" , eventDefinitionKey ) ; params . put ( "tenantId" , tenantId ) ; return ( EventDefinitionEntity ) getDbSqlSession ( ) . selectOne ( "selectLatestEventDefinitionByKeyAndTenantId" , params ) ; }
public Builder addAllTo ( java . lang . Iterable < ? extends io . kubernetes . client . proto . V1Networking . NetworkPolicyPeer > values ) { if ( toBuilder_ == null ) { ensureToIsMutable ( ) ; com . google . protobuf . AbstractMessageLite . Builder . addAll ( values , to_ ) ; onChanged ( ) ; } else { toBuilder_ . addAllMessages ( values ) ; } return this ; }
static List < EmailProvider > fromDomain ( Context context , String domain , Discover discover ) throws IOException { return fromEmail ( context , domain , discover , new IDiscovery ( ) { @ Override public void onStatus ( String status ) { } } ) ; }
public boolean isSync ( ) { return sync ; }
public String write ( Project project ) { final String templateReadme = ( ! JavaSettings . getInstance ( ) . isUnbranded ( ) ) ? "Readme_protocol.txt" : "Readme_unbranded.txt" ; return TemplateUtil . loadTextFromResource ( templateReadme , TemplateUtil . SERVICE_NAME , project . getServiceName ( ) , TemplateUtil . SERVICE_DESCRIPTION , project . getServiceDescriptionForMarkdown ( ) , TemplateUtil . GROUP_ID , project . getGroupId ( ) , TemplateUtil . ARTIFACT_ID , project . getArtifactId ( ) , TemplateUtil . ARTIFACT_VERSION , project . getVersion ( ) , TemplateUtil . PACKAGE_NAME , project . getNamespace ( ) ) ; }
public void text ( String str , float x1 , float y1 , float x2 , float y2 ) { if ( textFont == null ) { defaultFontOrDeath ( "text" ) ; } float hradius , vradius ; switch ( rectMode ) { case CORNER : x2 += x1 ; y2 += y1 ; break ; case RADIUS : hradius = x2 ; vradius = y2 ; x2 = x1 + hradius ; y2 = y1 + vradius ; x1 -= hradius ; y1 -= vradius ; break ; case CENTER : hradius = x2 / 2.0f ; vradius = y2 / 2.0f ; x2 = x1 + hradius ; y2 = y1 + vradius ; x1 -= hradius ; y1 -= vradius ; } if ( x2 < x1 ) { float temp = x1 ; x1 = x2 ; x2 = temp ; } if ( y2 < y1 ) { float temp = y1 ; y1 = y2 ; y2 = temp ; } float boxWidth = x2 - x1 ; float spaceWidth = textWidth ( ' ' ) ; if ( textBreakStart == null ) { textBreakStart = new int [ 20 ] ; textBreakStop = new int [ 20 ] ; } textBreakCount = 0 ; int length = str . length ( ) ; if ( length + 1 > textBuffer . length ) { textBuffer = new char [ length + 1 ] ; } str . getChars ( 0 , length , textBuffer , 0 ) ; textBuffer [ length ++ ] = '\n' ; int sentenceStart = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( textBuffer [ i ] == '\n' ) { boolean legit = textSentence ( textBuffer , sentenceStart , i , boxWidth , spaceWidth ) ; if ( ! legit ) break ; sentenceStart = i + 1 ; } } float lineX = x1 ; if ( textAlign == CENTER ) { lineX = lineX + boxWidth / 2f ; } else if ( textAlign == RIGHT ) { lineX = x2 ; } float boxHeight = y2 - y1 ; float topAndBottom = textAscent ( ) + textDescent ( ) ; int lineFitCount = 1 + PApplet . floor ( ( boxHeight - topAndBottom ) / textLeading ) ; int lineCount = Math . min ( textBreakCount , lineFitCount ) ; if ( textAlignY == CENTER ) { float lineHigh = textAscent ( ) + textLeading * ( lineCount - 1 ) ; float y = y1 + textAscent ( ) + ( boxHeight - lineHigh ) / 2 ; for ( int i = 0 ; i < lineCount ; i ++ ) { textLineAlignImpl ( textBuffer , textBreakStart [ i ] , textBreakStop [ i ] , lineX , y ) ; y += textLeading ; } } else if ( textAlignY == BOTTOM ) { float y = y2 - textDescent ( ) - textLeading * ( lineCount - 1 ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { textLineAlignImpl ( textBuffer , textBreakStart [ i ] , textBreakStop [ i ] , lineX , y ) ; y += textLeading ; } } else { float y = y1 + textAscent ( ) ; for ( int i = 0 ; i < lineCount ; i ++ ) { textLineAlignImpl ( textBuffer , textBreakStart [ i ] , textBreakStop [ i ] , lineX , y ) ; y += textLeading ; } } }
public void onDismissed ( Snackbar transientBottomBar , int event ) { prefs . edit ( ) . putBoolean ( "review_asked" , true ) . apply ( ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } ExecutionConfigInfo that = ( ExecutionConfigInfo ) o ; return parallelism == that . parallelism && isObjectReuse == that . isObjectReuse && Objects . equals ( restartStrategy , that . restartStrategy ) && Objects . equals ( globalJobParameters , that . globalJobParameters ) ; }
public void calculateHeightsFast ( ) { calculateHeights ( false ) ; }
public void setMinThreadsForStatusReplication ( int minThreadsForStatusReplication ) { this . minThreadsForStatusReplication = minThreadsForStatusReplication ; }
public void writeTo ( HierarchicalStreamWriter w ) { new ConverterImpl ( ) . marshal ( this , w , null ) ; }
private BackupResult getBackupResult ( boolean isBuiltInBackup ) { String json = _prefs . getString ( getBackupResultKey ( isBuiltInBackup ) , null ) ; if ( json == null ) { return null ; } try { BackupResult res = BackupResult . fromJson ( json ) ; res . setIsBuiltIn ( isBuiltInBackup ) ; return res ; } catch ( JSONException e ) { return null ; } }
public void setRoundRectRadius ( int topLeftRadius , int topRightRadius , int bottomLeftRadius , int bottomRightRadius ) { roundRadiusArray = new float [ 8 ] ; roundRadiusArray [ 0 ] = topLeftRadius ; roundRadiusArray [ 1 ] = topLeftRadius ; roundRadiusArray [ 2 ] = topRightRadius ; roundRadiusArray [ 3 ] = topRightRadius ; roundRadiusArray [ 4 ] = bottomRightRadius ; roundRadiusArray [ 5 ] = bottomRightRadius ; roundRadiusArray [ 6 ] = bottomLeftRadius ; roundRadiusArray [ 7 ] = bottomLeftRadius ; }
default List < ConfigurationParameter > getConfigurationParameters ( ) { return null ; }
public boolean isRestartable ( ) { return restartable ; }
private void initPaints ( ) { mPointPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mPointPaint . setColor ( mPointColor ) ; mPointPaint . setStrokeWidth ( mPointWidth ) ; mPointPaint . setStyle ( Paint . Style . STROKE ) ; mPointFillPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mPointFillPaint . setColor ( mPointFillColor ) ; mPointFillPaint . setStyle ( Paint . Style . FILL ) ; mPointFillPaint . setAlpha ( mPointFillAlpha ) ; mLinePaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mLinePaint . setColor ( mLineColor ) ; mLinePaint . setStrokeWidth ( mLineWidth ) ; mLinePaint . setStyle ( Paint . Style . STROKE ) ; mMaskPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mMaskPaint . setColor ( Color . BLACK ) ; mMaskPaint . setStyle ( Paint . Style . FILL ) ; mGuideLinePaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mGuideLinePaint . setColor ( mGuideLineColor ) ; mGuideLinePaint . setStyle ( Paint . Style . FILL ) ; mGuideLinePaint . setStrokeWidth ( mGuideLineWidth ) ; mMagnifierPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mMagnifierPaint . setColor ( Color . WHITE ) ; mMagnifierPaint . setStyle ( Paint . Style . FILL ) ; mMagnifierCrossPaint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; mMagnifierCrossPaint . setColor ( mMagnifierCrossColor ) ; mMagnifierCrossPaint . setStyle ( Paint . Style . FILL ) ; mMagnifierCrossPaint . setStrokeWidth ( dp2px ( MAGNIFIER_CROSS_LINE_WIDTH ) ) ; }
protected TableRecords buildTableRecords ( TableMeta tableMeta , String selectSQL , ArrayList < List < Object > > paramAppenderList ) throws SQLException { PreparedStatement ps = null ; ResultSet rs = null ; try { ps = statementProxy . getConnection ( ) . prepareStatement ( selectSQL ) ; if ( CollectionUtils . isNotEmpty ( paramAppenderList ) ) { for ( int i = 0 , ts = paramAppenderList . size ( ) ; i < ts ; i ++ ) { List < Object > paramAppender = paramAppenderList . get ( i ) ; for ( int j = 0 , ds = paramAppender . size ( ) ; j < ds ; j ++ ) { ps . setObject ( i * ds + j + 1 , paramAppender . get ( j ) ) ; } } } rs = ps . executeQuery ( ) ; return TableRecords . buildRecords ( tableMeta , rs ) ; } finally { IOUtil . close ( rs , ps ) ; } }
public static < T > T rethrow ( final Throwable throwable ) { return ExceptionUtils . < T , RuntimeException > eraseType ( throwable ) ; }
public KafkaFuture < Map < String , TopicListing > > namesToListings ( ) { return future ; }
public boolean isTimescaleDB ( ) { return isTimescaleDB ( gainSQLDatabase ( ) ) ; }
public void run ( ) { if ( password != null ) { key_mutf8 ( keyMaterial ) ; } }
public float getYOrigin ( ) { return yOrigin ; }
private void init ( Context context , AttributeSet attrs ) { mBannerManager = new BannerManager ( ) ; mBannerManager . initAttrs ( context , attrs ) ; initView ( ) ; }
public static boolean anyStartWith ( String text , List < String > prefixList ) { for ( String prefix : prefixList ) { if ( text . startsWith ( prefix ) ) { return true ; } } return false ; }
public void setPreserveNameAndDescription ( boolean preserveNameAndDescription ) { this . preserveNameAndDescription = preserveNameAndDescription ; preferences . setValue ( TaxonomyImportModel . PREF_PRESERVE_NAME_DESCRIPTION , preserveNameAndDescription ) ; }
private long toSnapshotId ( Table table , String refName ) { SnapshotRef ref = table . refs ( ) . get ( refName ) ; ValidationException . check ( ref != null , "Cannot find matching snapshot ID for ref %s" , refName ) ; return ref . snapshotId ( ) ; }
public JCheckBox getUpload_log_checkbox ( ) { return upload_log_checkbox ; }
private static void addLink ( InstitutionalMemory institutionalMemoryAspect , String linkUrl , String linkLabel , Urn actor , @ Nullable LinkSettingsInput settingsInput ) { if ( ! institutionalMemoryAspect . hasElements ( ) ) { institutionalMemoryAspect . setElements ( new InstitutionalMemoryMetadataArray ( ) ) ; } InstitutionalMemoryMetadataArray linksArray = institutionalMemoryAspect . getElements ( ) ; if ( hasDuplicates ( linksArray , linkUrl , linkLabel ) ) { throw new IllegalArgumentException ( String . format ( "The link '%s' with label '%s' already exists" , linkUrl , linkLabel ) ) ; } InstitutionalMemoryMetadata newLink = new InstitutionalMemoryMetadata ( ) ; newLink . setUrl ( new Url ( linkUrl ) ) ; newLink . setCreateStamp ( EntityUtils . getAuditStamp ( actor ) ) ; newLink . setDescription ( linkLabel ) ; if ( settingsInput != null ) { newLink . setSettings ( mapSettings ( settingsInput ) ) ; } linksArray . add ( newLink ) ; }
public void setTitle ( String title ) { this . title . setText ( title ) ; }
public final boolean isSubtypeOf ( Type supertype ) { checkNotNull ( supertype ) ; if ( supertype instanceof WildcardType ) { return any ( ( ( WildcardType ) supertype ) . getLowerBounds ( ) ) . isSupertypeOf ( runtimeType ) ; } if ( runtimeType instanceof WildcardType ) { return any ( ( ( WildcardType ) runtimeType ) . getUpperBounds ( ) ) . isSubtypeOf ( supertype ) ; } if ( runtimeType instanceof TypeVariable ) { return runtimeType . equals ( supertype ) || any ( ( ( TypeVariable < ? > ) runtimeType ) . getBounds ( ) ) . isSubtypeOf ( supertype ) ; } if ( runtimeType instanceof GenericArrayType ) { return of ( supertype ) . isSupertypeOfArray ( ( GenericArrayType ) runtimeType ) ; } if ( supertype instanceof Class ) { return this . someRawTypeIsSubclassOf ( ( Class < ? > ) supertype ) ; } else if ( supertype instanceof ParameterizedType ) { return this . isSubtypeOfParameterizedType ( ( ParameterizedType ) supertype ) ; } else if ( supertype instanceof GenericArrayType ) { return this . isSubtypeOfArrayType ( ( GenericArrayType ) supertype ) ; } else { return false ; } }
protected void setCursorPosition ( float x , float y ) { moveOffset = - 1 ; Drawable background = style . background ; BitmapFont font = style . font ; float height = getHeight ( ) ; if ( background != null ) { height -= background . getTopHeight ( ) ; x -= background . getLeftWidth ( ) ; } x = Math . max ( 0 , x ) ; if ( background != null ) { y -= background . getTopHeight ( ) ; } cursorLine = ( int ) Math . floor ( ( height - y ) / font . getLineHeight ( ) ) + firstLineShowing ; cursorLine = Math . max ( 0 , Math . min ( cursorLine , getLines ( ) - 1 ) ) ; super . setCursorPosition ( x , y ) ; updateCurrentLine ( ) ; }
public void getMessageProperties ( List < TdApi . Message > messages , RunnableData < TdApi . MessageProperties [ ] > callback ) { TdApi . MessageProperties [ ] allProperties = new TdApi . MessageProperties [ messages . size ( ) ] ; AtomicInteger remaining = new AtomicInteger ( messages . size ( ) ) ; int i = 0 ; for ( TdApi . Message message : messages ) { int index = i ; getMessageProperties ( message , properties -> { allProperties [ index ] = properties ; if ( remaining . decrementAndGet ( ) == 0 ) { callback . runWithData ( allProperties ) ; } } ) ; i ++ ; } }
private boolean yieldIfContendedHelper ( boolean checkFullyYielded , long sleepAfterYieldDelay ) { if ( mLock . getQueueLength ( ) == 0 ) { mLockAcquiredWallTime = SystemClock . elapsedRealtime ( ) ; mLockAcquiredThreadTime = Debug . threadCpuTimeNanos ( ) ; return false ; } setTransactionSuccessful ( ) ; SQLiteTransactionListener transactionListener = mTransactionListener ; endTransaction ( ) ; if ( checkFullyYielded ) { if ( this . isDbLockedByCurrentThread ( ) ) { throw new IllegalStateException ( "Db locked more than once. yielfIfContended cannot yield" ) ; } } if ( sleepAfterYieldDelay > 0 ) { long remainingDelay = sleepAfterYieldDelay ; while ( remainingDelay > 0 ) { try { Thread . sleep ( remainingDelay < SLEEP_AFTER_YIELD_QUANTUM ? remainingDelay : SLEEP_AFTER_YIELD_QUANTUM ) ; } catch ( InterruptedException e ) { Thread . interrupted ( ) ; } remainingDelay -= SLEEP_AFTER_YIELD_QUANTUM ; if ( mLock . getQueueLength ( ) == 0 ) { break ; } } } beginTransactionWithListener ( transactionListener ) ; return true ; }
default void sendPongAndAwait ( Buffer data ) { sendPong ( data ) . await ( ) . indefinitely ( ) ; }
void scrollToTop ( ) { binding . recyclerView . smoothScrollToPosition ( 0 ) ; }
public boolean hasFamilies ( ) { return ! this . familyMap . isEmpty ( ) ; }
public void setDevProcess ( String devProcess ) { this . devProcess = devProcess ; }
public RowKeyExtractor createRowKeyExtractor ( ) { switch ( bucketMode ( ) ) { case HASH_FIXED : return new FixedBucketRowKeyExtractor ( schema ( ) ) ; case HASH_DYNAMIC : case KEY_DYNAMIC : return new DynamicBucketRowKeyExtractor ( schema ( ) ) ; case BUCKET_UNAWARE : return new AppendTableRowKeyExtractor ( schema ( ) ) ; case POSTPONE_MODE : return new PostponeBucketRowKeyExtractor ( schema ( ) ) ; default : throw new UnsupportedOperationException ( "Unsupported mode: " + bucketMode ( ) ) ; } }
public int numberOfActionButtons ( ) { return mDialog . numberOfActionButtons ( ) ; }
public int getType ( ) { return mType ; }
public int compareTo ( AttributeInfo o ) { return this . name . compareTo ( o . name ) ; }
public void setMatrix ( PMatrix2D source ) { showMissingWarning ( "setMatrix" ) ; }
public void setChatMemberStatus ( final long chatId , final TdApi . MessageSender sender , final TdApi . ChatMemberStatus newStatus , final int forwardLimit , final @ Nullable TdApi . ChatMemberStatus currentStatus , @ Nullable final ChatMemberStatusChangeCallback callback ) { if ( ChatId . isBasicGroup ( chatId ) && TD . needUpgradeToSupergroup ( newStatus ) ) { Runnable act = ( ) -> upgradeToSupergroup ( chatId , ( oldChatId , newChatId , error ) -> { if ( newChatId != 0 ) setChatMemberStatusImpl ( newChatId , sender , newStatus , 0 , currentStatus , callback ) ; else if ( callback != null ) callback . onMemberStatusUpdated ( false , error ) ; } ) ; if ( forwardLimit > 0 && sender . getConstructor ( ) == TdApi . MessageSenderUser . CONSTRUCTOR && TD . isMember ( newStatus , false ) && ! TD . isMember ( currentStatus , false ) ) { client ( ) . send ( new TdApi . AddChatMember ( chatId , ( ( TdApi . MessageSenderUser ) sender ) . userId , forwardLimit ) , object -> { if ( TD . isOk ( object ) ) { act . run ( ) ; } else if ( callback != null ) { ui ( ) . post ( ( ) -> callback . onMemberStatusUpdated ( false , ( TdApi . Error ) object ) ) ; } } ) ; } else { act . run ( ) ; } } else { setChatMemberStatusImpl ( chatId , sender , newStatus , forwardLimit , currentStatus , callback ) ; } }
public void onChanged ( Boolean aBoolean ) { if ( aBoolean ) { imageAccessibilityPermission . setImageDrawable ( drawableYes ) ; } else { imageAccessibilityPermission . setImageDrawable ( drawableNo ) ; } }
public static final boolean isWindowsCE ( ) { return osType == WINDOWSCE ; }
private void beginTransactionWithListenerInternal ( SQLiteTransactionListener transactionListener , SQLiteDatabaseTransactionType transactionType ) { lockForced ( ) ; if ( ! isOpen ( ) ) { throw new IllegalStateException ( "database not open" ) ; } boolean ok = false ; try { if ( mLock . getHoldCount ( ) > 1 ) { if ( mInnerTransactionIsSuccessful ) { String msg = "Cannot call beginTransaction between " + "calling setTransactionSuccessful and endTransaction" ; IllegalStateException e = new IllegalStateException ( msg ) ; if ( BuildConfig . DEBUG ) { Log . e ( TAG , "beginTransaction() failed" , e ) ; } throw e ; } ok = true ; return ; } if ( transactionType == SQLiteDatabaseTransactionType . Exclusive ) { execSQL ( "BEGIN EXCLUSIVE;" ) ; } else if ( transactionType == SQLiteDatabaseTransactionType . Immediate ) { execSQL ( "BEGIN IMMEDIATE;" ) ; } else if ( transactionType == SQLiteDatabaseTransactionType . Deferred ) { execSQL ( "BEGIN DEFERRED;" ) ; } else { String message = String . format ( "%s is an unsupported transaction type" , transactionType ) ; throw new IllegalArgumentException ( message ) ; } mTransactionListener = transactionListener ; mTransactionIsSuccessful = true ; mInnerTransactionIsSuccessful = false ; if ( transactionListener != null ) { try { transactionListener . onBegin ( ) ; } catch ( RuntimeException e ) { execSQL ( "ROLLBACK;" ) ; throw e ; } } ok = true ; } finally { if ( ! ok ) { unlockForced ( ) ; } } }
public int getCode ( ) { return code ; }
public void inform ( Proposal proposal ) { QuorumPacket qp = new QuorumPacket ( Leader . INFORM , proposal . request . zxid , proposal . packet . getData ( ) , null ) ; sendObserverPacket ( qp ) ; }
public void selectAllIndices ( ) { mDialog . selectAllIndices ( ) ; }
public boolean isNoCompensate ( ) { return super . isNoCompensate ( ) || ( state . isCompensate ( ) && CollectionUtils . isEmpty ( compensations ) ) ; }
public void actionPerformed ( java . awt . event . ActionEvent evt ) { replaceAllButtonActionPerformed ( evt ) ; }
public static SlideBackManager with ( Activity activity , boolean isFixedSize ) { SlideBackManager manager = new SlideBackManager ( activity , isFixedSize ) ; sSideMap . put ( activity , manager ) ; return manager ; }
public static Timestamp getCalendarTimestamp ( Calendar cal ) { return new Timestamp ( cal . getTime ( ) . getTime ( ) ) ; }
public Set < EXPORT_SUMMARY > getClaimTypes ( ) { return claimTypes ; }
public static void setTranslucentForDrawerLayout ( Activity activity , DrawerLayout drawerLayout , int statusBarAlpha ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . KITKAT ) { return ; } setTransparentForDrawerLayout ( activity , drawerLayout ) ; addTranslucentView ( activity , statusBarAlpha ) ; }
public void closeLocksDependants ( ) { this . closeDelayedUpdateChecksum ( ) ; this . innerReadLock . closeReadLockLockDependants ( ) ; this . closeMapQueryDropSearchIfNestedContextsAndPresentHashLookupSlotCheckFailedDependants ( ) ; }
public DocumentContext writingDocument ( ) { return writingDocument ( false ) ; }
public boolean isDynamic ( ) { return dynamicExpression != null ; }
private void updateChatReplyMarkup ( TdApi . UpdateChatReplyMarkup update ) { synchronized ( dataLock ) { final TdApi . Chat chat = chats . get ( update . chatId ) ; if ( TdlibUtils . assertChat ( update . chatId , chat , update ) ) { return ; } chat . replyMarkupMessageId = update . replyMarkupMessageId ; } listeners . updateChatReplyMarkup ( update ) ; }
private float getViewPointY ( Point point ) { return getViewPointY ( point . y ) ; }
private void updateVersion ( int version ) throws SQLException { try ( Statement stmt = connection . createStatement ( ) ) { stmt . executeUpdate ( String . format ( "INSERT OR REPLACE INTO metadata (\"key\", \"value\") VALUES ('version', '%d')" , version ) ) ; } }
public Map < String , double [ ] > getDatas ( ) { return m_datas ; }
public Boolean isIcon128Delete ( ) { return icon128Delete ; }
protected void execute ( NetworkRequest < Void > callback ) { nativeRegisterDevice ( nativePtr , osSyncUser . getNativePtr ( ) , serviceName , registrationToken , callback ) ; }
public boolean commitUpdates ( Map < ? extends Long , ? extends Map < String , Object > > additionalValues ) { if ( ! supportsUpdates ( ) ) { Log . e ( TAG , "commitUpdates not supported on this cursor, did you include the _id column?" ) ; return false ; } synchronized ( mUpdatedRows ) { if ( additionalValues != null ) { mUpdatedRows . putAll ( additionalValues ) ; } if ( mUpdatedRows . size ( ) <= 0 ) { return false ; } try { boolean result = mBulkCursor . updateRows ( mUpdatedRows ) ; if ( result == true ) { mUpdatedRows . clear ( ) ; onChange ( true ) ; } return result ; } catch ( RemoteException ex ) { Log . e ( TAG , "Unable to commit updates because the remote process is dead" ) ; return false ; } } }
private void createTag ( String tagName , Snapshot fromSnapshot , @ Nullable Duration timeRetained ) { tagManager ( ) . createTag ( fromSnapshot , tagName , timeRetained , store ( ) . createTagCallbacks ( this ) , false ) ; }
public Dimension getPreferredSize ( ) { return new Dimension ( 30 , 255 ) ; }
public long inputKeyBytesSize ( ) { assert this . inputKeyBytesStoreInit ( ) : "InputKeyBytesStore should be init" ; return this . inputKeyBytesSize ; }
public void setOnList ( List < On > onList ) { this . onList = onList ; }
protected String getItemSelector ( ) { return ">.board-card" ; }
public BigDecimal getSoftScore ( int softLevel ) { return softScores [ softLevel ] ; }
public static Class < ? > getActualType ( Type type ) { if ( type instanceof Class ) { return ( Class < ? > ) type ; } if ( type instanceof ParameterizedType ) { return getActualType ( ( ( ParameterizedType ) type ) . getRawType ( ) ) ; } if ( type instanceof TypeVariable ) { return getActualType ( ( ( TypeVariable < ? > ) type ) . getBounds ( ) [ 0 ] ) ; } if ( type instanceof WildcardType ) { return getActualType ( ( ( WildcardType ) type ) . getUpperBounds ( ) [ 0 ] ) ; } if ( type instanceof GenericArrayType ) { Type componentType = ( ( GenericArrayType ) type ) . getGenericComponentType ( ) ; return Array . newInstance ( getActualType ( componentType ) , 0 ) . getClass ( ) ; } return null ; }
private static int lps ( String s , Integer [ ] [ ] dp , int i , int j ) { if ( j < i ) return 0 ; if ( i == j ) return 1 ; if ( dp [ i ] [ j ] != null ) return dp [ i ] [ j ] ; char c1 = s . charAt ( i ) , c2 = s . charAt ( j ) ; if ( c1 == c2 ) return dp [ i ] [ j ] = lps ( s , dp , i + 1 , j - 1 ) + 2 ; return dp [ i ] [ j ] = Math . max ( lps ( s , dp , i + 1 , j ) , lps ( s , dp , i , j - 1 ) ) ; }
public ServerResponse stream ( Consumer < ServerResponse . StreamBuilder > streamConsumer ) { return GatewayStreamingServerResponse . create ( this . statusCode , this . headers , this . cookies , streamConsumer , null ) ; }
public String getCourier ( ) { return courier ; }
public static Optional < PaymentMethod > getActivePaymentMethod ( String id ) { return Optional . ofNullable ( PAYMENT_METHOD_MAP . get ( id ) ) ; }
private static Predicate < InstitutionalMemoryMetadata > getPredicate ( String linkUrl , String linkLabel ) { return ( link ) -> link . getUrl ( ) . toString ( ) . equals ( linkUrl ) & link . getDescription ( ) . equals ( ( linkLabel ) ) ; }
public com . google . protobuf . ByteString getControllerBytes ( ) { java . lang . Object ref = controller_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; controller_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } }
public void setCanceledOnTouchOutside ( boolean cancel ) { mDialog . setCanceledOnTouchOutside ( cancel ) ; }
protected void setVideoFrameRate ( int rate ) { videoFrameRate = rate ; state = STATE_DATA_SOURCE_CONFIGURED ; }
public static void longToOctets ( long address , byte [ ] octets , int offset ) { octets [ offset ] = ( byte ) ( 0xffL & ( address > > > 56 ) ) ; octets [ offset + 1 ] = ( byte ) ( 0xffL & ( address > > > 48 ) ) ; octets [ offset + 2 ] = ( byte ) ( 0xffL & ( address > > > 40 ) ) ; octets [ offset + 3 ] = ( byte ) ( 0xffL & ( address > > > 32 ) ) ; octets [ offset + 4 ] = ( byte ) ( 0xffL & ( address > > > 24 ) ) ; octets [ offset + 5 ] = ( byte ) ( 0xffL & ( address > > > 16 ) ) ; octets [ offset + 6 ] = ( byte ) ( 0xffL & ( address > > > 8 ) ) ; octets [ offset + 7 ] = ( byte ) ( 0xffL & address ) ; }
public HitTestResult getHitTestResult ( ) { checkThread ( ) ; return mProvider . getHitTestResult ( ) ; }
public int getStackPopCount ( AVM2Instruction ins , ABC abc ) { return 2 ; }
public @ Nullable String getName ( ) { return name ; }
public Date fileIngestStartTime ( ) { return new Date ( snapshot . getFileIngestStartTime ( ) . getTime ( ) ) ; }
private void showStartLine ( boolean show ) { mDrawStartLine = show ; }
public void addParameterMap ( ParameterMap pm ) { parameterMaps . put ( pm . getId ( ) , pm ) ; }
public String getJobName ( ) { return jobName ; }
public List < OrderEntry > getOrders ( ) { return orders ; }
public V record ( ) { return value ; }
public io . kubernetes . client . proto . V1Networking . IngressStatus buildPartial ( ) { io . kubernetes . client . proto . V1Networking . IngressStatus result = new io . kubernetes . client . proto . V1Networking . IngressStatus ( this ) ; int from_bitField0_ = bitField0_ ; int to_bitField0_ = 0 ; if ( ( ( from_bitField0_ & 0x00000001 ) == 0x00000001 ) ) { to_bitField0_ |= 0x00000001 ; } if ( loadBalancerBuilder_ == null ) { result . loadBalancer_ = loadBalancer_ ; } else { result . loadBalancer_ = loadBalancerBuilder_ . build ( ) ; } result . bitField0_ = to_bitField0_ ; onBuilt ( ) ; return result ; }
public static void setExternalStorageRemovable ( File file , boolean isRemovable ) { STORAGE_REMOVABLE . put ( file , isRemovable ) ; }
public static @ Nullable TargetDebuggerConnection prepareDebuggerConnection ( @ NotNull JavaCommandLineState javaCommandLineState , @ NotNull TargetEnvironmentRequest request ) { final int remotePort ; JavaParameters javaParameters ; try { javaParameters = javaCommandLineState . getJavaParameters ( ) ; } catch ( ExecutionException e ) { return null ; } { Integer remotePort2 = requiredDebuggerTargetPort ( javaCommandLineState , request ) ; if ( remotePort2 == null ) { return null ; } remotePort = remotePort2 ; } try { final String remoteAddressForVmParams ; final boolean java9plus = Optional . ofNullable ( request . getConfiguration ( ) ) . map ( TargetEnvironmentConfiguration :: getRuntimes ) . map ( list -> list . findByType ( JavaLanguageRuntimeConfiguration . class ) ) . map ( JavaLanguageRuntimeConfiguration :: getJavaVersionString ) . filter ( StringUtil :: isNotEmpty ) . map ( JavaSdkVersion :: fromVersionString ) . map ( v -> v . isAtLeast ( JavaSdkVersion . JDK_1_9 ) ) . orElse ( false ) ; if ( java9plus ) { remoteAddressForVmParams = "0.0.0.0:" + remotePort ; } else { remoteAddressForVmParams = String . valueOf ( remotePort ) ; } RemoteConnection remoteConnection = new RemoteConnectionBuilder ( false , DebuggerSettings . SOCKET_TRANSPORT , remoteAddressForVmParams ) . suspend ( true ) . create ( javaParameters ) ; remoteConnection . setApplicationAddress ( String . valueOf ( remotePort ) ) ; if ( java9plus ) { remoteConnection . setApplicationHostName ( "*" ) ; } return new TargetDebuggerConnection ( remoteConnection , new TargetEnvironment . TargetPortBinding ( null , remotePort ) ) ; } catch ( ExecutionException e ) { return null ; } }
private Long diffLast ( String key , Long value ) { Object lastValue = lastValueMap . get ( key ) ; if ( lastValue != null ) { lastValueMap . put ( key , value ) ; return value - ( Long ) lastValue ; } else { lastValueMap . put ( key , value ) ; return value ; } }
public < ReqT , RespT > ClientCall < ReqT , RespT > interceptCall ( MethodDescriptor < ReqT , RespT > method , CallOptions callOptions , Channel channel ) { MethodDescriptor < ReqT , RespT > overriddenMethodDescriptor = callOptions . getOption ( GrpcSerializationUtils . OVERRIDDEN_METHOD_DESCRIPTOR ) ; if ( overriddenMethodDescriptor != null ) { method = overriddenMethodDescriptor ; } return channel . newCall ( method , callOptions ) ; }
Lexeme removeTail ( ) { Lexeme tail = this . pollLast ( ) ; if ( this . isEmpty ( ) ) { this . pathBegin = - 1 ; this . pathEnd = - 1 ; this . payloadLength = 0 ; } else { this . payloadLength -= tail . getLength ( ) ; Lexeme newTail = this . peekLast ( ) ; this . pathEnd = newTail . getBegin ( ) + newTail . getLength ( ) ; } return tail ; }
private static void log ( int level , String message , Object ... args ) { Debug . logx ( level , me + message , args ) ; }
protected Node nextMarkedNode ( int fromNodeId ) { assert fromNodeId >= 0 : fromNodeId ; int wordIndex = fromNodeId > > SHIFT ; int wordsInUse = bits . length ; if ( wordIndex < wordsInUse ) { long word = getPartOfWord ( bits [ wordIndex ] , fromNodeId ) ; while ( true ) { CompilationAlarm . checkProgress ( graph ) ; while ( word != 0 ) { int bitIndex = Long . numberOfTrailingZeros ( word ) ; int nodeId = wordIndex * Long . SIZE + bitIndex ; Node result = graph . getNode ( nodeId ) ; if ( result == null ) { bits [ wordIndex ] = bits [ wordIndex ] & ~ ( 1L << bitIndex ) ; int nextNodeId = nodeId + 1 ; if ( ( nextNodeId & ( Long . SIZE - 1 ) ) == 0 ) { break ; } else { word = getPartOfWord ( word , nextNodeId ) ; } } else { return result ; } } if ( ++ wordIndex == wordsInUse ) { break ; } word = bits [ wordIndex ] ; } } return null ; }
private void onRemove ( JavaRuntime java ) { if ( java . isManaged ( ) ) { Controllers . confirm ( i18n ( "java.uninstall.confirm" ) , i18n ( "message.warning" ) , ( ) -> Controllers . taskDialog ( JavaManager . getUninstallJavaTask ( java ) , i18n ( "java.uninstall" ) , TaskCancellationAction . NORMAL ) , null ) ; } else { Controllers . confirm ( i18n ( "java.disable.confirm" ) , i18n ( "message.warning" ) , ( ) -> { String path = java . getBinary ( ) . toString ( ) ; ConfigHolder . globalConfig ( ) . getUserJava ( ) . remove ( path ) ; ConfigHolder . globalConfig ( ) . getDisabledJava ( ) . add ( path ) ; try { JavaManager . removeJava ( java ) ; } catch ( InterruptedException ignored ) { } } , null ) ; } }
public Throwable getReason ( ) { return reason ; }
public void updateNull ( int col ) throws SQLException { throw unsupported ( ) ; }
synchronized void abortPendingFlushes ( ) { try { for ( DocumentsWriterPerThread dwpt : flushQueue ) { try { documentsWriter . subtractFlushedNumDocs ( dwpt . getNumDocsInRAM ( ) ) ; dwpt . abort ( ) ; } catch ( Exception _ ) { } finally { doAfterFlush ( dwpt ) ; } } for ( DocumentsWriterPerThread blockedFlush : blockedFlushes ) { try { addFlushingDWPT ( blockedFlush ) ; documentsWriter . subtractFlushedNumDocs ( blockedFlush . getNumDocsInRAM ( ) ) ; blockedFlush . abort ( ) ; } catch ( Exception _ ) { } finally { doAfterFlush ( blockedFlush ) ; } } } finally { flushQueue . clear ( ) ; blockedFlushes . clear ( ) ; updateStallState ( ) ; } }
public int getDimensionPixelOffset ( DisplayMetrics metrics ) { return ( int ) TypedValue . applyDimension ( mUnit , mValue , metrics ) ; }
public GSYVideoOptionBuilder setHideKey ( boolean hideKey ) { this . mHideKey = hideKey ; return this ; }
private void verificationSequenceSuccessMessage ( VerificationSequence verificationSequence , Consumer < String > resultConsumer , String logCorrelationId , String failureMessage ) { if ( isBlank ( failureMessage ) && MockServerLogger . isEnabled ( Level . INFO ) ) { mockServerLogger . logEvent ( new LogEntry ( ) . setType ( VERIFICATION_PASSED ) . setLogLevel ( Level . INFO ) . setCorrelationId ( logCorrelationId ) . setMessageFormat ( "request sequence found:{}" ) . setArguments ( verificationSequence . getHttpRequests ( ) ) ) ; } resultConsumer . accept ( failureMessage ) ; }
public DokitPicasso build ( ) { Context context = this . context ; if ( downloader == null ) { downloader = Utils . createDefaultDownloader ( context ) ; } if ( cache == null ) { cache = new LruCache ( context ) ; } if ( service == null ) { service = new PicassoExecutorService ( ) ; } if ( transformer == null ) { transformer = RequestTransformer . IDENTITY ; } Stats stats = new Stats ( cache ) ; Dispatcher dispatcher = new Dispatcher ( context , service , HANDLER , downloader , cache , stats ) ; return new DokitPicasso ( context , dispatcher , cache , listener , transformer , requestHandlers , stats , defaultBitmapConfig , indicatorsEnabled , loggingEnabled ) ; }
public void closeQuerySegmentStagesTierEntriesDependants ( ) { this . closeSegment ( ) ; }
public void setNormalLandAngleEnd ( int normalLandAngleEnd ) { this . mNormalLandAngleEnd = normalLandAngleEnd ; }
void writeBoolean ( int pos , boolean value ) ; void writeByte ( int pos , byte value ) ; void writeShort ( int pos , short value ) ; void writeInt ( int pos , int value ) ; void writeLong ( int pos , long value ) ; void writeFloat ( int pos , float value ) ; void writeDouble ( int pos , double value ) ; void writeString ( int pos , StringData value ) ; void writeBinary ( int pos , byte [ ] bytes ) ; void writeDecimal ( int pos , DecimalData value , int precision ) ; void writeTimestamp ( int pos , TimestampData value , int precision ) ; void writeLocalZonedTimestamp ( int pos , LocalZonedTimestampData value , int precision ) ; void writeZonedTimestamp ( int pos , ZonedTimestampData value , int precision ) ; void writeArray ( int pos , ArrayData value , ArrayDataSerializer serializer ) ; void writeMap ( int pos , MapData value , MapDataSerializer serializer ) ; void writeRecord ( int pos , RecordData value , TypeSerializer < RecordData > serializer ) ; void writeDate ( int pos , DateData value ) ; void writeTime ( int pos , TimeData value , int precision ) ; void writeVariant ( int pos , Variant variant ) ; void complete ( ) ; static void write ( BinaryWriter writer , int pos , Object o , DataType type , TypeSerializer < ? > serializer ) { switch ( type . getTypeRoot ( ) ) { case BOOLEAN : writer . writeBoolean ( pos , ( boolean ) o ) ; break ; case TINYINT : writer . writeByte ( pos , ( byte ) o ) ; break ; case SMALLINT : writer . writeShort ( pos , ( short ) o ) ; break ; case INTEGER : writer . writeInt ( pos , ( int ) o ) ; break ; case DATE : if ( o instanceof DateData ) { writer . writeDate ( pos , ( DateData ) o ) ; } else { writer . writeInt ( pos , ( int ) o ) ; } break ; case TIME_WITHOUT_TIME_ZONE : if ( o instanceof TimeData ) { writer . writeTime ( pos , ( TimeData ) o , ( ( TimeType ) type ) . getPrecision ( ) ) ; } else { writer . writeInt ( pos , ( int ) o ) ; } break ; case BIGINT : writer . writeLong ( pos , ( long ) o ) ; break ; case TIMESTAMP_WITHOUT_TIME_ZONE : TimestampType timestampType = ( TimestampType ) type ; writer . writeTimestamp ( pos , ( TimestampData ) o , timestampType . getPrecision ( ) ) ; break ; case TIMESTAMP_WITH_LOCAL_TIME_ZONE : LocalZonedTimestampType lzTs = ( LocalZonedTimestampType ) type ; writer . writeLocalZonedTimestamp ( pos , ( LocalZonedTimestampData ) o , lzTs . getPrecision ( ) ) ; break ; case TIMESTAMP_WITH_TIME_ZONE : ZonedTimestampType zTs = ( ZonedTimestampType ) type ; writer . writeZonedTimestamp ( pos , ( ZonedTimestampData ) o , zTs . getPrecision ( ) ) ; break ; case FLOAT : writer . writeFloat ( pos , ( float ) o ) ; break ; case DOUBLE : writer . writeDouble ( pos , ( double ) o ) ; break ; case CHAR : case VARCHAR : writer . writeString ( pos , ( StringData ) o ) ; break ; case DECIMAL : DecimalType decimalType = ( DecimalType ) type ; writer . writeDecimal ( pos , ( DecimalData ) o , decimalType . getPrecision ( ) ) ; break ; case ARRAY : if ( serializer instanceof NullableSerializerWrapper ) { serializer = ( ( NullableSerializerWrapper ) serializer ) . getWrappedSerializer ( ) ; } writer . writeArray ( pos , ( ArrayData ) o , ( ArrayDataSerializer ) serializer ) ; break ; case MAP : if ( serializer instanceof NullableSerializerWrapper ) { serializer = ( ( NullableSerializerWrapper ) serializer ) . getWrappedSerializer ( ) ; } writer . writeMap ( pos , ( MapData ) o , ( MapDataSerializer ) serializer ) ; break ; case ROW : writer . writeRecord ( pos , ( RecordData ) o , ( TypeSerializer < RecordData > ) serializer ) ; break ; case BINARY : case VARBINARY : writer . writeBinary ( pos , ( byte [ ] ) o ) ; break ; case VARIANT : writer . writeVariant ( pos , ( Variant ) o ) ; break ; default : throw new UnsupportedOperationException ( "Not support type: " + type ) ; } }
private void letStatement ( ) { move ( true ) ; Token < ? > var = this . lookahead ; checkVariableName ( var ) ; getCodeGenerator ( ) . onConstant ( var ) ; move ( true ) ; if ( ! expectChar ( '=' ) ) { reportSyntaxError ( "expect '='" ) ; } move ( true ) ; StatementType stmtType = statement ( ) ; if ( stmtType == StatementType . Empty ) { reportSyntaxError ( "invalid value to define" ) ; } checkVarIsInit ( var , stmtType ) ; ensureFeatureEnabled ( Feature . Assignment ) ; getCodeGeneratorWithTimes ( ) . onAssignment ( currentToken ( ) . withMeta ( Constants . DEFINE_META , true ) ) ; if ( ! expectChar ( ';' ) ) { reportSyntaxError ( "missing ';' for let statement" ) ; } move ( true ) ; }
public boolean setAsmInstruction ( AssemblerAsmInstruction instr ) { valid = false ; if ( ! Opcodes . contains ( instr . getOpcode ( ) . toLowerCase ( ) ) ) return false ; if ( instr . getNrOfParameters ( ) != 3 ) { instr . setError ( instr . getInstruction ( ) , S . getter ( "AssemblerExpectedThreeArguments" ) ) ; return false ; } valid = true ; operation = Opcodes . indexOf ( instr . getOpcode ( ) . toLowerCase ( ) ) ; valid &= Nios2Support . isCorrectRegister ( instr , 0 ) ; sourceC = Nios2Support . getRegisterIndex ( instr , 0 ) ; valid &= Nios2Support . isCorrectRegister ( instr , 1 ) ; sourceA = Nios2Support . getRegisterIndex ( instr , 1 ) ; if ( operation >= INSTR_ROLI ) { sourceB = 0 ; AssemblerToken [ ] param3 = instr . getParameter ( 2 ) ; if ( param3 . length != 1 || ! param3 [ 0 ] . isNumber ( ) ) { valid = false ; instr . setError ( param3 [ 0 ] , S . getter ( "AssemblerExpectedImmediateValue" ) ) ; } immediate = param3 [ 0 ] . getNumberValue ( ) ; if ( immediate > 31 || immediate < 0 ) { valid = false ; instr . setError ( param3 [ 0 ] , S . getter ( "AssemblerImmediateOutOfRange" ) ) ; } } else { immediate = 0 ; valid &= Nios2Support . isCorrectRegister ( instr , 2 ) ; sourceB = Nios2Support . getRegisterIndex ( instr , 2 ) ; } if ( valid ) { instruction = Nios2Support . getRTypeInstructionCode ( sourceA , sourceB , sourceC , OpxCodes . get ( operation ) , immediate ) ; instr . setInstructionByteCode ( instruction , 4 ) ; } return true ; }
public static boolean getBoolean ( Map < String , String > requestParams , String name , boolean defaultValue ) { boolean value = defaultValue ; if ( requestParams . get ( name ) != null ) { value = Boolean . valueOf ( requestParams . get ( name ) ) ; } return value ; }
public String getDst ( ) { return dst ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof NameMatch ) ) { return false ; } return Objects . equals ( spec , ( ( NameMatch ) o ) . spec ) ; }
public int getStoryListChatCount ( @ NonNull TdApi . StoryList list ) { synchronized ( dataLock ) { return storyListChatCount . get ( list . getConstructor ( ) ) ; } }
public boolean matchesText ( ) { return then . matchesText ( ) ; }
public boolean onPrepareOptionsMenu ( @ NonNull Menu menu ) { return mDialog . onPrepareOptionsMenu ( menu ) ; }
protected com . google . protobuf . GeneratedMessageV3 . FieldAccessorTable internalGetFieldAccessorTable ( ) { return io . kubernetes . client . proto . V1Networking . internal_static_k8s_io_api_networking_v1_IPBlock_fieldAccessorTable . ensureFieldAccessorsInitialized ( io . kubernetes . client . proto . V1Networking . IPBlock . class , io . kubernetes . client . proto . V1Networking . IPBlock . Builder . class ) ; }
public void writeTo ( StreamOutput out ) throws IOException { out . writeCollection ( lifecycles ) ; }
public static boolean isZero ( byte [ ] data ) { for ( byte tmp : data ) { if ( tmp != 0 ) { return false ; } } return true ; }
public Map < String , Object > getMetadata ( ) { return Collections . unmodifiableMap ( metadata ) ; }
public void setVideoSize ( int videoWidth , int videoHeight ) { mVideoWidth = videoWidth ; mVideoHeight = videoHeight ; }
public com . google . protobuf . Parser < IngressRuleValue > getParserForType ( ) { return PARSER ; }
private void flushPartition ( Object partitionKey , ConcurrentLinkedDeque < IdleChannel > partition ) { if ( partition != null ) { partitions . remove ( partitionKey ) ; for ( IdleChannel idleChannel : partition ) { close ( idleChannel . channel ) ; } } }
public J . DoWhileLoop visitDoWhileLoop ( J . DoWhileLoop doWhileLoop , SpacesStatistics stats ) { stats . beforeWhile += hasSpace ( doWhileLoop . getWhileCondition ( ) . getPrefix ( ) ) ; return super . visitDoWhileLoop ( doWhileLoop , stats ) ; }
public static int ruleTextSize ( ) { return gPrefs . getInt ( "ruleTextSize" , 32 ) ; }
public Builder removeTo ( int index ) { if ( toBuilder_ == null ) { ensureToIsMutable ( ) ; to_ . remove ( index ) ; onChanged ( ) ; } else { toBuilder_ . remove ( index ) ; } return this ; }
public void handle ( HttpExchange httpExchange ) throws IOException { String response = WSDL . replaceAll ( "HTTP_LOCALHOST_PLACEHOLDER" , HTTP_LOCALHOST_9998 ) ; byte [ ] bodyBytes = response . getBytes ( "UTF-8" ) ; httpExchange . sendResponseHeaders ( 200 , bodyBytes . length ) ; httpExchange . getResponseBody ( ) . write ( bodyBytes ) ; httpExchange . close ( ) ; }
public Event build ( ) { return event ; }
public Schema < Instant > newInstantSchema ( ) { return InstantSchema . of ( ) ; }
public JadModel setMatchedClassLoaders ( Collection < ClassLoaderVO > matchedClassLoaders ) { this . matchedClassLoaders = matchedClassLoaders ; return this ; }
public boolean inputValueDataAccessInit ( ) { return ( this . inputValueDataAccessInitialized ) ; }
public boolean isLoaded ( ) { return module . releasesLoaded ; }
public DefaultMutableTreeNode getDataAsTree ( ) { HelpSet hs = getHelpSet ( ) ; Hashtable < ? , ? > params = getParameters ( ) ; URL url ; if ( params == null || ! params . containsKey ( "data" ) ) { return new DefaultMutableTreeNode ( ) ; } try { url = new URL ( hs . getHelpSetURL ( ) , ( String ) params . get ( "data" ) ) ; } catch ( Exception ex ) { throw new Error ( "Trouble getting URL to TOC data; " + ex ) ; } return parse ( url , hs , hs . getLocale ( ) , new TreeItemFactoryImpl ( ) , this ) ; }
public void focusLost ( final FocusEvent e ) { deactivateLabelContent ( ) ; }
public SpringdocRouteBuilder OPTIONS ( String pattern , HandlerFunction < ServerResponse > handlerFunction , Consumer < Builder > operationsConsumer ) { Builder builder = getOperationBuilder ( operationsConsumer ) ; this . delegate . OPTIONS ( pattern , handlerFunction ) . withAttribute ( OPERATION_ATTRIBUTE , builder ) ; return this ; }
public static boolean isMongoDB ( String db ) { return DATABASE_MONGODB . equals ( db ) ; }
protected void printUsageAndExit ( Options options , int exitCode ) throws Shell . ExitCodeException { HelpFormatter formatter = new HelpFormatter ( ) ; formatter . printHelp ( "Thrift" , null , options , "To start the Thrift server run 'hbase-daemon.sh start thrift2' or " + "'hbase thrift2'\n" + "To shutdown the thrift server run 'hbase-daemon.sh stop thrift2' or" + " send a kill signal to the thrift server pid" , true ) ; System . exit ( exitCode ) ; }
public void onRevoke ( ) { Log . i ( TAG , "Revoke" ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( this ) ; prefs . edit ( ) . putBoolean ( "enabled" , false ) . apply ( ) ; showDisabledNotification ( ) ; WidgetMain . updateWidgets ( this ) ; super . onRevoke ( ) ; }
public String chatTitleShort ( long chatId ) { return chatTitle ( chatId , true , true ) ; }
public int hashCode ( ) { int result ; result = modification != null ? modification . hashCode ( ) : 0 ; result = 31 * result + ( getComment ( ) != null ? getComment ( ) . hashCode ( ) : 0 ) ; result = 31 * result + ( getRevision ( ) != null ? getRevision ( ) . hashCode ( ) : 0 ) ; result = 31 * result + ( getUserName ( ) != null ? getUserName ( ) . hashCode ( ) : 0 ) ; return result ; }
private void processReadyChunks ( ) { while ( ! readyChunks . isEmpty ( ) ) { LodChunk chunk = readyChunks . remove ( ) ; Vector3i pos = chunk . getPosition ( new Vector3i ( ) ) ; Integer requiredScale = requiredChunks . get ( pos ) ; int scale = chunk . scale ; if ( requiredScale != null && requiredScale <= scale ) { chunk . getMesh ( ) . updateMesh ( ) ; chunk . getMesh ( ) . discardData ( ) ; Vector3i subPos = new Vector3i ( ) ; if ( scale > 0 ) { int subScale = 1 << ( scale - 1 ) ; for ( int dx = 0 ; dx <= subScale ; dx += subScale ) { for ( int dy = 0 ; dy <= subScale ; dy += subScale ) { for ( int dz = 0 ; dz <= subScale ; dz += subScale ) { pos . add ( dx , dy , dz , subPos ) ; if ( chunks . get ( scale - 1 ) . containsKey ( subPos ) || scale == 1 && chunkProvider . isChunkReady ( subPos ) ) { chunk . hiddenness ++ ; } } } } } else { chunk . realVersion = chunkProvider . getChunk ( pos ) ; } chunks . get ( scale ) . put ( new Vector3i ( pos ) , chunk ) ; if ( scale < chunkLods ) { int mask = ~ ( 1 << scale ) ; LodChunk largerChunk = chunks . get ( scale + 1 ) . get ( new Vector3i ( pos . x & mask , pos . y & mask , pos . z & mask ) ) ; if ( largerChunk != null ) { largerChunk . hiddenness ++ ; } } } } }
abstract ImmutableList < Equivalence . Wrapper < AnnotationMirror > > annotationWrappers ( ) ; ImmutableList < AnnotationMirror > annotations ( ) { return annotationWrappers ( ) . stream ( ) . map ( Equivalence . Wrapper :: get ) . collect ( toImmutableList ( ) ) ; }
private void scanJarFileAndAddToIndex ( File file , Indexer indexer ) { try ( JarFile jar = new JarFile ( file ) ) { Enumeration < ? extends JarEntry > entries = jar . entries ( ) ; int totalEntries = 0 ; long totalBytesRead = 0 ; while ( entries . hasMoreElements ( ) ) { totalEntries ++ ; JarEntry entry = entries . nextElement ( ) ; if ( ! entry . isDirectory ( ) && entry . getName ( ) . endsWith ( CLASS_FILE_SUFFIX ) ) { long bytesRead = addToIndex ( jar , entry , indexer ) ; totalBytesRead = totalBytesRead + bytesRead ; } if ( totalEntries > maxJarEntries ) { throw new JandexException ( "Limit for total JAR file entries exceeded: " + totalEntries ) ; } if ( totalBytesRead > maxBytesReadFromJar ) { throw new JandexException ( "Limit for total bytes read from JAR file exceeded: " + totalBytesRead + " bytes" ) ; } } } catch ( IOException e ) { throw new JandexException ( "Could not index JAR file " + file , e ) ; } }
public int decrementUpdateGuarded ( ) { if ( ! ( this . locksInit ( ) ) ) this . initLocks ( ) ; return decrementUpdate ( ) ; }
public int getDim ( ) { return dim ; }
public File getDataFile ( String filename ) { return null ; }
public List < String > getGeneratedFiles ( ) { return generatedFiles ; }
public String getVersion ( ) { return version ; }
protected Map < String , OperationSet > getLargestSupportedOperationSet ( List < Jid > fullJids ) { Map < String , OperationSet > supportedOperationSets = new HashMap < > ( ) ; if ( fullJids != null ) { for ( Jid fullJid : fullJids ) { Map < String , OperationSet > newSupportedOperationSets = getSupportedOperationSets ( fullJid , true ) ; if ( newSupportedOperationSets . size ( ) > supportedOperationSets . size ( ) ) { supportedOperationSets = newSupportedOperationSets ; } } } return supportedOperationSets ; }
public io . kubernetes . client . proto . V1Networking . IngressBackend . Builder getDefaultBackendBuilder ( ) { bitField0_ |= 0x00000002 ; onChanged ( ) ; return getDefaultBackendFieldBuilder ( ) . getBuilder ( ) ; }
void defer ( ImageView view , DeferredRequestCreator request ) { targetToDeferredRequestCreator . put ( view , request ) ; }
private User getUser ( JSONObject params ) throws ApiException { int contextId = getContextId ( params ) ; int userId = getUserId ( params ) ; User user = extension . getContextUserAuthManager ( contextId ) . getUserById ( userId ) ; if ( user == null ) throw new ApiException ( Type . USER_NOT_FOUND , PARAM_USER_ID ) ; return user ; }
public Map < String , Set < Integer > > iterateOffsetTable2FindDirty ( final Set < String > existTopicSet ) { Map < String , Set < Integer > > topicQueueIdToBeDeletedMap = new HashMap < > ( ) ; try ( RocksIterator iterator = rocksDBStorage . seekOffsetCF ( ) ) { if ( iterator == null ) { return topicQueueIdToBeDeletedMap ; } for ( iterator . seekToFirst ( ) ; iterator . isValid ( ) ; iterator . next ( ) ) { byte [ ] key = iterator . key ( ) ; byte [ ] value = iterator . value ( ) ; if ( key == null || key . length <= OFFSET_KEY_LENGTH_WITHOUT_TOPIC_BYTES || value == null || value . length != OFFSET_VALUE_LENGTH ) { continue ; } ByteBuffer keyBB = ByteBuffer . wrap ( key ) ; int topicLen = keyBB . getInt ( 0 ) ; byte [ ] topicBytes = new byte [ topicLen ] ; keyBB . position ( 4 + 1 ) ; keyBB . get ( topicBytes ) ; String topic = new String ( topicBytes , StandardCharsets . UTF_8 ) ; if ( TopicValidator . isSystemTopic ( topic ) ) { continue ; } if ( MixAll . isLmq ( topic ) ) { continue ; } int queueId = keyBB . getInt ( 4 + 1 + topicLen + 1 + 3 + 1 ) ; if ( ! existTopicSet . contains ( topic ) ) { ByteBuffer valueBB = ByteBuffer . wrap ( value ) ; long cqOffset = valueBB . getLong ( OFFSET_CQ_OFFSET ) ; Set < Integer > topicQueueIdSet = topicQueueIdToBeDeletedMap . get ( topic ) ; if ( topicQueueIdSet == null ) { Set < Integer > newSet = new HashSet < > ( ) ; newSet . add ( queueId ) ; topicQueueIdToBeDeletedMap . put ( topic , newSet ) ; } else { topicQueueIdSet . add ( queueId ) ; } ERROR_LOG . info ( "RocksDBConsumeQueueOffsetTable has dirty cqOffset. topic: {}, queueId: {}, cqOffset: {}" , topic , queueId , cqOffset ) ; } } } catch ( Exception e ) { ERROR_LOG . error ( "iterateOffsetTable2MarkDirtyCQ Failed." , e ) ; } return topicQueueIdToBeDeletedMap ; }
public boolean alwaysEndsInStartState ( ) { return from . size ( ) == 1 && from . contains ( to ) ; }
public io . kubernetes . client . proto . V1Networking . NetworkPolicyEgressRule . Builder getEgressBuilder ( int index ) { return getEgressFieldBuilder ( ) . getBuilder ( index ) ; }
private void loadAllPanels ( final JPanel mainPanel ) { SwingUtilities . invokeLater ( ( ) -> { int numPanels = wizardComponents . length ; for ( int i1 = 0 ; i1 < numPanels ; i1 ++ ) { mainPanel . remove ( wizardComponents [ i1 ] ) ; } for ( int i2 = 0 ; i2 < numPanels ; i2 ++ ) { mainPanel . add ( wizardComponents [ i2 ] ) ; } validate ( ) ; repaint ( ) ; } ) ; }
public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate , boolean focusedChildVisible ) { parent . getHitRect ( parentRect ) ; child . getHitRect ( childRect ) ; if ( Rect . intersects ( parentRect , childRect ) ) return false ; try { return super . requestChildRectangleOnScreen ( parent , child , rect , immediate , focusedChildVisible ) ; } catch ( Throwable ex ) { Log . e ( ex ) ; return false ; } }
private static ConditionProcessor create ( RawResourceFilter . Condition condition ) { return new SimpleConditionProcessor ( condition ) ; }
public final JRubyAbstractQueueWriteClientExt inputQueueClient ( ) { return inputQueueClient ; }
default CompletableFuture < Map < String , Set < String > > > getSubscriptionPermissionsAsync ( NamespaceName namespaceName ) { return FutureUtil . failedFuture ( new IllegalStateException ( String . format ( "getSubscriptionPermissionsAsync on namespace %s is not supported by the Authorization" , namespaceName ) ) ) ; }
public double average ( ) { return CompReduceExecutor . apply ( this , CompReduceExecutor . ReduceOP . Avg ) ; }
public Builder mergeFrom ( com . google . protobuf . Message other ) { if ( other instanceof io . kubernetes . client . proto . V1Networking . NetworkPolicyIngressRule ) { return mergeFrom ( ( io . kubernetes . client . proto . V1Networking . NetworkPolicyIngressRule ) other ) ; } else { super . mergeFrom ( other ) ; return this ; } }
protected void onStop ( ) { super . onStop ( ) ; Context context = getContext ( ) ; if ( context instanceof ContextWrapper && ! ( context instanceof LaunchActivity ) ) { context = ( ( ContextWrapper ) context ) . getBaseContext ( ) ; } if ( context instanceof LaunchActivity ) { ( ( LaunchActivity ) context ) . removeOverlayPasscodeView ( passcodeView ) ; } }
public WriteCellData < ? > convertToExcelData ( String value , ExcelContentProperty contentProperty , GlobalConfiguration globalConfiguration ) throws IOException { return new WriteCellData < > ( FileUtils . readFileToByteArray ( new File ( value ) ) ) ; }
public void onEmojiStatusGranted ( boolean granted ) { final TLRPC . User bot = MessagesController . getInstance ( currentAccount ) . getUser ( botId ) ; if ( granted ) { BulletinFactory . UndoObject undo = new BulletinFactory . UndoObject ( ) ; undo . onUndo = ( ) -> { TL_bots . toggleUserEmojiStatusPermission req = new TL_bots . toggleUserEmojiStatusPermission ( ) ; req . bot = MessagesController . getInstance ( currentAccount ) . getInputUser ( botId ) ; req . enabled = false ; ConnectionsManager . getInstance ( currentAccount ) . sendRequest ( req , ( res , err ) -> AndroidUtilities . runOnUIThread ( ( ) -> { if ( res instanceof TLRPC . TL_boolTrue ) { webViewContainer . notifyEmojiStatusAccess ( "cancelled" ) ; } else { showBulletin ( b -> b . makeForError ( err ) ) ; } } ) ) ; } ; showBulletin ( b -> b . createUsersBulletin ( Arrays . asList ( bot ) , AndroidUtilities . replaceTags ( LocaleController . formatString ( R . string . BotEmojiStatusPermissionRequestGranted , UserObject . getUserName ( bot ) ) ) , null , undo ) . setDuration ( DURATION_PROLONG ) ) ; } }
public String getProviderType ( ) { return nativeGetProviderType ( nativePtr ) ; }
public void readUnlockAndDecrementCount ( ) { switch ( localLockState ) { case UNLOCKED : return ; case READ_LOCKED : if ( ( decrementRead ( ) ) == 0 ) { if ( ( updateZero ( ) ) && ( writeZero ( ) ) ) segmentHeader ( ) . readUnlock ( segmentHeaderAddress ( ) ) ; } return ; case UPDATE_LOCKED : if ( ( decrementUpdate ( ) ) == 0 ) { if ( writeZero ( ) ) { if ( readZero ( ) ) { segmentHeader ( ) . updateUnlock ( segmentHeaderAddress ( ) ) ; } else { segmentHeader ( ) . downgradeUpdateToReadLock ( segmentHeaderAddress ( ) ) ; } } } return ; case WRITE_LOCKED : if ( ( decrementWrite ( ) ) == 0 ) { if ( ! ( updateZero ( ) ) ) { segmentHeader ( ) . downgradeWriteToUpdateLock ( segmentHeaderAddress ( ) ) ; } else { if ( ! ( readZero ( ) ) ) { segmentHeader ( ) . downgradeWriteToReadLock ( segmentHeaderAddress ( ) ) ; } else { segmentHeader ( ) . writeUnlock ( segmentHeaderAddress ( ) ) ; } } } } }
public static RequestBuilder delete ( String url ) { return request ( DELETE , url ) ; }
public static boolean isMultiUser ( ) { return gPrefs . getBoolean ( MULTI_USER , false ) ; }
public String messageAuthor ( TdApi . Message message ) { return messageAuthor ( message , true , false ) ; }
protected void quit ( ) { if ( realObject == Looper . getMainLooper ( ) ) { throw new RuntimeException ( "Main thread not allowed to quit" ) ; } quitUnchecked ( ) ; }
public < X0 > Ennead < X0 , A , B , C , D , E , F , G , H > addAt0 ( final Unit < X0 > tuple ) { return addAt0 ( tuple . getValue0 ( ) ) ; }
public void warning ( ANTLRMessage msg ) { ST msgST = tool . errMgr . getMessageTemplate ( msg ) ; String outputMsg = msgST . render ( ) ; if ( tool . errMgr . formatWantsSingleLineMessage ( ) ) { outputMsg = outputMsg . replace ( '\n' , ' ' ) ; } System . err . println ( outputMsg ) ; }
private static String convertToSimpleDateFormat ( String format ) { String [ ] replace = FORMAT_REPLACE ; for ( int i = 0 ; i < replace . length ; i += 2 ) { format = StringUtils . replaceAll ( format , replace [ i ] , replace [ i + 1 ] ) ; } return format ; }
public EntryPosition getPostion ( ) { return postion ; }
private static Object getPresentable ( @ NotNull Stub node ) { if ( node instanceof PsiFileStubImpl ) { return null ; } if ( node instanceof StubElement ) { return ( ( StubElement < ? > ) node ) . getElementType ( ) ; } return node . getStubSerializer ( ) ; }
public Charset getCharacterEncoding ( ) { return characterEncoding ; }
public TbQueueProducer < TbProtoQueueMsg < TransportApiResponseMsg > > createTransportApiResponseProducer ( ) { TbKafkaProducerTemplate . TbKafkaProducerTemplateBuilder < TbProtoQueueMsg < TransportApiResponseMsg > > requestBuilder = TbKafkaProducerTemplate . builder ( ) ; requestBuilder . settings ( kafkaSettings ) ; requestBuilder . clientId ( "tb-core-transport-api-producer-" + serviceInfoProvider . getServiceId ( ) ) ; requestBuilder . defaultTopic ( topicService . buildTopicName ( transportApiSettings . getResponsesTopic ( ) ) ) ; requestBuilder . admin ( transportApiResponseAdmin ) ; return requestBuilder . build ( ) ; }
public int putBytes ( byte [ ] buff , int offset , byte [ ] ip ) { System . arraycopy ( ip , 0 , buff , offset , ip . length ) ; return ip . length ; }
public String toString ( ) { return "Enum fields map: " + fieldsMap ; }
public void printRow ( List < List < String > > lists , int i , List < Integer > maxSizeList ) { printf ( "|" ) ; int count ; int maxSize ; String element ; StringBuilder paddingStr ; for ( int j = 0 ; j < maxSizeList . size ( ) ; j ++ ) { maxSize = maxSizeList . get ( j ) ; element = lists . get ( j ) . get ( i ) ; count = computeHANCount ( element ) ; if ( count > 0 ) { int remain = maxSize - ( element . length ( ) + count ) ; if ( remain > 0 ) { paddingStr = padding ( remain ) ; maxSize = maxSize - count ; element = paddingStr . append ( element ) . toString ( ) ; } else if ( remain == 0 ) { maxSize = maxSize - count ; } } printf ( "%" + maxSize + "s|" , element ) ; } println ( ) ; }
boolean isIgnored ( ) { return hasOption ( "ignore" ) ; }
public String getMetalake ( ) { return config . getOrDefault ( GRAVITINO_METALAKE . key , GRAVITINO_METALAKE . defaultValue ) ; }
public int getClientOfflineSessionIdleTimeout ( ) { if ( isUpdated ( ) ) return updated . getClientOfflineSessionIdleTimeout ( ) ; return cached . getClientOfflineSessionIdleTimeout ( ) ; }
static String getFriendlyUnqualifiedSignature ( MethodDoc method ) { String sig = method . name ( ) + "(" ; Parameter [ ] parameters = method . parameters ( ) ; for ( int i = 0 ; i < parameters . length ; i ++ ) { if ( i > 0 ) { sig += ", " ; } Type paramType = parameters [ i ] . type ( ) ; sig += paramType . typeName ( ) + paramType . dimension ( ) ; } sig += ")" ; return sig ; }
public Criteria andAddTimeNotEqualTo ( LocalDateTime value ) { addCriterion ( "add_time <>" , value , "addTime" ) ; return ( Criteria ) this ; }
IndexedSeq < ? extends IndexedSeq < T > > combinations ( ) ; @ Override IndexedSeq < ? extends IndexedSeq < T > > combinations ( int k ) ; @ Override Iterator < ? extends IndexedSeq < T > > crossProduct ( int power ) ; @ Override IndexedSeq < T > distinct ( ) ; @ Override IndexedSeq < T > distinctBy ( @ NonNull Comparator < ? super T > comparator ) ; @ Override < U > IndexedSeq < T > distinctBy ( @ NonNull Function < ? super T , ? extends U > keyExtractor ) ; @ Override IndexedSeq < T > distinctByKeepLast ( @ NonNull Comparator < ? super T > comparator ) ; @ Override < U > IndexedSeq < T > distinctByKeepLast ( @ NonNull Function < ? super T , ? extends U > keyExtractor ) ; @ Override IndexedSeq < T > drop ( int n ) ; @ Override IndexedSeq < T > dropUntil ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropWhile ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropRight ( int n ) ; @ Override IndexedSeq < T > dropRightUntil ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropRightWhile ( @ NonNull Predicate < ? super T > predicate ) ; @ Override default boolean endsWith ( @ NonNull Seq < ? extends T > that ) { Objects . requireNonNull ( that , "that is null" ) ; if ( that instanceof IndexedSeq ) { int i = length ( ) - 1 ; int j = that . length ( ) - 1 ; if ( j > i ) { return false ; } else { while ( j >= 0 ) { if ( ! Objects . equals ( this . get ( i ) , that . get ( j ) ) ) { return false ; } i -- ; j -- ; } return true ; } } else { return Seq . super . endsWith ( that ) ; } }
public void run ( ) { if ( isHaveMore ) { srlBaseHttpList . finishLoadmore ( ) ; } else { srlBaseHttpList . finishLoadmoreWithNoMoreData ( ) ; } srlBaseHttpList . setLoadmoreFinished ( ! isHaveMore ) ; }
public Iterator < StoreFileMetadata > iterator ( ) { return metadataSnapshot . iterator ( ) ; }
public boolean shouldReclusterOnMapMovement ( ) { return false ; }
int compareNotNulls ( Integer o1 , Integer o2 ) { return compare ( o1 . intValue ( ) , o2 . intValue ( ) ) ; }
private void setCycle2 ( final int cycle , final WireStoreSupplier . CreateStrategy createStrategy ) { queue . throwExceptionIfClosed ( ) ; if ( cycle < 0 ) throw new IllegalArgumentException ( "You can not have a cycle that starts " + "before Epoch. cycle=" + cycle ) ; SingleChronicleQueue queue = this . queue ; SingleChronicleQueueStore oldStore = this . store ; SingleChronicleQueueStore newStore = storePool . acquire ( cycle , createStrategy , oldStore ) ; if ( newStore != oldStore ) { this . store = newStore ; if ( oldStore != null ) storePool . closeStore ( oldStore ) ; } resetWires ( queue ) ; this . cycle = cycle ; if ( this . store == null ) return ; wire . parent ( this ) ; wire . pauser ( queue . pauserSupplier . get ( ) ) ; resetPosition ( ) ; queue . onRoll ( cycle ) ; }
protected void onWalletActive ( final Wallet wallet ) { load ( ) ; }
public boolean equals ( final java . lang . Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof io . kubernetes . client . proto . V1Networking . IngressPortStatus ) ) { return super . equals ( obj ) ; } io . kubernetes . client . proto . V1Networking . IngressPortStatus other = ( io . kubernetes . client . proto . V1Networking . IngressPortStatus ) obj ; boolean result = true ; result = result && ( hasPort ( ) == other . hasPort ( ) ) ; if ( hasPort ( ) ) { result = result && ( getPort ( ) == other . getPort ( ) ) ; } result = result && ( hasProtocol ( ) == other . hasProtocol ( ) ) ; if ( hasProtocol ( ) ) { result = result && getProtocol ( ) . equals ( other . getProtocol ( ) ) ; } result = result && ( hasError ( ) == other . hasError ( ) ) ; if ( hasError ( ) ) { result = result && getError ( ) . equals ( other . getError ( ) ) ; } result = result && unknownFields . equals ( other . unknownFields ) ; return result ; }
protected boolean validate ( T input ) { return true ; }
public void moveDir ( String bucketName , String sourceDir , String destDir ) throws IOException { List < String > objectKeys = listDirObjects ( bucketName , sourceDir ) ; for ( String key : objectKeys ) { moveObject ( bucketName , key , destDir + key . substring ( sourceDir . length ( ) ) ) ; } }
public void setNextNode ( LocksInterface nextNode ) { this . nextNode = nextNode ; }
public void background ( int rgb ) { colorCalc ( rgb ) ; backgroundFromCalc ( ) ; }
public int getPriority ( ) { return priority ; }
private void replaceActivityThread_Applicatio ( ) { try { XposedHelpers . setObjectField ( getActivityThread ( ) , "mInitialApplication" , sOriginalApplication ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public boolean dispatchTrackballEvent ( @ NonNull MotionEvent ev ) { return mDialog . dispatchTrackballEvent ( ev ) ; }
public T pollLast ( ) { throw new UnsupportedOperationException ( ) ; }
public MyBatisBatchItemWriterBuilder < T > statementId ( String statementId ) { this . statementId = statementId ; return this ; }
public void onSuccess ( Token token ) { if ( canceled ) { return ; } paymentJson = String . format ( Locale . US , "{\"type\":\"%1$s\", \"id\":\"%2$s\"}" , token . getType ( ) , token . getId ( ) ) ; AndroidUtilities . runOnUIThread ( ( ) -> { goToNextStep ( ) ; showEditDoneProgress ( true , false ) ; setDonePressed ( false ) ; } ) ; }
public String toString ( ) { return _inner . toString ( ) + "." + _fieldName ; }
public Builder setSchemaDescriptor ( @ Nullable Object schemaDescriptor ) { this . schemaDescriptor = schemaDescriptor ; return this ; }
public Field loadClassAndGetField ( ) throws IllegalArgumentException { try { return loadClass ( ) . getField ( getName ( ) ) ; } catch ( final NoSuchFieldException e1 ) { try { return loadClass ( ) . getDeclaredField ( getName ( ) ) ; } catch ( final NoSuchFieldException e2 ) { throw new IllegalArgumentException ( "No such field: " + getClassName ( ) + "." + getName ( ) ) ; } } }
public boolean isStandalone ( ) { return true ; }
public static String protectionLevel ( ) { if ( gPrefs . getString ( PROTECTION_OPTION , "p0" ) . equals ( "Disable" ) ) { gPrefs . edit ( ) . putString ( PROTECTION_OPTION , "p0" ) . commit ( ) ; } return gPrefs . getString ( PROTECTION_OPTION , "p0" ) ; }
public @ Nullable ScalingUtils . ScaleType getRetryImageScaleType ( ) { return mRetryImageScaleType ; }
public List < Double > percentMain ( ) { return config ( ) . getDoubleList ( "window-tiny-lfu.percent-main" ) ; }
public ReturningClause getReturningClause ( ) { return returningClause ; }
public float [ ] getMVPMatrix ( ) { return mMVPMatrix ; }
public static LogMessage getInstance ( ) { return new LogMessage ( ) ; }
public double getRenewalPercentThreshold ( ) { return renewalPercentThreshold ; }
static void linkPro ( final TextView tv ) { if ( ActivityBilling . isPro ( tv . getContext ( ) ) && ! BuildConfig . DEBUG ) hide ( tv ) ; else { tv . getPaint ( ) . setUnderlineText ( true ) ; tv . setOnClickListener ( new View . OnClickListener ( ) { @ Override public void onClick ( View v ) { v . getContext ( ) . startActivity ( new Intent ( v . getContext ( ) , ActivityBilling . class ) ) ; } } ) ; } }
public Criteria andSearchTypeEqualTo ( Integer value ) { addCriterion ( "search_type =" , value , "searchType" ) ; return ( Criteria ) this ; }
public void setName ( String name ) { protocolMapper . setName ( name ) ; }
public String getDataSourceListJson ( ) { return dataSourceListJson ; }
public void setDealResult ( String dealResult ) { this . dealResult = dealResult ; }
public void setOperateMan ( String operateMan ) { this . operateMan = operateMan ; }
public void compressZip ( String rootDir , String sourceDir , String outputZipFile , Checksum checksum ) throws Throwable { File rootFile = new File ( Paths . get ( rootDir , sourceDir ) . toString ( ) ) ; File zipFile = new File ( outputZipFile ) ; LOG . info ( "Start to compress snapshot in parallel mode" ) ; FileUtils . forceMkdir ( zipFile . getParentFile ( ) ) ; ExecutorService compressExecutor = newFixedPool ( compressThreads , compressThreads , "raft-snapshot-compress-executor" , new ThreadPoolExecutor . CallerRunsPolicy ( ) ) ; ZipArchiveScatterOutputStream scatterOutput = new ZipArchiveScatterOutputStream ( compressExecutor ) ; compressDirectoryToZipFile ( rootFile , scatterOutput , sourceDir , ZipEntry . DEFLATED ) ; try ( FileOutputStream fos = new FileOutputStream ( zipFile ) ; BufferedOutputStream bos = new BufferedOutputStream ( fos ) ; CheckedOutputStream cos = new CheckedOutputStream ( bos , checksum ) ; ZipArchiveOutputStream archiveOutputStream = new ZipArchiveOutputStream ( cos ) ) { scatterOutput . writeTo ( archiveOutputStream ) ; archiveOutputStream . flush ( ) ; fos . getFD ( ) . sync ( ) ; } ExecutorServiceHelper . shutdownAndAwaitTermination ( compressExecutor ) ; }
private void closeNestedLocks ( ) { unlinkFromSegmentContextsChain ( ) ; readUnlockAndDecrementCount ( ) ; }
public InternalRow [ ] call ( InternalRow args ) { ProcedureInput input = new ProcedureInput ( spark ( ) , tableCatalog ( ) , PARAMETERS , args ) ; Identifier tableIdent = input . ident ( TABLE_PARAM ) ; Long snapshotId = input . asLong ( SNAPSHOT_ID_PARAM , null ) ; String ref = input . asString ( REF_PARAM , null ) ; Preconditions . checkArgument ( ( snapshotId != null && ref == null ) || ( snapshotId == null && ref != null ) , "Either snapshot_id or ref must be provided, not both" ) ; return modifyIcebergTable ( tableIdent , table -> { Snapshot previousSnapshot = table . currentSnapshot ( ) ; Long previousSnapshotId = previousSnapshot != null ? previousSnapshot . snapshotId ( ) : null ; long targetSnapshotId = snapshotId != null ? snapshotId : toSnapshotId ( table , ref ) ; table . manageSnapshots ( ) . setCurrentSnapshot ( targetSnapshotId ) . commit ( ) ; InternalRow outputRow = newInternalRow ( previousSnapshotId , targetSnapshotId ) ; return new InternalRow [ ] { outputRow } ; } ) ; }
protected void onSizeChanged ( final int w , final int h , final int oldw , final int oldh ) { updatePath ( w , h ) ; super . onSizeChanged ( w , h , oldw , oldh ) ; }
public short getShort ( int columnIndex ) { checkPosition ( ) ; synchronized ( mUpdatedRows ) { if ( isFieldUpdated ( columnIndex ) ) { Number value = ( Number ) getUpdatedField ( columnIndex ) ; return value . shortValue ( ) ; } } return mWindow . getShort ( mPos , columnIndex ) ; }
public BaseStatefulWindowedBolt < T > withPersistence ( ) { persistent = true ; return this ; }
public Location getTargetOffset ( ) { return offset ; }
public @ Nullable Primitive asPrimitive ( ) { switch ( typeName ) { case BOOLEAN : return Primitive . BOOLEAN ; case TINYINT : return Primitive . BYTE ; case SMALLINT : return Primitive . SHORT ; case INTEGER : return Primitive . INT ; case BIGINT : return Primitive . LONG ; case REAL : return Primitive . FLOAT ; case DOUBLE : return Primitive . DOUBLE ; default : return null ; } }
public boolean singleLineBreaksMarksPara ( ) { return false ; }
public BufferedImage getBImage ( ) { return image . get ( ) ; }
public void setNvdApiKey ( String nvdApiKey ) { this . nvdApiKey = nvdApiKey ; }
public Properties getClientInfo ( ) throws SQLException { return null ; }
public boolean isAd ( ) { throw new UnsupportedOperationException ( "Stub" ) ; }
public ImmutableMap < Object , Collection < Object > > asMap ( ) { return super . asMap ( ) ; }
public Result filter ( final Logger logger , final Level level , final Marker marker , final String msg , final Object p0 , final Object p1 , final Object p2 , final Object p3 , final Object p4 , final Object p5 , final Object p6 ) { return Result . DENY ; }
public static List < Map > tagsToCucumberJson ( Collection < Tag > tags ) { List < Map > list = new ArrayList ( tags . size ( ) ) ; for ( Tag tag : tags ) { Map < String , Object > tagMap = new HashMap ( 2 ) ; tagMap . put ( "line" , tag . getLine ( ) ) ; tagMap . put ( "name" , '@' + tag . getText ( ) ) ; list . add ( tagMap ) ; } return list ; }
public long getCleanupIntervalSeconds ( ) { return cleanupIntervalSeconds ; }
public void onParseRandomPostFailed ( ) { fetchRandomPostListener . fetchRandomPostFailed ( ) ; }
public Criteria andSortGreaterThanOrEqualTo ( Integer value ) { addCriterion ( "sort >=" , value , "sort" ) ; return ( Criteria ) this ; }
public void onStepStateChange ( PipelineSnapshot snapshot ) { ApplicationBuildPipeline buildPipeline = ApplicationBuildPipeline . fromPipeSnapshot ( snapshot ) . setAppId ( app . getId ( ) ) ; saveEntity ( buildPipeline ) ; }
public Response deleteCatalog ( @ HeaderParam ( HDR_CREATED_BY ) final String createdBy , @ HeaderParam ( HDR_REASON ) final String reason , @ HeaderParam ( HDR_COMMENT ) final String comment , @ javax . ws . rs . core . Context final UriInfo uriInfo , @ javax . ws . rs . core . Context final HttpServletRequest request ) throws TenantApiException , CatalogApiException { final CallContext callContext = context . createCallContextNoAccountId ( createdBy , reason , comment , request ) ; catalogUserApi . deleteCatalog ( callContext ) ; return Response . status ( Status . NO_CONTENT ) . build ( ) ; }
private IllegalStateException zeroReadException ( Exception cause ) { return new IllegalStateException ( ( ( ( ( ( CompiledMapQueryContext . this . h ( ) . toIdentityString ( ) ) + ": Most probable cause of this exception - zero bytes of\n" ) + "the minimum positive encoding length, supported by the specified or default\n" ) + "valueSizeMarshaller() is not correct serialized form of any value. You should\n" ) + "configure defaultValueProvider() in ChronicleMapBuilder" ) , cause ) ; }
public void startup ( ZooKeeperServer zks , boolean startServer ) throws IOException , InterruptedException { start ( ) ; setZooKeeperServer ( zks ) ; if ( startServer ) { zks . startdata ( ) ; zks . startup ( ) ; } }
public Employee receiveMessage ( ) throws JMSException { Map map = ( Map ) this . jmsTemplate . receiveAndConvert ( ) ; return new Employee ( ( String ) map . get ( "name" ) , ( Integer ) map . get ( "age" ) ) ; }
public void printInformation ( String message ) { if ( context . quiet ( ) ) { return ; } printResults ( message ) ; }
protected int getLayoutId ( ) { return R . layout . position_animation_settings_card ; }
public boolean test ( Person person , long time ) { HealthRecord . Observation observation = null ; if ( this . codes != null ) { for ( Code code : this . codes ) { HealthRecord . Observation last = person . record . getLatestObservation ( code . code ) ; if ( person . lossOfCareEnabled ) { if ( last == null ) { last = person . lossOfCareRecord . getLatestObservation ( code . code ) ; } if ( last == null ) { last = person . defaultRecord . getLatestObservation ( code . code ) ; } } if ( last == null && person . hasMultipleRecords ) { last = ( HealthRecord . Observation ) findEntryFromHistory ( person , HealthRecord . Observation . class , code ) ; if ( Config . getAsBoolean ( "exporter.split_records.duplicate_data" , false ) ) { person . record . currentEncounter ( time ) . observations . add ( last ) ; } } if ( last != null ) { observation = last ; break ; } } } else if ( this . referencedByAttribute != null ) { if ( person . attributes . containsKey ( this . referencedByAttribute ) ) { observation = ( HealthRecord . Observation ) person . attributes . get ( this . referencedByAttribute ) ; } else { return false ; } } if ( valueCode != null ) { value = valueCode ; } if ( operator . equals ( "is nil" ) ) { return observation == null ; } else if ( operator . equals ( "is not nil" ) ) { return observation != null ; } else if ( observation == null ) { if ( this . codes != null ) { if ( Config . getAsBoolean ( "exporter.split_records" , false ) ) { return false ; } throw new NullPointerException ( "Required observation " + this . codes + " is null." ) ; } else if ( this . referencedByAttribute != null ) { throw new NullPointerException ( "Required observation \"" + this . referencedByAttribute + "\" is null." ) ; } else { throw new NullPointerException ( "Required observation is null." ) ; } } else { return Utilities . compare ( observation . value , this . value , operator ) ; } }
private static void generateAccessOrderListenerMethodForNextGroupElement ( final StringBuilder sb , final FieldPrecedenceModel fieldPrecedenceModel , final String indent , final Token token ) { if ( null == fieldPrecedenceModel ) { return ; } sb . append ( "\n" ) ; sb . append ( indent ) . append ( INDENT ) . append ( "void onNextElementAccessed()\n" ) . append ( indent ) . append ( INDENT ) . append ( "{\n" ) . append ( indent ) . append ( TWO_INDENT ) . append ( "std::uint64_t remaining = m_count - m_index;\n" ) . append ( indent ) . append ( TWO_INDENT ) . append ( "if (remaining > 1)\n" ) . append ( indent ) . append ( TWO_INDENT ) . append ( "{\n" ) ; final FieldPrecedenceModel . CodecInteraction selectNextElementInGroup = fieldPrecedenceModel . interactionFactory ( ) . moveToNextElement ( token ) ; generateAccessOrderListener ( sb , indent + THREE_INDENT , "access next element in repeating group" , fieldPrecedenceModel , selectNextElementInGroup ) ; sb . append ( indent ) . append ( TWO_INDENT ) . append ( "}\n" ) . append ( indent ) . append ( TWO_INDENT ) . append ( "else if (1 == remaining)\n" ) . append ( indent ) . append ( TWO_INDENT ) . append ( "{\n" ) ; final FieldPrecedenceModel . CodecInteraction selectLastElementInGroup = fieldPrecedenceModel . interactionFactory ( ) . moveToLastElement ( token ) ; generateAccessOrderListener ( sb , indent + THREE_INDENT , "access next element in repeating group" , fieldPrecedenceModel , selectLastElementInGroup ) ; sb . append ( indent ) . append ( TWO_INDENT ) . append ( "}\n" ) . append ( indent ) . append ( INDENT ) . append ( "}\n" ) ; }
private boolean shouldRenderHalfRope ( ) { float f = offset % 1 ; return offset > .75f && ( f < .25f || f > .75f ) ; }
public A withDevice ( String device ) { this . device = device ; return ( A ) this ; }
public Criteria andNumberGreaterThanOrEqualToColumn ( LitemallGoodsProduct . Column column ) { addCriterion ( new StringBuilder ( "`number` >= " ) . append ( column . getEscapedColumnName ( ) ) . toString ( ) ) ; return ( Criteria ) this ; }
public byte getValue ( Chunk chunk , int x , int y , int z ) { return chunk . getSunlight ( x , y , z ) ; }
public IWaypointCollection getWaypoints ( ) { return this . waypoints ; }
public void setModeBothMonthWeekView ( ) { mCalendarShowMode = CALENDAR_SHOW_MODE_BOTH_MONTH_WEEK_VIEW ; requestLayout ( ) ; }
private void updateVisibilities ( ScrollPane scroll , VBox vbox ) { if ( ! Platform . isFxApplicationThread ( ) ) { throw new IllegalStateException ( "Not in FxApplication thread" ) ; } if ( ! scroll . isVisible ( ) || ! vbox . isVisible ( ) ) { return ; } if ( ! visibilityControl ) { return ; } int count = 0 ; for ( Node child : vbox . getChildren ( ) ) { var v = isVisible ( scroll , vbox , child ) ; child . setVisible ( v ) ; if ( v ) { count ++ ; } } }
public Mono < Void > clusterDeleteSlotsInRange ( RedisClusterNode redisClusterNode , RedisClusterNode . SlotRange slotRange ) { return clusterDeleteSlots ( redisClusterNode , slotRange . getSlotsArray ( ) ) ; }
NMCallbackHandler createNMCallbackHandler ( ) { return new NMCallbackHandler ( this ) ; }
public FieldAssembler < R > noDefault ( ) { return field . completeField ( schema ) ; }
public void propertyChange ( PropertyChangeEvent evt ) { if ( Boolean . FALSE . equals ( evt . getNewValue ( ) ) ) { scalarSQIconToggleButton . setSelected ( false ) ; } }
public static Namespace find ( Symbol name ) { return namespaces . get ( name ) ; }
public boolean matchDevice ( final String devicePath ) { try { return patternPartialPath . overlapWith ( new MeasurementPath ( devicePath , "*" ) ) ; } catch ( final IllegalPathException e ) { return false ; } }
static boolean isSurfaceDuo2 ( ) { return ( "Microsoft" . equalsIgnoreCase ( Build . MANUFACTURER ) && "Surface Duo 2" . equals ( Build . MODEL ) ) ; }
public Builder setProtocol ( java . lang . String value ) { if ( value == null ) { throw new NullPointerException ( ) ; } bitField0_ |= 0x00000002 ; protocol_ = value ; onChanged ( ) ; return this ; }
public BannerViewPager < T > setOnPageClickListener ( OnPageClickListener onPageClickListener , boolean scrollToThisItem ) { if ( mBannerPagerAdapter != null ) { mBannerPagerAdapter . setPageClickListener ( ( clickedView , realPosition , adapterPosition ) -> { onPageClickListener . onPageClick ( clickedView , realPosition ) ; if ( scrollToThisItem ) { mViewPager . setCurrentItem ( adapterPosition ) ; } } ) ; } return this ; }
public void detachTransference ( Transference transference ) { if ( _transferences . containsKey ( transference ) ) { _transferences . remove ( transference ) ; } }
public synchronized void lock ( ) { CompiledMapQueryContext . this . checkOnEachLockOperation ( ) ; switch ( CompiledMapQueryContext . this . localLockState ( ) ) { case UNLOCKED : CompiledMapQueryContext . this . checkIterationContextNotLockedInThisThread ( ) ; if ( CompiledMapQueryContext . this . writeZeroGuarded ( ) ) { if ( ! ( CompiledMapQueryContext . this . updateZeroGuarded ( ) ) ) { CompiledMapQueryContext . this . segmentHeader ( ) . upgradeUpdateToWriteLock ( CompiledMapQueryContext . this . segmentHeaderAddress ( ) ) ; } else { if ( ! ( CompiledMapQueryContext . this . readZeroGuarded ( ) ) ) throw forbiddenWriteLockWhenOuterContextReadLocked ( ) ; try { CompiledMapQueryContext . this . segmentHeader ( ) . writeLock ( CompiledMapQueryContext . this . segmentHeaderAddress ( ) ) ; } catch ( InterProcessDeadLockException e ) { throw CompiledMapQueryContext . this . debugContextsAndLocksGuarded ( e ) ; } } } CompiledMapQueryContext . this . incrementWriteGuarded ( ) ; CompiledMapQueryContext . this . setLocalLockStateGuarded ( LocalLockState . WRITE_LOCKED ) ; return ; case READ_LOCKED : throw forbiddenUpgrade ( ) ; case UPDATE_LOCKED : if ( CompiledMapQueryContext . this . writeZeroGuarded ( ) ) { assert ! ( CompiledMapQueryContext . this . updateZeroGuarded ( ) ) ; try { CompiledMapQueryContext . this . segmentHeader ( ) . upgradeUpdateToWriteLock ( CompiledMapQueryContext . this . segmentHeaderAddress ( ) ) ; } catch ( InterProcessDeadLockException e ) { throw CompiledMapQueryContext . this . debugContextsAndLocksGuarded ( e ) ; } } CompiledMapQueryContext . this . decrementUpdateGuarded ( ) ; CompiledMapQueryContext . this . incrementWriteGuarded ( ) ; CompiledMapQueryContext . this . setLocalLockStateGuarded ( LocalLockState . WRITE_LOCKED ) ; break ; case WRITE_LOCKED : break ; } }
public void setJvmOptions ( JvmOptions jvmOptions ) { this . jvmOptions = jvmOptions ; }
public boolean newFolder ( String path , String name ) { String fullPath = StringUtils . concat ( true , param . getBasePath ( ) , getCurrentUserBasePath ( ) , path , name ) ; try { return upYun . mkDir ( fullPath , true ) ; } catch ( IOException | UpException e ) { throw ExceptionUtil . wrapRuntime ( e ) ; } }
public boolean onTouchEvent ( @ NonNull MotionEvent event ) { return mDialog . onTouchEvent ( event ) ; }
public static boolean useConstituencyParse ( Properties props ) { return PropertiesUtils . getBool ( props , "coref.useConstituencyParse" , ( algorithm ( props ) != CorefAlgorithmType . STATISTICAL && algorithm ( props ) != CorefAlgorithmType . FASTNEURAL ) || conll ( props ) ) ; }
public int getAnimationsId ( ) { return mAnimationsId ; }
private void maybeForceBuilderInitialization ( ) { if ( com . google . protobuf . GeneratedMessageV3 . alwaysUseFieldBuilders ) { getParametersFieldBuilder ( ) ; } }
public InputStream getBinaryStream ( String col ) throws SQLException { return getBinaryStream ( findColumn ( col ) ) ; }
public boolean displayable ( ) { return true ; }
public void launch ( Opener opener , int selectedItem ) { var openerString = prepareOpenerStringForItem ( opener . execString , selectedItem ) ; if ( openerString . startsWith ( "http:" ) || openerString . startsWith ( "https:" ) || openerString . startsWith ( "ftp:" ) || openerString . startsWith ( "mailto:" ) || openerString . startsWith ( "\\\\" ) ) { BrowserLauncher . openURL ( openerString ) ; } else { try { if ( opener . inTerminal ) { TerminalLauncher . launchInTerminal ( openerString , opener . workingDir ) ; } else { if ( Platform . LINUX ) { Runtime . getRuntime ( ) . exec ( new String [ ] { "sh" , "-c" , openerString } , null , opener . workingDir ) ; } else { Runtime . getRuntime ( ) . exec ( splitCommand ( openerString ) , null , opener . workingDir ) ; } } } catch ( UserErrorException e ) { throw e ; } catch ( Exception e ) { throw new UserErrorException ( "opener.failed" , openerString ) ; } } }
public void pushStyle ( ) { if ( styleStackDepth == styleStack . length ) { styleStack = ( PStyle [ ] ) PApplet . expand ( styleStack ) ; } if ( styleStack [ styleStackDepth ] == null ) { styleStack [ styleStackDepth ] = new PStyle ( ) ; } PStyle s = styleStack [ styleStackDepth ++ ] ; getStyle ( s ) ; }
public Criteria andIdEqualToColumn ( LitemallFootprint . Column column ) { addCriterion ( new StringBuilder ( "id = " ) . append ( column . getEscapedColumnName ( ) ) . toString ( ) ) ; return ( Criteria ) this ; }
public Boolean getIsMigrated ( ) { return isMigrated ; }
public void writeTo ( com . google . protobuf . CodedOutputStream output ) throws java . io . IOException { if ( ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { com . google . protobuf . GeneratedMessageV3 . writeString ( output , 1 , name_ ) ; } if ( ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) ) { output . writeMessage ( 2 , getPort ( ) ) ; } unknownFields . writeTo ( output ) ; }
public < T extends ServerResponse > RouterFunctions . Builder OPTIONS ( RequestPredicate predicate , HandlerFunction < T > handlerFunction ) { builder . OPTIONS ( predicate , handlerFunction ) ; return this ; }
private static MessageModel getMessageModel ( String messageModel ) { for ( MessageModel model : MessageModel . values ( ) ) { if ( model . getModeCN ( ) . equalsIgnoreCase ( messageModel ) ) { return model ; } } return MessageModel . CLUSTERING ; }
public boolean isType ( ) { return false ; }
public void setup ( ) { for ( int i = 0 ; i < NODES ; i ++ ) { nodes [ i ] = createNode ( DSLInterpreterBenchmarkFactory . CachedDSLNodeGen :: create ) ; } }
public void setPage ( int page ) { super . addParam ( "page" , String . valueOf ( page ) ) ; }
public boolean equals ( final Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } final RenameColumn that = ( RenameColumn ) o ; return tableIfExists == that . tableIfExists && columnIfNotExists == that . columnIfNotExists && Objects . equals ( table , that . table ) && Objects . equals ( source , that . source ) && Objects . equals ( target , that . target ) && view == that . view ; }
public long insert ( String table , int conflictAlgorithm , ContentValues values ) throws android . database . SQLException { return insertWithOnConflict ( table , null , values , conflictAlgorithm ) ; }
private void validateInvalidCombinations ( RoundEnvironment roundEnv ) { for ( int i = 0 ; i < ALL . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < ALL . size ( ) ; j ++ ) { validateInvalidCombination ( roundEnv , ALL . get ( i ) , ALL . get ( j ) ) ; } } }
public void exp ( DataWord word ) { BigInteger result = value ( ) . modPow ( word . value ( ) , _2_256 ) ; this . data = ByteUtil . copyToArray ( result ) ; }
public void onReceive ( Context context , Intent intent ) { Log . i ( TAG , "Received " + intent ) ; Util . logExtras ( intent ) ; PowerManager pm = ( PowerManager ) context . getSystemService ( Context . POWER_SERVICE ) ; Log . i ( TAG , "device idle=" + pm . isDeviceIdleMode ( ) ) ; if ( ! pm . isDeviceIdleMode ( ) ) reload ( "idle state changed" , ServiceSinkhole . this , false ) ; }
public int length ( ) { return CHANNEL_OFFSET + lengthOfChannel ; }
public void sunsubscribed ( K shardChannel , long count ) { }
public static void build ( int n , int m ) { edgeCnt = 1 ; dfnCnt = 0 ; Arrays . fill ( head , 0 , n + 1 , 0 ) ; Arrays . fill ( dp [ n + 2 ] , 0 , m + 1 , 0 ) ; }
public String getModelEndpointName ( String modelName ) { return modelName ; }
public static Searcher newWithBuffer ( Version version , LongByteArray cBuff ) throws IOException { return new Searcher ( version , null , null , cBuff ) ; }
protected DefaultSubscriptionBase createSubscriptionForApiUse ( final SubscriptionBuilder builder , final List < SubscriptionBaseEvent > events , final SubscriptionCatalog catalog ) throws CatalogApiException { final DefaultSubscriptionBase subscription = new DefaultSubscriptionBase ( builder , apiService , clock ) ; if ( ! events . isEmpty ( ) ) { subscription . rebuildTransitions ( events , catalog ) ; } return subscription ; }
private void smoothWarning ( String method ) { PGraphics . showWarning ( "%s() can only be used before beginDraw()" , method ) ; }
public void onClick ( View v ) { FragmentDialogQuickActions buttons = new FragmentDialogQuickActions ( ) ; buttons . setTargetFragment ( FragmentMessages . this , REQUEST_QUICK_ACTIONS ) ; buttons . show ( getParentFragmentManager ( ) , "dialog:quickactions" ) ; }
public List < RoleMenu > findByRoleId ( String roleId ) { LambdaQueryWrapper < RoleMenu > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( RoleMenu :: getRoleId , roleId ) ; return this . baseMapper . selectList ( queryWrapper ) ; }
public void onWindowTimer ( OutputReceiver < KV < K , Iterable < InputT > > > receiver , @ Timestamp Instant timestamp , @ Key K key , @ StateId ( BATCH_ID ) BagState < InputT > batch , @ StateId ( NUM_ELEMENTS_IN_BATCH_ID ) CombiningState < Long , long [ ] , Long > storedBatchSize , @ StateId ( NUM_BYTES_IN_BATCH_ID ) CombiningState < Long , long [ ] , Long > storedBatchSizeBytes , @ StateId ( TIMER_TIMESTAMP ) ValueState < Long > timerTs , @ StateId ( MIN_BUFFERED_TS ) CombiningState < Long , long [ ] , Long > minBufferedTs , BoundedWindow window ) { LOG . debug ( "*** END OF WINDOW *** for timer timestamp {} in windows {}" , timestamp , window . toString ( ) ) ; flushBatch ( receiver , key , batch , storedBatchSize , storedBatchSizeBytes , timerTs , minBufferedTs ) ; }
public float writeSelectedRows ( int rowStart , int rowEnd , float xPos , float yPos , PdfContentByte canvas ) { return writeSelectedRows ( 0 , - 1 , rowStart , rowEnd , xPos , yPos , canvas ) ; }
public static void makeAccessible ( final Field field ) { Objects . requireNonNull ( field , "No field provided" ) ; if ( ( ! isAccessible ( field ) || Modifier . isFinal ( field . getModifiers ( ) ) ) && ! field . isAccessible ( ) ) { field . setAccessible ( true ) ; } }
public @ Nullable TdApi . ChatNotificationSettings chatSettings ( long chatId ) { TdApi . Chat chat = chat ( chatId ) ; return chat != null ? chat . notificationSettings : null ; }
public void setPagination ( final PaginationDto pagination ) { this . pagination = pagination ; }
public Future < Void > chown ( String path , @ Nullable String user , @ Nullable String group ) { return chownInternal ( path , user , group ) . run ( ) ; }
public static boolean objectNotEquals ( Object a , Object b ) { return ! Objects . equals ( a , b ) ; }
void markBufferOffset ( ) { this . buffOffset += this . cursor + 1 ; }
public static AnimatorBuilder asAnimator ( ) { return new AnimatorBuilder ( ) ; }
public String getPartitionPath ( Option < GenericRecord > record , Option < Row > row , Option < Pair < InternalRow , StructType > > internalRowStructTypePair ) { if ( getPartitionPathFields ( ) == null ) { throw new HoodieKeyException ( "Unable to find field names for partition path in cfg" ) ; } if ( partitionKeyGenerators . isEmpty ( ) ) { return "" ; } StringBuilder partitionPath = new StringBuilder ( ) ; for ( int i = 0 ; i < partitionKeyGenerators . size ( ) ; i ++ ) { BuiltinKeyGenerator keyGenerator = partitionKeyGenerators . get ( i ) ; if ( record . isPresent ( ) ) { partitionPath . append ( keyGenerator . getPartitionPath ( record . get ( ) ) ) ; } else if ( row . isPresent ( ) ) { partitionPath . append ( keyGenerator . getPartitionPath ( row . get ( ) ) ) ; } else { partitionPath . append ( keyGenerator . getPartitionPath ( internalRowStructTypePair . get ( ) . getKey ( ) , internalRowStructTypePair . get ( ) . getValue ( ) ) ) ; } if ( i != partitionKeyGenerators . size ( ) - 1 ) { partitionPath . append ( customAvroKeyGenerator . getDefaultPartitionPathSeparator ( ) ) ; } } return partitionPath . toString ( ) ; }
public final void setStrictness ( Strictness strictness ) { this . strictness = Objects . requireNonNull ( strictness ) ; }
public String getText ( Token start , Token stop ) { return getText ( Interval . of ( start . getTokenIndex ( ) , stop . getTokenIndex ( ) ) ) ; }
private void adjustTop ( RectF rect , float top , RectF bounds , float snapMargin , float aspectRatio , boolean leftMoves , boolean rightMoves ) { float newTop = top ; if ( newTop < 0 ) { newTop /= 1.05f ; mTouchOffset . y -= newTop / 1.1f ; } if ( newTop < bounds . top ) { mTouchOffset . y -= ( newTop - bounds . top ) / 2f ; } if ( newTop - bounds . top < snapMargin ) { newTop = bounds . top ; } if ( rect . bottom - newTop < mMinCropHeight ) { newTop = rect . bottom - mMinCropHeight ; } if ( rect . bottom - newTop > mMaxCropHeight ) { newTop = rect . bottom - mMaxCropHeight ; } if ( newTop - bounds . top < snapMargin ) { newTop = bounds . top ; } if ( aspectRatio > 0 ) { float newWidth = ( rect . bottom - newTop ) * aspectRatio ; if ( newWidth < mMinCropWidth ) { newTop = Math . max ( bounds . top , rect . bottom - ( mMinCropWidth / aspectRatio ) ) ; newWidth = ( rect . bottom - newTop ) * aspectRatio ; } if ( newWidth > mMaxCropWidth ) { newTop = Math . max ( bounds . top , rect . bottom - ( mMaxCropWidth / aspectRatio ) ) ; newWidth = ( rect . bottom - newTop ) * aspectRatio ; } if ( leftMoves && rightMoves ) { newTop = Math . max ( newTop , Math . max ( bounds . top , rect . bottom - bounds . width ( ) / aspectRatio ) ) ; } else { if ( leftMoves && rect . right - newWidth < bounds . left ) { newTop = Math . max ( bounds . top , rect . bottom - ( rect . right - bounds . left ) / aspectRatio ) ; newWidth = ( rect . bottom - newTop ) * aspectRatio ; } if ( rightMoves && rect . left + newWidth > bounds . right ) { newTop = Math . max ( newTop , Math . max ( bounds . top , rect . bottom - ( bounds . right - rect . left ) / aspectRatio ) ) ; } } } rect . top = newTop ; }
static long getInstallTime ( Context context ) { try { PackageManager pm = context . getPackageManager ( ) ; PackageInfo pi = pm . getPackageInfo ( BuildConfig . APPLICATION_ID , 0 ) ; if ( pi != null ) return pi . firstInstallTime ; } catch ( Throwable ex ) { Log . e ( ex ) ; } return 0 ; }
public int requestFusion ( int requestedMode ) { int m ; if ( ( requestedMode & Fuseable . THREAD_BARRIER ) != 0 ) { return Fuseable . NONE ; } else { m = s . requestFusion ( requestedMode ) ; } sourceMode = m ; return m ; }
public BbBranch getBranch ( @ NonNull String orgId , @ NonNull String repoSlug , @ NonNull String branch ) { try { HttpResponse response = request . get ( String . format ( "%s/%s/refs/branches/%s?fields=target.hash,target.repository.mainbranch.name,target.repository.*,target.repository.owner.*,target.repository.owner.links.avatar.href,name" , baseUrl + "repositories/" + encodePath ( orgId ) , encodePath ( repoSlug ) , encodePath ( branch ) ) ) ; if ( response . getStatus ( ) == 404 ) { return null ; } return om . readValue ( response . getContent ( ) , BbCloudBranch . class ) ; } catch ( Exception e ) { throw handleException ( e ) ; } }
private int replace ( HashedItem fpaux , byte victim , int bucketStart , int removedOffset ) { byte chainId = fpaux . chainId ; fpaux . chainId = victim ; cache [ bucketStart + removedOffset ] = 0 ; indexing . removeItem ( fpaux , chainIndex , lastIndex ) ; fpaux . chainId = chainId ; int idxToAdd = indexing . addItem ( fpaux , chainIndex , lastIndex ) ; int delta = ( removedOffset < idxToAdd ) ? - 1 : 1 ; replaceItems ( idxToAdd , fpaux . fingerprint , bucketStart , delta ) ; return removedOffset ; }
public void addRule ( RuleDefinition rule , String type ) { ruleRepository . addRule ( type , rule ) ; this . rulesFormatAndSave ( ) ; }
public Bundle getOptionBundle ( ) { return mOptionBundle ; }
public boolean readZeroGuarded ( ) { if ( ! ( this . locksInit ( ) ) ) this . initLocks ( ) ; return readZero ( ) ; }
public static void setStyle ( IToastStyle < ? > style ) { if ( style == null ) { return ; } sToastStyle = style ; }
public void render ( Renderable renderable , Attributes combinedAttributes ) { if ( ! combinedAttributes . has ( BlendingAttribute . Type ) ) context . setBlending ( false , GL20 . GL_SRC_ALPHA , GL20 . GL_ONE_MINUS_SRC_ALPHA ) ; bindMaterial ( combinedAttributes ) ; if ( lighting ) bindLights ( renderable , combinedAttributes ) ; super . render ( renderable , combinedAttributes ) ; }
public void dismiss ( ) { mDialog . dismiss ( ) ; }
public boolean isFinalReward ( ) { return this . isFinalReward ; }
protected void onExecuted ( Bundle args , Void data ) { if ( viewType == AdapterMessage . ViewType . THREAD ) { PagedList < TupleMessageEx > messages = adapter . getCurrentList ( ) ; if ( messages != null && result . size ( ) > 0 ) { Log . i ( "Eval confirmed messages=" + messages . size ( ) + " targets=" + result . size ( ) ) ; handleThreadActions ( messages , result , null ) ; } } }
private static FlowMetric createFlowMetric ( final RubySymbol name , final Metric < ? extends Number > numeratorMetric , final Metric < ? extends Number > denominatorMetric ) { return FlowMetric . create ( name . asJavaString ( ) , numeratorMetric , denominatorMetric ) ; }
public static ZksnarkClient getInstance ( ) { return instance ; }
public static String getBCVDirectory ( ) { while ( ! BCV_DIR . exists ( ) ) BCV_DIR . mkdirs ( ) ; if ( isWindows ( ) && ! BCV_DIR . isHidden ( ) ) { new Thread ( ( ) -> { try { Process p = new ProcessBuilder ( "attrib" , "+H" , BCV_DIR . getAbsolutePath ( ) ) . start ( ) ; } catch ( Exception e ) { } } , "Hide BCV Dir" ) . start ( ) ; } return BCV_DIR . getAbsolutePath ( ) ; }
public Void perform ( ) { try { Path source = resolveFile ( path ) . toPath ( ) ; delete ( source , recursive ) ; } catch ( IOException e ) { throw new FileSystemException ( getFileAccessErrorMessage ( "delete" , path ) , e ) ; } return null ; }
public ImpactsEnum impacts ( int flags ) throws IOException { throw new UnsupportedOperationException ( ) ; }
JDBCType getJdbcType ( ) ; ValueCodec < ? , ? > getCodec ( ) ; default int getLength ( ) { return 255 ; }
public static final boolean isSolaris ( ) { return osType == SOLARIS ; }
public @ NonNull List < TdApi . User > chatUsers ( long [ ] chatIds ) { final ArrayList < TdApi . User > result = new ArrayList < > ( chatIds . length ) ; synchronized ( dataLock ) { for ( long chatId : chatIds ) { TdApi . User user = chatUser ( chatId ) ; if ( user != null ) result . add ( user ) ; } } return result ; }
private ApplicationLog getApplicationLog ( FlinkApplication app ) { ApplicationLog applicationLog = new ApplicationLog ( ) ; applicationLog . setOptionName ( RELEASE . getValue ( ) ) ; applicationLog . setAppId ( app . getId ( ) ) ; applicationLog . setCreateTime ( new Date ( ) ) ; applicationLog . setUserId ( ServiceHelper . getUserId ( ) ) ; return applicationLog ; }
public void foundRedundantNullCheck ( Location location , RedundantBranch redundantBranch ) { boolean isChecked = redundantBranch . firstValue . isChecked ( ) ; boolean wouldHaveBeenAKaboom = redundantBranch . firstValue . wouldHaveBeenAKaboom ( ) ; boolean isParameter = redundantBranch . firstValue . isParamValue ( ) ; Location locationOfKaBoom = redundantBranch . firstValue . getLocationOfKaBoom ( ) ; if ( isParameter && ! wouldHaveBeenAKaboom ) { return ; } boolean createdDeadCode = false ; boolean infeasibleEdgeSimplyThrowsException = false ; Edge infeasibleEdge = redundantBranch . infeasibleEdge ; if ( infeasibleEdge != null ) { if ( DEBUG ) { System . out . println ( "Check if " + redundantBranch + " creates dead code" ) ; } BasicBlock target = infeasibleEdge . getTarget ( ) ; if ( DEBUG ) { System . out . println ( "Target block is  " + ( target . isExceptionThrower ( ) ? " exception thrower" : " not exception thrower" ) ) ; } boolean empty = ! target . isExceptionThrower ( ) && ( target . isEmpty ( ) || isGoto ( target . getFirstInstruction ( ) . getInstruction ( ) ) ) ; if ( ! empty ) { try { if ( classContext . getCFG ( method ) . getNumIncomingEdges ( target ) > 1 ) { if ( DEBUG ) { System . out . println ( "Target of infeasible edge has multiple incoming edges" ) ; } empty = true ; } } catch ( CFGBuilderException e ) { assert true ; } } if ( DEBUG ) { System . out . println ( "Target block is  " + ( empty ? "empty" : "not empty" ) ) ; } if ( ! empty && isThrower ( target ) ) { infeasibleEdgeSimplyThrowsException = true ; } if ( ! empty && ! previouslyDeadBlocks . get ( target . getLabel ( ) ) ) { if ( DEBUG ) { System . out . println ( "target was alive previously" ) ; } IsNullValueFrame invFrame = invDataflow . getStartFact ( target ) ; createdDeadCode = invFrame . isTop ( ) ; if ( DEBUG ) { System . out . println ( "target is now " + ( createdDeadCode ? "dead" : "alive" ) ) ; } } } int priority ; boolean valueIsNull = true ; String warning ; int pc = location . getHandle ( ) . getPosition ( ) ; OpcodeStack stack = null ; OpcodeStack . Item item1 = null ; OpcodeStack . Item item2 = null ; try { stack = OpcodeStackScanner . getStackAt ( classContext . getJavaClass ( ) , method , pc ) ; item1 = stack . getStackItem ( 0 ) ; } catch ( RuntimeException e ) { if ( SystemProperties . ASSERTIONS_ENABLED ) { AnalysisContext . logError ( "Error getting stack at specific PC" , e ) ; } assert true ; } if ( redundantBranch . secondValue == null ) { if ( isGeneratedCodeInCatchBlock ( method , pc ) ) { log . debug ( "skip RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE found in the generated code at {}" , location ) ; return ; } else if ( redundantBranch . firstValue . isDefinitelyNull ( ) ) { warning = "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE" ; priority = NORMAL_PRIORITY ; } else { warning = "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE" ; valueIsNull = false ; priority = isChecked ? HIGH_PRIORITY : NORMAL_PRIORITY ; } if ( infeasibleEdgeSimplyThrowsException ) { priority ++ ; } } else { if ( stack != null ) { item2 = stack . getStackItem ( 1 ) ; } boolean bothNull = redundantBranch . firstValue . isDefinitelyNull ( ) && redundantBranch . secondValue . isDefinitelyNull ( ) ; if ( redundantBranch . secondValue . isChecked ( ) ) { isChecked = true ; } if ( redundantBranch . secondValue . wouldHaveBeenAKaboom ( ) ) { wouldHaveBeenAKaboom = true ; locationOfKaBoom = redundantBranch . secondValue . getLocationOfKaBoom ( ) ; } if ( bothNull ) { warning = "RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES" ; priority = NORMAL_PRIORITY ; } else { warning = "RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE" ; priority = isChecked ? NORMAL_PRIORITY : LOW_PRIORITY ; } } if ( wouldHaveBeenAKaboom ) { priority = HIGH_PRIORITY ; warning = "RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE" ; if ( locationOfKaBoom == null ) { throw new NullPointerException ( "location of KaBoom is null" ) ; } } if ( DEBUG ) { System . out . println ( createdDeadCode + " " + infeasibleEdgeSimplyThrowsException + " " + valueIsNull + " " + priority ) ; } if ( createdDeadCode ) { if ( ! infeasibleEdgeSimplyThrowsException ) { priority += 0 ; } else { if ( valueIsNull ) { priority += 0 ; } else { priority += 1 ; } } } else { priority += 1 ; } if ( DEBUG ) { System . out . println ( "RCN " + priority + " " + redundantBranch . firstValue + " =? " + redundantBranch . secondValue + " : " + warning ) ; if ( isChecked ) { System . out . println ( "isChecked" ) ; } if ( wouldHaveBeenAKaboom ) { System . out . println ( "wouldHaveBeenAKaboom" ) ; } if ( createdDeadCode ) { System . out . println ( "createdDeadCode" ) ; } } if ( priority > LOW_PRIORITY ) { return ; } BugAnnotation variableAnnotation = null ; try { ValueNumberFrame vnaFrame = classContext . getValueNumberDataflow ( method ) . getFactAtLocation ( location ) ; if ( vnaFrame . isValid ( ) ) { Instruction ins = location . getHandle ( ) . getInstruction ( ) ; ValueNumber valueNumber = vnaFrame . getInstance ( ins , classContext . getConstantPoolGen ( ) ) ; if ( valueNumber . hasFlag ( ValueNumber . CONSTANT_CLASS_OBJECT ) ) { return ; } variableAnnotation = ValueNumberSourceInfo . findAnnotationFromValueNumber ( method , location , valueNumber , vnaFrame , "VALUE_OF" ) ; if ( variableAnnotation instanceof LocalVariableAnnotation ) { LocalVariableAnnotation local = ( LocalVariableAnnotation ) variableAnnotation ; if ( ! local . isNamed ( ) ) { if ( "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE" . equals ( warning ) ) { return ; } priority ++ ; } } } } catch ( DataflowAnalysisException | CFGBuilderException e ) { } BugInstance bugInstance = new BugInstance ( this , warning , priority ) . addClassAndMethod ( classContext . getJavaClass ( ) , method ) ; LocalVariableAnnotation fallback = new LocalVariableAnnotation ( "?" , - 1 , - 1 ) ; boolean foundSource = bugInstance . tryAddingOptionalUniqueAnnotations ( variableAnnotation , BugInstance . getFieldOrMethodValueSource ( item1 ) , BugInstance . getFieldOrMethodValueSource ( item2 ) ) ; if ( ! foundSource ) { if ( "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE" . equals ( warning ) ) { return ; } bugInstance . setPriority ( priority + 1 ) ; bugInstance . add ( fallback ) ; } if ( wouldHaveBeenAKaboom ) { bugInstance . addSourceLine ( classContext , method , locationOfKaBoom ) ; } if ( FindBugsAnalysisFeatures . isRelaxedMode ( ) ) { WarningPropertySet < WarningProperty > propertySet = new WarningPropertySet < > ( ) ; WarningPropertyUtil . addPropertiesForDataMining ( propertySet , classContext , method , location ) ; if ( isChecked ) { propertySet . addProperty ( NullDerefProperty . CHECKED_VALUE ) ; } if ( wouldHaveBeenAKaboom ) { propertySet . addProperty ( NullDerefProperty . WOULD_HAVE_BEEN_A_KABOOM ) ; } if ( createdDeadCode ) { propertySet . addProperty ( NullDerefProperty . CREATED_DEAD_CODE ) ; } propertySet . decorateBugInstance ( bugInstance ) ; } SourceLineAnnotation sourceLine = SourceLineAnnotation . fromVisitedInstruction ( classContext , method , location ) ; sourceLine . setDescription ( "SOURCE_REDUNDANT_NULL_CHECK" ) ; bugAccumulator . accumulateBug ( bugInstance , sourceLine ) ; }
public RuleConditionDTOBuilder paramType ( final String paramType ) { this . paramType = paramType ; return this ; }
public int getY ( ) { return y ; }
public boolean canAddToOtherChat ( TdApi . Chat chat ) { TdApi . User user = chatUser ( chat ) ; if ( user == null ) { return false ; } switch ( user . type . getConstructor ( ) ) { case TdApi . UserTypeRegular . CONSTRUCTOR : return true ; case TdApi . UserTypeBot . CONSTRUCTOR : return ( ( TdApi . UserTypeBot ) user . type ) . canJoinGroups ; } return false ; }
public ImportResult importItem ( UUID jobId , IdempotentImportExecutor idempotentExecutor , TokensAndUrlAuthData authData , ContactsModelWrapper data ) throws Exception { JCardReader reader = new JCardReader ( data . getVCards ( ) ) ; try { List < VCard > vCardList = reader . readAll ( ) ; PeopleService . People peopleService = getOrCreatePeopleService ( authData ) . people ( ) ; for ( VCard vCard : vCardList ) { Person person = convert ( vCard ) ; idempotentExecutor . executeAndSwallowIOExceptions ( vCard . toString ( ) , vCard . getFormattedName ( ) . toString ( ) , ( ) -> peopleService . createContact ( person ) . execute ( ) . toPrettyString ( ) ) ; } return ImportResult . OK ; } catch ( IOException e ) { return new ImportResult ( e ) ; } }
@ Override public String getMessage ( ) { return String . format ( Locale . getDefault ( ) , "This table is required by the GTFS specification but is missing." ) ; }
public int compare ( com . salesmanager . core . model . order . OrderTotal x , com . salesmanager . core . model . order . OrderTotal y ) { if ( x . getSortOrder ( ) == y . getSortOrder ( ) ) return 0 ; return x . getSortOrder ( ) < y . getSortOrder ( ) ? - 1 : 1 ; }
public float incrementAndGet ( ) { value ++ ; return value ; }
public BaseStatefulWindowedBolt < T > withLateTupleStream ( String streamName ) { super . withLateTupleStream ( streamName ) ; return this ; }
public CompletableFuture < Void > asyncAddEventExecution ( EventExecution eventExecution ) { return CompletableFuture . runAsync ( ( ) -> addEventExecution ( eventExecution ) , logExecutorService ) ; }
public Optional < Statistics > statistics ( ) { Snapshot snapshot = TimeTravelUtil . tryTravelOrLatest ( this ) ; if ( snapshot != null ) { String file = snapshot . statistics ( ) ; if ( file == null ) { return Optional . empty ( ) ; } if ( statsCache != null ) { Statistics stats = statsCache . getIfPresent ( file ) ; if ( stats != null ) { return Optional . of ( stats ) ; } } Statistics stats = store ( ) . newStatsFileHandler ( ) . readStats ( file ) ; if ( statsCache != null ) { statsCache . put ( file , stats ) ; } return Optional . of ( stats ) ; } return Optional . empty ( ) ; }
public String getName ( ) { return "notEquals" ; }
public IntArray2D div ( int x ) { for ( int i = 0 ; i < A . length ; i ++ ) { A [ i ] /= x ; } return this ; }
public BatcherBuilder newKeyBasedBatcherBuilder ( ) { return new KeyBasedBatcherBuilder ( ) ; }
public static Object getPrimitiveDefaultValue ( Class < ? > clazz ) { if ( long . class == clazz ) { return 0L ; } else if ( int . class == clazz ) { return 0 ; } else if ( short . class == clazz ) { return ( short ) 0 ; } else if ( char . class == clazz ) { return ( char ) 0 ; } else if ( byte . class == clazz ) { return ( byte ) 0 ; } else if ( double . class == clazz ) { return 0D ; } else if ( float . class == clazz ) { return 0f ; } else if ( boolean . class == clazz ) { return false ; } return null ; }
static Class < ? > [ ] getClassAry ( ) { return CLASSES ; }
public void onRealChunkUnloaded ( Vector3ic pos ) { if ( chunkLods > 0 && ! probablyLoadedRegion . contains ( pos ) && lodRegions [ 0 ] . contains ( pos ) && ! requiredChunks . containsKey ( pos ) ) { addChunk ( pos , 0 ) ; } else if ( chunkLods > 0 ) { LodChunk unscaledChunk = chunks . get ( 0 ) . get ( new Vector3i ( pos ) ) ; LodChunk scaledChunk = chunks . get ( 1 ) . get ( new Vector3i ( pos . x ( ) & - 2 , pos . y ( ) & - 2 , pos . z ( ) & - 2 ) ) ; if ( unscaledChunk != null ) { unscaledChunk . realVersion = null ; } else if ( scaledChunk != null ) { scaledChunk . hiddenness -- ; } } }
public synchronized int size ( ) { return objects . size ( ) ; }
public static List < Throwable > getThrowableList ( Throwable throwable ) { final List < Throwable > list = new ArrayList < > ( ) ; while ( throwable != null && ! list . contains ( throwable ) ) { list . add ( throwable ) ; throwable = throwable . getCause ( ) ; } return list ; }
private File resolveFile ( String from ) { return vertx . fileResolver ( ) . resolve ( from ) ; }
public AjaxJson < Void > updatePwd ( @ RequestBody @ Valid UpdateUserPwdRequest updateUserPwdRequest ) { userService . updateUserNameAndPwdById ( ZFileAuthUtil . getCurrentUserId ( ) , updateUserPwdRequest ) ; return AjaxJson . getSuccess ( ) ; }
private static byte [ ] cast ( Object array ) { return ( byte [ ] ) array ; }
public void set ( double number ) { if ( ! hasKey ) { key = ( K ) Double . valueOf ( number ) ; hasKey = true ; return ; } Object value = Double . valueOf ( number ) ; output . put ( key , value ) ; key = null ; hasKey = false ; }
public void close ( ) { Log . i ( Log . TAG_ACCOUNTS , "Calling client.close(), accountId:%d" , tdlib . accountId ) ; long ms = SystemClock . uptimeMillis ( ) ; Log . i ( Log . TAG_ACCOUNTS , "client.close() done in %dms, accountId:%d, accountsNum:%d" , SystemClock . uptimeMillis ( ) - ms , tdlib . accountId , runningClients . decrementAndGet ( ) ) ; }
public void cancel ( ) { cancel . set ( true ) ; }
public Criteria andInputListGreaterThanOrEqualTo ( String value ) { addCriterion ( "input_list >=" , value , "inputList" ) ; return ( Criteria ) this ; }
