public static org . joda . time . Instant microsecondToInstant ( long microsecond ) { return org . joda . time . Instant . ofEpochMilli ( microsecond / 1_000L ) ; }
public boolean connectBlocking ( ) { boolean success = false ; try { success = super . connectBlocking ( ) ; } catch ( Exception exception ) { LOG . error ( "websocket connection server[{}] is error.....[{}]" , this . getURI ( ) . toString ( ) , exception . getMessage ( ) ) ; } if ( success ) { LOG . info ( "websocket connection server[{}] is successful....." , this . getURI ( ) . toString ( ) ) ; } else { LOG . warn ( "websocket connection server[{}] is error....." , this . getURI ( ) . toString ( ) ) ; } return success ; }
public void compact ( @ Nullable NonThrownExecutor executor , CompactionPlanEvent event , Collector < CompactionCommitEvent > collector , boolean needReloadMetaClient , FlinkCompactionMetrics compactionMetrics ) throws Exception { String instantTime = event . getCompactionInstantTime ( ) ; if ( executor != null ) { executor . execute ( ( ) -> doCompaction ( event , collector , needReloadMetaClient , compactionMetrics ) , ( errMsg , t ) -> collector . collect ( createFailedCommitEvent ( event ) ) , "Execute compaction for instant %s from task %d" , instantTime , taskID ) ; } else { log . info ( "Execute compaction for instant {} from task {}" , instantTime , taskID ) ; doCompaction ( event , collector , needReloadMetaClient , compactionMetrics ) ; } }
public Criteria andUpdateUserLessThanOrEqualTo ( String value ) { addCriterion ( "update_user <=" , value , "updateUser" ) ; return ( Criteria ) this ; }
public void handlerRule ( final RuleData ruleData ) { ApplicationConfigCache . getInstance ( ) . cacheRuleHandle ( ruleData . getId ( ) , ruleData . getHandle ( ) ) ; }
public String getName ( ) { return "inline" ; }
public void apply ( Project project ) { synchronized ( project ) { List < Row > rows = project . rows ; for ( CellChange cellChange : _cellChanges ) { rows . get ( cellChange . row ) . setCell ( cellChange . cellIndex , cellChange . newCell ) ; } if ( _commonColumnName != null ) { Column column = project . columnModel . getColumnByName ( _commonColumnName ) ; column . clearPrecomputes ( ) ; ProjectManager . singleton . getLookupCacheManager ( ) . flushLookupsInvolvingProjectColumn ( project . id , _commonColumnName ) ; } if ( _updateRowContextDependencies ) { project . update ( ) ; } } }
public String getClusterName ( ) { return clusterName ; }
public long getMaxFieldSectionSize ( ) { return getOrDefault ( MAX_FIELD_SECTION_SIZE ) ; }
private String getGeTuiAccessToken ( Object account ) { String accessToken = "" ; try { GeTuiAccount geTuiAccount = ( GeTuiAccount ) account ; String url = SendChanelUrlConstant . GE_TUI_BASE_URL + geTuiAccount . getAppId ( ) + SendChanelUrlConstant . GE_TUI_AUTH ; String time = String . valueOf ( System . currentTimeMillis ( ) ) ; String digest = SecureUtil . sha256 ( ) . digestHex ( geTuiAccount . getAppKey ( ) + time + geTuiAccount . getMasterSecret ( ) ) ; QueryTokenParamDTO param = QueryTokenParamDTO . builder ( ) . timestamp ( time ) . appKey ( geTuiAccount . getAppKey ( ) ) . sign ( digest ) . build ( ) ; String body = HttpRequest . post ( url ) . header ( Header . CONTENT_TYPE . getValue ( ) , ContentType . JSON . getValue ( ) ) . body ( JSON . toJSONString ( param ) ) . timeout ( 2000 ) . execute ( ) . body ( ) ; GeTuiTokenResultDTO geTuiTokenResultDTO = JSON . parseObject ( body , GeTuiTokenResultDTO . class ) ; if ( geTuiTokenResultDTO . getCode ( ) . equals ( 0 ) ) { accessToken = geTuiTokenResultDTO . getData ( ) . getToken ( ) ; } } catch ( Exception e ) { log . error ( "AccessTokenUtils#getGeTuiAccessToken fail:{}" , Throwables . getStackTraceAsString ( e ) ) ; } return accessToken ; }
public boolean sendEventToJS ( String eventName , Bundle data , ReactContext reactContext ) { if ( reactContext != null ) { sendEventToJS ( eventName , Arguments . fromBundle ( data ) , reactContext ) ; return true ; } return false ; }
public static String gainCondition ( boolean not , String condition , boolean addOuterBracket ) { String s = not ? NOT + "(" + condition + ")" : condition ; return addOuterBracket ? "( " + s + " )" : s ; }
public String getCreateTemporaryTableColumnAnnotation ( int sqlTypeCode ) { return "" ; }
public void setSubfolder ( String subFolder ) { this . subFolder = subFolder ; String recordingSubfolder = getAppSettings ( ) . getRecordingSubfolder ( ) ; if ( ! StringUtils . isBlank ( recordingSubfolder ) ) { if ( ! StringUtils . isBlank ( this . subFolder ) ) { this . subFolder = subFolder + File . separator + recordingSubfolder ; } else { this . subFolder = recordingSubfolder ; } } }
public RFuture < Void > putAsync ( V e ) { RedissonQueueSemaphore semaphore = createSemaphore ( e ) ; return semaphore . acquireAsync ( ) ; }
public Integer getWidth ( ) { return width ; }
public void setObjects ( Map < String , ? > objects ) { this . objects . clear ( ) ; this . objects . putAll ( createDefaultObjectMap ( ) ) ; apply ( objects ) ; }
public static synchronized MainNetParams get ( ) { if ( instance == null ) { instance = new MainNetParams ( ) ; } return instance ; }
public void printTo ( Appendable appendable , ReadablePartial partial , Locale locale ) throws IOException { appendable . append ( iValue ) ; }
public OpType getOpType ( ) { return OpType . INTERSECTION ; }
public AsyncStage < Stat > forPath ( String path , byte [ ] data ) { return internalForPath ( path , data , true ) ; }
private static String usage ( CLI cli ) { StringBuilder usageStringBuilder = new StringBuilder ( ) ; UsageMessageFormatter usageMessageFormatter = new UsageMessageFormatter ( ) ; usageMessageFormatter . setOptionComparator ( null ) ; cli . usage ( usageStringBuilder , usageMessageFormatter ) ; return UsageRender . render ( usageStringBuilder . toString ( ) ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof RolePO ) ) { return false ; } RolePO tablePO = ( RolePO ) o ; return Objects . equal ( getRoleId ( ) , tablePO . getRoleId ( ) ) && Objects . equal ( getRoleName ( ) , tablePO . getRoleName ( ) ) && Objects . equal ( getMetalakeId ( ) , tablePO . getMetalakeId ( ) ) && Objects . equal ( getProperties ( ) , tablePO . getProperties ( ) ) && Objects . equal ( getAuditInfo ( ) , tablePO . getAuditInfo ( ) ) && Objects . equal ( getCurrentVersion ( ) , tablePO . getCurrentVersion ( ) ) && Objects . equal ( getLastVersion ( ) , tablePO . getLastVersion ( ) ) && Objects . equal ( getDeletedAt ( ) , tablePO . getDeletedAt ( ) ) ; }
public NDArray logicalOr ( NDArray other ) { return getAlternativeArray ( ) . logicalOr ( alternativeManager . from ( other ) ) ; }
default JSONMap < M , L > setHaving ( String keys ) { return setHaving ( keys , false ) ; }
public void add ( String keyWord , T t ) { SmartForest < T > tempBranch = this ; for ( int i = 0 ; i < keyWord . length ( ) ; i ++ ) { if ( keyWord . length ( ) == i + 1 ) { tempBranch . add ( new SmartForest < T > ( keyWord . charAt ( i ) , 3 , t ) ) ; } else { tempBranch . add ( new SmartForest < T > ( keyWord . charAt ( i ) , 1 , null ) ) ; } tempBranch = tempBranch . branches [ tempBranch . getIndex ( keyWord . charAt ( i ) ) ] ; } }
protected VirtualMouse createVirtualMouse ( @ Nonnull VirtualDisplay display , @ Nonnull String inputDeviceName , int vendorId , int productId ) { return createVirtualMouse ( new VirtualMouseConfig . Builder ( ) . setInputDeviceName ( inputDeviceName ) . build ( ) ) ; }
public ProblemBenchmarksConfig withSolutionFileIOClass ( Class < ? extends SolutionFileIO < ? > > solutionFileIOClass ) { this . setSolutionFileIOClass ( solutionFileIOClass ) ; return this ; }
public Long replanWaitTime ( ) { return 0L ; }
public Criteria andLinkNumberIn ( List < String > values ) { addCriterion ( "link_number in" , values , "linkNumber" ) ; return ( Criteria ) this ; }
public List < JobDetail > getJobDetails ( GroupMatcher < JobKey > matcher ) throws JobPersistenceException { return ( List < JobDetail > ) executeWithoutLock ( ( TransactionCallback ) conn -> retrieveJobs ( conn , matcher ) ) ; }
public boolean isWithResponseBodySchemaDoc ( ) { return withResponseBodySchemaDoc ; }
public void ixor ( ) { visitInsn ( Opcodes . IXOR ) ; }
public void fireSubscriptionMovedEvent ( Contact source , ContactGroup oldParent , ContactGroup newParent ) { SubscriptionMovedEvent evt = new SubscriptionMovedEvent ( source , parentProvider , oldParent , newParent ) ; Collection < SubscriptionListener > listeners ; synchronized ( subscriptionListeners ) { listeners = new ArrayList < SubscriptionListener > ( subscriptionListeners ) ; } if ( logger . isDebugEnabled ( ) ) logger . debug ( "Dispatching a Subscription Event to" + listeners . size ( ) + " listeners. Evt=" + evt ) ; for ( SubscriptionListener listener : listeners ) listener . subscriptionMoved ( evt ) ; }
public synchronized void addFailure ( final Test test , final AssertionFailedError e ) { testFailed ( TestRunListener . STATUS_FAILURE , test , e ) ; }
public SettingBar setLineSize ( int size ) { FrameLayout . LayoutParams params = ( FrameLayout . LayoutParams ) mLineView . getLayoutParams ( ) ; if ( params == null ) { params = generateDefaultLayoutParams ( ) ; } params . height = size ; mLineView . setLayoutParams ( params ) ; return this ; }
public static int hashFor ( char character , String fontFamily , String style ) { int result = ( int ) character ; result = 31 * result + fontFamily . hashCode ( ) ; result = 31 * result + style . hashCode ( ) ; return result ; }
public void sendEmailVC ( final RequestContext context ) { context . renderJSON ( StatusCodes . ERR ) ; final JSONObject requestJSONObject = context . requestJSON ( ) ; final String email = StringUtils . lowerCase ( StringUtils . trim ( requestJSONObject . optString ( User . USER_EMAIL ) ) ) ; if ( ! Strings . isEmail ( email ) ) { final String msg = langPropsService . get ( "sendFailedLabel" ) + " - " + langPropsService . get ( "invalidEmailLabel" ) ; context . renderMsg ( msg ) ; return ; } final String captcha = requestJSONObject . optString ( CaptchaProcessor . CAPTCHA ) ; if ( CaptchaProcessor . invalidCaptcha ( captcha ) ) { final String msg = langPropsService . get ( "sendFailedLabel" ) + " - " + langPropsService . get ( "captchaErrorLabel" ) ; context . renderMsg ( msg ) ; return ; } final JSONObject user = Sessions . getUser ( ) ; if ( email . equalsIgnoreCase ( user . optString ( User . USER_EMAIL ) ) ) { final String msg = langPropsService . get ( "sendFailedLabel" ) + " - " + langPropsService . get ( "bindedLabel" ) ; context . renderMsg ( msg ) ; return ; } final String userId = user . optString ( Keys . OBJECT_ID ) ; try { JSONObject verifycode = verifycodeQueryService . getVerifycodeByUserId ( Verifycode . TYPE_C_EMAIL , Verifycode . BIZ_TYPE_C_BIND_EMAIL , userId ) ; if ( null != verifycode ) { context . renderJSON ( StatusCodes . SUCC ) . renderMsg ( langPropsService . get ( "vcSentLabel" ) ) ; return ; } if ( null != userQueryService . getUserByEmail ( email ) ) { context . renderMsg ( langPropsService . get ( "duplicatedEmailLabel" ) ) ; return ; } final String code = RandomStringUtils . randomNumeric ( 6 ) ; verifycode = new JSONObject ( ) ; verifycode . put ( Verifycode . USER_ID , userId ) ; verifycode . put ( Verifycode . BIZ_TYPE , Verifycode . BIZ_TYPE_C_BIND_EMAIL ) ; verifycode . put ( Verifycode . TYPE , Verifycode . TYPE_C_EMAIL ) ; verifycode . put ( Verifycode . CODE , code ) ; verifycode . put ( Verifycode . STATUS , Verifycode . STATUS_C_UNSENT ) ; verifycode . put ( Verifycode . EXPIRED , DateUtils . addMinutes ( new Date ( ) , 10 ) . getTime ( ) ) ; verifycode . put ( Verifycode . RECEIVER , email ) ; verifycodeMgmtService . addVerifycode ( verifycode ) ; context . renderJSON ( StatusCodes . SUCC ) . renderMsg ( langPropsService . get ( "verifycodeSentLabel" ) ) ; } catch ( final ServiceException e ) { context . renderMsg ( e . getMessage ( ) ) ; } }
public void propertySetter ( JMethod setter , JDefinedClass clazz , String propertyName ) { setter . annotate ( JsonProperty . class ) . param ( "value" , propertyName ) ; }
public void onCreate ( ) { super . onCreate ( ) ; Log . i ( TAG , "onCreate.." ) ; libPublisher = new SmartPublisherJniV2 ( ) ; libPublisher . InitRtspServer ( this . getApplicationContext ( ) ) ; }
public Criteria andPostCodeEqualTo ( String value ) { addCriterion ( "post_code =" , value , "postCode" ) ; return ( Criteria ) this ; }
public String getRouteEnvironmentFailover ( ) { RuleEntity ruleEntity = pluginAdapter . getRule ( ) ; if ( ruleEntity != null ) { StrategyFailoverEntity strategyFailoverEntity = ruleEntity . getStrategyFailoverEntity ( ) ; if ( strategyFailoverEntity != null ) { return strategyFailoverEntity . getEnvironmentFailoverValue ( ) ; } } return null ; }
public Criteria andCityIn ( List < String > values ) { addCriterion ( "city in" , values , "city" ) ; return ( Criteria ) this ; }
public static < T extends AbstractJVMInstruction > T get ( int opcode , JobDetailsBuilder jobDetailsBuilder ) { final Function < JobDetailsBuilder , AbstractJVMInstruction > instructionBuilder = instructions . get ( opcode ) ; if ( instructionBuilder == null ) { if ( unsupportedInstructions . containsKey ( opcode ) ) { throw new IllegalArgumentException ( "Unsupported lambda" , new UnsupportedOperationException ( unsupportedInstructions . get ( opcode ) ) ) ; } throw JobRunrException . shouldNotHappenException ( new IllegalArgumentException ( "Instruction " + opcode + " not found" ) ) ; } return cast ( instructionBuilder . apply ( jobDetailsBuilder ) ) ; }
MediaStreamTrack getLocalTrack ( String trackId ) { return getUserMediaImpl . getTrack ( trackId ) ; }
public Dialog onCreateDialog ( @ Nullable final Bundle savedInstanceState ) { if ( getStreamEntities ( ) == null ) { return super . onCreateDialog ( savedInstanceState ) ; } final DialogEditTextBinding dialogBinding = DialogEditTextBinding . inflate ( getLayoutInflater ( ) ) ; dialogBinding . getRoot ( ) . getContext ( ) . setTheme ( ThemeHelper . getDialogTheme ( requireContext ( ) ) ) ; dialogBinding . dialogEditText . setHint ( R . string . name ) ; dialogBinding . dialogEditText . setInputType ( InputType . TYPE_CLASS_TEXT ) ; final Builder dialogBuilder = new Builder ( requireContext ( ) , ThemeHelper . getDialogTheme ( requireContext ( ) ) ) . setTitle ( R . string . create_playlist ) . setView ( dialogBinding . getRoot ( ) ) . setCancelable ( true ) . setNegativeButton ( R . string . cancel , null ) . setPositiveButton ( R . string . create , ( dialogInterface , i ) -> { final String name = dialogBinding . dialogEditText . getText ( ) . toString ( ) ; final LocalPlaylistManager playlistManager = new LocalPlaylistManager ( NewPipeDatabase . getInstance ( requireContext ( ) ) ) ; final Toast successToast = Toast . makeText ( getActivity ( ) , R . string . playlist_creation_success , Toast . LENGTH_SHORT ) ; playlistManager . createPlaylist ( name , getStreamEntities ( ) ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( longs -> successToast . show ( ) ) ; } ) ; return dialogBuilder . create ( ) ; }
public Builder maxLineCount ( int maxLineCount ) { this . maxLineCount = maxLineCount ; return this ; }
public void removeUpdate ( DocumentEvent e ) { documentChanged ( e ) ; }
public ModuleSplit addPlaceholderNativeEntries ( ModuleSplit moduleSplit ) { return moduleSplit . toBuilder ( ) . setEntries ( ImmutableList . < ModuleEntry > builder ( ) . addAll ( moduleSplit . getEntries ( ) ) . addAll ( abiPlaceholders . stream ( ) . map ( AbiPlaceholderInjector :: createEntryForAbi ) . collect ( toImmutableList ( ) ) ) . build ( ) ) . build ( ) ; }
public final void addThemeLinkTextColorListener ( Object view , @ ColorId int color ) { addThemeListener ( new ThemeListenerEntry ( ThemeListenerEntry . MODE_LINK_TEXT_COLOR , color , view ) ) ; }
public void putFloat ( @ Nullable String key , float value ) { super . putFloat ( key , value ) ; }
public int getProcessorCount ( ) throws DataUnavailable { if ( 0 == _cpuCount ) { throw new DataUnavailable ( "Processor count could not be found" ) ; } else { return _cpuCount ; } }
public boolean hasEmployeePDP ( ) { return employeePDP ; }
protected EventEvaluatorModel makeNewInstance ( ) { return new EventEvaluatorModel ( ) ; }
public void warning ( final String msg ) { warnings ++ ; if ( ! suppressOutput ) { out . println ( "WARNING: " + msg ) ; } if ( warningsFatal && stopOnError ) { throw new IllegalArgumentException ( msg ) ; } }
public void onActivityPaused ( @ NonNull Activity activity ) { }
public Integer getReplicas ( ) { return this . replicas ; }
public IInterface queryLocalInterface ( @ NonNull String descriptor ) { throw new RuntimeException ( "STUB" ) ; }
public boolean onStartNestedScroll ( View child , View target , int nestedScrollAxes ) { return nestedScrollAxes == ViewCompat . SCROLL_AXIS_VERTICAL && enableDrag ; }
public Map < String , Properties > topicConfigs ( Set < String > topics ) { Map < ConfigResource , KafkaFuture < Config > > topicConfigs ; topicConfigs = _adminClient . describeConfigs ( topics . stream ( ) . map ( name -> new ConfigResource ( ConfigResource . Type . TOPIC , name ) ) . collect ( Collectors . toList ( ) ) ) . values ( ) ; Map < String , Properties > propsMap = new HashMap < > ( ) ; if ( topicConfigs != null ) { for ( Map . Entry < ConfigResource , KafkaFuture < Config > > entry : topicConfigs . entrySet ( ) ) { try { Config config = entry . getValue ( ) . get ( ) ; propsMap . put ( entry . getKey ( ) . name ( ) , convertConfigToProperties ( config ) ) ; } catch ( ExecutionException ee ) { if ( Errors . REQUEST_TIMED_OUT . exception ( ) . getClass ( ) == ee . getCause ( ) . getClass ( ) ) { LOG . warn ( "Failed to retrieve config for topics due to describeConfigs request timing out. " + "Check for Kafka-side issues and consider increasing the configured timeout." ) ; break ; } else { LOG . debug ( "Cannot retrieve config for topic {}." , entry . getKey ( ) . name ( ) , ee ) ; } } catch ( InterruptedException ie ) { LOG . debug ( "Interrupted while getting config for topic {}." , entry . getKey ( ) . name ( ) , ie ) ; } } } return propsMap ; }
private void readWebSocketFrame ( ) throws IOException { try { Frame frame = Frame . read ( this . inputStream ) ; if ( frame . getType ( ) == Frame . Type . PING ) { writeWebSocketFrame ( new Frame ( Frame . Type . PONG ) ) ; } else if ( frame . getType ( ) == Frame . Type . CLOSE ) { throw new ConnectionClosedException ( ) ; } else if ( frame . getType ( ) == Frame . Type . TEXT ) { logger . debug ( LogMessage . format ( "Received LiveReload text frame %s" , frame ) ) ; } else { throw new IOException ( "Unexpected Frame Type " + frame . getType ( ) ) ; } } catch ( SocketTimeoutException ex ) { writeWebSocketFrame ( new Frame ( Frame . Type . PING ) ) ; Frame frame = Frame . read ( this . inputStream ) ; if ( frame . getType ( ) != Frame . Type . PONG ) { throw new IllegalStateException ( "No Pong" ) ; } } }
public < S > Void visit ( XorExpression xorExpression , S context ) { visitBinaryExpression ( xorExpression ) ; return null ; }
public Object asType ( Class < ? > type ) throws MalformedURLException { if ( type == URI . class ) return this . toURI ( ) ; if ( type == URL . class ) return this . toURL ( ) ; if ( type == String . class ) return this . toString ( ) ; throw new ClassCastException ( "Cannot cast instance of URIBuilder to class " + type ) ; }
private void initPaint ( ) { mPaint = new Paint ( ) ; mPaint . setColor ( mPaintColor ) ; mPaint . setAntiAlias ( true ) ; mPaint . setStrokeCap ( Paint . Cap . ROUND ) ; }
private static RasterPlotter drawNetworkPicture ( final SeedDB seedDB , final int width , final int height , final int passiveLimit , final int potentialLimit , final int maxCount , final int coronaangle , final long communicationTimeout , final String networkName , final String networkTitle , final long color_back , final int cyc ) { final RasterPlotter . DrawMode drawMode = ( RasterPlotter . darkColor ( color_back ) ) ? RasterPlotter . DrawMode . MODE_ADD : RasterPlotter . DrawMode . MODE_SUB ; final RasterPlotter networkPicture = new RasterPlotter ( width , height , drawMode , color_back ) ; if ( seedDB == null ) return networkPicture ; final int maxradius = Math . min ( width / 2 , height * 3 / 5 ) ; final int innerradius = maxradius * 4 / 10 ; final int outerradius = maxradius - 20 ; networkPicture . setColor ( COL_DHTCIRCLE ) ; networkPicture . arc ( width / 2 , height / 2 , innerradius - 20 , innerradius + 20 , 100 ) ; Seed seed ; long lastseen ; int count = 0 ; int totalCount = 0 ; Iterator < Seed > e = seedDB . seedsConnected ( true , false , null , ( float ) 0.0 ) ; while ( e . hasNext ( ) && count < maxCount ) { seed = e . next ( ) ; if ( seed == null ) { ConcurrentLog . warn ( "NetworkGraph" , "connected seed == null" ) ; continue ; } if ( seed . hash . startsWith ( "AD" ) ) { continue ; } new drawNetworkPicturePeerJob ( networkPicture , width / 2 , height / 2 , innerradius , outerradius , seed , COL_ACTIVE_DOT , COL_ACTIVE_LINE , COL_ACTIVE_TEXT , coronaangle , cyc ) . draw ( ) ; count ++ ; } totalCount += count ; count = 0 ; e = seedDB . seedsSortedDisconnected ( false , Seed . LASTSEEN ) ; while ( e . hasNext ( ) && count < maxCount ) { seed = e . next ( ) ; if ( seed == null ) { ConcurrentLog . warn ( "NetworkGraph" , "disconnected seed == null" ) ; continue ; } lastseen = Math . abs ( ( System . currentTimeMillis ( ) - seed . getLastSeenUTC ( ) ) / 1000 / 60 ) ; if ( lastseen > passiveLimit ) { break ; } new drawNetworkPicturePeerJob ( networkPicture , width / 2 , height / 2 , innerradius , outerradius , seed , COL_PASSIVE_DOT , COL_PASSIVE_LINE , COL_PASSIVE_TEXT , coronaangle , cyc ) . draw ( ) ; count ++ ; } totalCount += count ; count = 0 ; e = seedDB . seedsSortedPotential ( false , Seed . LASTSEEN ) ; while ( e . hasNext ( ) && count < maxCount ) { seed = e . next ( ) ; if ( seed == null ) { ConcurrentLog . warn ( "NetworkGraph" , "potential seed == null" ) ; continue ; } lastseen = Math . abs ( ( System . currentTimeMillis ( ) - seed . getLastSeenUTC ( ) ) / 1000 / 60 ) ; if ( lastseen > potentialLimit ) { break ; } new drawNetworkPicturePeerJob ( networkPicture , width / 2 , height / 2 , innerradius , outerradius , seed , COL_POTENTIAL_DOT , COL_POTENTIAL_LINE , COL_POTENTIAL_TEXT , coronaangle , cyc ) . draw ( ) ; count ++ ; } totalCount += count ; new drawNetworkPicturePeerJob ( networkPicture , width / 2 , height / 2 , innerradius , outerradius , seedDB . mySeed ( ) , COL_MYPEER_DOT , COL_MYPEER_LINE , COL_MYPEER_TEXT , coronaangle , cyc ) . draw ( ) ; if ( communicationTimeout >= 0 ) { final Date horizon = new Date ( System . currentTimeMillis ( ) - communicationTimeout ) ; for ( final Hit event : EventChannel . channels ( EventChannel . DHTRECEIVE ) ) { if ( event == null ) break ; if ( event . getPubDate ( ) == null ) continue ; if ( event . getPubDate ( ) . after ( horizon ) ) { drawNetworkPictureDHT ( networkPicture , width / 2 , height / 2 , innerradius , seedDB . mySeed ( ) , seedDB . get ( event . getLink ( ) ) , COL_DHTIN , coronaangle , false , cyc ) ; } } for ( final Hit event : EventChannel . channels ( EventChannel . DHTSEND ) ) { if ( event == null || event . getPubDate ( ) == null ) continue ; if ( event . getPubDate ( ) . after ( horizon ) ) { drawNetworkPictureDHT ( networkPicture , width / 2 , height / 2 , innerradius , seedDB . mySeed ( ) , seedDB . get ( event . getLink ( ) ) , COL_DHTOUT , coronaangle , true , cyc ) ; } } } networkPicture . setColor ( COL_HEADLINE ) ; PrintTool . print6 ( networkPicture , 2 , 10 , 0 , "YACY NETWORK '" + networkName . toUpperCase ( ) + "'" , - 1 , 100 , true , false ) ; PrintTool . print6 ( networkPicture , 2 , 20 , 0 , networkTitle . toUpperCase ( ) , - 1 , 80 , true , false ) ; PrintTool . print6 ( networkPicture , width - 2 , 10 , 0 , "SNAPSHOT FROM " + new Date ( ) . toString ( ) . toUpperCase ( ) , 1 , 80 , true , false ) ; PrintTool . print6 ( networkPicture , width - 2 , 20 , 0 , "DRAWING OF " + totalCount + " SELECTED PEERS" , 1 , 80 , true , false ) ; return networkPicture ; }
public void skipString ( ) throws IOException { doSkipBytes ( readLong ( ) ) ; }
public Presence presence ( ) { return presence ; }
public File getPluginDirectory ( ) { return pluginDirectory ; }
static void log ( final Context context , @ NonNull Type type , Long account , Long folder , Long message , String data ) { Log . i ( data ) ; if ( context == null ) return ; if ( ( type == Type . Debug1 || type == Type . Debug2 || type == Type . Debug3 || type == Type . Debug4 || type == Type . Debug5 ) && ! ( BuildConfig . DEBUG || Log . isTestRelease ( ) ) ) return ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; boolean main_log = prefs . getBoolean ( "main_log" , true ) ; if ( ! main_log ) return ; boolean main_log_memory = prefs . getBoolean ( "main_log_memory" , false ) ; if ( main_log_memory ) { long j = Log . getAvailableMb ( ) - Log . getFreeMemMb ( ) ; long n = Debug . getNativeHeapSize ( ) / 1024L / 1024L ; data = j + "/" + n + " " + data ; } final EntityLog entry = new EntityLog ( ) ; entry . time = new Date ( ) . getTime ( ) ; entry . type = type ; entry . thread = Thread . currentThread ( ) . getId ( ) ; entry . account = account ; entry . folder = folder ; entry . message = message ; entry . data = data ; final DB db = DB . getInstance ( context ) ; final Context acontext = context . getApplicationContext ( ) ; Helper . getSerialExecutor ( ) . submit ( new Runnable ( ) { @ Override public void run ( ) { if ( ! ok || ( ++ count % LOG_DELETE_BATCH_SIZE ) == 0 ) { long cake = Helper . getAvailableStorageSpace ( ) ; boolean wasOk = ok ; ok = ( cake > Helper . MIN_REQUIRED_SPACE ) ; if ( ! ok ) if ( wasOk ) { entry . type = Type . General ; entry . account = null ; entry . folder = null ; entry . message = null ; entry . data = "Insufficient storage space=" + Helper . humanReadableByteCount ( cake ) + "/" + Helper . humanReadableByteCount ( Helper . MIN_REQUIRED_SPACE ) ; } else return ; } try { db . beginTransaction ( ) ; db . log ( ) . insertLog ( entry ) ; db . setTransactionSuccessful ( ) ; } catch ( Throwable ex ) { Log . e ( ex ) ; } finally { db . endTransaction ( ) ; } long now = new Date ( ) . getTime ( ) ; if ( last_cleanup == null || last_cleanup + LOG_CLEANUP_INTERVAL < now ) { last_cleanup = now ; cleanup ( acontext , now - LOG_KEEP_DURATION ) ; } } } ) ; }
public final int readByte ( ) throws IOException { return readInt ( 1 ) ; }
protected boolean validate ( AttachmentRenderData data ) { return null != data && null != data . readAttachmentData ( ) && null != data . getFileType ( ) ; }
protected < T > CompletableFuture < List < T > > allOf ( List < CompletableFuture < T > > futuresList ) { CompletableFuture < Void > allFuturesResult = CompletableFuture . allOf ( futuresList . toArray ( new CompletableFuture [ 0 ] ) ) ; return allFuturesResult . thenApply ( v -> futuresList . stream ( ) . map ( CompletableFuture :: join ) . collect ( Collectors . < T > toList ( ) ) ) ; }
public String getLagLevel ( ) { return lagLevel ; }
public static float px2sp ( @ Nullable Context context , int value ) { if ( context == null ) { return 0 ; } return px2sp ( context . getResources ( ) , value ) ; }
public < T extends Parcelable > SparseArray < T > getSparseParcelableArray ( @ Nullable String key ) { unparcel ( ) ; Object o = mMap . get ( key ) ; if ( o == null ) { return null ; } try { return ( SparseArray < T > ) o ; } catch ( ClassCastException e ) { typeWarning ( key , o , "SparseArray" , e ) ; return null ; } }
default R or ( ) { return Matchers . extract ( this ) . or ( ) . create ( ) ; }
public long getNextNum ( String projectId ) { return NumGenerator . nextNum ( projectId , ApplicationNumScope . TASK ) ; }
public void setName ( SQLName x ) { if ( x != null ) { x . setParent ( this ) ; } this . name = x ; }
static VectorValues of ( float [ ] vector ) { return new SingleIndexVectorValues ( vector ) ; }
void trim ( HplsqlParser . Expr_spec_funcContext ctx ) { int cnt = ctx . expr ( ) . size ( ) ; if ( cnt != 1 ) { evalNull ( ) ; return ; } String str = evalPop ( ctx . expr ( 0 ) ) . toString ( ) ; str = unquoteString ( str ) ; evalString ( str . trim ( ) ) ; }
protected final boolean isTransforming ( ) { return transformFactor != 0f && ! transformFullyApplied ; }
public int hashCode ( ) { int result = string != null ? string . hashCode ( ) : 0 ; result = 31 * result + stringRes ; result = 31 * result + pluralRes ; result = 31 * result + quantity ; result = 31 * result + Arrays . hashCode ( formatArgs ) ; return result ; }
public String getSecurityServiceLocation ( ) { return securityServiceLocation ; }
public AppOutputAppendEventTupleScheme getScheme ( ) { return new AppOutputAppendEventTupleScheme ( ) ; }
public void configure ( Map configurationValues ) { try { DruidDataSourceFactory . config ( dataSource , configurationValues ) ; } catch ( SQLException e ) { throw new IllegalArgumentException ( "config error" , e ) ; } }
public Criteria andAllResourcePoolEqualTo ( Boolean value ) { addCriterion ( "all_resource_pool =" , value , "allResourcePool" ) ; return ( Criteria ) this ; }
private List < Object > getFieldAndValue ( ColumnRowData row ) { if ( row . getArity ( ) - redisConfig . getKeyIndexes ( ) . size ( ) != REDIS_KEY_VALUE_SIZE . defaultValue ( ) ) { throw new IllegalArgumentException ( "Each row record can have only one pair of attributes and values except key" ) ; } List < Object > values = new ArrayList < > ( row . getArity ( ) ) ; for ( int i = 0 ; i < row . getArity ( ) ; i ++ ) { values . add ( row . getField ( i ) ) ; } for ( Integer keyIndex : redisConfig . getKeyIndexes ( ) ) { values . remove ( ( int ) keyIndex ) ; } return values ; }
private void updateSpringMinVisibleChange ( ) { int width = getBounds ( ) . width ( ) ; int height = getBounds ( ) . height ( ) ; if ( width <= 0 || height <= 0 ) { return ; } if ( drawingDelegate instanceof LinearDrawingDelegate ) { springAnimation . setMinimumVisibleChange ( ( float ) MAX_DRAWABLE_LEVEL / width ) ; } else { springAnimation . setMinimumVisibleChange ( ( float ) ( MAX_DRAWABLE_LEVEL / ( min ( height , width ) * Math . PI ) ) ) ; } }
public boolean compressIntArray ( ) { return compressIntArray ; }
public LazyXmlParser changeCompatibilityMode ( CompatibilityMode mode ) { this . compatibilityMode = mode ; return this ; }
public ConnectorTableHandle getTableHandle ( ) { return tableHandle ; }
public int getOnErrorContainer ( ) { return getArgb ( new MaterialDynamicColors ( ) . onErrorContainer ( ) ) ; }
public List < Double > percentMain ( ) { return config ( ) . getDoubleList ( "lru-window-tiny-lfu.percent-main" ) ; }
public void run ( ) { try { doPeriodicalFlush ( ) ; } catch ( Throwable t ) { log . error ( "Failed to flush data to BanyanDB" , t ) ; } }
protected Interpolator getSearchTransformInterpolator ( ) { return AnimatorUtils . DECELERATE_INTERPOLATOR ; }
int modify ( final int iValue ) { return iValue == 12 ? 0 : iValue ; }
public void refresh ( ) { ( ( Refreshable ) getCurrentPage ( ) ) . refresh ( ) ; }
public void describeTo ( Description description ) { description . appendText ( matcherDescription ) ; }
public OptExpression visitLogicalTableScan ( OptExpression optExpression , EnforceContext context ) { LogicalScanOperator scanOperator = optExpression . getOp ( ) . cast ( ) ; LogicalScanOperator . Builder builder = OperatorBuilderFactory . build ( scanOperator ) ; builder . withOperator ( scanOperator ) ; Map < ColumnRefOperator , Column > columnRefOperatorColumnMap = Maps . newHashMap ( scanOperator . getColRefToColumnMetaMap ( ) ) ; for ( ColumnRefOperator columnRef : columnsToEnforce ) { for ( Map . Entry < Column , ColumnRefOperator > entry : scanOperator . getColumnMetaToColRefMap ( ) . entrySet ( ) ) { ColumnRefOperator toEnforceColumnRefOp = entry . getValue ( ) ; if ( toEnforceColumnRefOp . equals ( columnRef ) ) { if ( ! columnRefOperatorColumnMap . containsKey ( toEnforceColumnRefOp ) ) { columnRefOperatorColumnMap . put ( columnRef , entry . getKey ( ) ) ; context . enforcedNonExistedColumns . add ( columnRef ) ; } context . enforcedColumns . add ( columnRef ) ; } } } builder . setColRefToColumnMetaMap ( columnRefOperatorColumnMap ) ; OptExpression newScan = new OptExpression ( builder . build ( ) ) ; newScan . deriveLogicalPropertyItself ( ) ; return newScan ; }
public void sendCanMatch ( Transport . Connection connection , final ShardSearchRequest request , SearchTask task , final ActionListener < SearchService . CanMatchResponse > listener ) { transportService . sendChildRequest ( connection , QUERY_CAN_MATCH_NAME , request , task , TransportRequestOptions . EMPTY , new ActionListenerResponseHandler < > ( listener , SearchService . CanMatchResponse :: new ) ) ; }
ImmutableList < String > copiedClassAnnotations ( TypeElement type ) { if ( hasAnnotationMirror ( type , COPY_ANNOTATIONS_NAME ) ) { Set < String > excludedAnnotations = ImmutableSet . < String > builder ( ) . addAll ( getExcludedAnnotationClassNames ( type ) ) . addAll ( getAnnotationsMarkedWithInherited ( type ) ) . add ( ClassNames . KOTLIN_METADATA_NAME ) . build ( ) ; return copyAnnotations ( type , type , excludedAnnotations ) ; } else { return ImmutableList . of ( ) ; } }
public Criteria andDeleteFlagBetween ( String value1 , String value2 ) { addCriterion ( "delete_Flag between" , value1 , value2 , "deleteFlag" ) ; return ( Criteria ) this ; }
private ParticleController createDefaultBillboardController ( ) { RegularEmitter emitter = new RegularEmitter ( ) ; emitter . getDuration ( ) . setLow ( 3000 ) ; emitter . getEmission ( ) . setHigh ( 250 ) ; emitter . getLife ( ) . setHigh ( 500 , 1000 ) ; emitter . getLife ( ) . setTimeline ( new float [ ] { 0 , 0.66f , 1 } ) ; emitter . getLife ( ) . setScaling ( new float [ ] { 1 , 1 , 0.3f } ) ; emitter . setMaxParticleCount ( 200 ) ; PointSpawnShapeValue pointSpawnShapeValue = new PointSpawnShapeValue ( ) ; SpawnInfluencer spawnSource = new SpawnInfluencer ( pointSpawnShapeValue ) ; ColorInfluencer . Single colorInfluencer = new ColorInfluencer . Single ( ) ; colorInfluencer . colorValue . setColors ( new float [ ] { 1 , 0.12156863f , 0.047058824f , 0 , 0 , 0 } ) ; colorInfluencer . colorValue . setTimeline ( new float [ ] { 0 , 1 } ) ; colorInfluencer . alphaValue . setHigh ( 1 ) ; colorInfluencer . alphaValue . setTimeline ( new float [ ] { 0 , 0.5f , 0.8f , 1 } ) ; colorInfluencer . alphaValue . setScaling ( new float [ ] { 0 , 0.15f , 0.5f , 0 } ) ; DynamicsInfluencer velocityInfluencer = new DynamicsInfluencer ( ) ; DynamicsModifier . PolarAcceleration velocityValue = new DynamicsModifier . PolarAcceleration ( ) ; velocityValue . phiValue . setHigh ( - 35 , 35 ) ; velocityValue . phiValue . setActive ( true ) ; velocityValue . phiValue . setTimeline ( new float [ ] { 0 , 0.5f , 1 } ) ; velocityValue . phiValue . setScaling ( new float [ ] { 1 , 0 , 0 } ) ; velocityValue . thetaValue . setHigh ( 0 , 360 ) ; velocityValue . strengthValue . setHigh ( 5 , 10 ) ; velocityInfluencer . velocities . add ( velocityValue ) ; return new ParticleController ( "Billboard Controller" , emitter , new BillboardRenderer ( editor . getBillboardBatch ( ) ) , new RegionInfluencer . Single ( editor . getTexture ( ) ) , spawnSource , colorInfluencer , velocityInfluencer ) ; }
public void appendFunctionAttributes ( boolean hasExpression , StringBuilder builder , Map < String , String > functionAttributes ) { builder . append ( "," ) . append ( functionAttributes . get ( ROUND_PLACES ) ) ; }
public void surfaceChanged ( SurfaceHolder holder , int format , int width , int height ) { Log . i ( TAG , "surfaceChanged.." ) ; initPushCamera ( holder ) ; }
public Builder clientName ( String clientName ) { this . clientName = clientName ; return this ; }
public boolean maybeEndInterpolation ( String capture ) throws IOException { if ( dHead . nendbrace <= 0 ) { return false ; } if ( capture . startsWith ( "}" ) ) { if ( -- dHead . nendbrace <= 0 ) { int rem = capture . length ( ) - 1 ; String opener = capture . substring ( 0 , 1 ) ; popData ( ) ; yypop ( ) ; disjointSpan ( HtmlConsts . STRING_CLASS ) ; offer ( opener ) ; if ( rem > 0 ) { yypushback ( rem ) ; } return true ; } } else if ( capture . startsWith ( "{" ) ) { ++ dHead . nendbrace ; } return false ; }
public StringBuilder visit ( UnPivotPipeOperator unPivot , Void context ) { builder . append ( "|> " ) . append ( "UNPIVOT( " ) . append ( unPivot . getValuesColumn ( ) ) . append ( " FOR " ) . append ( unPivot . getNameColumn ( ) ) . append ( " IN (" ) . append ( Select . getStringList ( unPivot . getPivotColumns ( ) ) ) . append ( "))" ) ; if ( unPivot . getAlias ( ) != null ) { builder . append ( " " ) . append ( unPivot . getAlias ( ) ) ; } builder . append ( "\n" ) ; return builder ; }
public void closeAllPreProWaiting ( ) { _transference_preprocess_queue . clear ( ) ; _transference_preprocess_global_queue . clear ( ) ; _transference_provision_queue . clear ( ) ; _transference_remove_queue . addAll ( new ArrayList ( getTransference_waitstart_queue ( ) ) ) ; getTransference_waitstart_queue ( ) . clear ( ) ; synchronized ( getWait_queue_lock ( ) ) { getWait_queue_lock ( ) . notifyAll ( ) ; } secureNotify ( ) ; }
private void bfs ( Graph G , int s ) { Deque < Integer > queue = new LinkedList < > ( ) ; queue . offer ( s ) ; while ( ! queue . isEmpty ( ) ) { int v = queue . poll ( ) ; for ( int w : G . adj ( v ) ) { edgeTo [ w ] = v ; marked [ w ] = true ; queue . offer ( w ) ; } } }
public String getStartTimeString ( ) { return DATE_FORMAT . format ( getStartTime ( ) . toInstant ( ) ) ; }
public int hashCode ( ) { return Util . hashCombine ( name . hashCode ( ) , Util . hash ( ns ) ) ; }
public boolean isInRecentTab ( ) { return mCurrentCategoryId == EmojiCategory . ID_RECENTS ; }
public Resolution newAccountForm ( ) { return new ForwardResolution ( NEW_ACCOUNT ) ; }
public void setRootViewBackgroundColor ( @ ColorInt int color ) { mOptionBundle . putInt ( EXTRA_UCROP_ROOT_VIEW_BACKGROUND_COLOR , color ) ; }
public A withReadOnly ( Boolean readOnly ) { this . readOnly = readOnly ; return ( A ) this ; }
public String getParams ( ) { return "element e, string s" ; }
public static Object coerceNumber ( Object value ) { if ( value instanceof Number && ! ( value instanceof BigDecimal ) ) { return getBigDecimalOrNull ( value ) ; } else { return value ; } }
public XorExpression withLeftExpression ( Expression expression ) { return ( XorExpression ) super . withLeftExpression ( expression ) ; }
public void dismissInternal ( ) { super . dismissInternal ( ) ; if ( orientationEventListener != null ) { orientationEventListener . disable ( ) ; orientationEventListener = null ; } }
public static void main ( String [ ] args ) throws InterruptedException { threadWait ( ) ; }
public void reopen ( ) { toTop ( ) ; }
protected int safeGetColumnType ( int col ) throws SQLException { return stmt . pointer . safeRunInt ( ( db , ptr ) -> db . column_type ( ptr , col ) ) ; }
public Map < String , List < ObjectTypeExtensionDefinition > > objectTypeExtensions ( ) { return new LinkedHashMap < > ( objectTypeExtensions ) ; }
public final void removeAttachStateListener ( AttachListener listener ) { if ( attachListeners != null ) { attachListeners . remove ( listener ) ; } }
static < M , P1 , P2 , P3 , P4 , P5 > TypedModelSpec5 < M , P1 , P2 , P3 , P4 , P5 > from ( ModelSpecBuilder < M > builder , TypedZPath5 < P1 , P2 , P3 , P4 , P5 > path ) { return ( p1 , p2 , p3 , p4 , p5 ) -> builder . withPath ( path . resolved ( p1 , p2 , p3 , p4 , p5 ) ) . build ( ) ; }
public Set < MediaType > getSupportedTypes ( ParseContext context ) { return getWrappedParser ( ) . getSupportedTypes ( context ) ; }
public int getTransparency ( ) { return TRANSLUCENT ; }
public List < Pair < RegionInfo , RegionInfo > > getHoles ( ) { return this . holes ; }
public TimeZone getTimeZone ( ) { return timeZone ; }
public Criteria andFileNameLike ( String value ) { addCriterion ( "file_name like" , value , "fileName" ) ; return ( Criteria ) this ; }
private static FFIType ffi_type_double ( ) { long __result = nffi_type_double ( ) ; return FFIType . create ( __result ) ; }
public @ Nullable String getFromHeader ( ) { return this . fromHeader ; }
public TException getException ( ) { return exception ; }
private void callAnalyserHandleOnModel ( Model model , ModelHandlerBase analyser ) { try { analyser . handle ( mic , model ) ; } catch ( ModelHandlerException e ) { addError ( "Failed to traverse model " + model . getTag ( ) , e ) ; } }
public boolean isBlueOceanCredentialsProvidedEnabled ( ) { return ExtensionList . lookupSingleton ( BlueOceanCredentialsProvider . class ) . isEnabled ( null ) ; }
public static Set < ClaimType > getClaimTypes ( HealthRecord . Encounter encounter ) { Set < ClaimType > types = new HashSet < > ( ) ; boolean isSNF = encounter . type . equals ( HealthRecord . EncounterType . SNF . toString ( ) ) ; boolean isHome = encounter . type . equals ( HealthRecord . EncounterType . HOME . toString ( ) ) ; boolean isHospice = encounter . type . equals ( HealthRecord . EncounterType . HOSPICE . toString ( ) ) ; boolean isInpatient = encounter . type . equals ( HealthRecord . EncounterType . INPATIENT . toString ( ) ) ; boolean isEmergency = encounter . type . equals ( HealthRecord . EncounterType . EMERGENCY . toString ( ) ) ; boolean isWellness = encounter . type . equals ( HealthRecord . EncounterType . WELLNESS . toString ( ) ) ; boolean isUrgent = encounter . type . equals ( HealthRecord . EncounterType . URGENTCARE . toString ( ) ) ; boolean isVirtual = encounter . type . equals ( HealthRecord . EncounterType . VIRTUAL . toString ( ) ) ; boolean isAmbulatory = encounter . type . equals ( HealthRecord . EncounterType . AMBULATORY . toString ( ) ) ; boolean isOutpatient = encounter . type . equals ( HealthRecord . EncounterType . OUTPATIENT . toString ( ) ) ; boolean isPrimary = Provider . ProviderType . PRIMARY == encounter . provider . type ; boolean isVirtualOutpatient = isVirtual && ( Provider . ProviderType . HOSPITAL == encounter . provider . type ) ; boolean isVirtualHome = isVirtual && ( Provider . ProviderType . HOME_HEALTH == encounter . provider . type ) ; boolean isVirtualHospice = isVirtual && ( Provider . ProviderType . HOSPICE == encounter . provider . type ) ; boolean isVirtualNursing = isVirtual && ( Provider . ProviderType . NURSING == encounter . provider . type ) ; if ( ! isVAorIHS ( encounter ) ) { if ( isSNF ) { types . add ( ClaimType . SNF ) ; } else if ( isHome || isVirtualHome ) { types . add ( ClaimType . HHA ) ; } else if ( isHospice || isVirtualHospice ) { types . add ( ClaimType . HOSPICE ) ; } else if ( isInpatient || isEmergency ) { types . add ( ClaimType . INPATIENT ) ; } else if ( isPrimary || isWellness || isUrgent || isVirtualNursing ) { types . add ( ClaimType . CARRIER ) ; } else if ( isAmbulatory || isOutpatient || isVirtualOutpatient ) { types . add ( ClaimType . OUTPATIENT ) ; } if ( types . isEmpty ( ) ) { System . out . printf ( "BFD RIF unhandled encounter type (" + encounter . type + ") and provider type (" + encounter . provider . type . toString ( ) + ")\n" ) ; } } return types ; }
private static String discoverClassName ( ClassLoader tccl ) { String className = getClassNameServices ( tccl ) ; if ( className == null ) { className = getClassNameJreDir ( ) ; } if ( className == null ) { className = getClassNameSysProp ( ) ; } if ( className == null ) { className = "org.flowable.common.engine.impl.de.odysseus.el.ExpressionFactoryImpl" ; } return className ; }
public void printTo ( StringBuffer buf , int value ) { buf . append ( value == 1 ? iSingularText : iPluralText ) ; }
protected Animator onCreateShowAnimator ( ) { return null ; }
public boolean isDefault ( ) { return false ; }
public String annotation ( XSAnnotation ann ) { throw new UnsupportedOperationException ( ) ; }
public T createConversionCast ( T column , PrimitiveTypeInfo tableFieldTypeInfo ) throws SemanticException { String baseType = TypeInfoUtils . getBaseName ( tableFieldTypeInfo . getTypeName ( ) ) ; return getDefaultExprProcessor ( ) . getFuncExprNodeDescWithUdfData ( baseType , tableFieldTypeInfo , column ) ; }
public void init ( ShaderPackScreen screen , NavigationController navigation ) { super . init ( screen , navigation ) ; String actualPendingValue = this . element . getPendingOptionValues ( ) . getStringValueOrDefault ( this . option . getName ( ) ) ; this . appliedValue = this . element . getAppliedOptionValues ( ) . getStringValueOrDefault ( this . option . getName ( ) ) ; this . prefix = Component . literal ( Language . getInstance ( ) . has ( "prefix." + this . option . getName ( ) ) ? Language . getInstance ( ) . getOrDefault ( "prefix." + this . option . getName ( ) ) : "" ) ; this . suffix = Component . literal ( Language . getInstance ( ) . has ( "suffix." + this . option . getName ( ) ) ? Language . getInstance ( ) . getOrDefault ( "suffix." + this . option . getName ( ) ) : "" ) ; this . setLabel ( GuiUtil . translateOrDefault ( Component . literal ( this . option . getName ( ) ) , "option." + this . option . getName ( ) ) ) ; List < String > values = this . option . getAllowedValues ( ) ; this . valueCount = values . size ( ) ; this . valueIndex = values . indexOf ( actualPendingValue ) ; }
public AbstractSQLConfig < T , M , L > setFill ( String ... conditions ) { return setFill ( StringUtil . get ( conditions ) ) ; }
public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) { if ( "module-info.java" . equals ( file . getFileName ( ) . toString ( ) ) ) { return CONTINUE ; } if ( javaMatcher . matches ( file ) ) { current_root = getRoot ( file ) . orElse ( null ) ; if ( current_root != null ) { return SKIP_SIBLINGS ; } } return CONTINUE ; }
public static CodePointCharStream fromString ( String s , String sourceName ) { CodePointBuffer . Builder codePointBufferBuilder = CodePointBuffer . builder ( s . length ( ) ) ; CharBuffer cb = CharBuffer . allocate ( s . length ( ) ) ; cb . put ( s ) ; cb . flip ( ) ; codePointBufferBuilder . append ( cb ) ; return CodePointCharStream . fromBuffer ( codePointBufferBuilder . build ( ) , sourceName ) ; }
public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; addPreferencesFromResource ( R . xml . preferences ) ; }
public void setCreateTime ( String createTime ) { this . createTime = createTime ; }
public void setFullStreamDecompression ( boolean fullStreamDecompression ) { delegate ( ) . setFullStreamDecompression ( fullStreamDecompression ) ; }
private void setFlag ( int flag , boolean added ) { if ( ! added ) { this . flag &= ~ flag ; } else { this . flag |= flag ; } }
private void initJobHandlerMethodRepository ( List < Object > xxlJobBeanList ) { if ( xxlJobBeanList == null || xxlJobBeanList . isEmpty ( ) ) { return ; } for ( Object bean : xxlJobBeanList ) { Method [ ] methods = bean . getClass ( ) . getDeclaredMethods ( ) ; if ( methods . length == 0 ) { continue ; } for ( Method executeMethod : methods ) { XxlJob xxlJob = executeMethod . getAnnotation ( XxlJob . class ) ; registryJobHandler ( xxlJob , bean , executeMethod ) ; } } }
private boolean isRedundantConversionFunction ( ASTNode expr , boolean isFunction , List < T > children ) { if ( ! isFunction ) { return false ; } if ( children . size ( ) != 1 ) { return false ; } String funcText = CONVERSION_FUNCTION_TEXT_MAP . get ( ( ( ASTNode ) expr . getChild ( 0 ) ) . getType ( ) ) ; if ( funcText == null ) { return false ; } return exprFactory . getTypeInfo ( children . get ( 0 ) ) . getTypeName ( ) . equalsIgnoreCase ( funcText ) ; }
public Sign . SignatureData getSignatureData ( ) { return signatureData ; }
public String toSafeString ( ) { String name = ex . getClass ( ) . getName ( ) ; String message = getSafeMessage ( ) ; return ( message == null ? name : ( name + ": " + message ) ) ; }
public String toString ( ) { return this . int2IdMap . toString ( ) ; }
public static String [ ] getStringArray ( @ NonNull String resName ) { return Resources . getSystem ( ) . getStringArray ( getResourceId ( ARRAY , resName ) ) ; }
private static Object findParent ( final ConvertedMap data , final FieldReference field ) { Object target = data ; for ( final String key : field . getPath ( ) ) { target = fetch ( target , key ) ; if ( ! ( target instanceof ConvertedMap || target instanceof ConvertedList ) ) { return null ; } } return target ; }
public Criteria andPhoneNumberLike ( String value ) { addCriterion ( "phone_number like" , value , "phoneNumber" ) ; return ( Criteria ) this ; }
public double pop ( ) { if ( count == 0 ) { throw new RuntimeException ( "Can't call pop() on an empty list" ) ; } double value = get ( count - 1 ) ; count -- ; return value ; }
public void onException ( final HttpServerExchange exchange , final Sender sender , final IOException exception ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( exception ) ; exchange . endExchange ( ) ; }
public long getAverageCheckoutTime ( ) { lock . lock ( ) ; try { return requestCount == 0 ? 0 : accumulatedCheckoutTime / requestCount ; } finally { lock . unlock ( ) ; } }
public String create ( Description description , Representation representation ) { return formatter . format ( description , representation , format , arguments ) ; }
public ImmutableRoaringBitmap rangeLT ( ImmutableRoaringBitmap foundSet , int predicate ) { return compare ( BitmapSliceIndex . Operation . LT , predicate , 0 , foundSet ) ; }
public boolean isEnabled ( RecyclerView . ViewHolder holder ) { return holder . getItemViewType ( ) == VIEW_TYPE_ADD_EXCEPTION || holder . getItemViewType ( ) == VIEW_TYPE_TOPIC || holder . getItemViewType ( ) == VIEW_TYPE_DELETE_ALL ; }
public boolean hasIqn ( ) { return this . iqn != null ; }
void setCalendar ( final FastDateParser parser , final Calendar cal , final String value ) { final Integer iVal = lKeyValues . get ( value . toLowerCase ( locale ) ) ; if ( iVal == null ) { final StringBuilder sb = new StringBuilder ( value ) ; sb . append ( " not in (" ) ; for ( final String textKeyValue : lKeyValues . keySet ( ) ) { sb . append ( textKeyValue ) . append ( ' ' ) ; } sb . setCharAt ( sb . length ( ) - 1 , ')' ) ; throw new IllegalArgumentException ( sb . toString ( ) ) ; } cal . set ( field , iVal . intValue ( ) ) ; }
Neo4jTemplate neo4jTemplate ( Neo4jClient neo4jClient , Neo4jMappingContext neo4jMappingContext ) { return new Neo4jTemplate ( neo4jClient , neo4jMappingContext ) ; }
private void initialize ( ) { getStyleClass ( ) . add ( DEFAULT_STYLE_CLASS ) ; initializeTextArea ( ) ; getChildren ( ) . add ( textArea ) ; }
public void setSessionInfoVisitor ( final ISessionInfoVisitor visitor ) { this . sessionInfoVisitor = visitor ; }
public void setExpandedSubtitleTypeface ( @ Nullable Typeface typeface ) { collapsingSubtitleHelper . setExpandedTypeface ( typeface ) ; }
public void onSwipeUp ( boolean wasFling , PointF finalVelocity ) { try { ActivityManager . getService ( ) . closeSystemDialogs ( SYSTEM_DIALOG_REASON_GESTURE_NAV ) ; } catch ( RemoteException e ) { Log . e ( TAG , "Exception calling closeSystemDialogs " + e . getMessage ( ) ) ; } }
protected TypeDescription declaringType ( AnnotationDescription . Loadable < FieldGetterHandle > annotation ) { return annotation . getValue ( DECLARING_TYPE ) . resolve ( TypeDescription . class ) ; }
public GenericSecretSource getAccessToken ( ) { return accessToken ; }
protected void logParam ( String paramName , Object paramValue ) { reqSpec . formParam ( paramName , paramValue ) ; }
public final List < Long > insertAndReturnIdsList ( T [ ] entities ) { final SupportSQLiteStatement stmt = acquire ( ) ; try { final List < Long > result = new ArrayList < > ( entities . length ) ; int index = 0 ; for ( T entity : entities ) { bind ( stmt , entity ) ; result . add ( index , stmt . executeInsert ( ) ) ; index ++ ; } return result ; } finally { release ( stmt ) ; } }
public Criteria andPayTypeGreaterThanOrEqualTo ( String value ) { addCriterion ( "pay_type >=" , value , "payType" ) ; return ( Criteria ) this ; }
public AbstractParameters parseParameters ( String taskParams ) { return JSONUtils . parseObject ( taskParams , DatasyncParameters . class ) ; }
private void initAttrs ( Context context , AttributeSet attrs , int defStyleAttr ) { TypedArray array = getContext ( ) . obtainStyledAttributes ( attrs , R . styleable . MiniLoadingView , defStyleAttr , 0 ) ; mSize = array . getDimensionPixelSize ( R . styleable . MiniLoadingView_mlv_loading_view_size , DensityUtils . dp2px ( context , 32 ) ) ; mPaintColor = array . getColor ( R . styleable . MiniLoadingView_mlv_loading_view_color , Color . WHITE ) ; array . recycle ( ) ; }
public String toString ( ) { String physicalLocation ; if ( fileName != null && lineNumber >= 0 ) { physicalLocation = fileName + ":" + lineNumber ; } else if ( isNativeMethod ( ) ) { physicalLocation = "Native Method" ; } else { physicalLocation = "Unknown Source" ; } return className + "." + methodName + "(" + physicalLocation + ")" ; }
boolean isNullAt ( Object [ ] in , int ordinal ) { return in [ ordinal ] == null ; }
public boolean equals ( java . lang . Object that ) { if ( that == null ) return false ; if ( that instanceof AppOutputAppendEvent ) return this . equals ( ( AppOutputAppendEvent ) that ) ; return false ; }
private static Supplier < String > makeFormattingSupplier ( String format , Supplier < Object > [ ] args ) { return ( ) -> { Object [ ] objects = new Object [ args . length ] ; for ( int i = 0 ; i < args . length ; i ++ ) { objects [ i ] = args [ i ] . get ( ) ; } return f ( format , objects ) ; } ; }
public RecoverableFsDataOutputStream . Committer recoverForCommit ( CommitRecoverable recoverable ) throws IOException { return new AzureBlobFsRecoverableDataOutputStream . ABFSCommitter ( fs , ( HadoopFsRecoverable ) recoverable ) ; }
public int getContainerIndex ( char x ) { return this . binarySearch ( 0 , size , x ) ; }
public void addAccessChangedListener ( AccessChangedListener listener ) { accessChangedListeners . add ( listener ) ; }
public static void openURL ( String url ) { if ( ! Program . launch ( url ) ) throw new UserErrorException ( "openURL.failed" , url ) ; }
public WindowOffset withType ( Type type ) { this . setType ( type ) ; return this ; }
private void setInsets ( InsetsState state ) { mInsetsState = state ; mDisplayLayout . setInsets ( mContext . getResources ( ) , state ) ; }
public JSONArray setDateFormat ( String format ) { this . config . setDateFormat ( format ) ; return this ; }
protected StreamingService getService ( ) { return channelInfo . getService ( ) ; }
public float getCollapsedTitleTextSize ( ) { return collapsingTitleHelper . getCollapsedTextSize ( ) ; }
public void invalidate ( K key ) { cache . invalidate ( key ) ; }
public DependencyRangesInfoContributor dependencyRangesInfoContributor ( InitializrMetadataProvider metadataProvider ) { return new DependencyRangesInfoContributor ( metadataProvider ) ; }
public Mark findMarkBefore ( long time ) throws NoSuchElementException { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "findMarkBefore(" + time + ")" ) ; } Mark last = marks . getFirst ( ) ; for ( Mark m : marks ) { if ( m . getTime ( ) > time ) { break ; } last = m ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( "return " + last ) ; } return last ; }
public void printTotal ( ) { long elapsed = System . currentTimeMillis ( ) - start ; double recsPerSec = 1000.0 * count / ( double ) elapsed ; double mbPerSec = 1000.0 * this . bytes / ( double ) elapsed / ( 1024.0 * 1024.0 ) ; int [ ] percs = percentiles ( this . latencies , index , 0.5 , 0.95 , 0.99 , 0.999 ) ; System . out . printf ( "%d records sent, %f records/sec (%.2f MB/sec), %.2f ms avg latency, %.2f ms max latency, %d ms 50th, %d ms 95th, %d ms 99th, %d ms 99.9th.%n" , count , recsPerSec , mbPerSec , totalLatency / ( double ) count , ( double ) maxLatency , percs [ 0 ] , percs [ 1 ] , percs [ 2 ] , percs [ 3 ] ) ; }
public boolean taskCancelled ( ) { return cancelled ; }
public Map < String , Long > getPendingSearchRequests ( ) { return new HashMap < > ( clientConnections ) ; }
public boolean hasSecretRef ( ) { return this . secretRef != null ; }
public String code ( ) { return this . code ; }
public Set < JavaPackage > apply ( JavaPackage javaPackage ) { return javaPackage . getSubpackages ( ) ; }
public void setAccessKey ( String accessKey ) { this . accessKey = accessKey ; }
public String description ( ) { return "number of skipped data manifests" ; }
public NDArray gt ( NDArray other ) { return getAlternativeArray ( ) . gt ( alternativeManager . from ( other ) ) ; }
public static Object avg ( Object sum , int count ) { if ( sum instanceof BigDecimal ) { return ( ( BigDecimal ) sum ) . divide ( new BigDecimal ( count ) , Divide_Scale , Divide_Round ) ; } else if ( sum instanceof BigInteger ) { BigDecimal decimal = new BigDecimal ( ( BigInteger ) sum ) ; return decimal . divide ( new BigDecimal ( count ) , Divide_Scale , Divide_Round ) ; } else if ( sum instanceof Number ) { return new Double ( ( ( Number ) sum ) . doubleValue ( ) / count ) ; } else if ( sum == null ) { return null ; } else { MessageManager mm = EngineMessage . get ( ) ; throw new RQException ( getDataType ( sum ) + mm . getMessage ( "engine.illEverage" ) ) ; } }
protected String checkForNullOrEmptyLiteral ( String stringValue ) { if ( stringValue == null ) { return null ; } if ( "\"null\"" . equals ( stringValue ) ) { return NULL_VALUE_TOKEN ; } else if ( "\"\"\"\"" . equals ( stringValue ) ) { return EMPTY_STRING_VALUE_TOKEN ; } else { return stringValue ; } }
public String getErrorClass ( ) { return errorClass ; }
public static String setSchema ( String url , String schema ) { if ( StringUtils . isEmpty ( url ) || StringUtils . isEmpty ( schema ) ) { return url ; } if ( ! schema . endsWith ( "://" ) ) { schema += "://" ; } String lowerUrl = url . toLowerCase ( ) ; if ( lowerUrl . startsWith ( "http://" ) ) { url = url . substring ( 7 ) ; } else if ( lowerUrl . startsWith ( "https://" ) ) { url = url . substring ( 8 ) ; } return schema + url ; }
public RFuture < V > takeLastAndOfferFirstToAsync ( String queueName ) { return pollLastAndOfferFirstToAsync ( queueName , 0 , TimeUnit . SECONDS ) ; }
void getStats ( final Result result ) { peerConnection . getStats ( rtcStatsReport -> handleStatsReport ( rtcStatsReport , result ) ) ; }
public void windowStateChanged ( WindowEvent evt ) { int oldState = evt . getOldState ( ) ; int newState = evt . getNewState ( ) ; if ( ( oldState & Frame . MAXIMIZED_BOTH ) == 0 && ( newState & Frame . MAXIMIZED_BOTH ) != 0 ) mainViewerGUI . isMaximized = true ; else if ( ( oldState & Frame . MAXIMIZED_BOTH ) != 0 && ( newState & Frame . MAXIMIZED_BOTH ) == 0 ) mainViewerGUI . isMaximized = false ; }
public void onWholeMessage ( ByteBuffer wholeMessage ) { for ( Decoder . Binary < T > decoder : _decoders ) { if ( decoder . willDecode ( wholeMessage ) ) { try { T obj = decoder . decode ( wholeMessage ) ; invoke ( obj ) ; return ; } catch ( DecodeException e ) { throw new CloseException ( CloseReason . CloseCodes . CANNOT_ACCEPT . getCode ( ) , "Unable to decode" , e ) ; } } } LOG . warn ( "Message lost, willDecode() has returned false for all decoders in the decoder list." ) ; }
public MappingProvider mappingProvider ( ) { return mappingProvider ; }
public void close ( ) throws IOException { if ( onClose != null ) { try { onClose . run ( ) ; } catch ( final Exception e ) { } onClose = null ; } byteBuffer = null ; }
public WARCRecordInfo buildRecord ( CrawlURI curi , URI concurrentTo ) throws IOException { final String timestamp = ArchiveUtils . getLog14Date ( curi . getFetchBeginTime ( ) ) ; String controlConversation = curi . getData ( ) . get ( A_FTP_CONTROL_CONVERSATION ) . toString ( ) ; WARCRecordInfo recordInfo = new WARCRecordInfo ( ) ; recordInfo . setRecordId ( generateRecordID ( ) ) ; if ( concurrentTo != null ) { recordInfo . addExtraHeader ( HEADER_KEY_CONCURRENT_TO , '<' + concurrentTo . toString ( ) + '>' ) ; } recordInfo . setCreate14DigitDate ( timestamp ) ; recordInfo . setUrl ( curi . toString ( ) ) ; recordInfo . setMimetype ( FTP_CONTROL_CONVERSATION_MIMETYPE ) ; recordInfo . setEnforceLength ( true ) ; recordInfo . setType ( WARCRecordType . metadata ) ; if ( curi . getServerIP ( ) != null ) { recordInfo . addExtraHeader ( HEADER_KEY_IP , curi . getServerIP ( ) ) ; } byte [ ] b = controlConversation . getBytes ( "UTF-8" ) ; recordInfo . setContentStream ( new ByteArrayInputStream ( b ) ) ; recordInfo . setContentLength ( ( long ) b . length ) ; return recordInfo ; }
public String findTypeName ( MapperConfig < ? > config , AnnotatedClass ac ) { return null ; }
public final void onConfigured ( final AuthorizerConfigurationContext configurationContext ) throws SecurityProviderCreationException { doOnConfigured ( configurationContext ) ; }
public String toString ( ) { if ( toString == null ) { toString = getNumerator ( ) + "/" + getDenominator ( ) ; } return toString ; }
public Criteria andModuleSettingLike ( String value ) { addCriterion ( "module_setting like" , value , "moduleSetting" ) ; return ( Criteria ) this ; }
public void before ( BeforeHookParam param ) { if ( param . getArgs ( ) [ 0 ] . equals ( APP_MODULE_ID ) ) param . getArgs ( ) [ 0 ] = null ; }
protected void setSchemaTemplate ( TSSetSchemaTemplateReq request ) throws IoTDBConnectionException , StatementExecutionException { final TSStatus status = callWithRetryAndReconnect ( ( ) -> { request . setSessionId ( sessionId ) ; return client . setSchemaTemplate ( request ) ; } ) . getResult ( ) ; RpcUtils . verifySuccess ( status ) ; }
private TSStatus deleteDataInternal ( TSDeleteDataReq request ) throws TException { request . setSessionId ( sessionId ) ; return client . deleteData ( request ) ; }
protected List < String > getReferenceableColumnAliases ( TypeCheckCtx ctx ) { return ctx . getInputRR ( ) . getReferenceableColumnAliases ( null , - 1 ) ; }
public boolean isHtml ( ) { return this == HTML ; }
void process ( String url , String user , String password , String fileName , Charset charset , boolean continueOnError ) throws SQLException { if ( charset == null ) { charset = StandardCharsets . UTF_8 ; } try ( Connection conn = JdbcUtils . getConnection ( null , url , user , password ) ) { process ( conn , fileName , continueOnError , charset ) ; } catch ( IOException e ) { throw DbException . convertIOException ( e , fileName ) ; } }
public String getURL ( ) { return "plocal:" + url ; }
@ Override public Collection < InetSocketAddress > getRegisteredAddresses ( ) throws IgniteSpiException { initFolder ( ) ; Collection < InetSocketAddress > addrs = new LinkedList < > ( ) ; for ( String fileName : folder . list ( ) ) { StringTokenizer st = new StringTokenizer ( fileName , DELIM ) ; if ( st . countTokens ( ) != 2 ) continue ; String addrStr = st . nextToken ( ) ; String portStr = st . nextToken ( ) ; try { int port = Integer . parseInt ( portStr ) ; addrs . add ( new InetSocketAddress ( denormalizeAddress ( addrStr ) , port ) ) ; } catch ( IllegalArgumentException e ) { U . error ( log , "Failed to parse file entry: " + fileName , e ) ; } } return Collections . unmodifiableCollection ( addrs ) ; }
public static Table tablePercents ( Table table , String column1 , String column2 ) { return tablePercents ( table , table . categoricalColumn ( column1 ) , table . categoricalColumn ( column2 ) ) ; }
public @ Nullable Channel poll ( Object partitionKey ) { return null ; }
public Criteria andNameLessThanOrEqualTo ( String value ) { addCriterion ( "`name` <=" , value , "name" ) ; return ( Criteria ) this ; }
private FieldSpec buildCacheField ( TypeName type , String name ) { FieldSpec . Builder builder = FieldSpec . builder ( type , name , PRIVATE , TRANSIENT , VOLATILE ) ; if ( lazyInitAnnotation . isPresent ( ) ) { builder . addAnnotation ( lazyInitAnnotation . get ( ) ) ; builder . addAnnotation ( SUPPRESS_WARNINGS ) ; } return builder . build ( ) ; }
public < T2 , T1 extends MultiStepOperation < T2 > > InProgressSequences with ( MultiStepOperation . SequenceKey key , Function < T1 , T1 > update ) { ImmutableMap . Builder < MultiStepOperation . SequenceKey , MultiStepOperation < ? > > builder = ImmutableMap . builder ( ) ; for ( Map . Entry < MultiStepOperation . SequenceKey , MultiStepOperation < ? > > e : state . entrySet ( ) ) { if ( e . getKey ( ) . equals ( key ) ) builder . put ( e . getKey ( ) , update . apply ( ( T1 ) e . getValue ( ) ) ) ; else builder . put ( e . getKey ( ) , e . getValue ( ) ) ; } return new InProgressSequences ( lastModified , builder . build ( ) ) ; }
public void setCategoryId ( Long categoryId ) { this . categoryId = categoryId ; }
public Builder domainEventFields ( Function < EventSchema , String > domainEventFields ) { this . domainEventFields = domainEventFields ; return this ; }
protected boolean allowLeavingSearchMode ( ) { return true ; }
public Set < String > getPausedTriggerGroups ( Connection conn ) throws JobPersistenceException { try { return getDelegate ( ) . selectPausedTriggerGroups ( conn ) ; } catch ( SQLException e ) { throw new JobPersistenceException ( "Couldn't determine paused trigger groups: " + e . getMessage ( ) , e ) ; } }
public CharSequence getText ( int index ) { Object replacement = ( ( XResources ) getResources ( ) ) . getReplacement ( getResourceId ( index , 0 ) ) ; if ( replacement instanceof CharSequence ) { return ( CharSequence ) replacement ; } else if ( replacement instanceof XResForwarder ) { Resources repRes = ( ( XResForwarder ) replacement ) . getResources ( ) ; int repId = ( ( XResForwarder ) replacement ) . getId ( ) ; return repRes . getText ( repId ) ; } return super . getText ( index ) ; }
private static Pair < Long , Long > queryVmStat ( ) { long swapPagesIn = 0L ; long swapPagesOut = 0L ; List < String > procVmStat = FileUtil . readFile ( ProcPath . VMSTAT ) ; for ( String checkLine : procVmStat ) { String [ ] memorySplit = ParseUtil . whitespaces . split ( checkLine ) ; if ( memorySplit . length > 1 ) { switch ( memorySplit [ 0 ] ) { case "pswpin" : swapPagesIn = ParseUtil . parseLongOrDefault ( memorySplit [ 1 ] , 0L ) ; break ; case "pswpout" : swapPagesOut = ParseUtil . parseLongOrDefault ( memorySplit [ 1 ] , 0L ) ; break ; default : break ; } } } return new Pair < > ( swapPagesIn , swapPagesOut ) ; }
public static MsgType fromValue ( int value ) { for ( MsgType type : MsgType . values ( ) ) { if ( type . value == value ) { return type ; } } throw new IllegalArgumentException ( "Unknown MsgType value: " + value ) ; }
public List < ByteBuffer > getProxyResultBufferList ( ) { return proxyResultBuffer ; }
public static TypeDescription convertToOrcSchema ( RowType rowType ) { TypeDescription struct = TypeDescription . createStruct ( ) ; for ( DataField dataField : rowType . getFields ( ) ) { TypeDescription child = convertToOrcType ( dataField . type ( ) , dataField . id ( ) , 0 ) ; struct . addField ( dataField . name ( ) , child ) ; } return struct ; }
public boolean hasTerminated ( ) { return this . terminated != null ; }
protected StringResourceModel canRemove ( DataAccessRule data ) { return null ; }
public MatchResult match ( Request request , Parameters parameters ) { return exactMatch ( ) ; }
public void checkGetAccess ( ) throws TIllegalAccessException { if ( getter == null ) { throw new TIllegalAccessException ( ) ; } }
Hash computeHash ( HashRequest request ) ; String getDefaultAlgorithmName ( ) ; default Map < String , Object > getParameters ( ) { return Map . of ( ) ; }
public IBinder getBinder ( @ Nullable String key ) { unparcel ( ) ; Object o = mMap . get ( key ) ; if ( o == null ) { return null ; } try { return ( IBinder ) o ; } catch ( ClassCastException e ) { typeWarning ( key , o , "IBinder" , e ) ; return null ; } }
public List < Record > loadFromMetaData ( List < RecordMetaData > recordMetaDatas ) throws IOException { List < Record > out = new ArrayList < > ( ) ; for ( RecordMetaData metaData : recordMetaDatas ) { URI uri = metaData . getURI ( ) ; String fileAsString ; try { fileAsString = FileUtils . readFileToString ( new File ( uri . toURL ( ) . getFile ( ) ) ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error reading URI file" , e ) ; } List < Writable > writables = readValues ( uri , fileAsString ) ; out . add ( new org . datavec . api . records . impl . Record ( writables , metaData ) ) ; } return out ; }
default JSONMap < M , L > setCache ( String cache ) { return puts ( KEY_CACHE , cache ) ; }
public static void create ( String libName ) { create ( Library . loadNative ( VK . class , "org.lwjgl.vulkan" , libName ) ) ; }
private Map < String , Object > toQueryMap ( Object value , QueryMapEncoder queryMapEncoder ) { if ( value instanceof Map ) { return ( Map < String , Object > ) value ; } try { return queryMapEncoder != null ? queryMapEncoder . encode ( value ) : this . queryMapEncoder . encode ( value ) ; } catch ( EncodeException e ) { throw new IllegalStateException ( e ) ; } }
static boolean isAuto ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; boolean lt_enabled = prefs . getBoolean ( "lt_enabled" , false ) ; boolean lt_auto = prefs . getBoolean ( "lt_auto" , true ) ; return ( lt_enabled && lt_auto ) ; }
public void setMaxMisfiresToHandleAtATime ( int maxToRecoverAtATime ) { this . maxToRecoverAtATime = maxToRecoverAtATime ; }
public void setStatus ( final Integer status ) { this . status = status ; }
protected void doWrite ( Tuple tuple ) throws IOException { byte [ ] bytes = this . format . format ( tuple ) ; out . write ( bytes ) ; this . offset += bytes . length ; }
public final V get ( T obj ) { accessCheck ( obj ) ; return ( V ) U . getObjectVolatile ( obj , offset ) ; }
public Optional < Long > readOffsetForPartition ( int metadataPartition ) { return consumerTask . readOffsetForMetadataPartition ( metadataPartition ) ; }
protected List < CardState > getCardStates ( ) { if ( states == null ) { states = collectSupportedCardStates ( ) ; } return states ; }
private static boolean isXmlCached ( Resources res , int id ) { int [ ] mCachedXmlBlockIds = ( int [ ] ) getObjectField ( getObjectField ( res , "mResourcesImpl" ) , "mCachedXmlBlockCookies" ) ; synchronized ( mCachedXmlBlockIds ) { for ( int cachedId : mCachedXmlBlockIds ) { if ( cachedId == id ) return true ; } } return false ; }
protected synchronized void startContext ( ) { try { ac . start ( ) ; getJobLogger ( ) . removeHandler ( currentLaunchJobLogHandler ) ; File f = new File ( ac . getCurrentLaunchDir ( ) , "job.log" ) ; currentLaunchJobLogHandler = new FileHandler ( f . getAbsolutePath ( ) , true ) ; currentLaunchJobLogHandler . setFormatter ( new JobLogFormatter ( ) ) ; getJobLogger ( ) . addHandler ( currentLaunchJobLogHandler ) ; } catch ( BeansException be ) { doTeardown ( ) ; beansException ( be ) ; } catch ( Exception e ) { LOGGER . log ( Level . SEVERE , e . getClass ( ) . getSimpleName ( ) + ": " + e . getMessage ( ) , e ) ; try { doTeardown ( ) ; } catch ( Exception e2 ) { e2 . printStackTrace ( System . err ) ; } } }
public Criteria andSalesManNotLike ( String value ) { addCriterion ( "sales_man not like" , value , "salesMan" ) ; return ( Criteria ) this ; }
public String getPath ( ) { return path ; }
protected Throwable doInBackground ( Object ... objects ) { InputStream in = null ; try { Log . i ( TAG , "Reading URI=" + data . getData ( ) ) ; ContentResolver resolver = getContentResolver ( ) ; String [ ] streamTypes = resolver . getStreamTypes ( data . getData ( ) , "*/*" ) ; String streamType = ( streamTypes == null || streamTypes . length == 0 ? "*/*" : streamTypes [ 0 ] ) ; AssetFileDescriptor descriptor = resolver . openTypedAssetFileDescriptor ( data . getData ( ) , streamType , null ) ; in = descriptor . createInputStream ( ) ; xmlImport ( in ) ; return null ; } catch ( Throwable ex ) { Log . e ( TAG , ex . toString ( ) + "\n" + Log . getStackTraceString ( ex ) ) ; return ex ; } finally { if ( in != null ) try { in . close ( ) ; } catch ( IOException ex ) { Log . e ( TAG , ex . toString ( ) + "\n" + Log . getStackTraceString ( ex ) ) ; } } }
default void deleteJobInstance ( JobInstance jobInstance ) { throw new UnsupportedOperationException ( ) ; }
public void setContentType ( String ct ) { set ( getSchema ( ) . getContentType ( ) , ct ) ; }
public NDArray transpose ( ) { return getAlternativeArray ( ) . transpose ( ) ; }
public void put ( EpoxyViewHolder holder ) { holders . put ( holder . getItemId ( ) , holder ) ; }
public < X0 > Sextet < A , B , C , D , E , X0 > addAt5 ( final X0 value0 ) { return new Sextet < A , B , C , D , E , X0 > ( this . val0 , this . val1 , this . val2 , this . val3 , this . val4 , value0 ) ; }
public String getBeanName ( ) { return this . beanName ; }
public void setProperty ( String name , Object value ) throws XmlPullParserException { throw new XmlPullParserException ( E_NOT_SUPPORTED ) ; }
public Map < String , ModelsMap > postProcessAllModels ( Map < String , ModelsMap > objs ) { final Map < String , ModelsMap > processed = super . postProcessAllModels ( objs ) ; for ( Map . Entry < String , ModelsMap > entry : objs . entrySet ( ) ) { CodegenModel cm = ModelUtils . getModelByName ( entry . getKey ( ) , objs ) ; codegenModelMap . put ( cm . classname , ModelUtils . getModelByName ( entry . getKey ( ) , objs ) ) ; } for ( String m : codegenModelMap . keySet ( ) ) { createImportMapOfSet ( m , codegenModelMap ) ; } for ( Map . Entry < String , ModelsMap > entry : processed . entrySet ( ) ) { entry . setValue ( postProcessModelsMap ( entry . getValue ( ) ) ) ; } return processed ; }
public long contentLength ( ) throws IOException { return 0 ; }
public static void setParameterExplode ( Parameter parameter , io . swagger . v3 . oas . annotations . Parameter p ) { if ( isExplodable ( p , parameter ) ) { if ( Explode . TRUE . equals ( p . explode ( ) ) ) { parameter . setExplode ( Boolean . TRUE ) ; } else if ( Explode . FALSE . equals ( p . explode ( ) ) ) { parameter . setExplode ( Boolean . FALSE ) ; } } }
int big5_probability ( byte [ ] rawtext ) { int i , rawtextlen = 0 ; int dbchars = 1 , bfchars = 1 ; float rangeval = 0 , freqval = 0 ; long bffreq = 0 , totalfreq = 1 ; int row , column ; rawtextlen = rawtext . length ; for ( i = 0 ; i < rawtextlen - 1 ; i ++ ) { if ( rawtext [ i ] >= 0 ) { } else { dbchars ++ ; if ( ( byte ) 0xA1 <= rawtext [ i ] && rawtext [ i ] <= ( byte ) 0xF9 && ( ( ( byte ) 0x40 <= rawtext [ i + 1 ] && rawtext [ i + 1 ] <= ( byte ) 0x7E ) || ( ( byte ) 0xA1 <= rawtext [ i + 1 ] && rawtext [ i + 1 ] <= ( byte ) 0xFE ) ) ) { bfchars ++ ; totalfreq += 500 ; row = rawtext [ i ] + 256 - 0xA1 ; if ( 0x40 <= rawtext [ i + 1 ] && rawtext [ i + 1 ] <= 0x7E ) { column = rawtext [ i + 1 ] - 0x40 ; } else { column = rawtext [ i + 1 ] + 256 - 0x61 ; } if ( Big5Freq [ row ] [ column ] != 0 ) { bffreq += Big5Freq [ row ] [ column ] ; } else if ( 3 <= row && row <= 37 ) { bffreq += 200 ; } } i ++ ; } } rangeval = 50 * ( ( float ) bfchars / ( float ) dbchars ) ; freqval = 50 * ( ( float ) bffreq / ( float ) totalfreq ) ; return ( int ) ( rangeval + freqval ) ; }
private FlinkYarnApplicationBuildRequest buildFlinkYarnApplicationBuildRequest ( @ Nonnull FlinkApplication app , String mainClass , String localWorkspace , String yarnProvidedPath ) { return new FlinkYarnApplicationBuildRequest ( app . getJobName ( ) , mainClass , localWorkspace , yarnProvidedPath , app . getJobTypeEnum ( ) , getMergedDependencyInfo ( app ) ) ; }
public String getPathInContext ( ) { return encodePath ( URIUtil . addPaths ( _servletRequest . getServletPath ( ) , _servletRequest . getPathInfo ( ) ) ) ; }
public DefinitionVersionResponseDtoBuilder version ( final String version ) { this . version = version ; return this ; }
public void set ( Object obj , Object value ) throws TIllegalArgumentException , TIllegalAccessException { checkSetAccess ( ) ; checkInstance ( obj ) ; setWithoutCheck ( obj , value ) ; }
public Criteria andFileNameNotBetween ( String value1 , String value2 ) { addCriterion ( "file_name not between" , value1 , value2 , "fileName" ) ; return ( Criteria ) this ; }
public DialectConfig getDialect ( ) { return super . getDialect ( ) ; }
public final void removeThemeListenerByTarget ( Object target ) { if ( themeListeners != null ) { themeListeners . removeThemeListenerByTarget ( target ) ; } }
protected String urlAssignment ( String url ) { return "url = uri(\"" + url + "\")" ; }
public Local addOrGetVariable ( ProtoIlInstructions . IlVariableMsg v , Type type , Body jbTmp ) { if ( v == null ) { return null ; } if ( v . getName ( ) . equals ( "this" ) ) { return this . mainJb . getThisLocal ( ) ; } if ( this . mainJb . getLocals ( ) . stream ( ) . anyMatch ( x -> x . getName ( ) . equals ( v . getName ( ) ) ) ) { return this . mainJb . getLocals ( ) . stream ( ) . filter ( x -> x . getName ( ) . equals ( v . getName ( ) ) ) . findFirst ( ) . orElse ( null ) ; } Type localType = ( type == null || type instanceof UnknownType || type instanceof NullType ) ? DotnetTypeFactory . toSootType ( v . getType ( ) ) : DotnetTypeFactory . toSootType ( type ) ; String n = v . getName ( ) ; if ( n . isEmpty ( ) ) { n = "noname" ; } Local newLocal = Jimple . v ( ) . newLocal ( n , localType ) ; this . mainJb . getLocals ( ) . add ( newLocal ) ; if ( jbTmp != null && jbTmp != this . mainJb ) { jbTmp . getLocals ( ) . add ( newLocal ) ; } return newLocal ; }
public HashMap < String , MegaDirNode > getChildren ( ) { return _children ; }
public Criteria andIdGreaterThan ( Long value ) { addCriterion ( "id >" , value , "id" ) ; return ( Criteria ) this ; }
public void additionalPropertiesField ( JFieldVar field , JDefinedClass clazz , String propertyName ) { field . annotate ( JsonIgnore . class ) ; }
private void updateView ( ) { final boolean showActions = ! getResources ( ) . getBoolean ( R . bool . wallet_actions_top ) ; final View view = getView ( ) ; final ViewParent parent = view . getParent ( ) ; final View fragment = parent instanceof FrameLayout ? ( FrameLayout ) parent : view ; fragment . setVisibility ( showActions ? View . VISIBLE : View . GONE ) ; }
public Long hsetnx ( String key , String field , String value ) { return jedisCommands . hsetnx ( key , field , value ) ; }
public BackupsVersioningStrategy getBackupVersioningStrategy ( ) { Uri uri = getBackupsLocation ( ) ; if ( uri == null ) { return BackupsVersioningStrategy . UNDEFINED ; } if ( DocumentsContractCompat . isTreeUri ( uri ) ) { return BackupsVersioningStrategy . MULTIPLE_BACKUPS ; } else { return BackupsVersioningStrategy . SINGLE_BACKUP ; } }
public INDArray sizeAt ( INDArray in , int dimension ) { return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . shape . SizeAt ( in , dimension ) ) [ 0 ] ; }
public void stop ( ) { for ( Animator animator : mAnimators ) { animator . end ( ) ; } }
public boolean isLaunchInfoPartial ( ) { return isLaunchInfoPartial ; }
public boolean wasSuccess ( ) { return compilations != null && ! compilations . isEmpty ( ) && exception == null && diagnostics . stream ( ) . noneMatch ( d -> d . level ( ) == CompilerDiagnostic . Level . ERROR ) ; }
public FormErrorInfo [ ] getWarnings ( ) { return myWarnings . toArray ( new FormErrorInfo [ 0 ] ) ; }
default int patchApiVersion ( ) { return minorApiVersion ( ) ; }
public void accept ( Exception e ) { if ( e != null ) { promise . reject ( e ) ; return ; } promise . resolve ( captureController . getSettings ( ) ) ; }
private static boolean hasTiKVOptions ( Map < String , String > options ) { return options . keySet ( ) . stream ( ) . anyMatch ( k -> k . startsWith ( TIKV_OPTIONS_PREFIX ) ) ; }
protected boolean onDrawSelected ( Canvas canvas , Calendar calendar , int x , int y , boolean hasScheme ) { int cx = x + mItemWidth / 2 ; int cy = y + mItemHeight / 2 ; canvas . drawCircle ( cx , cy , mRadius , mSelectedPaint ) ; return false ; }
public List < Extension > getNegotiatedExtensions ( List < Extension > installed , List < Extension > requested ) { if ( hasContainerDefaultConfigurator . get ( ) ) { return super . getNegotiatedExtensions ( installed , requested ) ; } List < Extension > negotiatedExtensions = new ArrayList < > ( ) ; for ( Extension ext : requested ) { long matches = negotiatedExtensions . stream ( ) . filter ( e -> e . getName ( ) . equals ( ext . getName ( ) ) ) . count ( ) ; if ( matches == 0 ) negotiatedExtensions . add ( ext ) ; } return negotiatedExtensions ; }
public void mousePressed ( MouseEvent e ) { if ( SwingUtilities . isLeftMouseButton ( e ) || isAbsolutePositioning ( e ) ) { isPressed = true ; repaint ( ) ; if ( isAbsolutePositioning ( e ) ) update ( e . getX ( ) , e . getY ( ) ) ; } }
public String getVariable ( String variableName ) { return null ; }
public JFieldVar apply ( String nodeName , JsonNode node , JsonNode parent , JFieldVar field , Schema currentSchema ) { if ( ruleFactory . getGenerationConfig ( ) . isIncludeJsr303Annotations ( ) && ( node . has ( "minItems" ) || node . has ( "maxItems" ) ) && isApplicableType ( field ) ) { final Class < ? extends Annotation > sizeClass = ruleFactory . getGenerationConfig ( ) . isUseJakartaValidation ( ) ? Size . class : javax . validation . constraints . Size . class ; JAnnotationUse annotation = field . annotate ( sizeClass ) ; if ( node . has ( "minItems" ) ) { annotation . param ( "min" , node . get ( "minItems" ) . asInt ( ) ) ; } if ( node . has ( "maxItems" ) ) { annotation . param ( "max" , node . get ( "maxItems" ) . asInt ( ) ) ; } } return field ; }
public void printTo ( StringBuffer buf , ReadablePeriod period , Locale locale ) { PeriodPrinter before = iBeforePrinter ; PeriodPrinter after = iAfterPrinter ; before . printTo ( buf , period , locale ) ; if ( iUseBefore ) { if ( before . countFieldsToPrint ( period , 1 , locale ) > 0 ) { if ( iUseAfter ) { int afterCount = after . countFieldsToPrint ( period , 2 , locale ) ; if ( afterCount > 0 ) { buf . append ( afterCount > 1 ? iText : iFinalText ) ; } } else { buf . append ( iText ) ; } } } else if ( iUseAfter && after . countFieldsToPrint ( period , 1 , locale ) > 0 ) { buf . append ( iText ) ; } after . printTo ( buf , period , locale ) ; }
public void registerAliases ( String packageName ) { registerAliases ( packageName , Object . class ) ; }
public void verifyIssuance ( List < SignatureVerifierContext > issuerVerifyingKeys , IssuerSignedJwtVerificationOpts issuerSignedJwtVerificationOpts , PresentationRequirements presentationRequirements ) throws VerificationException { validateIssuerSignedJwt ( issuerVerifyingKeys ) ; JsonNode disclosedPayload = validateDisclosuresDigests ( ) ; issuerSignedJwtVerificationOpts . verify ( issuerSignedJwt ) ; if ( presentationRequirements != null ) { presentationRequirements . checkIfSatisfiedBy ( disclosedPayload ) ; } }
public FindIterable < ResultT > projection ( @ Nullable final Bson projection ) { this . options . projection ( projection ) ; return this ; }
public static int set ( int s , int j , int v ) { return s & ( ~ ( 3 << ( j << 1 ) ) ) | ( v << ( j << 1 ) ) ; }
public org . openxmlformats . schemas . drawingml . x2006 . chart . CTOfPieType addNewOfPieType ( ) { synchronized ( monitor ( ) ) { check_orphaned ( ) ; org . openxmlformats . schemas . drawingml . x2006 . chart . CTOfPieType target = null ; target = ( org . openxmlformats . schemas . drawingml . x2006 . chart . CTOfPieType ) get_store ( ) . add_element_user ( PROPERTY_QNAME [ 0 ] ) ; return target ; } }
private int getNumberOfSelectedAlerts ( ) { JTree treeAlert = this . extAlert . getAlertPanel ( ) . getTreeAlert ( ) ; int count = treeAlert . getSelectionCount ( ) ; if ( count == 0 ) { return 0 ; } if ( count == 1 ) { DefaultMutableTreeNode alertNode = ( DefaultMutableTreeNode ) treeAlert . getSelectionPath ( ) . getLastPathComponent ( ) ; if ( alertNode . getChildCount ( ) == 0 || ! isMultiSelect ( ) ) { return 1 ; } return alertNode . getChildCount ( ) ; } count = 0 ; TreePath [ ] paths = treeAlert . getSelectionPaths ( ) ; for ( TreePath nodePath : paths ) { int childCount = ( ( DefaultMutableTreeNode ) nodePath . getLastPathComponent ( ) ) . getChildCount ( ) ; count += childCount != 0 ? childCount : ( treeAlert . isPathSelected ( nodePath . getParentPath ( ) ) ? 0 : 1 ) ; } return count ; }
private EntityRelationshipsResult mapEntityRelationships ( @ Nullable final QueryContext context , final EntityRelationships entityRelationships , final RelationshipDirection relationshipDirection , final boolean includeSoftDelete ) { final EntityRelationshipsResult result = new EntityRelationshipsResult ( ) ; final Set < Urn > existentUrns ; if ( context != null && _entityService != null && ! includeSoftDelete ) { Set < Urn > allRelatedUrns = entityRelationships . getRelationships ( ) . stream ( ) . map ( EntityRelationship :: getEntity ) . collect ( Collectors . toSet ( ) ) ; existentUrns = _entityService . exists ( context . getOperationContext ( ) , allRelatedUrns , false ) ; } else { existentUrns = null ; } List < EntityRelationship > viewable = entityRelationships . getRelationships ( ) . stream ( ) . filter ( rel -> ( existentUrns == null || existentUrns . contains ( rel . getEntity ( ) ) ) && ( context == null || canView ( context . getOperationContext ( ) , rel . getEntity ( ) ) ) ) . collect ( Collectors . toList ( ) ) ; result . setStart ( entityRelationships . getStart ( ) ) ; result . setCount ( viewable . size ( ) ) ; result . setTotal ( entityRelationships . getTotal ( ) - ( entityRelationships . getCount ( ) - viewable . size ( ) ) ) ; result . setRelationships ( viewable . stream ( ) . map ( entityRelationship -> mapEntityRelationship ( context , com . linkedin . datahub . graphql . generated . RelationshipDirection . valueOf ( relationshipDirection . name ( ) ) , entityRelationship ) ) . collect ( Collectors . toList ( ) ) ) ; return result ; }
public boolean charTyped ( CharInput input ) { try { for ( Cell < ? > cell : cells ) { if ( propagateEvents ( cell . widget ( ) ) && cell . widget ( ) . charTyped ( input ) ) return true ; } } catch ( ConcurrentModificationException ignored ) { } return super . charTyped ( input ) ; }
public @ NotNull ContentManagerImpl createContentManager ( @ NotNull ContentUI contentUI , boolean canCloseContents , @ NotNull Project project ) { return new ContentManagerImpl ( contentUI , canCloseContents , project ) ; }
public static void applyTrimPathIfNeeded ( Path path , @ Nullable TrimPathContent trimPath ) { if ( trimPath == null || trimPath . isHidden ( ) ) { return ; } float start = ( ( FloatKeyframeAnimation ) trimPath . getStart ( ) ) . getFloatValue ( ) ; float end = ( ( FloatKeyframeAnimation ) trimPath . getEnd ( ) ) . getFloatValue ( ) ; float offset = ( ( FloatKeyframeAnimation ) trimPath . getOffset ( ) ) . getFloatValue ( ) ; applyTrimPathIfNeeded ( path , start / 100f , end / 100f , offset / 360f ) ; }
public static TByte valueOf ( byte i ) { return byteCache [ i + 128 ] ; }
public Boolean alwaysFalse ( ) { return ROWS_CANNOT_MATCH ; }
private Time getTime ( final String startTime , final String endTime ) { final Time time = new Time ( ) ; parseTime ( startTime ) . ifPresent ( time :: setStart ) ; parseTime ( endTime ) . ifPresent ( time :: setStop ) ; if ( Objects . nonNull ( time . getStart ( ) ) && Objects . nonNull ( time . getStop ( ) ) ) { time . setDuration ( time . getStop ( ) - time . getStart ( ) ) ; } return time ; }
public int getYOffset ( ) { return mYOffset ; }
public void aaload ( ) { visitInsn ( Opcodes . AALOAD ) ; }
protected MethodDelegationBinder . ParameterBinding < ? > bind ( FieldDescription fieldDescription , AnnotationDescription . Loadable < FieldGetterHandle > annotation , MethodDescription source , ParameterDescription target , Implementation . Target implementationTarget , Assigner assigner ) { if ( ! target . getType ( ) . asErasure ( ) . isAssignableFrom ( JavaType . METHOD_HANDLE . getTypeStub ( ) ) ) { throw new IllegalStateException ( "Cannot assign method handle to " + target ) ; } else if ( fieldDescription . isStatic ( ) ) { return new MethodDelegationBinder . ParameterBinding . Anonymous ( JavaConstant . MethodHandle . ofGetter ( fieldDescription . asDefined ( ) ) . toStackManipulation ( ) ) ; } else { return new MethodDelegationBinder . ParameterBinding . Anonymous ( new StackManipulation . Compound ( JavaConstant . MethodHandle . ofGetter ( fieldDescription . asDefined ( ) ) . toStackManipulation ( ) , MethodVariableAccess . loadThis ( ) , MethodInvocation . invoke ( new MethodDescription . Latent ( JavaType . METHOD_HANDLE . getTypeStub ( ) , new MethodDescription . Token ( "bindTo" , Opcodes . ACC_PUBLIC , JavaType . METHOD_HANDLE . getTypeStub ( ) . asGenericType ( ) , new TypeList . Generic . Explicit ( TypeDefinition . Sort . describe ( Object . class ) ) ) ) ) ) ) ; } }
public void setValue ( ObservableValue value ) { this . value = value ; }
public int getNumberOfUserRecords ( ) { synchronized ( this ) { return userMap . size ( ) ; } }
private static int x2c ( byte b1 , byte b2 ) { int digit = ( b1 >= 'A' ) ? ( ( b1 & 0xDF ) - 'A' ) + 10 : ( b1 - '0' ) ; digit *= 16 ; digit += ( b2 >= 'A' ) ? ( ( b2 & 0xDF ) - 'A' ) + 10 : ( b2 - '0' ) ; return digit ; }
private ConstantDynamic readConstantDynamic ( final int constantPoolEntryIndex , final char [ ] charBuffer ) { ConstantDynamic constantDynamic = ( ConstantDynamic ) cpInfoValues [ constantPoolEntryIndex ] ; if ( constantDynamic != null ) { return constantDynamic ; } int cpInfoOffset = cpInfoOffsets [ constantPoolEntryIndex ] ; int nameAndTypeCpInfoOffset = cpInfoOffsets [ readUnsignedShort ( cpInfoOffset + 2 ) ] ; String name = readUTF8 ( nameAndTypeCpInfoOffset , charBuffer ) ; String descriptor = readUTF8 ( nameAndTypeCpInfoOffset + 2 , charBuffer ) ; int bootstrapMethodOffset = bootstrapMethodOffsets [ readUnsignedShort ( cpInfoOffset ) ] ; Handle handle = ( Handle ) readConst ( readUnsignedShort ( bootstrapMethodOffset ) , charBuffer ) ; Object [ ] bootstrapMethodArguments = new Object [ readUnsignedShort ( bootstrapMethodOffset + 2 ) ] ; bootstrapMethodOffset += 4 ; for ( int i = 0 ; i < bootstrapMethodArguments . length ; i ++ ) { bootstrapMethodArguments [ i ] = readConst ( readUnsignedShort ( bootstrapMethodOffset ) , charBuffer ) ; bootstrapMethodOffset += 2 ; } constantDynamic = new ConstantDynamic ( name , descriptor , handle , bootstrapMethodArguments ) ; cpInfoValues [ constantPoolEntryIndex ] = constantDynamic ; return constantDynamic ; }
public void setTip ( String tip ) { this . tip = tip ; this . label . setText ( tip ) ; }
public int size ( ) { if ( isA ) { return keysASize ; } else { return keysBSize ; } }
public String toExampleValue ( Schema schema ) { return toExampleValueRecursive ( schema , new ArrayList < > ( ) , 5 ) ; }
public void onBindViewHolder ( int section , int position , RecyclerView . ViewHolder holder ) { if ( holder . getItemViewType ( ) == TYPE_COUNTRY ) { ArrayList < Country > arr = countries . get ( sortedCountries . get ( section ) ) ; Country c = arr . get ( position ) ; TextSettingsCell settingsCell = ( TextSettingsCell ) holder . itemView ; settingsCell . setTextAndValue ( Emoji . replaceEmoji ( getCountryNameWithFlag ( c ) , settingsCell . getTextView ( ) . getPaint ( ) . getFontMetricsInt ( ) , false ) , needPhoneCode ? "+" + c . code : null , false ) ; } }
final int getFirstAttributeOffset ( ) { int currentOffset = header + 8 + readUnsignedShort ( header + 6 ) * 2 ; int fieldsCount = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; while ( fieldsCount -- > 0 ) { int attributesCount = readUnsignedShort ( currentOffset + 6 ) ; currentOffset += 8 ; while ( attributesCount -- > 0 ) { currentOffset += 6 + readInt ( currentOffset + 2 ) ; } } int methodsCount = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; while ( methodsCount -- > 0 ) { int attributesCount = readUnsignedShort ( currentOffset + 6 ) ; currentOffset += 8 ; while ( attributesCount -- > 0 ) { currentOffset += 6 + readInt ( currentOffset + 2 ) ; } } return currentOffset + 2 ; }
public void execute ( String label , IArgConsumer args ) throws CommandException { args . requireMin ( 1 ) ; FollowGroup group ; FollowList list ; List < Entity > entities = new ArrayList < > ( ) ; List < EntityType > classes = new ArrayList < > ( ) ; if ( args . hasExactlyOne ( ) ) { baritone . getFollowProcess ( ) . follow ( ( group = args . getEnum ( FollowGroup . class ) ) . filter ) ; } else { args . requireMin ( 2 ) ; group = null ; list = args . getEnum ( FollowList . class ) ; while ( args . hasAny ( ) ) { Object gotten = args . getDatatypeFor ( list . datatype ) ; if ( gotten instanceof EntityType ) { classes . add ( ( EntityType ) gotten ) ; } else if ( gotten != null ) { entities . add ( ( Entity ) gotten ) ; } } baritone . getFollowProcess ( ) . follow ( classes . isEmpty ( ) ? entities :: contains : e -> classes . stream ( ) . anyMatch ( c -> e . getType ( ) . equals ( c ) ) ) ; } if ( group != null ) { logDirect ( String . format ( "Following all %s" , group . name ( ) . toLowerCase ( Locale . US ) ) ) ; } else { if ( classes . isEmpty ( ) ) { if ( entities . isEmpty ( ) ) throw new NoEntitiesException ( ) ; logDirect ( "Following these entities:" ) ; entities . stream ( ) . map ( Entity :: toString ) . forEach ( this :: logDirect ) ; } else { logDirect ( "Following these types of entities:" ) ; classes . stream ( ) . map ( BuiltInRegistries . ENTITY_TYPE :: getKey ) . map ( Objects :: requireNonNull ) . map ( ResourceLocation :: toString ) . forEach ( this :: logDirect ) ; } } }
public boolean onTouchEvent ( MotionEvent event ) { mLastX = ( int ) event . getX ( ) ; mLastY = ( int ) event . getY ( ) ; onUpdateColorSelection ( mLastX , mLastY ) ; invalidate ( ) ; switch ( event . getAction ( ) ) { case MotionEvent . ACTION_DOWN : getParent ( ) . requestDisallowInterceptTouchEvent ( true ) ; break ; case MotionEvent . ACTION_UP : case MotionEvent . ACTION_CANCEL : getParent ( ) . requestDisallowInterceptTouchEvent ( false ) ; break ; } return super . onTouchEvent ( event ) ; }
private void setMaxL ( int maxL ) { sentenceListProcessed . setMaxL ( maxL ) ; }
public void addTransceiver ( MediaStreamTrack track , Map < String , Object > transceiverInit , Result result ) { RtpTransceiver transceiver ; if ( transceiverInit != null ) { transceiver = peerConnection . addTransceiver ( track , mapToRtpTransceiverInit ( transceiverInit ) ) ; } else { transceiver = peerConnection . addTransceiver ( track ) ; } String transceiverId = transceiver . getMid ( ) ; if ( null == transceiverId ) { transceiverId = stateProvider . getNextStreamUUID ( ) ; } transceivers . put ( transceiverId , transceiver ) ; result . success ( transceiverToMap ( transceiverId , transceiver ) ) ; }
private void updateActions ( final NotificationCompat . Builder builder ) { builder . mActions . clear ( ) ; for ( int i = 0 ; i < 5 ; ++ i ) { addAction ( builder , notificationSlots [ i ] ) ; } }
public void setSecret ( @ Nullable String secret ) { this . secret = secret ; }
public Module with ( ) { return with ( Arrays . asList ( ) ) ; }
public boolean isHttpEnabled ( ) { return httpEnabled ; }
public Boolean findMergeInfo ( MapperConfig < ? > config , Annotated a ) { return null ; }
public CanBeAnnotated getAnnotatedElement ( ) { return annotatedElement ; }
public LifecycleTransaction tryModify ( Iterable < ? extends SSTableReader > sstables , OperationType operationType ) { return tryModify ( sstables , operationType , TimeUUID . Generator . nextTimeUUID ( ) ) ; }
private void validatePath ( String path ) { char [ ] chars = path . toCharArray ( ) ; for ( char ch : chars ) { if ( ch < 0x20 || ch > 0x7E || ch == ';' ) { throw new IllegalArgumentException ( sm . getString ( "rfc6265CookieProcessor.invalidPath" , path ) ) ; } } }
public String getTimeZoneDisplayName ( String tzID , NameType type ) { if ( tzID == null || tzID . length ( ) == 0 ) { return null ; } return loadTimeZoneNames ( tzID ) . getName ( type ) ; }
public void setExpiresTime ( long expiresTime ) { this . expiresTime = expiresTime ; }
public ExportResult < VideosContainerResource > export ( UUID jobId , TokensAndUrlAuthData authData , Optional < ExportInformation > exportInformation ) throws CopyExceptionWithFailureReason { Preconditions . checkNotNull ( authData ) ; KoofrClient koofrClient = koofrClientFactory . create ( authData ) ; KoofrMediaExport export = new KoofrMediaExport ( koofrClient , monitor ) ; try { export . export ( ) ; List < VideoAlbum > exportAlbums = export . getVideoAlbums ( ) ; List < VideoModel > exportVideos = export . getVideos ( ) ; VideosContainerResource containerResource = new VideosContainerResource ( exportAlbums , exportVideos ) ; return new ExportResult < > ( ExportResult . ResultType . END , containerResource , null ) ; } catch ( IOException e ) { return new ExportResult < > ( e ) ; } }
public void setRecoveryRetry ( String recoveryRetry ) { this . recoveryRetry = recoveryRetry ; }
public int delete ( List < Long > ids ) { SmsHomeRecommendSubjectExample example = new SmsHomeRecommendSubjectExample ( ) ; example . createCriteria ( ) . andIdIn ( ids ) ; return recommendProductMapper . deleteByExample ( example ) ; }
public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { if ( executor . isShutdown ( ) ) { return ; } try { executor . getQueue ( ) . put ( r ) ; } catch ( InterruptedException e ) { log . error ( "Adding Queue task to thread pool failed." , e ) ; } }
public String replaceSidebar ( String html , Map < String , List < Images > > monthMap , String nowMonth ) { StringBuilder sidebar = new StringBuilder ( ) ; for ( String month : monthMap . keySet ( ) ) { String sidabarMenu = Sidebar . getSidabarMenuList ( month + ".html" , month ) ; if ( month != null && month . equals ( nowMonth ) ) { sidabarMenu = sidabarMenu . replace ( Sidebar . VAR_SIDABAR_COLOR , Sidebar . VAR_SIDABAR_NOW_COLOR ) ; } sidebar . append ( sidabarMenu ) ; } return html . replace ( Sidebar . VAR_SIDABAR , sidebar . toString ( ) ) ; }
public JsonNode getClaimValue ( ) { return claimValue ; }
void onViewPagerPageChanged ( int position , float positionOffset ) { mSelectedPosition = position ; mSelectionOffset = positionOffset ; invalidate ( ) ; }
public static XmlPath from ( File file ) { return new XmlPath ( file ) ; }
public String [ ] getResulSets ( ) { return resultSets ; }
public void terminate ( ) { if ( started ) { stop ( ) ; } for ( Service < T > s : services ) { s . terminate ( getParent ( ) ) ; } }
public void appStateChanged ( AppState state ) { Context context = getContext ( ) ; if ( context == null ) return ; if ( mMenu != null ) { if ( ( state == AppState . running ) || ( state == AppState . stopping ) ) { mStartBtn . setVisible ( false ) ; mStopBtn . setEnabled ( true ) ; mStopBtn . setVisible ( ! CaptureService . isAlwaysOnVPN ( ) ) ; mMenuSettings . setEnabled ( false ) ; mOpenPcap . setEnabled ( false ) ; mDecryptPcap . setEnabled ( false ) ; } else { mStopBtn . setVisible ( false ) ; mStartBtn . setEnabled ( true ) ; mStartBtn . setVisible ( ! CaptureService . isAlwaysOnVPN ( ) ) ; mMenuSettings . setEnabled ( true ) ; mOpenPcap . setEnabled ( true ) ; mDecryptPcap . setEnabled ( true ) ; } } switch ( state ) { case ready : mCaptureStatus . setText ( R . string . ready ) ; mCollectorInfoLayout . setVisibility ( View . GONE ) ; mInterfaceInfo . setVisibility ( View . GONE ) ; mQuickSettings . setVisibility ( View . VISIBLE ) ; mAppFilter = Prefs . getAppFilter ( mPrefs ) ; refreshFilterInfo ( ) ; break ; case starting : if ( mMenu != null ) mStartBtn . setEnabled ( false ) ; break ; case stopping : if ( mMenu != null ) mStopBtn . setEnabled ( false ) ; break ; case running : mCaptureStatus . setText ( Utils . formatBytes ( CaptureService . getBytes ( ) ) ) ; mCollectorInfoLayout . setVisibility ( View . VISIBLE ) ; mQuickSettings . setVisibility ( View . GONE ) ; CaptureService service = CaptureService . requireInstance ( ) ; if ( CaptureService . isDecryptingTLS ( ) ) { refreshDecryptionStatus ( ) ; mInterfaceInfo . setVisibility ( View . VISIBLE ) ; } else if ( CaptureService . isCapturingAsRoot ( ) ) { String capiface = service . getCaptureInterface ( ) ; if ( capiface . equals ( "@inet" ) ) capiface = getString ( R . string . internet ) ; else if ( capiface . equals ( "any" ) ) capiface = getString ( R . string . all_interfaces ) ; mInterfaceInfo . setText ( String . format ( getResources ( ) . getString ( R . string . capturing_from ) , capiface ) ) ; mInterfaceInfo . setVisibility ( View . VISIBLE ) ; } else if ( service . getSocks5Enabled ( ) == 1 ) { mInterfaceInfo . setText ( String . format ( getResources ( ) . getString ( R . string . socks5_info ) , service . getSocks5ProxyAddress ( ) , service . getSocks5ProxyPort ( ) ) ) ; mInterfaceInfo . setVisibility ( View . VISIBLE ) ; } else mInterfaceInfo . setVisibility ( View . GONE ) ; mAppFilter = CaptureService . getAppFilter ( ) ; refreshPcapDumpInfo ( context ) ; break ; default : break ; } }
public void reset ( ) { toTop ( ) ; }
Long update ( Long dst , Long src ) { if ( src == null ) { return dst ; } if ( dst == null ) { return src ; } return dst + src ; }
public static RectF trapToRect ( float [ ] array ) { RectF r = new RectF ( Float . POSITIVE_INFINITY , Float . POSITIVE_INFINITY , Float . NEGATIVE_INFINITY , Float . NEGATIVE_INFINITY ) ; for ( int i = 1 ; i < array . length ; i += 2 ) { float x = Math . round ( array [ i - 1 ] * 10 ) / 10.f ; float y = Math . round ( array [ i ] * 10 ) / 10.f ; r . left = ( x < r . left ) ? x : r . left ; r . top = ( y < r . top ) ? y : r . top ; r . right = ( x > r . right ) ? x : r . right ; r . bottom = ( y > r . bottom ) ? y : r . bottom ; } r . sort ( ) ; return r ; }
public Class < ? extends Decorator > [ ] before ( ) { return new Class [ ] { AddCustomResourceDefinitionVersionDecorator . class , CustomResourceDefinitionDecorator . class } ; }
public Object getStyleableValue ( JComponent c , String key ) { return getStyleableValue ( this , renderer , key ) ; }
public void setCountrySelectActivityDelegate ( CountrySelectActivityDelegate delegate ) { this . delegate = delegate ; }
public boolean isScopeSet ( ) { return isScopeSet ; }
public static < T > ResponseDTO < T > error ( ErrorCode errorCode , String msg ) { return new ResponseDTO < > ( errorCode , false , msg , null ) ; }
public List < SubscribeTaskInfo > getAllTaskInfo ( ) { String scanKey = String . format ( "%s_%s_*" , prefix , userSetting . getServerId ( ) ) ; List < Object > values = RedisUtil . scan ( redisTemplate , scanKey ) ; if ( values . isEmpty ( ) ) { return new ArrayList < > ( ) ; } List < SubscribeTaskInfo > result = new ArrayList < > ( ) ; for ( Object value : values ) { String redisKey = ( String ) value ; SubscribeTaskInfo taskInfo = ( SubscribeTaskInfo ) redisTemplate . opsForValue ( ) . get ( redisKey ) ; if ( taskInfo == null ) { continue ; } Long expire = redisTemplate . getExpire ( redisKey , TimeUnit . SECONDS ) ; taskInfo . setExpireTime ( expire ) ; result . add ( taskInfo ) ; } return result ; }
public void setDecryptionCertificate ( X509Certificate decryptionCertificate ) { this . decryptionCertificate = decryptionCertificate ; }
default Base64Value decryptFromString ( String cipherText ) { Matcher matcher = PREFIX_PATTERN . matcher ( cipherText ) ; if ( matcher . matches ( ) ) { return decrypt ( Base64Value . createFromEncoded ( matcher . group ( 2 ) ) ) ; } else { throw new CryptoException ( "String does not contain Helidon prefix: " + cipherText ) ; } }
private Builder require ( UpdateRequirement requirement ) { Preconditions . checkArgument ( requirement != null , "Invalid requirement: null" ) ; requirements . add ( requirement ) ; return this ; }
public static double getDouble ( ) { return r . nextDouble ( ) ; }
public void setAsyncSupported ( boolean isAsyncSupported ) { illegalStateIfContextStarted ( ) ; Holder . this . setAsyncSupported ( isAsyncSupported ) ; }
public int getPriority ( ) { return DEFAULT_PRIORITY ; }
protected void initViews ( final View rootView , final Bundle savedInstanceState ) { }
public void setIllustJson ( String illustJson ) { this . illustJson = illustJson ; }
void setLimit ( int limit ) { if ( detached ) this . limit = limit ; else decoder . limit = limit ; }
public void setDatabaseParam ( DatabaseParam databaseOptions ) { if ( databaseOptions == null ) { throw new IllegalArgumentException ( "Parameter databaseOptions must not be null." ) ; } setDatabaseOptions ( databaseOptions ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + " [apiGroup=" + apiGroup + ", kind=" + kind + ", name=" + name + ", plural=" + plural + ", scope=" + scope + "]" ; }
public int getIndex ( ) { return index ; }
public QueryId getQueryId ( ) { return queryId ; }
public Country getItem ( int i ) { if ( searchResult == null || i < 0 || i >= searchResult . size ( ) ) { return null ; } return searchResult . get ( i ) ; }
public BrowserPublicKeyCredentialCreationOptions . Builder setOrigin ( @ NonNull Uri origin ) { this . origin = origin ; return this ; }
public static PDObjectStream createStream ( PDDocument document ) { COSStream cosStream = document . getDocument ( ) . createCOSStream ( ) ; PDObjectStream strm = new PDObjectStream ( cosStream ) ; strm . getCOSObject ( ) . setItem ( COSName . TYPE , COSName . OBJ_STM ) ; return strm ; }
public Local getReferenceLocal ( Local element ) { return localsToReference . get ( element ) ; }
public GenericDraweeHierarchyBuilder setActualImageFocusPoint ( @ Nullable PointF focusPoint ) { mActualImageFocusPoint = focusPoint ; return this ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( "class V1ExactDeviceRequest {\n" ) ; sb . append ( "    adminAccess: " ) . append ( toIndentedString ( adminAccess ) ) . append ( "\n" ) ; sb . append ( "    allocationMode: " ) . append ( toIndentedString ( allocationMode ) ) . append ( "\n" ) ; sb . append ( "    capacity: " ) . append ( toIndentedString ( capacity ) ) . append ( "\n" ) ; sb . append ( "    count: " ) . append ( toIndentedString ( count ) ) . append ( "\n" ) ; sb . append ( "    deviceClassName: " ) . append ( toIndentedString ( deviceClassName ) ) . append ( "\n" ) ; sb . append ( "    selectors: " ) . append ( toIndentedString ( selectors ) ) . append ( "\n" ) ; sb . append ( "    tolerations: " ) . append ( toIndentedString ( tolerations ) ) . append ( "\n" ) ; sb . append ( "}" ) ; return sb . toString ( ) ; }
public NDArray trunc ( ) { return getAlternativeArray ( ) . trunc ( ) ; }
public void executeVoid ( Connection conn ) throws JobPersistenceException { releaseAcquiredTrigger ( conn , trigger ) ; }
public void setRunType ( String runType ) { this . runType = runType ; }
private void restructureIfNecessary ( boolean allowResize ) { int currCount = this . count . get ( ) ; boolean needsResize = allowResize && ( currCount > 0 && currCount >= this . resizeThreshold ) ; Reference < K , V > ref = this . referenceManager . pollForPurge ( ) ; if ( ref != null || ( needsResize ) ) { restructure ( allowResize , ref ) ; } }
public BasePopupWindow setAutoShowKeyboard ( boolean autoShow ) { return setAutoShowKeyboard ( null , autoShow ) ; }
public void addHeader ( final HttpString name , final String value ) { if ( name == null ) { throw UndertowServletMessages . MESSAGES . headerNameWasNull ( ) ; } if ( Bits . anyAreSet ( flags , INSIDE_INCLUDE_FLAG | IGNORED_FLUSH_PERFORMED_FLAG | TREAT_AS_COMMITTED_FLAG | CONTENT_FULLY_WRITTEN_FLAG ) ) { return ; } if ( name . equals ( Headers . CONTENT_TYPE ) && ! exchange . getResponseHeaders ( ) . contains ( Headers . CONTENT_TYPE ) ) { setContentType ( value ) ; } else { exchange . getResponseHeaders ( ) . add ( name , value ) ; } }
public static void setIsLightNavigationBar ( boolean isLight ) { isLightNavigationBar = isLight ? 1 : - 1 ; }
protected PageData < DeviceProfile > findEntities ( TenantId tenantId , TenantId id , PageLink pageLink ) { return deviceProfileDao . findDeviceProfiles ( id , pageLink ) ; }
public static ComponentUI createUI ( JComponent c ) { return new MotifEditorPaneUI ( ) ; }
public static synchronized CertificateProviderRegistry getInstance ( ) { if ( instance == null ) { instance = new CertificateProviderRegistry ( ) ; instance . register ( new FileWatcherCertificateProviderProvider ( ) ) ; } return instance ; }
public List < PremiumTool > getPremiumTools ( ) { try { return Arrays . asList ( mapper . readValue ( new URL ( appBrand . property ( BrandableProperty . PREMIUM_TOOLS_URL ) ) , PremiumTool [ ] . class ) ) ; } catch ( IOException e ) { LOG . warn ( i18n ( ) . tr ( "Unable to retrieve premium features description" ) , e ) ; } return Collections . emptyList ( ) ; }
public Criteria andNameNotEqualTo ( String value ) { addCriterion ( "`name` <>" , value , "name" ) ; return ( Criteria ) this ; }
public void setAlert ( boolean alert ) { this . alert = alert ; }
public void setApplicationContext ( ApplicationContext applicationContext ) throws BeansException { this . appCtx = applicationContext ; }
public TenantInfo mapRow ( ResultSet rs , int rowNum ) throws SQLException { TenantInfo info = new TenantInfo ( ) ; info . setTenantId ( rs . getString ( "tenant_id" ) ) ; info . setTenantName ( rs . getString ( "tenant_name" ) ) ; info . setTenantDesc ( rs . getString ( "tenant_desc" ) ) ; return info ; }
protected void onDetachedFromWindow ( ) { AndroidUtilities . checkAndroidTheme ( context , false ) ; super . onDetachedFromWindow ( ) ; }
protected StreamingService getService ( ) { return streamInfo . getService ( ) ; }
public void checkClientTrusted ( X509Certificate [ ] certs , String authType ) { }
public boolean isSuspended ( ) { return Status . SUSPENDED == status ; }
public void setSeeds ( SeedModule seeds ) { this . seeds = seeds ; }
public SecurityScheme in ( In in ) { this . in = in ; return this ; }
public boolean shellOnly ( ) { return true ; }
public int throttleTimeMs ( ) { return data . throttleTimeMs ( ) ; }
default JSONMap < M , L > setCast ( String keyTypes ) { return puts ( KEY_CAST , keyTypes ) ; }
protected long transferContentTo ( WritableByteChannel target ) throws IOException { return transfer ( contentBuffer , target , MultipartState . POST_CONTENT ) ; }
public void setLineSpacingAdd ( float spacingAdd ) { collapsingTitleHelper . setLineSpacingAdd ( spacingAdd ) ; }
public void onClick ( View v ) { ListItem item = ( ListItem ) v . getTag ( ) ; if ( item != null && item . getViewType ( ) == ListItem . TYPE_CUSTOM_INLINE ) { if ( adapter . isInSelectMode ( ) ) { toggleSelected ( item ) ; return ; } InlineResult < ? > result = ( InlineResult < ? > ) item . getData ( ) ; switch ( result . getType ( ) ) { case InlineResult . TYPE_AUDIO : case InlineResult . TYPE_VOICE : { tdlib . context ( ) . player ( ) . playPauseMessage ( tdlib , result . getMessage ( ) , this ) ; break ; } case InlineResult . TYPE_DOCUMENT : { ( ( InlineResultCommon ) result ) . performClick ( v ) ; break ; } case InlineResult . TYPE_ARTICLE : { tdlib . ui ( ) . openMessage ( this , chatId , new MessageId ( chatId , result . getQueryId ( ) ) , new TdlibUi . UrlOpenParameters ( ) . tooltip ( context ( ) . tooltipManager ( ) . builder ( v ) ) ) ; break ; } } } }
public static InputStream getUrlStream ( String urlPath ) throws IOException { logger . info ( "Read contents from remote uri:{}" , urlPath ) ; URL url = new URL ( urlPath ) ; URLConnection connection = url . openConnection ( ) ; connection . addRequestProperty ( "User-Agent" , "Mozilla/4.0" ) ; connection . setConnectTimeout ( 15000 ) ; connection . setReadTimeout ( 15000 ) ; InputStream inputStream = connection . getInputStream ( ) ; if ( connection instanceof HttpURLConnection ) { if ( 200 != ( ( HttpURLConnection ) connection ) . getResponseCode ( ) ) { throw new IOException ( "get url " + urlPath + " content error, response status: " + ( ( HttpURLConnection ) connection ) . getResponseCode ( ) ) ; } } return inputStream ; }
String name ( ) ; default boolean isMethod ( ) { return false ; }
static TrackingToken unwrapLowerBound ( TrackingToken token ) { return token instanceof WrappedToken ? ( ( WrappedToken ) token ) . lowerBound ( ) : token ; }
public CharSequence format ( CharSequence value , int index ) { return NOT_DIGITS_OR_PLUS . matcher ( ContactEncoder . formatPhone ( value . toString ( ) ) ) . replaceAll ( "" ) ; }
public final void showUnsavedChangesPromptBeforeLeaving ( @ Nullable Runnable onConfirm ) { showUnsavedChangesPromptBeforeLeaving ( null , Lang . getString ( R . string . DiscardChanges ) , onConfirm ) ; }
public void onAnimationEnd ( Animator animation ) { expandedView . setVisibility ( View . GONE ) ; }
public static RowType variantFileType ( Type fileType ) { boolean isShredded = fileType . asGroupType ( ) . containsField ( PaimonShreddingUtils . TYPED_VALUE_FIELD_NAME ) ; if ( isShredded ) { return ( RowType ) ParquetSchemaConverter . convertToPaimonField ( fileType ) . type ( ) ; } else { List < DataField > dataFields = new ArrayList < > ( ) ; dataFields . add ( new DataField ( 0 , VALUE , DataTypes . BYTES ( ) . notNull ( ) ) ) ; dataFields . add ( new DataField ( 1 , METADATA , DataTypes . BYTES ( ) . notNull ( ) ) ) ; return new RowType ( dataFields ) ; } }
public StringBuilder read ( MemoryBuffer buffer ) { return new StringBuilder ( stringSerializer . readJavaString ( buffer ) ) ; }
private static void writeFieldSchema ( Schema schema , Writer writer , Set < String > alreadyDeclared , Set < Schema > toDeclare , String recordNameSpace ) throws IOException { Schema . Type type = schema . getType ( ) ; if ( type == Schema . Type . RECORD || type == Schema . Type . ENUM || type == Schema . Type . FIXED ) { if ( Objects . equals ( recordNameSpace , schema . getNamespace ( ) ) ) { writer . append ( schema . getName ( ) ) ; } else { writer . append ( schema . getFullName ( ) ) ; } if ( ! alreadyDeclared . contains ( schema . getFullName ( ) ) ) { toDeclare . add ( schema ) ; } } else if ( type == Schema . Type . ARRAY ) { writeJsonProperties ( schema , writer , null ) ; writer . append ( "array<" ) ; writeFieldSchema ( schema . getElementType ( ) , writer , alreadyDeclared , toDeclare , recordNameSpace ) ; writer . append ( '>' ) ; } else if ( type == Schema . Type . MAP ) { writeJsonProperties ( schema , writer , null ) ; writer . append ( "map<" ) ; writeFieldSchema ( schema . getValueType ( ) , writer , alreadyDeclared , toDeclare , recordNameSpace ) ; writer . append ( '>' ) ; } else if ( type == Schema . Type . UNION ) { Schema schemaForNullableSyntax = getNullableUnionType ( schema ) ; if ( schemaForNullableSyntax != null ) { writeFieldSchema ( schemaForNullableSyntax , writer , alreadyDeclared , toDeclare , recordNameSpace ) ; writer . append ( '?' ) ; } else { writer . append ( "union{" ) ; List < Schema > types = schema . getTypes ( ) ; Iterator < Schema > iterator = types . iterator ( ) ; if ( iterator . hasNext ( ) ) { writeFieldSchema ( iterator . next ( ) , writer , alreadyDeclared , toDeclare , recordNameSpace ) ; while ( iterator . hasNext ( ) ) { writer . append ( ", " ) ; writeFieldSchema ( iterator . next ( ) , writer , alreadyDeclared , toDeclare , recordNameSpace ) ; } } else { throw new AvroRuntimeException ( "Union schemas must have member types " + schema ) ; } writer . append ( '}' ) ; } } else { Set < String > propertiesToSkip = new HashSet < > ( ) ; String typeName ; if ( schema . getLogicalType ( ) == null ) { typeName = schema . getName ( ) ; } else { String logicalName = schema . getLogicalType ( ) . getName ( ) ; switch ( logicalName ) { case "date" : case "time-millis" : case "timestamp-millis" : propertiesToSkip . add ( "logicalType" ) ; typeName = logicalName . replace ( "-millis" , "_ms" ) ; break ; case "decimal" : propertiesToSkip . addAll ( asList ( "logicalType" , "precision" , "scale" ) ) ; LogicalTypes . Decimal decimal = ( LogicalTypes . Decimal ) schema . getLogicalType ( ) ; typeName = String . format ( "decimal(%d,%d)" , decimal . getPrecision ( ) , decimal . getScale ( ) ) ; break ; default : propertiesToSkip = Collections . emptySet ( ) ; typeName = schema . getName ( ) ; break ; } } writeJsonProperties ( schema , propertiesToSkip , writer , null ) ; writer . append ( typeName ) ; } }
public void ensureValid ( String name , Object value ) { base . ensureValid ( name . substring ( keyPrefix . length ( ) ) , value ) ; }
public DBManage getDBManage ( ) { return new HiveDBManage ( ) ; }
public String getArtifactsZipFile ( ) { if ( run . getHasArtifacts ( ) ) { return "/" + run . getUrl ( ) + "artifact/*zip*/archive.zip" ; } else { return null ; } }
protected boolean isExistingTransaction ( Object transaction ) { return false ; }
public Animation getDismissAnimation ( ) { return mHelper . mDismissAnimation ; }
boolean contains ( int v ) { return v >= start && v < end ; }
private float getViewPointY ( Point point ) { return getViewPointY ( point . y ) ; }
protected void onDraw ( Canvas c ) { if ( chat == null ) { return ; } final int chatListMode = getChatListMode ( ) ; boolean rtl = Lang . rtl ( ) ; int viewWidth = getMeasuredWidth ( ) ; if ( isDragging ) { c . drawColor ( ColorUtils . alphaColor ( .8f , Theme . fillingColor ( ) ) ) ; } c . drawText ( chat . getTime ( ) , ( rtl ? viewWidth - chat . getTimeLeft ( ) - chat . getTimeWidth ( ) : chat . getTimeLeft ( ) ) , getTitleTop ( chatListMode ) , timePaint ) ; Text title = chat . getTitle ( ) ; if ( title != null ) { int titleX = getLeftPadding ( chatListMode ) ; int titleTop = getTitleTop2 ( chatListMode ) ; if ( chat . isSecretChat ( ) ) { Drawable d = Icons . getSecureDrawable ( ) ; Drawables . drawRtl ( c , d , titleX - Screen . dp ( 7f ) , titleTop + title . getHeight ( ) / 2 - d . getMinimumHeight ( ) / 2 , Paints . getGreenPorterDuffPaint ( ) , viewWidth , rtl ) ; titleX += Screen . dp ( 14f ) ; } title . draw ( c , titleX , titleTop ) ; } EmojiStatusHelper . EmojiStatusDrawable emojiStatus = chat . getEmojiStatus ( ) ; if ( emojiStatus != null ) { emojiStatus . draw ( c , chat . getEmojiStatusLeft ( ) , getTitleTop2 ( chatListMode ) , 1f , emojiStatusReceiver ) ; } if ( chat . showVerify ( ) ) { Drawables . drawRtl ( c , Icons . getChatVerifyDrawable ( ) , chat . getVerifyLeft ( ) , getMuteTop ( chatListMode ) , Paints . getVerifyPaint ( ) , viewWidth , rtl ) ; } if ( ( chat . showScam ( ) || chat . showFake ( ) ) && chat . getChatMark ( ) != null ) { int additionalPadding = Screen . dp ( 4f ) ; int chatMarkLeft = chat . getVerifyLeft ( ) + Screen . dp ( 10f ) ; int chatMarkY = getTitleTop2 ( chatListMode ) + Screen . dp ( 0.5f ) ; RectF rct = Paints . getRectF ( ) ; rct . set ( chatMarkLeft - additionalPadding , chatMarkY , chatMarkLeft + chat . getChatMark ( ) . getWidth ( ) + additionalPadding , chatMarkY + chat . getChatMark ( ) . getLineHeight ( true ) ) ; c . drawRoundRect ( rct , Screen . dp ( 2f ) , Screen . dp ( 2f ) , Paints . getProgressPaint ( Theme . getColor ( ColorId . textNegative ) , Screen . dp ( 1.5f ) ) ) ; chat . getChatMark ( ) . draw ( c , chatMarkLeft , chatMarkY + Screen . dp ( 1f ) ) ; } if ( chat . showMute ( ) ) { Drawables . drawRtl ( c , Icons . getChatMuteDrawable ( ColorId . chatListMute ) , chat . getMuteLeft ( ) , getMuteTop ( chatListMode ) , Paints . getChatsMutePaint ( ) , viewWidth , rtl ) ; } if ( chat . isSending ( ) ) { int x = chat . getChecksRight ( ) - Screen . dp ( 10f ) - Screen . dp ( Icons . CLOCK_SHIFT_X ) ; Drawables . drawRtl ( c , Icons . getClockIcon ( ColorId . iconLight ) , x , getClockTop ( chatListMode ) - Screen . dp ( Icons . CLOCK_SHIFT_Y ) , Paints . getIconLightPorterDuffPaint ( ) , viewWidth , rtl ) ; } else { int x = chat . getChecksRight ( ) ; int y = getClockTop ( chatListMode ) ; if ( chat . isOutgoing ( ) && ! chat . isSelfChat ( ) ) { if ( chat . showViews ( ) ) { y -= Screen . dp ( .5f ) ; } else if ( chat . isUnread ( ) ) { x += Screen . dp ( 4f ) ; } if ( chat . showViews ( ) ) { chat . getViewCounter ( ) . draw ( c , x + Screen . dp ( 3f ) , y + Screen . dp ( 14f ) / 2f , Gravity . RIGHT , 1f , this , ColorId . ticksRead ) ; x -= chat . getViewCounter ( ) . getScaledWidth ( Screen . dp ( 3 ) ) ; } else { int iconX = x - Screen . dp ( Icons . TICKS_SHIFT_X ) - Screen . dp ( 14f ) ; boolean unread = chat . isUnread ( ) ; Drawables . drawRtl ( c , unread ? Icons . getSingleTick ( ColorId . ticks ) : Icons . getDoubleTick ( ColorId . ticks ) , iconX , y - Screen . dp ( Icons . TICKS_SHIFT_Y ) , unread ? Paints . getTicksPaint ( ) : Paints . getTicksReadPaint ( ) , viewWidth , rtl ) ; x -= Screen . dp ( 24 - 8 + 3 ) ; } } if ( chat . needDrawReactionsPreview ( ) ) { chat . getReactionsCounterDrawable ( ) . draw ( c , x - chat . getReactionsWidth ( ) , y + Screen . dp ( 6f ) ) ; } } Counter counter = chat . getCounter ( ) ; float counterRight = viewWidth - getRightPadding ( ) ; float counterRadius = getCounterRadius ( ) ; float counterCenterY = getCounterTop ( chatListMode ) ; counter . draw ( c , counterRight - counterRadius , counterCenterY , Gravity . RIGHT , 1f ) ; counterRight -= counter . getScaledWidth ( getTimePaddingLeft ( ) ) ; Counter mentionCounter = chat . getMentionCounter ( ) ; mentionCounter . draw ( c , counterRight - counterRadius , counterCenterY , Gravity . RIGHT , 1f , this , ColorId . badgeText ) ; counterRight -= mentionCounter . getScaledWidth ( getTimePaddingLeft ( ) ) ; Counter reactionCounter = chat . getReactionsCounter ( ) ; reactionCounter . draw ( c , counterRight - counterRadius , counterCenterY , Gravity . RIGHT , 1f , this , chat . notificationsEnabled ( ) ? ColorId . badgeText : ColorId . badgeMutedText ) ; counterRight -= reactionCounter . getScaledWidth ( getTimePaddingLeft ( ) ) ; TdlibStatusManager . Helper status = chat . statusHelper ( ) ; TdlibStatusManager . ChatState state = status != null ? status . drawingState ( ) : null ; float statusVisibility = state != null ? state . visibility ( ) : 0f ; float textAlpha = 1f - statusVisibility ; if ( textAlpha > 0f ) { final int dy = ( int ) ( Screen . dp ( 14f ) * statusVisibility ) ; final boolean needRestore = dy != 0 ; final int saveCount ; if ( needRestore ) { saveCount = Views . save ( c ) ; c . translate ( 0 , dy ) ; } else { saveCount = - 1 ; } int textTop = getTextTop ( chatListMode ) ; Text prefix = chat . getPrefix ( ) ; if ( prefix != null ) { int titleColor = ColorUtils . alphaColor ( textAlpha , chat . showDraft ( ) ? Theme . textRedColor ( ) : Theme . textAccentColor ( ) ) ; prefix . draw ( c , getLeftPadding ( chatListMode ) , textTop , null , textAlpha ) ; } Text text = chat . getText ( ) ; if ( text != null ) { if ( chatListMode != Settings . CHAT_MODE_2LINE ) { if ( prefix != null ) { textTop += prefix . getNextLineHeight ( ) ; } else if ( text . getLineCount ( ) == 1 ) { textTop += getSingleLineOffset ( chatListMode ) ; } } IntList prefixIcons = chat . getTextIconIds ( ) ; if ( prefixIcons != null ) { int x = chat . getTextLeft ( ) ; for ( int i = 0 ; i < prefixIcons . size ( ) ; i ++ ) { Paint paint = PorterDuffPaint . get ( chat . getTextIconColorId ( ) , textAlpha ) ; int iconId = prefixIcons . get ( i ) ; Drawable d = getSparseDrawable ( iconId , ColorId . NONE ) ; int y = textTop + text . getLineHeight ( false ) / 2 - d . getMinimumHeight ( ) / 2 ; if ( iconId == R . drawable . baseline_camera_alt_16 ) { y += Screen . dp ( .5f ) ; } Drawables . drawRtl ( c , d , x , y , paint , viewWidth , rtl ) ; x += Screen . dp ( 18f ) ; } } text . draw ( c , chat . getTextLeft ( ) , textTop , null , textAlpha , textMediaReceiver ) ; } if ( needRestore ) { Views . restore ( c , saveCount ) ; } } if ( statusVisibility > 0f ) { Text text = status . drawingText ( ) ; if ( text != null ) { float top = getTextTop ( chatListMode ) - Screen . dp ( 14f ) * textAlpha ; if ( chatListMode != Settings . CHAT_MODE_2LINE && text . getLineCount ( ) == 1 ) { top += getSingleLineOffset ( chatListMode ) ; } DrawAlgorithms . drawStatus ( c , state , rtl ? viewWidth - getLeftPadding ( chatListMode ) : getLeftPadding ( chatListMode ) , top + text . getLineHeight ( ) / 2f , ColorUtils . alphaColor ( statusVisibility , text . getTextColor ( ) ) , this , statusVisibility == 1f ? ColorId . textLight : ColorId . NONE ) ; int x = getLeftPadding ( chatListMode ) ; text . draw ( c , x , ( int ) top , null , statusVisibility ) ; } } avatarReceiver . forceAllowOnline ( ! isSelected . getValue ( ) , 1f - isSelected . getFloatValue ( ) ) ; layoutReceiver ( ) ; if ( avatarReceiver . needPlaceholder ( ) ) { avatarReceiver . drawPlaceholder ( c ) ; } avatarReceiver . draw ( c ) ; DrawAlgorithms . drawIcon ( c , avatarReceiver , 315f , chat . getScheduleAnimator ( ) . getFloatValue ( ) , Theme . fillingColor ( ) , getSparseDrawable ( R . drawable . baseline_watch_later_10 , ColorId . badgeMuted ) , PorterDuffPaint . get ( ColorId . badgeMuted , chat . getScheduleAnimator ( ) . getFloatValue ( ) ) ) ; DrawAlgorithms . drawSimplestCheckBox ( c , avatarReceiver , isSelected . getFloatValue ( ) ) ; }
protected void testInsertRecord ( TSInsertRecordReq request ) throws IoTDBConnectionException , StatementExecutionException { final TSStatus status = callWithRetryAndReconnect ( ( ) -> { request . setSessionId ( sessionId ) ; return client . testInsertRecord ( request ) ; } ) . getResult ( ) ; RpcUtils . verifySuccess ( status ) ; }
public CorrelatedMessageSubscriptionFilter subscriptionKey ( final Long subscriptionKey ) { return subscriptionKey ( f -> f . eq ( subscriptionKey ) ) ; }
public ExecutionWriterTargetUnion getWriterTargetUnion ( ) { return writerTarget . map ( ExecutionWriterTargetUnion :: fromExecutionWriterTarget ) . orElse ( null ) ; }
public static < T extends RecordTemplate > AspectWithMetadata < T > from ( @ Nonnull T aspect , @ Nullable SystemMetadata systemMetadata ) { String version = extractVersion ( systemMetadata ) ; return new AspectWithMetadata < > ( aspect , systemMetadata , version ) ; }
private SentenceSuggestionsInfo [ ] splitAndSuggest ( TextInfo [ ] textInfos , int suggestionsLimit ) { if ( textInfos == null || textInfos . length == 0 ) { return SentenceLevelAdapter . getEmptySentenceSuggestionsInfo ( ) ; } SentenceLevelAdapter sentenceLevelAdapter ; synchronized ( this ) { sentenceLevelAdapter = mSentenceLevelAdapter ; if ( sentenceLevelAdapter == null ) { final String localeString = getLocale ( ) ; if ( ! TextUtils . isEmpty ( localeString ) ) { sentenceLevelAdapter = new SentenceLevelAdapter ( mResources , LocaleUtils . constructLocale ( localeString ) ) ; mSentenceLevelAdapter = sentenceLevelAdapter ; } } } if ( sentenceLevelAdapter == null ) { return SentenceLevelAdapter . getEmptySentenceSuggestionsInfo ( ) ; } final int infosSize = textInfos . length ; final SentenceSuggestionsInfo [ ] retval = new SentenceSuggestionsInfo [ infosSize ] ; for ( int i = 0 ; i < infosSize ; ++ i ) { final SentenceLevelAdapter . SentenceTextInfoParams textInfoParams = sentenceLevelAdapter . getSplitWords ( textInfos [ i ] ) ; final ArrayList < SentenceLevelAdapter . SentenceWordItem > mItems = textInfoParams . mItems ; final int itemsSize = mItems . size ( ) ; final TextInfo [ ] splitTextInfos = new TextInfo [ itemsSize ] ; for ( int j = 0 ; j < itemsSize ; ++ j ) { splitTextInfos [ j ] = mItems . get ( j ) . mTextInfo ; } retval [ i ] = SentenceLevelAdapter . reconstructSuggestions ( textInfoParams , onGetSuggestionsMultiple ( splitTextInfos , suggestionsLimit , true ) ) ; } return retval ; }
public static boolean isDameng ( String db ) { return DATABASE_DAMENG . equals ( db ) ; }
public static int andCardinality ( RoaringBitmap ... bitmaps ) { switch ( bitmaps . length ) { case 0 : return 0 ; case 1 : return bitmaps [ 0 ] . getCardinality ( ) ; case 2 : return RoaringBitmap . andCardinality ( bitmaps [ 0 ] , bitmaps [ 1 ] ) ; default : return workShyAndCardinality ( bitmaps ) ; } }
private static boolean canContainEqDeletesForFile ( DataFile dataFile , EqualityDeleteFile deleteFile ) { Map < Integer , ByteBuffer > dataLowers = dataFile . lowerBounds ( ) ; Map < Integer , ByteBuffer > dataUppers = dataFile . upperBounds ( ) ; boolean checkRanges = dataLowers != null && dataUppers != null && deleteFile . hasLowerAndUpperBounds ( ) ; Map < Integer , Long > dataNullCounts = dataFile . nullValueCounts ( ) ; Map < Integer , Long > dataValueCounts = dataFile . valueCounts ( ) ; Map < Integer , Long > deleteNullCounts = deleteFile . nullValueCounts ( ) ; Map < Integer , Long > deleteValueCounts = deleteFile . valueCounts ( ) ; for ( Types . NestedField field : deleteFile . equalityFields ( ) ) { if ( ! field . type ( ) . isPrimitiveType ( ) ) { continue ; } if ( containsNull ( dataNullCounts , field ) && containsNull ( deleteNullCounts , field ) ) { continue ; } if ( allNull ( dataNullCounts , dataValueCounts , field ) && allNonNull ( deleteNullCounts , field ) ) { return false ; } if ( allNull ( deleteNullCounts , deleteValueCounts , field ) && allNonNull ( dataNullCounts , field ) ) { return false ; } if ( ! checkRanges ) { continue ; } int id = field . fieldId ( ) ; ByteBuffer dataLower = dataLowers . get ( id ) ; ByteBuffer dataUpper = dataUppers . get ( id ) ; Object deleteLower = deleteFile . lowerBound ( id ) ; Object deleteUpper = deleteFile . upperBound ( id ) ; if ( dataLower == null || dataUpper == null || deleteLower == null || deleteUpper == null ) { continue ; } if ( ! rangesOverlap ( field , dataLower , dataUpper , deleteLower , deleteUpper ) ) { return false ; } } return true ; }
public Criteria andReportStatusIsNotNull ( ) { addCriterion ( "report_status is not null" ) ; return ( Criteria ) this ; }
public Long zcard ( String key ) { return jedisCommands . zcard ( key ) ; }
public void onClick ( View v ) { if ( isPlaying || isRecording ) { return ; } Intent intent = new Intent ( ) ; intent . setClass ( SmartPlayer . this , RecorderManager . class ) ; intent . putExtra ( "RecoderDir" , recDir ) ; startActivity ( intent ) ; }
public ExitMessage newExitMessage ( final EntryMessage message ) { return new SimpleExitMessage ( exitText , message ) ; }
public String generate ( PsiElement element ) { try { return LocalDateTime . now ( ) . format ( DateTimeFormatter . ofPattern ( getConfig ( ) . getDateFormat ( ) ) ) ; } catch ( Exception e ) { LOGGER . error ( "date format error" , e ) ; return LocalDateTime . now ( ) . format ( DateTimeFormatter . ofPattern ( Consts . DEFAULT_DATE_FORMAT ) ) ; } }
private static int parseUnsignedInt ( String s ) { if ( s == null || s . length ( ) == 0 ) return - 1 ; int result = 0 ; int i = 0 , max = s . length ( ) ; int digit ; int limit = - Integer . MAX_VALUE ; int multmin = limit / 10 ; if ( i < max ) { digit = Character . digit ( s . charAt ( i ++ ) , 10 ) ; if ( digit < 0 ) { return - 1 ; } else { result = - digit ; } } while ( i < max ) { digit = Character . digit ( s . charAt ( i ++ ) , 10 ) ; if ( digit < 0 ) { return - 1 ; } if ( result < multmin ) { return - 1 ; } result *= 10 ; if ( result < limit + digit ) { return - 1 ; } result -= digit ; } return - result ; }
public static double [ ] rgb2cielab ( double [ ] rgb ) { return xyz2lab ( rgb2xyz ( rgb ) ) ; }
public void setLoginId ( String loginId ) { this . loginId = loginId ; }
public static List < String > getApplicationNames ( int uid , Context context ) { List < String > listResult = new ArrayList < > ( ) ; if ( uid == 0 ) listResult . add ( context . getString ( R . string . title_root ) ) ; else if ( uid == 1013 ) listResult . add ( context . getString ( R . string . title_mediaserver ) ) ; else if ( uid == 9999 ) listResult . add ( context . getString ( R . string . title_nobody ) ) ; else { PackageManager pm = context . getPackageManager ( ) ; String [ ] pkgs = pm . getPackagesForUid ( uid ) ; if ( pkgs != null ) for ( String pkg : pkgs ) try { ApplicationInfo info = pm . getApplicationInfo ( pkg , 0 ) ; String name = pm . getApplicationLabel ( info ) . toString ( ) ; if ( ! TextUtils . isEmpty ( name ) ) listResult . add ( name ) ; } catch ( PackageManager . NameNotFoundException ignored ) { } Collections . sort ( listResult ) ; } return listResult ; }
public String getBetaDetails ( ) { return bdetails ; }
public void close ( ) throws IOException { ExceptionAccumulator accumulator = new ExceptionAccumulator ( ) ; for ( ServiceProvider < T > provider : Lists . newArrayList ( providers ) ) { CloseableUtils . closeQuietly ( provider ) ; } for ( Entry < T > entry : services . values ( ) ) { try { internalUnregisterService ( entry ) ; } catch ( KeeperException . NoNodeException ignore ) { } catch ( Exception e ) { accumulator . add ( e ) ; log . error ( "Could not unregister instance: " + entry . service . getName ( ) , e ) ; } } client . getConnectionStateListenable ( ) . removeListener ( connectionStateListener ) ; accumulator . propagate ( ) ; }
public boolean removeTrustedSigner ( Class < ? extends ApkSignaturePin > cls ) { for ( ApkSignaturePin pin : pinList ) { if ( pin . getClass ( ) . equals ( cls ) ) { return pinList . remove ( pin ) ; } } return false ; }
public String getGlobalRouteVersion ( ) { RuleEntity ruleEntity = pluginAdapter . getRule ( ) ; if ( ruleEntity != null ) { StrategyEntity strategyEntity = ruleEntity . getStrategyEntity ( ) ; if ( strategyEntity != null ) { return strategyEntity . getVersionValue ( ) ; } } return null ; }
public boolean isHeaderViewDetached ( ) { return true ; }
public String toString ( ) { return "UserIdentity{" + "userId='" + userId + '\'' + ", providerId='" + providerId + '\'' + '}' ; }
public World matchWorld ( World world ) { if ( world instanceof SpongeWorld ) { return world ; } else { for ( ServerWorld spongeWorld : Sponge . server ( ) . worldManager ( ) . worlds ( ) ) { if ( spongeWorld . key ( ) . toString ( ) . equals ( world . getName ( ) ) ) { return SpongeAdapter . adapt ( spongeWorld ) ; } } return null ; } }
private static boolean isEquals ( byte [ ] b1 , byte [ ] b2 ) { int len1 = b1 . length ; if ( b2 . length != len1 ) { return false ; } for ( int i = 0 ; i < len1 ; ++ i ) { if ( b1 [ i ] != b2 [ i ] ) { return false ; } } return true ; }
public void initialize ( ) { this . viewModel = new GeneralTabViewModel ( dialogService , preferences , httpServerManager , languageServerController , uiMessageHandler , remoteListenerServerManager , stateManager ) ; new ViewModelListCellFactory < Language > ( ) . withText ( Language :: getDisplayName ) . install ( language ) ; language . itemsProperty ( ) . bind ( viewModel . languagesListProperty ( ) ) ; language . valueProperty ( ) . bindBidirectional ( viewModel . selectedLanguageProperty ( ) ) ; fontOverride . selectedProperty ( ) . bindBidirectional ( viewModel . fontOverrideProperty ( ) ) ; fontSize . disableProperty ( ) . bind ( fontOverride . selectedProperty ( ) . not ( ) ) ; fontSize . getEditor ( ) . setAlignment ( Pos . CENTER_RIGHT ) ; fontSize . setValueFactory ( GeneralTabViewModel . fontSizeValueFactory ) ; fontSize . getEditor ( ) . textProperty ( ) . bindBidirectional ( viewModel . fontSizeProperty ( ) ) ; fontSize . getEditor ( ) . setTextFormatter ( fontSizeFormatter ) ; new ViewModelListCellFactory < ThemeTypes > ( ) . withText ( ThemeTypes :: getDisplayName ) . install ( theme ) ; theme . itemsProperty ( ) . bind ( viewModel . themesListProperty ( ) ) ; theme . valueProperty ( ) . bindBidirectional ( viewModel . selectedThemeProperty ( ) ) ; themeSyncOs . selectedProperty ( ) . bindBidirectional ( viewModel . themeSyncOsProperty ( ) ) ; customThemePath . textProperty ( ) . bindBidirectional ( viewModel . customPathToThemeProperty ( ) ) ; EasyBind . subscribe ( viewModel . selectedThemeProperty ( ) , theme -> { boolean isCustomTheme = theme == ThemeTypes . CUSTOM ; customThemePath . disableProperty ( ) . set ( ! isCustomTheme ) ; customThemeBrowse . disableProperty ( ) . set ( ! isCustomTheme ) ; } ) ; validationVisualizer . setDecoration ( new IconValidationDecorator ( ) ) ; openLastStartup . selectedProperty ( ) . bindBidirectional ( viewModel . openLastStartupProperty ( ) ) ; showAdvancedHints . selectedProperty ( ) . bindBidirectional ( viewModel . showAdvancedHintsProperty ( ) ) ; confirmDelete . selectedProperty ( ) . bindBidirectional ( viewModel . confirmDeleteProperty ( ) ) ; shouldAskForIncludingCrossReferences . selectedProperty ( ) . bindBidirectional ( viewModel . shouldAskForIncludingCrossReferences ( ) ) ; confirmHideTabBar . selectedProperty ( ) . bindBidirectional ( viewModel . confirmHideTabBarProperty ( ) ) ; donationNeverShow . selectedProperty ( ) . bindBidirectional ( viewModel . donationNeverShowProperty ( ) ) ; new ViewModelListCellFactory < BibDatabaseMode > ( ) . withText ( BibDatabaseMode :: getFormattedName ) . install ( biblatexMode ) ; biblatexMode . itemsProperty ( ) . bind ( viewModel . biblatexModeListProperty ( ) ) ; biblatexMode . valueProperty ( ) . bindBidirectional ( viewModel . selectedBiblatexModeProperty ( ) ) ; alwaysReformatBib . selectedProperty ( ) . bindBidirectional ( viewModel . alwaysReformatBibProperty ( ) ) ; autosaveLocalLibraries . selectedProperty ( ) . bindBidirectional ( viewModel . autosaveLocalLibrariesProperty ( ) ) ; ActionFactory actionFactory = new ActionFactory ( ) ; actionFactory . configureIconButton ( StandardActions . HELP , new HelpAction ( HelpFile . AUTOSAVE , dialogService , preferences . getExternalApplicationsPreferences ( ) ) , autosaveLocalLibrariesHelp ) ; actionFactory . configureIconButton ( StandardActions . HELP , new HelpAction ( HelpFile . REMOTE , dialogService , preferences . getExternalApplicationsPreferences ( ) ) , remoteHelp ) ; createBackup . selectedProperty ( ) . bindBidirectional ( viewModel . createBackupProperty ( ) ) ; backupDirectory . textProperty ( ) . bindBidirectional ( viewModel . backupDirectoryProperty ( ) ) ; backupDirectory . disableProperty ( ) . bind ( viewModel . createBackupProperty ( ) . not ( ) ) ; Platform . runLater ( ( ) -> { validationVisualizer . initVisualization ( viewModel . remotePortValidationStatus ( ) , remotePort ) ; validationVisualizer . initVisualization ( viewModel . httpPortValidationStatus ( ) , httpServerPort ) ; validationVisualizer . initVisualization ( viewModel . languageServerPortValidationStatus ( ) , languageServerPort ) ; validationVisualizer . initVisualization ( viewModel . fontSizeValidationStatus ( ) , fontSize ) ; validationVisualizer . initVisualization ( viewModel . customPathToThemeValidationStatus ( ) , customThemePath ) ; } ) ; remoteServer . selectedProperty ( ) . bindBidirectional ( viewModel . remoteServerProperty ( ) ) ; remotePort . textProperty ( ) . bindBidirectional ( viewModel . remotePortProperty ( ) ) ; remotePort . disableProperty ( ) . bind ( remoteServer . selectedProperty ( ) . not ( ) ) ; enableHttpServer . selectedProperty ( ) . bindBidirectional ( viewModel . enableHttpServerProperty ( ) ) ; httpServerPort . textProperty ( ) . bindBidirectional ( viewModel . httpPortProperty ( ) ) ; httpServerPort . disableProperty ( ) . bind ( enableHttpServer . selectedProperty ( ) . not ( ) ) ; enableLanguageServer . selectedProperty ( ) . bindBidirectional ( viewModel . enableLanguageServerProperty ( ) ) ; languageServerPort . textProperty ( ) . bindBidirectional ( viewModel . languageServerPortProperty ( ) ) ; languageServerPort . disableProperty ( ) . bind ( enableLanguageServer . selectedProperty ( ) . not ( ) ) ; }
public boolean unregister ( LongGauge longGauge ) { return false ; }
public Class < ? > getEntityType ( ) { return type ; }
public Criteria andBackAmountGreaterThanOrEqualTo ( BigDecimal value ) { addCriterion ( "back_amount >=" , value , "backAmount" ) ; return ( Criteria ) this ; }
public Criteria andDescriptionLessThanOrEqualTo ( String value ) { addCriterion ( "description <=" , value , "description" ) ; return ( Criteria ) this ; }
public static void launch ( Context context ) { if ( ! WebRTCModuleOptions . getInstance ( ) . enableMediaProjectionService ) { return ; } MediaProjectionNotification . createNotificationChannel ( context ) ; Intent intent = new Intent ( context , MediaProjectionService . class ) ; ComponentName componentName ; try { if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . O ) { componentName = context . startForegroundService ( intent ) ; } else { componentName = context . startService ( intent ) ; } } catch ( RuntimeException e ) { Log . w ( TAG , "Media projection service not started" , e ) ; return ; } if ( componentName == null ) { Log . w ( TAG , "Media projection service not started" ) ; } else { Log . i ( TAG , "Media projection service started" ) ; } }
public Builder description ( String description ) { this . description = description ; return this ; }
private String getEncodeStarRocksIntermediateHiveTableSql ( String dictColumn , List < String > childColumn ) { StringBuilder sql = new StringBuilder ( ) ; sql . append ( "insert overwrite table " ) . append ( starrocksIntermediateHiveTable ) . append ( " select " ) ; if ( mapSideJoinColumns . size ( ) != 0 && mapSideJoinColumns . contains ( dictColumn ) ) { sql . append ( " /*+ BROADCAST (t) */ " ) ; } intermediateTableColumnList . forEach ( columnName -> { if ( dictColumn . equals ( columnName ) ) { sql . append ( "t.dict_value" ) . append ( " ," ) ; } else if ( childColumn != null && childColumn . contains ( columnName ) ) { sql . append ( String . format ( " if(%s is null, null, t.dict_value) " , columnName ) ) . append ( " ," ) ; } else { sql . append ( starrocksIntermediateHiveTable ) . append ( "." ) . append ( columnName ) . append ( " ," ) ; } } ) ; sql . deleteCharAt ( sql . length ( ) - 1 ) . append ( " from " ) . append ( starrocksIntermediateHiveTable ) . append ( " LEFT OUTER JOIN ( select dict_key,dict_value from " ) . append ( globalDictTableName ) . append ( " where dict_column='" ) . append ( dictColumn ) . append ( "' ) t on " ) . append ( starrocksIntermediateHiveTable ) . append ( "." ) . append ( dictColumn ) . append ( " = t.dict_key " ) ; return sql . toString ( ) ; }
public < T > CloseableReference < T > create ( T t , ResourceReleaser < T > resourceReleaser ) { return CloseableReference . of ( t , resourceReleaser , mLeakHandler ) ; }
public Object invokeInstruction ( ) { int intValue = ( int ) jobDetailsBuilder . getStack ( ) . pollLast ( ) ; return ( long ) intValue ; }
public void put ( K key , V value ) { map . put ( key , value ) ; timestamps . put ( key , now ( ) ) ; }
public Builder resultOrdered ( boolean resultOrdered ) { mappedStatement . resultOrdered = resultOrdered ; return this ; }
public void setDotRadiusDp ( float dotRadius ) { setDotRadius ( dpToPx ( dotRadius ) ) ; }
protected @ NotNull CodeInsightActionHandler getHandler ( ) { return new Handler ( ) ; }
public < E extends RealmModel > boolean isEmbedded ( Class < E > clazz ) { checkSchemaHasClass ( Util . getOriginalModelClass ( clazz ) ) ; return originalMediator . isEmbedded ( clazz ) ; }
public AbstractSQLConfig < T , M , L > setCompat ( Boolean compat ) { this . compat = compat ; return this ; }
private static Class < ? > potentiallyUnwrapReturnTypeFor ( RepositoryMetadata metadata , Method method ) { TypeInformation < ? > returnType = metadata . getReturnType ( method ) ; while ( QueryExecutionConverters . supports ( returnType . getType ( ) ) || QueryExecutionConverters . supportsUnwrapping ( returnType . getType ( ) ) ) { returnType = returnType . getRequiredComponentType ( ) ; } return returnType . getType ( ) ; }
public SslContext createClientModeSslContext ( ) throws SSLException , UnrecoverableKeyException , NoSuchAlgorithmException , KeyStoreException { Set < String > protocols = new HashSet < > ( configuration . getEncryptionProtocols ( ) ) ; protocols . remove ( "SSLv2Hello" ) ; return SslContextBuilder . forClient ( ) . protocols ( protocols ) . ciphers ( configuration . getEncryptionCipherSuites ( ) ) . keyManager ( getKeyManagerFactory ( ) ) . trustManager ( getTrustManagers ( ) [ 0 ] ) . startTls ( false ) . build ( ) ; }
public YamlPipelineJobItemProgressSwapper < ? , ? > getYamlJobItemProgressSwapper ( ) { return isTransmissionJob ? new YamlTransmissionJobItemProgressSwapper ( ) : new YamlConsistencyCheckJobItemProgressSwapper ( ) ; }
protected void createNewInstance ( Map < String , Object > objects , String name , String value ) { Object currentInstance = objects . get ( name ) ; if ( currentInstance != null ) { LOGGER . info ( "An instance with name '{}' already exists.  " + "Redefining this object as a new instance of type {}" , name , value ) ; } Object instance ; try { instance = ClassUtils . newInstance ( value ) ; if ( instance instanceof Nameable ) { ( ( Nameable ) instance ) . setName ( name ) ; } } catch ( Exception e ) { instance = alternateObjectSupplier . apply ( value ) ; if ( instance == null ) { String msg = "Unable to instantiate class [" + value + "] for object named '" + name + "'.  " + "Please ensure you've specified the fully qualified class name correctly." ; throw new ConfigurationException ( msg , e ) ; } } objects . put ( name , instance ) ; }
public int changeEndOffset ( ) { return change . changeEndOffset ( ) ; }
public static void setSystemWideReplacement ( String fullName , Object replacement ) { int id = getSystem ( ) . getIdentifier ( fullName , null , null ) ; if ( id == 0 ) throw new NotFoundException ( fullName ) ; setReplacement ( id , replacement , null ) ; }
private long getFunctionAddress ( String name , boolean required ) { try ( MemoryStack stack = stackPush ( ) ) { long address = callPPP ( NULL , memAddress ( stack . ASCII ( name ) ) , vkGetInstanceProcAddr ) ; if ( address == NULL && required ) { throw new IllegalArgumentException ( "A critical function is missing. Make sure that Vulkan is available." ) ; } return address ; } }
public Set < JavaClass > getClasses ( ) { return classes ; }
public String particle ( XSParticle particle ) { throw new UnsupportedOperationException ( ) ; }
public byte [ ] assemble ( Address at , String line , AssemblyPatternBlock ctx ) throws AssemblySyntaxException , AssemblySemanticException , IOException { byte [ ] full = baos . toByteArray ( ) ; byte [ ] bytes = asm . assembleLine ( at , line , ctx ) ; System . arraycopy ( bytes , 0 , full , ( int ) at . subtract ( entry ) , bytes . length ) ; baos . reset ( ) ; baos . write ( full ) ; return bytes ; }
void setLocalVarSymbol ( ASTVariableId id ) { assert ! id . isField ( ) && ! id . isEnumConstant ( ) : "Local var symbol is not appropriate for fields" ; assert ! id . isFormalParameter ( ) || id . isLambdaParameter ( ) || id . isExceptionBlockParameter ( ) : "Local var symbol is not appropriate for method parameters" ; new AstLocalVarSym ( id , this ) ; }
public static boolean isJavaxScriptSource ( String source ) { return isJavascriptSource ( source ) || isRubySource ( source ) ; }
String columnNameLocked ( int columnIndex ) { acquireReference ( ) ; try { return native_column_name ( columnIndex ) ; } finally { releaseReference ( ) ; } }
boolean isResponseCacheable ( ServerHttpResponse response ) { return isStatusCodeToCache ( response ) && isCacheControlAllowed ( response ) && ! isVaryWildcard ( response ) ; }
private static long serializedColumnDataSize ( SerializationHelper helper , ColumnData data , long v ) { ColumnMetadata column = helper . si . next ( data . column ( ) ) ; assert column != null ; if ( data . column . isSimple ( ) ) return v + Cell . serializer . serializedSize ( ( Cell < ? > ) data , column , helper . pkLiveness , helper . header ) ; else return v + sizeOfComplexColumn ( ( ComplexColumnData ) data , column , helper . hasComplexDeletion , helper . pkLiveness , helper . header ) ; }
public void onPermissionsGranted ( int requestCode , List < String > list ) { selectPhoto ( ) ; }
protected boolean usePopupMode ( ) { return false ; }
public Builder trackedEventFields ( Function < EventSchema , String > trackedEventFields ) { this . trackedEventFields = trackedEventFields ; return this ; }
default Matrix pdist ( T [ ] x , T [ ] y ) { int m = x . length ; int n = y . length ; DenseMatrix D = DenseMatrix . zeros ( Float64 , m , n ) ; IntStream . range ( 0 , m ) . parallel ( ) . forEach ( i -> { T xi = x [ i ] ; for ( int j = 0 ; j < n ; j ++ ) { D . set ( i , j , d ( xi , y [ j ] ) ) ; } } ) ; return D ; }
public String getDatabase ( ) { return options . getString ( KEY_DATABASE ) ; }
final ImmutableBiMap < String , ExecutableElement > propertyNameToMethodMap ( Set < ExecutableElement > propertyMethods ) { Map < String , ExecutableElement > map = new LinkedHashMap < > ( ) ; Set < String > reportedDups = new HashSet < > ( ) ; boolean allPrefixed = gettersAllPrefixed ( propertyMethods ) ; for ( ExecutableElement method : propertyMethods ) { String methodName = method . getSimpleName ( ) . toString ( ) ; String name = allPrefixed ? nameWithoutPrefix ( methodName ) : methodName ; ExecutableElement old = map . put ( name , method ) ; if ( old != null ) { List < ExecutableElement > contexts = new ArrayList < > ( Arrays . asList ( method ) ) ; if ( reportedDups . add ( name ) ) { contexts . add ( old ) ; } for ( ExecutableElement context : contexts ) { errorReporter . reportError ( context , "[%sDupProperty] More than one @%s property called %s" , simpleAnnotationName , simpleAnnotationName , name ) ; } } } return ImmutableBiMap . copyOf ( map ) ; }
public Qualified mapExpressions ( Function < Expression , Expression > fn ) { return this ; }
public InsetsState getInsetsState ( int displayId ) { final DisplayRecord r = mDisplays . get ( displayId ) ; return r != null ? r . mInsetsState : null ; }
public static void applyLocaleToContext ( @ NonNull Context context , @ Nullable String localeString ) { final Locale forceLocale = LocaleTools . getLocaleForLocaleString ( localeString ) ; final Configuration configuration = context . getResources ( ) . getConfiguration ( ) ; configuration . setLocale ( forceLocale ) ; context . getResources ( ) . updateConfiguration ( configuration , null ) ; }
public static String byte2Base64 ( byte [ ] bytes ) { return new String ( Base64 . getEncoder ( ) . encode ( bytes ) , StandardCharsets . UTF_8 ) ; }
protected void doReadBytes ( byte [ ] bytes , int start , int length ) throws IOException { if ( length < 0 ) throw new AvroRuntimeException ( "Malformed data. Length is negative: " + length ) ; int remaining = limit - pos ; if ( length <= remaining ) { System . arraycopy ( buf , pos , bytes , start , length ) ; pos += length ; } else { System . arraycopy ( buf , pos , bytes , start , remaining ) ; start += remaining ; length -= remaining ; pos = limit ; source . readRaw ( bytes , start , length ) ; } }
public Duration getIdleSoftEvictDuration ( ) { return idleSoftEvictDuration ; }
public List < DebuggingView . DVFrame > getFrames ( int from , int to ) { CPPFrame [ ] stack = getStack ( ) ; if ( stack != null ) { return new FrameList ( stack , from , to ) ; } else { return Collections . emptyList ( ) ; } }
public String getNamespace ( ) { return namespace ; }
public List < JSONObject > getMostTagNaviDomains ( final int fetchSize ) { final Query query = new Query ( ) . setFilter ( new PropertyFilter ( Domain . DOMAIN_NAV , FilterOperator . EQUAL , Domain . DOMAIN_NAV_C_ENABLED ) ) . addSort ( Domain . DOMAIN_SORT , SortDirection . ASCENDING ) . addSort ( Domain . DOMAIN_TAG_COUNT , SortDirection . DESCENDING ) . addSort ( Keys . OBJECT_ID , SortDirection . DESCENDING ) . setPage ( 1 , fetchSize ) . setPageCount ( 1 ) ; try { final List < JSONObject > ret = domainRepository . getList ( query ) ; for ( final JSONObject domain : ret ) { final List < JSONObject > tags = getTags ( domain . optString ( Keys . OBJECT_ID ) ) ; domain . put ( Domain . DOMAIN_T_TAGS , ( Object ) tags ) ; } return ret ; } catch ( final Exception e ) { LOGGER . log ( Level . ERROR , "Gets most tag navigation domains failed" , e ) ; return Collections . emptyList ( ) ; } }
public boolean getContentStatusBarNightMode ( ) { return isNightMode ( ) ; }
public Criteria andEnableEqualTo ( Boolean value ) { addCriterion ( "`enable` =" , value , "enable" ) ; return ( Criteria ) this ; }
public static LocationRetriever newRetriever ( BaseActivity context ) { return new GoogleLocationRetriever ( context ) ; }
public File getFile ( JobID jobId , TransientBlobKey key ) throws IOException { checkNotNull ( jobId ) ; return getFileInternalWithReadLock ( jobId , key ) ; }
private void initValues ( GLSurfaceView mGlSurfaceView ) { mWidth = mGlSurfaceView . getWidth ( ) ; mHeight = mGlSurfaceView . getHeight ( ) ; mRandom = new Random ( new Date ( ) . getTime ( ) ) ; }
public void onSizeChange ( int oldW , int oldH , int newW , int newH ) { }
public NDArray acosh ( ) { return getAlternativeArray ( ) . acosh ( ) ; }
public TypeMirror getReturnTypeMirror ( ) { return executableElement . getReturnType ( ) ; }
public final Mono < Void > commit ( ReactiveTransaction transaction ) { if ( transaction . isCompleted ( ) ) { return Mono . error ( new IllegalTransactionStateException ( "Transaction is already completed - do not call commit or rollback more than once per transaction" ) ) ; } return TransactionSynchronizationManager . forCurrentTransaction ( ) . flatMap ( synchronizationManager -> { GenericReactiveTransaction reactiveTx = ( GenericReactiveTransaction ) transaction ; if ( reactiveTx . isRollbackOnly ( ) ) { if ( reactiveTx . isDebug ( ) ) { logger . debug ( "Transactional code has requested rollback" ) ; } return processRollback ( synchronizationManager , reactiveTx ) ; } return processCommit ( synchronizationManager , reactiveTx ) ; } ) ; }
public int hashCode ( ) { return partitionId . hashCode ( ) ^ producerId . hashCode ( ) ; }
void removeSubscriber ( Set < String > eventNames , PropertyChangeListener subscriber ) { for ( String eventName : eventNames ) { removeSubscriber ( eventName , subscriber ) ; } }
public N and ( ) { return ( N ) V1ISCSIVolumeSourceFluent . this . withSecretRef ( builder . build ( ) ) ; }
public String stringify ( Binary value ) { byte [ ] bytes = value . getBytesUnsafe ( ) ; StringBuilder builder = new StringBuilder ( 36 ) ; appendHex ( bytes , 0 , 4 , builder ) ; builder . append ( '-' ) ; appendHex ( bytes , 4 , 2 , builder ) ; builder . append ( '-' ) ; appendHex ( bytes , 6 , 2 , builder ) ; builder . append ( '-' ) ; appendHex ( bytes , 8 , 2 , builder ) ; builder . append ( '-' ) ; appendHex ( bytes , 10 , 6 , builder ) ; return builder . toString ( ) ; }
public int getPipelineId ( ) { return taskGroupLocation . getPipelineId ( ) ; }
private List < ResolvedType > collectRegularConstraints ( MethodUsage methodUsage , List < ResolvedType > parameterTypes , InferenceContext inferenceContext ) { List < ResolvedType > constraints = new LinkedList < > ( ) ; for ( int i = 0 ; i < parameterTypes . size ( ) ; i ++ ) { ResolvedType formalType = methodUsage . getParamType ( i ) ; ResolvedType actualType = parameterTypes . get ( i ) ; constraints . add ( inferenceContext . addPair ( formalType , actualType ) ) ; } return constraints ; }
public XmlResourceParser getLayout ( int id ) throws NotFoundException { XmlResourceParser result ; Object replacement = getReplacement ( id ) ; if ( replacement instanceof XResForwarder ) { Resources repRes = ( ( XResForwarder ) replacement ) . getResources ( ) ; int repId = ( ( XResForwarder ) replacement ) . getId ( ) ; boolean loadedFromCache = isXmlCached ( repRes , repId ) ; result = repRes . getLayout ( repId ) ; if ( ! loadedFromCache ) { long parseState = getLongField ( result , "mParseState" ) ; rewriteXmlReferencesNative ( parseState , this , repRes ) ; } } else { result = super . getLayout ( id ) ; } HashMap < String , CopyOnWriteSortedSet < XC_LayoutInflated > > inner ; synchronized ( sLayoutCallbacks ) { inner = sLayoutCallbacks . get ( id ) ; } if ( inner != null ) { CopyOnWriteSortedSet < XC_LayoutInflated > callbacks ; synchronized ( inner ) { callbacks = inner . get ( mResDir ) ; if ( callbacks == null && mResDir != null ) callbacks = inner . get ( null ) ; } if ( callbacks != null ) { String variant = "layout" ; TypedValue value = ( TypedValue ) getObjectField ( this , "mTmpValue" ) ; getValue ( id , value , true ) ; if ( value . type == TypedValue . TYPE_STRING ) { String [ ] components = value . string . toString ( ) . split ( "/" , 3 ) ; if ( components . length == 3 ) variant = components [ 1 ] ; else XposedBridge . log ( "Unexpected resource path \"" + value . string . toString ( ) + "\" for resource id 0x" + Integer . toHexString ( id ) ) ; } else { XposedBridge . log ( new NotFoundException ( "Could not find file name for resource id 0x" ) + Integer . toHexString ( id ) ) ; } synchronized ( sXmlInstanceDetails ) { synchronized ( sResourceNames ) { HashMap < String , ResourceNames > resNamesInner = sResourceNames . get ( id ) ; if ( resNamesInner != null ) { synchronized ( resNamesInner ) { XMLInstanceDetails details = new XMLInstanceDetails ( resNamesInner . get ( mResDir ) , variant , callbacks ) ; sXmlInstanceDetails . put ( result , details ) ; MethodHookParam top = sIncludedLayouts . get ( ) . peek ( ) ; if ( top != null ) top . setObjectExtra ( EXTRA_XML_INSTANCE_DETAILS , details ) ; } } } } } } return result ; }
public Token getToken ( String tokenId ) { long startTime = System . nanoTime ( ) ; Token token = null ; synchronized ( tokenLock ) { try { token = tokenDatastore . find ( Token . class ) . filter ( Filters . eq ( TOKEN_ID , tokenId ) ) . first ( ) ; } catch ( Exception e ) { logger . error ( ExceptionUtils . getStackTrace ( e ) ) ; } } recordQueryDuration ( startTime , "getToken" ) ; return token ; }
public static Boolean isDisabled ( Object item ) { if ( item instanceof AbstractFolder ) { return Disabler . isDisabled ( ( AbstractFolder ) item ) ; } if ( item instanceof AbstractProject ) { return Disabler . isDisabled ( ( AbstractProject ) item ) ; } if ( item instanceof ParameterizedJobMixIn . ParameterizedJob ) { return Disabler . isDisabled ( ( ParameterizedJobMixIn . ParameterizedJob ) item ) ; } return null ; }
public static boolean isKingBase ( String db ) { return DATABASE_KINGBASE . equals ( db ) ; }
long getNextRotationTime ( long now ) { if ( now <= 0 ) { now = clock . millis ( ) ; } long nowTod = timeOfDayMillis ( now ) ; long next = 0 ; for ( long rotationTime : rotationTimes ) { if ( nowTod < rotationTime ) { next = rotationTime - nowTod + now ; break ; } } if ( next == 0 ) { next = rotationTimes [ 0 ] + lengthOfDayMillis - nowTod + now ; } return next ; }
public static String getTablePrefix ( ) { return nativeGetTablePrefix ( ) ; }
public SslOptions getSslOptions ( ) { return sslOptions ; }
public void run ( ) { final boolean isSystemOutput = os . equals ( System . out ) || os . equals ( System . err ) ; try ( OutputStream ignored = isSystemOutput ? null : os ; InputStream ignored1 = is ) { is . transferTo ( os ) ; } catch ( IOException e ) { log . warn ( "Error writing stream" , e ) ; } }
public Criteria andOrganIdLessThanOrEqualTo ( Long value ) { addCriterion ( "organ_id <=" , value , "organId" ) ; return ( Criteria ) this ; }
public void multipleInstancesDetected ( OtrContact contact ) { ScOtrEngineListener l = getListener ( ) ; if ( l != null ) l . multipleInstancesDetected ( contact ) ; }
public boolean apply ( ShellControl shellControl ) throws Exception { return ! shellControl . command ( "test -S /var/lib/incus/unix.socket && test -w /var/lib/incus/unix.socket || " + "test -S /var/snap/incus/common/incus/unix.socket && test -w /var/snap/incus/common/incus/unix.socket || " + "test -S /var/snap/incus/common/incus/unix.socket.user && test -w /var/snap/incus/common/incus/unix.socket.user || " + "test -S /var/lib/incus/unix.socket.user && test -w /var/lib/incus/unix.socket.user" ) . executeAndCheck ( ) ; }
public void setExtractLinks ( boolean extractLinks ) { this . extractLinks = extractLinks ; }
protected Collection < AbstractFile > getAllFromChildren ( Content parent ) { Collection < AbstractFile > all = new ArrayList < > ( ) ; try { for ( Content child : parent . getChildren ( ) ) { if ( child instanceof AbstractContent ) { all . addAll ( child . accept ( this ) ) ; } } } catch ( TskException ex ) { logger . log ( Level . SEVERE , "Error getting Content children" , ex ) ; } return all ; }
public int getFactoryId ( ) { return TaskDataSerializerHook . FACTORY_ID ; }
public boolean isEnabled ( ) { return setting == null || setting . get ( ) ; }
public void arbiter ( III_Result r ) { virtualTimeScheduler . advanceTime ( ) ; r . r1 = subscriber . onNextCalls . get ( ) ; r . r2 = subscriber . onErrorCalls . get ( ) ; r . r3 = subscriber . onCompleteCalls . get ( ) ; }
public Grid getTo ( ) { return to ; }
public static boolean isSysTrayInitiated ( ) { return mSysTray != null ; }
public void putParcelableList ( String key , List < ? extends Parcelable > value ) { unparcel ( ) ; mMap . put ( key , value ) ; mFlags &= ~ FLAG_HAS_FDS_KNOWN ; }
public float getAsFloat ( ) { throw new UnsupportedOperationException ( getClass ( ) . getSimpleName ( ) ) ; }
public NDArray lt ( NDArray other ) { return getAlternativeArray ( ) . lt ( alternativeManager . from ( other ) ) ; }
public String getEntityName ( ) { return entityName ; }
public PeriodFormatterBuilder appendSeconds ( ) { appendField ( SECONDS ) ; return this ; }
@ Override public RecordType type ( ) { return RecordType . BTREE_META_PAGE_INIT_ROOT2 ; }
public static int getOutputImageWidth ( @ NonNull Intent intent ) { return intent . getIntExtra ( EXTRA_OUTPUT_IMAGE_WIDTH , - 1 ) ; }
public int getNdisPhysicalMediumType ( ) { return this . ndisPhysicalMediumType ; }
public void setBorderRadiusDp ( float borderRadius ) { this . borderRadiusPx = dpToPx ( borderRadius ) ; requiresShapeUpdate ( ) ; }
void clearLoad ( ) { _replicas . forEach ( Replica :: clearLoad ) ; }
protected Rectangle2D . Double getBoundsOfNode ( Tree node ) { return treeLayout . getNodeBounds ( ) . get ( node ) ; }
protected RecoverMisfiredJobsResult recoverMisfiredJobs ( Connection conn , boolean recovering ) throws JobPersistenceException , SQLException { int maxMisfiresToHandleAtATime = ( recovering ) ? - 1 : getMaxMisfiresToHandleAtATime ( ) ; List < TriggerKey > misfiredTriggers = new LinkedList < > ( ) ; long earliestNewTime = Long . MAX_VALUE ; boolean hasMoreMisfiredTriggers = getDelegate ( ) . hasMisfiredTriggersInState ( conn , STATE_WAITING , getMisfireTime ( ) , maxMisfiresToHandleAtATime , misfiredTriggers ) ; if ( hasMoreMisfiredTriggers ) { getLog ( ) . info ( "Handling the first {} triggers that missed their scheduled fire-time.  More misfired triggers remain to be processed." , misfiredTriggers . size ( ) ) ; } else if ( ! misfiredTriggers . isEmpty ( ) ) { getLog ( ) . info ( "Handling {} trigger(s) that missed their scheduled fire-time." , misfiredTriggers . size ( ) ) ; } else { getLog ( ) . debug ( "Found 0 triggers that missed their scheduled fire-time." ) ; return RecoverMisfiredJobsResult . NO_OP ; } for ( TriggerKey triggerKey : misfiredTriggers ) { OperableTrigger trig ; try { trig = retrieveTrigger ( conn , triggerKey ) ; } catch ( Exception e ) { getLog ( ) . error ( "Error retrieving the misfired trigger: {}" , triggerKey , e ) ; continue ; } if ( trig == null ) { continue ; } try { doUpdateOfMisfiredTrigger ( conn , trig , false , STATE_WAITING , recovering ) ; } catch ( Exception e ) { getLog ( ) . error ( "Error updating misfired trigger: {}" , trig . getKey ( ) , e ) ; continue ; } if ( trig . getNextFireTime ( ) != null && trig . getNextFireTime ( ) . getTime ( ) < earliestNewTime ) earliestNewTime = trig . getNextFireTime ( ) . getTime ( ) ; } return new RecoverMisfiredJobsResult ( hasMoreMisfiredTriggers , misfiredTriggers . size ( ) , earliestNewTime ) ; }
public Transport . Connection getConnection ( @ Nullable String clusterAlias , DiscoveryNode node ) { if ( clusterAlias == null ) { return transportService . getConnection ( node ) ; } else { return transportService . getRemoteClusterService ( ) . getConnection ( node , clusterAlias ) ; } }
long getNativeAudioTrack ( ) { return getNativeMediaStreamTrack ( ) ; }
public boolean dispatchTouchEvent ( MotionEvent ev ) { if ( OobeUtils . needFastAnimation ( ) ) return super . dispatchTouchEvent ( ev ) ; if ( isAnimEnded ( ) ) return super . dispatchTouchEvent ( ev ) ; return true ; }
protected CheckResult commonCheckAndGetGlobalStatus ( String xid , String branchId ) { commonCheck ( xid , branchId ) ; GlobalSession globalSession = SessionHolder . findGlobalSession ( xid ) ; if ( Objects . isNull ( globalSession ) ) { throw new IllegalArgumentException ( "global session is not exist, may be finished" ) ; } List < BranchSession > branchSessions = globalSession . getBranchSessions ( ) ; Long paramBranchId = Long . valueOf ( branchId ) ; BranchSession branchSession = branchSessions . stream ( ) . filter ( session -> paramBranchId . equals ( session . getBranchId ( ) ) ) . findAny ( ) . orElseThrow ( ( ) -> new IllegalArgumentException ( "branch session is not exist, may be finished" ) ) ; return new CheckResult ( globalSession , branchSession ) ; }
private void clearPrefix ( ) throws IllegalStateException { if ( iPrefix != null ) { throw new IllegalStateException ( "Prefix not followed by field" ) ; } iPrefix = null ; }
public static KeyPair getKeyPair ( ) throws Exception { KeyPairGenerator keyPairGenerator = KeyPairGenerator . getInstance ( "RSA" ) ; keyPairGenerator . initialize ( 2048 ) ; KeyPair keyPair = keyPairGenerator . generateKeyPair ( ) ; return keyPair ; }
static ImmutableList < PushImageStep > makeList ( BuildContext buildContext , ProgressEventDispatcher . Factory progressEventDispatcherFactory , RegistryClient registryClient , BlobDescriptor containerConfigurationDigestAndSize , Image builtImage , boolean manifestAlreadyExists ) throws IOException { BuildableManifestTemplate manifestTemplate = new ImageToJsonTranslator ( builtImage ) . getManifestTemplate ( buildContext . getTargetFormat ( ) , containerConfigurationDigestAndSize ) ; DescriptorDigest manifestDigest = Digests . computeJsonDigest ( manifestTemplate ) ; Set < String > imageQualifiers = getImageQualifiers ( buildContext , builtImage , manifestDigest ) ; EventHandlers eventHandlers = buildContext . getEventHandlers ( ) ; try ( TimerEventDispatcher ignored = new TimerEventDispatcher ( eventHandlers , "Preparing manifest pushers" ) ; ProgressEventDispatcher progressDispatcher = progressEventDispatcherFactory . create ( "launching manifest pushers" , imageQualifiers . size ( ) ) ) { if ( JibSystemProperties . skipExistingImages ( ) && manifestAlreadyExists ) { eventHandlers . dispatch ( LogEvent . info ( "Skipping pushing manifest; already exists." ) ) ; return ImmutableList . of ( ) ; } return imageQualifiers . stream ( ) . map ( qualifier -> new PushImageStep ( buildContext , progressDispatcher . newChildProducer ( ) , registryClient , manifestTemplate , qualifier , manifestDigest , containerConfigurationDigestAndSize . getDigest ( ) ) ) . collect ( ImmutableList . toImmutableList ( ) ) ; } }
public void init ( ) { super . init ( ) ; registerBR ( ) ; }
public void set ( Single colorInfluencer ) { this . colorValue . load ( colorInfluencer . colorValue ) ; this . alphaValue . load ( colorInfluencer . alphaValue ) ; }
public RoutingContext getCtx ( ) { return ctx ; }
public int compareTo ( final Resource o ) { return toString ( ) . compareTo ( o . toString ( ) ) ; }
public int getContainerViewHeight ( ) { if ( playerLayout == null ) { return 0 ; } if ( playlist . size ( ) <= 1 ) { return playerLayout . getMeasuredHeight ( ) + backgroundPaddingTop ; } else { int offset = dp ( 13 ) ; int top = scrollOffsetY - backgroundPaddingTop - offset ; top += listView . getTranslationY ( ) ; if ( top + backgroundPaddingTop < ActionBar . getCurrentActionBarHeight ( ) ) { float toMove = offset + dp ( 11 - 7 ) ; float moveProgress = Math . min ( 1.0f , ( ActionBar . getCurrentActionBarHeight ( ) - top - backgroundPaddingTop ) / toMove ) ; float availableToMove = ActionBar . getCurrentActionBarHeight ( ) - toMove ; int diff = ( int ) ( availableToMove * moveProgress ) ; top -= diff ; } if ( Build . VERSION . SDK_INT >= 21 ) { top += AndroidUtilities . statusBarHeight ; } return container . getMeasuredHeight ( ) - top ; } }
public void preCheck ( ) { this . init ( ) ; this . doPreCheck ( ) ; }
public static TypeConverterMetaData [ ] extract ( Element element ) { List < ? extends AnnotationMirror > annotationMirrors = element . getAnnotationMirrors ( ) ; for ( AnnotationMirror mirror : annotationMirrors ) { DeclaredType annotationType = mirror . getAnnotationType ( ) ; if ( TypeUtil . isOption ( annotationType ) || TypeUtil . isParameter ( annotationType ) ) { Map < ? extends ExecutableElement , ? extends AnnotationValue > elementValues = mirror . getElementValues ( ) ; for ( ExecutableElement attribute : elementValues . keySet ( ) ) { if ( "converter" . equals ( attribute . getSimpleName ( ) . toString ( ) ) ) { AnnotationValue list = elementValues . get ( attribute ) ; List < AnnotationValue > typeMirrors = ( List < AnnotationValue > ) list . getValue ( ) ; List < TypeConverterMetaData > result = new ArrayList < TypeConverterMetaData > ( ) ; for ( AnnotationValue annotationValue : typeMirrors ) { result . add ( new TypeConverterMetaData ( ( TypeMirror ) annotationValue . getValue ( ) ) ) ; } return result . toArray ( new TypeConverterMetaData [ 0 ] ) ; } } } } return new TypeConverterMetaData [ 0 ] ; }
public Registries getRegistries ( ) { return SpongeRegistries . getInstance ( ) ; }
public byte getStatus ( ) { return this . status ; }
public int hashCode ( ) { return Objects . hash ( property ) ; }
public < S > Void visit ( NotEqualsTo notEqualsTo , S context ) { visitBinaryExpression ( notEqualsTo ) ; return null ; }
public TextRenderData convert ( Object source ) throws Exception { if ( null == source ) return null ; TextRenderData text = source instanceof TextRenderData ? ( TextRenderData ) source : new TextRenderData ( source . toString ( ) ) ; return null == text . getText ( ) ? new TextRenderData ( "" ) : text ; }
public void start ( ) { initJobHandlerMethodRepository ( xxlJobBeanList ) ; try { super . start ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
private void updateSubMenu ( ) { setMenuItemChecked ( shuffleListItem , SharedConfig . shuffleMusic ) ; setMenuItemChecked ( reverseOrderItem , SharedConfig . playOrderReversed ) ; setMenuItemChecked ( repeatListItem , SharedConfig . repeatMode == 1 ) ; setMenuItemChecked ( repeatSongItem , SharedConfig . repeatMode == 2 ) ; }
protected int getLayoutId ( ) { return R . layout . activity_simple ; }
public RunningNested < A > editRunning ( ) { return this . withNewRunningLike ( Optional . ofNullable ( this . buildRunning ( ) ) . orElse ( null ) ) ; }
protected Object createProxyChangeInfo ( PasswdInetSocketAddress proxyAddr ) throws ClassNotFoundException , NoSuchMethodException , IllegalAccessException , InvocationTargetException , InstantiationException { if ( Build . VERSION . SDK_INT < 21 ) { @ SuppressLint ( "PrivateApi" ) Class < ? > proxyPropClazz = Class . forName ( "android.net.ProxyProperties" ) ; Constructor proxyPropCtor = proxyPropClazz . getDeclaredConstructor ( String . class , String . class , String [ ] . class ) ; return proxyPropCtor . newInstance ( proxyAddr . getHostString ( ) , Integer . toString ( proxyAddr . getPort ( ) ) , null ) ; } else { return ProxyInfo . buildDirectProxy ( proxyAddr . getHostString ( ) , proxyAddr . getPort ( ) ) ; } }
private void clearSearchInput ( String text , boolean reset ) { if ( searchHeaderView != null ) { if ( reset ) { lastSearchInput = text ; } searchHeaderView . editView ( ) . setText ( text ) ; if ( ! text . isEmpty ( ) ) { searchHeaderView . editView ( ) . setSelection ( text . length ( ) ) ; } updateClearSearchButton ( ! text . isEmpty ( ) , false ) ; } }
@ Override public boolean isNativeLookAndFeel ( ) { return false ; }
@ Override public String toString ( ) { return S . toString ( GridQueryFailResponse . class , this ) ; }
public final BackupImageView getImageView ( ) { return imageViews [ activeIndex ] ; }
private void invalidateAllScrollOffsets ( ) { mScrollOffsets . clear ( ) ; }
public Criteria andShowStatusLessThanOrEqualTo ( Integer value ) { addCriterion ( "show_status <=" , value , "showStatus" ) ; return ( Criteria ) this ; }
public boolean existsByUid ( String uid ) { if ( uid == null ) { return false ; } LambdaQueryWrapper < UserInfo > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( UserInfo :: getUid , uid ) ; return userInfoMapper . selectCount ( wrapper ) > 0 ; }
public INDArray sequenceMask ( INDArray lengths , int maxLen , DataType dataType ) { NDValidation . validateNumerical ( "sequenceMask" , "lengths" , lengths ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . shape . SequenceMask ( lengths , maxLen , dataType ) ) [ 0 ] ; }
public @ Nullable List < Drawable > getOverlays ( ) { return mOverlays ; }
public boolean isEquipped ( Hero hero ) { return hero != null && ( hero . belongings . weapon ( ) == this || hero . belongings . secondWep ( ) == this ) ; }
public Criteria andPayTypeLessThanOrEqualTo ( String value ) { addCriterion ( "pay_type <=" , value , "payType" ) ; return ( Criteria ) this ; }
public void pushBoolean ( boolean value ) { mArray . add ( value ) ; }
private static String parseContentInternal ( Object obj ) { String result = null ; if ( obj instanceof String ) { result = ( String ) obj ; } else if ( obj instanceof Throwable ) { result = fromThrowable ( ( Throwable ) obj ) ; } else if ( obj instanceof List ) { result = fromList ( ( List ) obj ) ; } else if ( obj instanceof Map ) { result = fromMap ( ( Map ) obj ) ; } else if ( obj instanceof MotionEvent ) { result = fromMotionEvent ( ( MotionEvent ) obj ) ; } else { result = String . valueOf ( obj ) ; } return result ; }
public DefineWindowFame orderBy ( String ... columnNames ) { windowSpecificationBuilder . setSort ( Sort . create ( this . table , columnNames ) ) ; return this ; }
protected void close ( ) { if ( window != null ) window . dispatchEvent ( new WindowEvent ( window , WindowEvent . WINDOW_CLOSING ) ) ; }
public < V > BaseProperty < ? > removeProperty ( Id key ) { return this . properties . remove ( intFromId ( key ) ) ; }
static String getTld ( Context context , @ NonNull String host ) { ensureSuffixList ( context ) ; String eval = host . toLowerCase ( Locale . ROOT ) ; while ( true ) { int d = eval . indexOf ( '.' ) ; String w = ( d < 0 ? null : '*' + eval . substring ( d ) ) ; synchronized ( suffixList ) { if ( suffixList . contains ( eval ) ) return eval ; if ( suffixList . contains ( w ) ) if ( suffixList . contains ( '!' + eval ) ) return eval . substring ( d + 1 ) ; else return eval ; } int dot = eval . indexOf ( '.' ) ; if ( dot < 0 ) return null ; eval = eval . substring ( dot + 1 ) ; } }
public void writeToParcel ( Parcel dest , int flags ) { synchronized ( this ) { dest . writeInt ( mNetworkType ) ; dest . writeInt ( mSubtype ) ; dest . writeString ( mTypeName ) ; dest . writeString ( mSubtypeName ) ; dest . writeString ( mState . name ( ) ) ; dest . writeString ( mDetailedState . name ( ) ) ; dest . writeInt ( mIsFailover ? 1 : 0 ) ; dest . writeInt ( mIsAvailable ? 1 : 0 ) ; dest . writeInt ( mIsRoaming ? 1 : 0 ) ; dest . writeString ( mReason ) ; dest . writeString ( mExtraInfo ) ; } }
static String nameWithoutPrefix ( String name ) { if ( name . startsWith ( "get" ) ) { name = name . substring ( 3 ) ; } else { assert name . startsWith ( "is" ) ; name = name . substring ( 2 ) ; } return PropertyNames . decapitalizeLikeJavaBeans ( name ) ; }
public static String getRecordKey ( RowData indexRow ) { return String . valueOf ( indexRow . getString ( KEY_ORD ) ) ; }
public Function < Table , Selection > isNotEqualTo ( NumericColumn < ? > d ) { return table -> table . numberColumn ( name ( ) ) . isNotEqualTo ( d ) ; }
default Selection isMidnight ( ) { return eval ( PackedLocalTime :: isMidnight ) ; }
public void keyReleased ( final KeyEvent keyEvent ) { final Object source = keyEvent . getSource ( ) ; if ( source instanceof MTextField ) { ( ( MTextField < ? > ) source ) . keyEvent ( keyEvent ) ; } }
public static void error ( @ Nullable Throwable throwable , @ Nullable String message , Object ... args ) { log ( LogLevel . ERROR , throwable , message , args ) ; }
default Activity getActivity ( ) { Context context = getContext ( ) ; do { if ( context instanceof Activity ) { return ( Activity ) context ; } else if ( context instanceof ContextWrapper ) { context = ( ( ContextWrapper ) context ) . getBaseContext ( ) ; } else { return null ; } } while ( context != null ) ; return null ; }
public Criteria andReportTypeLessThanOrEqualTo ( Integer value ) { addCriterion ( "report_type <=" , value , "reportType" ) ; return ( Criteria ) this ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } SingleMatchMultiValuePattern that = ( SingleMatchMultiValuePattern ) o ; return Objects . equals ( valuePattern , that . valuePattern ) ; }
public TransactionInitializationTrace transactionInitialisationTrace ( ) { return routerTransaction . initializationTrace ( ) ; }
protected void onLayout ( boolean changed , int left , int top , int right , int bottom ) { super . onLayout ( changed , left , top , right , bottom ) ; if ( isCenter ) { for ( int a = 0 ; a < textViews . length ; a ++ ) { View v = textViews [ a ] ; if ( v == null ) continue ; if ( v . getMeasuredWidth ( ) < getMeasuredWidth ( ) ) { int l = ( getMeasuredWidth ( ) - v . getMeasuredWidth ( ) ) / 2 ; v . layout ( l , 0 , l + v . getMeasuredWidth ( ) , v . getMeasuredHeight ( ) ) ; } } } }
public static MethodCPUCCTNode locate ( int methodId , RuntimeCCTNode [ ] nodes ) { for ( RuntimeCCTNode n : nodes ) { if ( n instanceof MethodCPUCCTNode && ( ( MethodCPUCCTNode ) n ) . getMethodId ( ) == methodId ) { return ( MethodCPUCCTNode ) n ; } } return null ; }
private static ApplicationManifestInfo parseApplicationFromXml ( @ NonNull XmlResourceParser parser ) { ApplicationManifestInfo applicationInfo = new ApplicationManifestInfo ( ) ; String applicationClassName = parser . getAttributeValue ( ANDROID_NAMESPACE_URI , ATTR_NAME ) ; applicationInfo . name = applicationClassName != null ? applicationClassName : "" ; applicationInfo . requestLegacyExternalStorage = parser . getAttributeBooleanValue ( ANDROID_NAMESPACE_URI , ATTR_REQUEST_LEGACY_EXTERNAL_STORAGE , false ) ; return applicationInfo ; }
public RecyclerView . ViewHolder onCreateViewHolder ( ViewGroup parent , int viewType ) { return new RecyclerListView . Holder ( createSettingsCell ( mContext ) ) ; }
public Criteria andModuleSettingIn ( List < String > values ) { addCriterion ( "module_setting in" , values , "moduleSetting" ) ; return ( Criteria ) this ; }
public < S > Void visit ( HighExpression highExpression , S context ) { highExpression . getExpression ( ) . accept ( this , context ) ; return null ; }
public void resetMissile ( float x , float y ) { revive ( ) ; this . x = x ; this . y = y ; left = lifespan ; speed . polar ( - Random . Float ( 3.1415926f ) , Random . Float ( 6 ) ) ; }
protected void releaseAcquiredTrigger ( Connection conn , OperableTrigger trigger ) throws JobPersistenceException { try { getDelegate ( ) . updateTriggerStateFromOtherState ( conn , trigger . getKey ( ) , STATE_WAITING , STATE_ACQUIRED ) ; getDelegate ( ) . updateTriggerStateFromOtherState ( conn , trigger . getKey ( ) , STATE_WAITING , STATE_BLOCKED ) ; getDelegate ( ) . deleteFiredTrigger ( conn , trigger . getFireInstanceId ( ) ) ; } catch ( SQLException e ) { throw new JobPersistenceException ( "Couldn't release acquired trigger: " + e . getMessage ( ) , e ) ; } }
public SetArgs px ( long timeout ) { if ( timeout < 0 ) { throw new IllegalArgumentException ( "`timeout` must be positive" ) ; } this . px = timeout ; return this ; }
public AuthenticationExtensions getAuthenticationExtensions ( ) { return delegate . getAuthenticationExtensions ( ) ; }
private void createTableApp ( SQLiteDatabase db ) { Log . i ( TAG , "Creating app table" ) ; db . execSQL ( "CREATE TABLE app (" + " ID INTEGER PRIMARY KEY AUTOINCREMENT" + ", package TEXT" + ", label TEXT" + ", system INTEGER  NOT NULL" + ", internet INTEGER NOT NULL" + ", enabled INTEGER NOT NULL" + ");" ) ; db . execSQL ( "CREATE UNIQUE INDEX idx_package ON app(package)" ) ; }
public boolean hasMatchingVolumeClaimTemplate ( Predicate < V1PersistentVolumeClaimBuilder > predicate ) { for ( V1PersistentVolumeClaimBuilder item : volumeClaimTemplates ) { if ( predicate . test ( item ) ) { return true ; } } return false ; }
public Object postProcessAfterInitialization ( Object bean , String beanName ) { if ( REST_TEMPLATE_INTERCEPTOR_AVAILABLE && bean instanceof RestTemplate ) { final RestTemplate restTemplate = ( RestTemplate ) bean ; final List < ClientHttpRequestInterceptor > interceptors = new ArrayList < > ( restTemplate . getInterceptors ( ) ) ; for ( final ClientHttpRequestInterceptor interceptor : interceptors ) { if ( interceptor instanceof SpringRestTemplateInterceptor ) { return bean ; } } interceptors . add ( SpringRestTemplateInterceptor . SINGLETON ) ; restTemplate . setInterceptors ( interceptors ) ; LOG . debug ( "rest template interceptor initialized" ) ; } return bean ; }
public static String getGroupFromRetryTopic ( String retryTopic ) { if ( retryTopic == null ) { return null ; } return KeyBuilder . parseGroup ( retryTopic ) ; }
public Constant getConstant ( int position ) { return constants [ position ] ; }
public void dispose ( ) { upstream . dispose ( ) ; upstream = DisposableHelper . DISPOSED ; }
public void addIPAddress ( Object newAddress ) { _ipAddresses . add ( newAddress ) ; }
public final Runnable getScheduledAnimation ( ) { return scheduledAnimation ; }
public void setShardManager ( ShardManager shardManager ) { this . shardManager = shardManager ; }
public static String generate ( Object ... args ) { String hexIdString = ByteUtil . toHexString ( toByteArray ( Objects . hash ( args ) , MachineUtil . getMachineIdentifier ( ) , counter . incrementAndGet ( ) ) ) ; return KEY_JOINER . join ( TIMESTAMP_FORMAT . format ( new Date ( ) ) , hexIdString ) ; }
public String name ( ) { return "zip" ; }
public Receiver getAvatarReceiver ( ) { return avatarReceiver ; }
private static String accessOrderListenerMethodName ( final Token token , final String suffix ) { return "On" + Generators . toUpperFirstChar ( token . name ( ) ) + suffix + "Accessed" ; }
private void runJsCode ( String code ) { if ( Build . VERSION . SDK_INT >= 21 ) { webView . evaluateJavascript ( code , null ) ; } else { try { webView . loadUrl ( "javascript:" + code ) ; } catch ( Exception e ) { FileLog . e ( e ) ; } } }
protected Object [ ] extractNextValues ( Iterator < ? > [ ] iterators , List < DataProviderInfo > providerInfos ) { Assert . that ( iterators . length == providerInfos . size ( ) ) ; Object [ ] result = new Object [ iterators . length ] ; for ( int i = 0 ; i < iterators . length ; i ++ ) { try { result [ i ] = iterators [ i ] . next ( ) ; } catch ( Throwable t ) { supervisor . error ( context . getErrorInfoCollector ( ) , new ErrorInfo ( providerInfos . get ( i ) . getDataProviderMethod ( ) , t , getErrorContext ( ) ) ) ; return null ; } } return result ; }
void setFare ( Fare fare ) { this . fare = fare ; }
public RestAIStreamClient . Builder okHttpClient ( OkHttpClient val ) { this . okHttpClient = val ; return this ; }
public static long hash64 ( final String text , int from , int length ) { return hash64 ( text . substring ( from , from + length ) ) ; }
public List < ApiVersionVo > getVersionVos ( ) { return versionVos ; }
static int getHeaderLenFieldBytes ( ) { return HEADER_LEN_FIELD_BYTES ; }
public void setInputSegmentsDir ( String inputSegmentsDir ) { _inputSegmentsDir = inputSegmentsDir ; }
private int readStackMapFrame ( final int stackMapFrameOffset , final boolean compressed , final boolean expand , final Context context ) { int currentOffset = stackMapFrameOffset ; final char [ ] charBuffer = context . charBuffer ; final Label [ ] labels = context . currentMethodLabels ; int frameType ; if ( compressed ) { frameType = b [ currentOffset ++ ] & 0xFF ; } else { frameType = Frame . FULL_FRAME ; context . currentFrameOffset = - 1 ; } int offsetDelta ; context . currentFrameLocalCountDelta = 0 ; if ( frameType < Frame . SAME_LOCALS_1_STACK_ITEM_FRAME ) { offsetDelta = frameType ; context . currentFrameType = Opcodes . F_SAME ; context . currentFrameStackCount = 0 ; } else if ( frameType < Frame . RESERVED ) { offsetDelta = frameType - Frame . SAME_LOCALS_1_STACK_ITEM_FRAME ; currentOffset = readVerificationTypeInfo ( currentOffset , context . currentFrameStackTypes , 0 , charBuffer , labels ) ; context . currentFrameType = Opcodes . F_SAME1 ; context . currentFrameStackCount = 1 ; } else if ( frameType >= Frame . SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED ) { offsetDelta = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; if ( frameType == Frame . SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED ) { currentOffset = readVerificationTypeInfo ( currentOffset , context . currentFrameStackTypes , 0 , charBuffer , labels ) ; context . currentFrameType = Opcodes . F_SAME1 ; context . currentFrameStackCount = 1 ; } else if ( frameType >= Frame . CHOP_FRAME && frameType < Frame . SAME_FRAME_EXTENDED ) { context . currentFrameType = Opcodes . F_CHOP ; context . currentFrameLocalCountDelta = Frame . SAME_FRAME_EXTENDED - frameType ; context . currentFrameLocalCount -= context . currentFrameLocalCountDelta ; context . currentFrameStackCount = 0 ; } else if ( frameType == Frame . SAME_FRAME_EXTENDED ) { context . currentFrameType = Opcodes . F_SAME ; context . currentFrameStackCount = 0 ; } else if ( frameType < Frame . FULL_FRAME ) { int local = expand ? context . currentFrameLocalCount : 0 ; for ( int k = frameType - Frame . SAME_FRAME_EXTENDED ; k > 0 ; k -- ) { currentOffset = readVerificationTypeInfo ( currentOffset , context . currentFrameLocalTypes , local ++ , charBuffer , labels ) ; } context . currentFrameType = Opcodes . F_APPEND ; context . currentFrameLocalCountDelta = frameType - Frame . SAME_FRAME_EXTENDED ; context . currentFrameLocalCount += context . currentFrameLocalCountDelta ; context . currentFrameStackCount = 0 ; } else { final int numberOfLocals = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; context . currentFrameType = Opcodes . F_FULL ; context . currentFrameLocalCountDelta = numberOfLocals ; context . currentFrameLocalCount = numberOfLocals ; for ( int local = 0 ; local < numberOfLocals ; ++ local ) { currentOffset = readVerificationTypeInfo ( currentOffset , context . currentFrameLocalTypes , local , charBuffer , labels ) ; } final int numberOfStackItems = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; context . currentFrameStackCount = numberOfStackItems ; for ( int stack = 0 ; stack < numberOfStackItems ; ++ stack ) { currentOffset = readVerificationTypeInfo ( currentOffset , context . currentFrameStackTypes , stack , charBuffer , labels ) ; } } } else { throw new IllegalArgumentException ( ) ; } context . currentFrameOffset += offsetDelta + 1 ; createLabel ( context . currentFrameOffset , labels ) ; return currentOffset ; }
static public final int constrain ( int amt , int low , int high ) { return ( amt < low ) ? low : ( ( amt > high ) ? high : amt ) ; }
public static Typeface createFromFile ( @ Nullable File file ) { Typeface typeface = new Builder ( file ) . build ( ) ; if ( typeface != null ) return typeface ; if ( ! file . exists ( ) ) { throw new RuntimeException ( "Font asset not found " + file . getAbsolutePath ( ) ) ; } return Typeface . DEFAULT ; }
public int getDefaultLookback ( ) { return defaultLookback ; }
protected ClassOrInterfaceType functionType ( ) { String type = "Function" + lambdaParameters . size ( ) ; return toClassOrInterfaceType ( "org.drools.model.functions." + type ) ; }
private static List < Path > listResults ( final Path directory ) { final List < Path > result = new ArrayList < > ( ) ; if ( ! Files . isDirectory ( directory ) ) { return result ; } try ( DirectoryStream < Path > directoryStream = newDirectoryStream ( directory , "*.trx" ) ) { for ( Path path : directoryStream ) { if ( ! Files . isDirectory ( path ) ) { result . add ( path ) ; } } } catch ( IOException e ) { LOGGER . error ( "Could not read data from {}" , directory , e ) ; } return result ; }
public INDArray sparseToDense ( INDArray indices , INDArray shape , INDArray values , INDArray defaultValue ) { NDValidation . validateNumerical ( "sparseToDense" , "indices" , indices ) ; NDValidation . validateNumerical ( "sparseToDense" , "shape" , shape ) ; NDValidation . validateNumerical ( "sparseToDense" , "values" , values ) ; NDValidation . validateNumerical ( "sparseToDense" , "defaultValue" , defaultValue ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . compat . CompatSparseToDense ( indices , shape , values , defaultValue ) ) [ 0 ] ; }
public List < String > getLabels ( ) { throw new UnsupportedOperationException ( ) ; }
public void run ( ) { SerializingServerCall . super . setCompression ( compressor ) ; }
public void error ( String s , Throwable e ) { logger . log ( MARKER , FQCN , LocationAwareLogger . ERROR_INT , s , null , e ) ; }
protected boolean onCustomMeasure ( View view , int width , int height ) { if ( view == videoView . getControlsView ( ) ) { ViewGroup . LayoutParams layoutParams = view . getLayoutParams ( ) ; layoutParams . width = videoView . getMeasuredWidth ( ) ; layoutParams . height = videoView . getAspectRatioView ( ) . getMeasuredHeight ( ) + ( videoView . isInFullscreen ( ) ? 0 : AndroidUtilities . dp ( 10 ) ) ; } return false ; }
public Image getColumnImage ( Object element , int columnIndex ) { return null ; }
private int waitForChallengeResponse ( final long nowMs ) { authenticator . onChallengedSession ( controlSessionProxy . controlSession ( this ) , nowMs ) ; return 1 ; }
protected void paintTrack ( Graphics g , JComponent c , Rectangle trackBounds ) { if ( trackBounds . isEmpty ( ) || ! scrollbar . isEnabled ( ) ) return ; g . setColor ( getTrackColor ( c , hoverTrack , isPressed && hoverTrack && ! hoverThumb ) ) ; paintTrackOrThumb ( g , c , trackBounds , trackInsets , trackArc ) ; }
public void setMisfireThreshold ( long misfireThreshold ) { if ( misfireThreshold < 1 ) { throw new IllegalArgumentException ( "Misfire threshold must be larger than 0" ) ; } this . misfireThreshold = misfireThreshold ; }
public String getProxyUriString ( ) { if ( mProxy == null || mProxy . type ( ) == Proxy . Type . DIRECT ) { return "" ; } else { PasswdInetSocketAddress proxyAddr = ( PasswdInetSocketAddress ) mProxy . address ( ) ; String usernameAndPasswd = "" ; if ( proxyAddr . getUsername ( ) != null && proxyAddr . getPassword ( ) != null ) { usernameAndPasswd = proxyAddr . getUsername ( ) + ":" + proxyAddr . getPassword ( ) + "@" ; } return mProxy . type ( ) . name ( ) . toLowerCase ( ) + "://" + usernameAndPasswd + proxyAddr . getHostString ( ) + ":" + proxyAddr . getPort ( ) ; } }
protected void checkoutState ( ) { removeCallbacks ( mCheckoutTask ) ; mInnerHandler . postDelayed ( mCheckoutTask , 500 ) ; }
public long getSubtrackCount ( String mainTrackId , String role , String status ) { long startTime = System . nanoTime ( ) ; long subtrackCount = 0 ; synchronized ( broadcastLock ) { subtrackCount = datastore . find ( Broadcast . class ) . filter ( getFilterForSubtracks ( mainTrackId , role , status ) ) . count ( ) ; } recordQueryDuration ( startTime , "getSubtrackCount" ) ; return subtrackCount ; }
private static void parse ( JSONValue v , GeometryUtils . Target target ) { if ( v instanceof JSONNull ) { target . startPoint ( ) ; target . addCoordinate ( Double . NaN , Double . NaN , Double . NaN , Double . NaN , 0 , 1 ) ; target . endObject ( POINT ) ; } else if ( v instanceof JSONObject ) { JSONObject o = ( JSONObject ) v ; JSONValue t = o . getFirst ( "type" ) ; if ( ! ( t instanceof JSONString ) ) { throw new IllegalArgumentException ( ) ; } switch ( ( ( JSONString ) t ) . getString ( ) ) { case "Point" : parse ( o , target , POINT ) ; break ; case "LineString" : parse ( o , target , LINE_STRING ) ; break ; case "Polygon" : parse ( o , target , POLYGON ) ; break ; case "MultiPoint" : parse ( o , target , MULTI_POINT ) ; break ; case "MultiLineString" : parse ( o , target , MULTI_LINE_STRING ) ; break ; case "MultiPolygon" : parse ( o , target , MULTI_POLYGON ) ; break ; case "GeometryCollection" : parseGeometryCollection ( o , target ) ; break ; default : throw new IllegalArgumentException ( ) ; } } else { throw new IllegalArgumentException ( ) ; } }
public static Region loadRegion ( RegionDirectories dirs ) throws IOException { Region r = new Region ( ) ; if ( dirs . getRegion ( ) != null ) { r . loadRegion ( dirs . getRegion ( ) ) ; } if ( dirs . getPoi ( ) != null ) { r . loadPoi ( dirs . getPoi ( ) ) ; } if ( dirs . getEntities ( ) != null ) { r . loadEntities ( dirs . getEntities ( ) ) ; } r . location = dirs . getLocation ( ) ; r . directories = dirs ; return r ; }
public void onViewAttachedToWindow ( @ NonNull View v ) { onAttachedToWindow ( ) ; }
public static String substringTrimmed ( String str , int beginIndex , int endIndex ) { beginIndex = trimBegin ( str , beginIndex , endIndex ) ; endIndex = trimEnd ( str , beginIndex , endIndex ) ; return ( endIndex > beginIndex ) ? str . substring ( beginIndex , endIndex ) : "" ; }
public void onFragmentDestroy ( ) { super . onFragmentDestroy ( ) ; }
protected List < VirtualDevice > getVirtualDevices ( ) { return mVirtualDevices . stream ( ) . map ( virtualDevice -> { VirtualDeviceReflector accessor = reflector ( VirtualDeviceReflector . class ) ; String deviceName = ( ( ShadowVirtualDevice ) Shadow . extract ( virtualDevice ) ) . getParams ( ) . getName ( ) ; int [ ] displayIds = ( ( ShadowVirtualDevice ) Shadow . extract ( virtualDevice ) ) . getDisplayIds ( ) ; try { VirtualDevice . class . getDeclaredConstructor ( int . class , String . class ) ; return accessor . newInstance ( virtualDevice . getDeviceId ( ) , deviceName ) ; } catch ( NoSuchMethodException e ) { DeviceManagerVirtualDeviceReflector virtualDeviceReflector = reflector ( DeviceManagerVirtualDeviceReflector . class , virtualDevice ) ; return accessor . newInstanceV ( ReflectionHelpers . createDelegatingProxy ( IVirtualDevice . class , ( VirtualDeviceDelegate ) ( ) -> displayIds ) , virtualDevice . getDeviceId ( ) , virtualDeviceReflector . getPersistentDeviceId ( ) , deviceName ) ; } } ) . collect ( Collectors . toList ( ) ) ; }
public void setReceivePortForVideo ( int receivePortForVideo ) { this . receivePortForVideo = receivePortForVideo ; }
static public void showError ( String title , String message , Throwable e ) { if ( title == null ) title = "Error" ; if ( Base . isCommandLine ( ) ) { System . err . println ( title + ": " + message ) ; } else { JOptionPane . showMessageDialog ( new Frame ( ) , message , title , JOptionPane . ERROR_MESSAGE ) ; } if ( e != null ) e . printStackTrace ( ) ; System . exit ( 1 ) ; }
public Builder popupPosition ( PopupPosition popupPosition ) { this . popupInfo . popupPosition = popupPosition ; return this ; }
public Flux < ConfigPropertyDef > getPropertyDef ( String scope ) { return Flux . fromIterable ( scopes . getOrDefault ( ConfigScope . of ( scope , scope , false ) , Collections . emptySet ( ) ) ) ; }
public void onIceConnectionChange ( PeerConnection . IceConnectionState iceConnectionState ) { ConstraintsMap params = new ConstraintsMap ( ) ; params . putString ( "event" , "iceConnectionState" ) ; params . putString ( "state" , Utils . iceConnectionStateString ( iceConnectionState ) ) ; sendEvent ( params ) ; }
protected static boolean rangesEqual ( int [ ] a , int [ ] b , int length ) { for ( int i = 0 ; i < length ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; }
private static String getProxyProtocolAddress ( Channel channel ) { if ( ! channel . hasAttr ( AttributeKeys . PROXY_PROTOCOL_ADDR ) ) { return null ; } String proxyProtocolAddr = getAttributeValue ( AttributeKeys . PROXY_PROTOCOL_ADDR , channel ) ; String proxyProtocolPort = getAttributeValue ( AttributeKeys . PROXY_PROTOCOL_PORT , channel ) ; if ( StringUtils . isBlank ( proxyProtocolAddr ) || proxyProtocolPort == null ) { return null ; } return proxyProtocolAddr + ":" + proxyProtocolPort ; }
public INDArray stack ( int axis , INDArray ... values ) { Preconditions . checkArgument ( values . length >= 1 , "values has incorrect size/length. Expected: values.length >= 1, got %s" , values . length ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . shape . Stack ( values , axis ) ) [ 0 ] ; }
protected void rollbackConnection ( Connection conn ) { if ( conn != null ) { try { conn . rollback ( ) ; } catch ( SQLException e ) { getLog ( ) . error ( "Couldn't rollback jdbc connection. {}" , e . getMessage ( ) , e ) ; } } }
public Object [ ] next ( ) { if ( context . getErrorInfoCollector ( ) . hasErrors ( ) ) { return null ; } Assert . that ( dataProviders . length == context . getCurrentFeature ( ) . getDataProviders ( ) . size ( ) ) ; firstIteration = false ; Object [ ] next = new Object [ dataProviders . length ] ; for ( int i = 0 ; i < dataProviders . length ; ) { try { if ( dataProviderIterators [ i ] == null ) { continue ; } if ( ! dataProviderIterators [ i ] . hasNext ( ) ) { return null ; } Object [ ] nextValues = dataProviderIterators [ i ] . next ( ) ; if ( nextValues == null ) { return null ; } System . arraycopy ( nextValues , 0 , next , i , nextValues . length ) ; i += nextValues . length ; } catch ( Throwable t ) { supervisor . error ( context . getErrorInfoCollector ( ) , new ErrorInfo ( context . getCurrentFeature ( ) . getDataProviders ( ) . get ( i ) . getDataProviderMethod ( ) , t , getErrorContext ( ) ) ) ; return null ; } } return next ; }
public void close ( ) throws IOException { closed = true ; if ( reader != null ) { reader . close ( ) ; } }
public Function < Table , Selection > isEqualTo ( double other ) { return table -> table . numberColumn ( name ( ) ) . isEqualTo ( other ) ; }
public void onAnimationEnd ( Animator animation ) { bbev . setContentVisibility ( true ) ; }
protected InetSocketAddress getServerAddress ( ) { return httpServer == null ? bindAddress : httpServer . getAddress ( ) ; }
public void setCircleRadius ( int mCircleRadius ) { this . mCircleRadius = mCircleRadius ; }
protected void generateSpans ( ) { createTabSpans ( _tabSize ) ; createUnderlineHexColorsSpans ( ) ; createSmallBlueLinkSpans ( ) ; if ( rules == null || styles == null ) { return ; } for ( Syntax . Rule rule : rules ) { CodeTheme . ThemeValue style = styles . get ( rule . type ) ; if ( style != null ) { createColorSpanForMatches ( rule . getPattern ( ) , style . getColor ( ) ) ; } } }
public void writeLength ( int length ) throws IOException { throw new TrevniRuntimeException ( "Not an array column: " + meta ) ; }
private DefaultMutableTreeNode getTreeNode ( RejTreeNode node ) { DefaultMutableTreeNode ret ; ret = new DefaultMutableTreeNode ( node ) ; ret . setAllowsChildren ( node . hasChildren ( ) ) ; return ret ; }
public Criteria andPurchaseStatusNotIn ( List < String > values ) { addCriterion ( "purchase_status not in" , values , "purchaseStatus" ) ; return ( Criteria ) this ; }
public boolean isOpenGauss ( ) { return isOpenGauss ( gainSQLDatabase ( ) ) ; }
protected final void postNavigateBack ( ) { UI . post ( this :: navigateBack ) ; }
public Criteria andCommentIdIsNull ( ) { addCriterion ( "comment_id is null" ) ; return ( Criteria ) this ; }
public DeclareStatement addColumnDefinitions ( Collection < ? extends ColumnDefinition > columnDefinitions ) { List < ColumnDefinition > collection = Optional . ofNullable ( getColumnDefinitions ( ) ) . orElseGet ( ArrayList :: new ) ; collection . addAll ( columnDefinitions ) ; return this . withColumnDefinitions ( collection ) ; }
public void removeSubscriptionListener ( SubscriptionListener listener ) { synchronized ( subscriptionListeners ) { subscriptionListeners . remove ( listener ) ; } }
private int readElementValue ( final AnnotationVisitor annotationVisitor , final int elementValueOffset , final String elementName , final char [ ] charBuffer ) { int currentOffset = elementValueOffset ; if ( annotationVisitor == null ) { switch ( b [ currentOffset ] & 0xFF ) { case 'e' : return currentOffset + 5 ; case '@' : return readElementValues ( null , currentOffset + 3 , true , charBuffer ) ; case '[' : return readElementValues ( null , currentOffset + 1 , false , charBuffer ) ; default : return currentOffset + 3 ; } } switch ( b [ currentOffset ++ ] & 0xFF ) { case 'B' : annotationVisitor . visit ( elementName , ( byte ) readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset ) ] ) ) ; currentOffset += 2 ; break ; case 'C' : annotationVisitor . visit ( elementName , ( char ) readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset ) ] ) ) ; currentOffset += 2 ; break ; case 'D' : case 'F' : case 'I' : case 'J' : annotationVisitor . visit ( elementName , readConst ( readUnsignedShort ( currentOffset ) , charBuffer ) ) ; currentOffset += 2 ; break ; case 'S' : annotationVisitor . visit ( elementName , ( short ) readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset ) ] ) ) ; currentOffset += 2 ; break ; case 'Z' : annotationVisitor . visit ( elementName , readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset ) ] ) == 0 ? Boolean . FALSE : Boolean . TRUE ) ; currentOffset += 2 ; break ; case 's' : annotationVisitor . visit ( elementName , readUTF8 ( currentOffset , charBuffer ) ) ; currentOffset += 2 ; break ; case 'e' : annotationVisitor . visitEnum ( elementName , readUTF8 ( currentOffset , charBuffer ) , readUTF8 ( currentOffset + 2 , charBuffer ) ) ; currentOffset += 4 ; break ; case 'c' : annotationVisitor . visit ( elementName , Type . getType ( readUTF8 ( currentOffset , charBuffer ) ) ) ; currentOffset += 2 ; break ; case '@' : currentOffset = readElementValues ( annotationVisitor . visitAnnotation ( elementName , readUTF8 ( currentOffset , charBuffer ) ) , currentOffset + 2 , true , charBuffer ) ; break ; case '[' : int numValues = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; if ( numValues == 0 ) { return readElementValues ( annotationVisitor . visitArray ( elementName ) , currentOffset - 2 , false , charBuffer ) ; } switch ( b [ currentOffset ] & 0xFF ) { case 'B' : byte [ ] byteValues = new byte [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { byteValues [ i ] = ( byte ) readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , byteValues ) ; break ; case 'Z' : boolean [ ] booleanValues = new boolean [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { booleanValues [ i ] = readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) != 0 ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , booleanValues ) ; break ; case 'S' : short [ ] shortValues = new short [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { shortValues [ i ] = ( short ) readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , shortValues ) ; break ; case 'C' : char [ ] charValues = new char [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { charValues [ i ] = ( char ) readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , charValues ) ; break ; case 'I' : int [ ] intValues = new int [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { intValues [ i ] = readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , intValues ) ; break ; case 'J' : long [ ] longValues = new long [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { longValues [ i ] = readLong ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , longValues ) ; break ; case 'F' : float [ ] floatValues = new float [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { floatValues [ i ] = Float . intBitsToFloat ( readInt ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , floatValues ) ; break ; case 'D' : double [ ] doubleValues = new double [ numValues ] ; for ( int i = 0 ; i < numValues ; i ++ ) { doubleValues [ i ] = Double . longBitsToDouble ( readLong ( cpInfoOffsets [ readUnsignedShort ( currentOffset + 1 ) ] ) ) ; currentOffset += 3 ; } annotationVisitor . visit ( elementName , doubleValues ) ; break ; default : currentOffset = readElementValues ( annotationVisitor . visitArray ( elementName ) , currentOffset - 2 , false , charBuffer ) ; break ; } break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
public String getObject ( ) { return object ; }
public void visitUnaryMinusExpression ( final UnaryMinusExpression expression ) { pushContext ( expression ) ; super . visitUnaryMinusExpression ( expression ) ; popContext ( ) ; }
private void configureEqualityCheckMethod ( String srcFolder ) { switch ( equalityCheckMethod ) { case EQUALITY_CHECK_METHOD_EQUATABLE : additionalProperties . put ( "useEquatable" , "true" ) ; break ; default : case EQUALITY_CHECK_METHOD_DEFAULT : break ; } }
public void bind ( @ NonNull T holder , @ NonNull List < Object > payloads ) { super . bind ( holder , payloads ) ; }
public void beforeTextChanged ( CharSequence s , int start , int count , int after ) { oldText = s . toString ( ) . trim ( ) ; }
public GlideBuilder setPreserveGainmapAndColorSpaceForTransformations ( boolean isEnabled ) { return this ; }
public void updateService ( final ServiceInstance < T > service ) throws Exception { Entry < T > entry = services . get ( service . getId ( ) ) ; if ( entry == null ) { throw new Exception ( "Service not registered: " + service ) ; } synchronized ( entry ) { entry . service = service ; byte [ ] bytes = serializer . serialize ( service ) ; String path = pathForInstance ( service . getName ( ) , service . getId ( ) ) ; client . setData ( ) . forPath ( path , bytes ) ; } }
public static Response doPostJson ( String url , String jsonBody , Map < String , String > headers , int timeout ) throws IOException { RequestBody requestBody = jsonBody != null ? RequestBody . create ( jsonBody , MEDIA_TYPE_JSON ) : RequestBody . create ( new byte [ 0 ] , MEDIA_TYPE_JSON ) ; Map < String , String > headersWithContentType = headers != null ? new java . util . HashMap < > ( headers ) : new java . util . HashMap < > ( ) ; headersWithContentType . put ( "Content-Type" , "application/json" ) ; Request request = buildRequest ( url , headersWithContentType , requestBody , "POST" ) ; OkHttpClient client = createHttp1ClientWithTimeout ( timeout ) ; return client . newCall ( request ) . execute ( ) ; }
public long getReprocessQueueSize ( ) { return reprocessQueue . size ( ) ; }
private void setCustomPaddingRight ( int padding , boolean animated ) { if ( rightPaddingAnimator != null ) { rightPaddingAnimator . cancel ( ) ; rightPaddingAnimator = null ; } if ( titleTextView . getCustomPaddingRight ( ) == padding ) { return ; } if ( ! animated ) { titleTextView . setCustomPaddingRight ( padding ) ; authorTextView . setCustomPaddingRight ( padding ) ; return ; } rightPaddingAnimator = ValueAnimator . ofInt ( titleTextView . getCustomPaddingRight ( ) , padding ) ; if ( padding == 0 ) { rightPaddingAnimator . setStartDelay ( 200L ) ; rightPaddingAnimator . setDuration ( 100L ) ; } else { rightPaddingAnimator . setDuration ( 200L ) ; } rightPaddingAnimator . setInterpolator ( new android . view . animation . DecelerateInterpolator ( ) ) ; rightPaddingAnimator . addUpdateListener ( animation -> { titleTextView . setCustomPaddingRight ( ( int ) animation . getAnimatedValue ( ) ) ; authorTextView . setCustomPaddingRight ( ( int ) animation . getAnimatedValue ( ) ) ; } ) ; rightPaddingAnimator . start ( ) ; }
@ Override public Pointer pointer ( ) { return pointer ; }
private Duration toDuration ( String string ) { String resolved = resolver != null ? resolver . resolveStringValue ( string ) : string ; if ( resolved == null ) { resolved = string ; } return durationConverter . convert ( resolved ) ; }
private void syncRootTypesWithInnerVars ( Map < String , ModelsMap > objs ) { Map < String , CodegenModel > allModels = new HashMap < > ( ) ; for ( ModelsMap modelsEntries : objs . values ( ) ) { for ( ModelMap modelsMap : modelsEntries . getModels ( ) ) { CodegenModel model = modelsMap . getModel ( ) ; allModels . put ( model . getClassname ( ) , model ) ; } } for ( CodegenModel model : allModels . values ( ) ) { syncRootTypesWithInnerVars ( allModels , model ) ; } }
public void addSortedColumn ( int columnIndex ) { addSortedColumn ( columnIndex , SortDirection . ASCENDING ) ; }
public Criteria andCityIsNull ( ) { addCriterion ( "city is null" ) ; return ( Criteria ) this ; }
public void addWeeks ( int weeks ) { super . addField ( DurationFieldType . weeks ( ) , weeks ) ; }
public void shutdown ( ) { cleanIdle ( 0 ) ; eurekaConnCleaner . shutdown ( ) ; Monitors . unregisterObject ( this ) ; }
public boolean isBusy ( ) { return effectiveMode != PaintMode . NONE ; }
public void setYears ( int years ) { super . setField ( DurationFieldType . years ( ) , years ) ; }
public PieEntry copy ( ) { PieEntry e = new PieEntry ( getY ( ) , label , getData ( ) ) ; return e ; }
void onStartBoundedReplay ( final long correlationId , final long recordingId , final long position , final long length , final int limitCounterId , final int fileIoMaxLength , final int replayStreamId , final String replayChannel ) { attemptToActivate ( ) ; if ( State . ACTIVE == state ) { conductor . startBoundedReplay ( correlationId , recordingId , position , length , limitCounterId , fileIoMaxLength , replayStreamId , replayChannel , this ) ; } }
public void setProfileEnable ( String profileEnable ) { this . profileEnable = profileEnable ; }
static ServerAuthenticationProvider wrap ( AuthenticationProvider provider ) { if ( provider == null ) { return null ; } return ( provider instanceof ServerAuthenticationProvider ) ? ( ServerAuthenticationProvider ) provider : new WrappedAuthenticationProvider ( provider ) ; }
public OkHttpClient getClient ( ) { if ( client == null ) { client = new OkHttpClient ( ) ; } return client ; }
public static CharStream fromPath ( Path path , Charset charset ) throws IOException { long size = Files . size ( path ) ; try ( ReadableByteChannel channel = Files . newByteChannel ( path ) ) { return fromChannel ( channel , charset , DEFAULT_BUFFER_SIZE , CodingErrorAction . REPLACE , path . toString ( ) , size ) ; } }
private static < T > boolean acceptFile ( File file , String endpointPath , GenericFileFilter < T > filter , AntFilter antFilter , Pattern excludePattern , Pattern includePattern ) { GenericFile gf = new GenericFile < > ( ) ; gf . setEndpointPath ( endpointPath ) ; gf . setFile ( file ) ; gf . setFileNameOnly ( file . getName ( ) ) ; gf . setFileLength ( file . length ( ) ) ; gf . setDirectory ( file . isDirectory ( ) ) ; gf . setAbsolute ( FileUtil . isAbsolute ( file ) ) ; gf . setAbsoluteFilePath ( file . getAbsolutePath ( ) ) ; gf . setLastModified ( file . lastModified ( ) ) ; File path ; String endpointNormalized = FileUtil . normalizePath ( endpointPath ) ; if ( file . getPath ( ) . startsWith ( endpointNormalized + File . separator ) ) { path = new File ( StringHelper . after ( file . getPath ( ) , endpointNormalized + File . separator ) ) ; } else { path = new File ( file . getPath ( ) ) ; } if ( path . getParent ( ) != null ) { gf . setRelativeFilePath ( path . getParent ( ) + File . separator + file . getName ( ) ) ; } else { gf . setRelativeFilePath ( path . getName ( ) ) ; } gf . setFileName ( gf . getRelativeFilePath ( ) ) ; if ( filter != null ) { if ( ! filter . accept ( gf ) ) { return false ; } } if ( file . isDirectory ( ) ) { return true ; } if ( antFilter != null ) { if ( ! antFilter . accept ( gf . isDirectory ( ) , gf . getRelativeFilePath ( ) ) ) { return false ; } } if ( excludePattern != null ) { if ( excludePattern . matcher ( file . getName ( ) ) . matches ( ) ) { return false ; } } if ( includePattern != null ) { if ( ! includePattern . matcher ( file . getName ( ) ) . matches ( ) ) { return false ; } } return true ; }
public Iterator < File > iterator ( ) { return iter ; }
protected void scanJobLog ( ) { File jobLog = getJobLog ( ) ; launchCount = 0 ; if ( ! jobLog . exists ( ) ) return ; try { Pattern launchLine = Pattern . compile ( "(\\S+) (\\S+) Job launched" ) ; long startPosition = 0 ; if ( jobLog . length ( ) > FileUtils . ONE_KB * 100 ) { isLaunchInfoPartial = true ; startPosition = jobLog . length ( ) - ( FileUtils . ONE_KB * 100 ) ; } try ( FileInputStream jobLogIn = new FileInputStream ( jobLog ) ) { jobLogIn . getChannel ( ) . position ( startPosition ) ; BufferedReader jobLogReader = new BufferedReader ( new InputStreamReader ( jobLogIn ) ) ; String line ; if ( startPosition != 0 ) { line = jobLogReader . readLine ( ) ; } while ( ( line = jobLogReader . readLine ( ) ) != null ) { Matcher m = launchLine . matcher ( line ) ; if ( m . matches ( ) ) { launchCount ++ ; lastLaunch = Instant . parse ( m . group ( 1 ) ) ; } } } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
default double apply ( T x , T y ) { return d ( x , y ) ; }
public ViewHolder onCreateViewHolder ( @ NonNull ViewGroup parent , int viewType ) { ViewHolder holder = new ViewHolder ( AdapterVodBinding . inflate ( LayoutInflater . from ( parent . getContext ( ) ) , parent , false ) ) ; holder . binding . getRoot ( ) . getLayoutParams ( ) . width = width ; holder . binding . image . getLayoutParams ( ) . height = height ; return holder ; }
public String getEventDescription ( ) { return "Updating Instance affinity group" ; }
public int size ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { return size ; } finally { lock . unlock ( ) ; } }
public void setPointerDrawable ( @ DrawableRes int pointerDrawable ) { setPointerDrawable ( getResources ( ) . getDrawable ( pointerDrawable ) ) ; }
public Mono < Authentication > authenticate ( Authentication authentication ) { String username = authentication . getName ( ) ; String presentedPassword = ( authentication . getCredentials ( ) != null ) ? authentication . getCredentials ( ) . toString ( ) : null ; return retrieveUser ( username ) . doOnNext ( this . preAuthenticationChecks :: check ) . publishOn ( this . scheduler ) . filter ( ( userDetails ) -> this . passwordEncoder . matches ( presentedPassword , userDetails . getPassword ( ) ) ) . switchIfEmpty ( Mono . defer ( ( ) -> Mono . error ( new BadCredentialsException ( "Invalid Credentials" ) ) ) ) . flatMap ( ( userDetails ) -> checkCompromisedPassword ( presentedPassword ) . thenReturn ( userDetails ) ) . flatMap ( ( userDetails ) -> upgradeEncodingIfNecessary ( userDetails , presentedPassword ) ) . doOnNext ( this . postAuthenticationChecks :: check ) . map ( this :: createUsernamePasswordAuthenticationToken ) ; }
public Criteria andTenantIdGreaterThan ( Long value ) { addCriterion ( "tenant_id >" , value , "tenantId" ) ; return ( Criteria ) this ; }
V replace ( K key , int hash , V newValue ) { lock ( ) ; try { removeStale ( ) ; HashEntry < K , V > e = getFirst ( hash ) ; while ( e != null && ( e . hash != hash || ! key . equals ( e . keyRef . get ( ) ) ) ) e = e . next ; V oldValue = null ; if ( e != null ) { oldValue = e . value ; e . value = newValue ; } return oldValue ; } finally { unlock ( ) ; } }
protected List < RecoveryInfo > getAllRecoveryInfos ( Connection c ) throws SQLException { try ( PreparedStatement s = c . prepareStatement ( "SELECT * from `positions` where client_id = ? order by last_heartbeat_read DESC" ) ) { s . setString ( 1 , clientID ) ; try ( ResultSet rs = s . executeQuery ( ) ) { ArrayList < RecoveryInfo > recoveries = new ArrayList < > ( ) ; while ( rs . next ( ) ) { Long server_id = rs . getLong ( "server_id" ) ; String gtid = gtidMode ? rs . getString ( "gtid_set" ) : null ; Position position = new Position ( BinlogPosition . at ( gtid , rs . getLong ( "binlog_position" ) , rs . getString ( "binlog_file" ) ) , rs . getLong ( "last_heartbeat_read" ) ) ; if ( rs . wasNull ( ) ) { LOGGER . warn ( "master recovery is ignoring position with NULL heartbeat" ) ; } else { recoveries . add ( new RecoveryInfo ( position , server_id , clientID ) ) ; } } return recoveries ; } } }
protected boolean isMenuBarEmbedded ( ) { if ( isFullWindowContent ( ) ) return false ; return FlatUIUtils . getBoolean ( rootPane , FlatSystemProperties . MENUBAR_EMBEDDED , FlatClientProperties . MENU_BAR_EMBEDDED , "TitlePane.menuBarEmbedded" , false ) ; }
public DevicesNested < A > addNewDeviceLike ( V1beta1AllocatedDeviceStatus item ) { return new DevicesNested ( - 1 , item ) ; }
public boolean isAttachedToNavigationController ( ) { return ( flags & FLAG_ATTACHED_TO_NAVIGATION ) != 0 ; }
public String stringify ( int value ) { return stringifyWithScale ( BigInteger . valueOf ( value ) ) ; }
public Criteria andUpdateUserBetween ( String value1 , String value2 ) { addCriterion ( "update_user between" , value1 , value2 , "updateUser" ) ; return ( Criteria ) this ; }
public static Date parseDateStrictly ( final String str , final String ... parsePatterns ) throws ParseException { return parseDateStrictly ( str , null , parsePatterns ) ; }
protected boolean getDefaultEditable ( ) { throw new RuntimeException ( "Stub!" ) ; }
public void create ( final OContextConfiguration contextConfiguration , ODatabaseId id ) { try { stateLock . writeLock ( ) . lock ( ) ; try { doCreate ( contextConfiguration , id ) ; } finally { stateLock . writeLock ( ) . unlock ( ) ; } } catch ( final RuntimeException e ) { throw logAndPrepareForRethrow ( e ) ; } catch ( final Error e ) { throw logAndPrepareForRethrow ( e ) ; } catch ( final Throwable t ) { throw logAndPrepareForRethrow ( t ) ; } }
public void onResume ( ) { super . onResume ( ) ; getPreferenceManager ( ) . getSharedPreferences ( ) . registerOnSharedPreferenceChangeListener ( this ) ; }
public UUID getParentAccountId ( ) { return parentInvoice != null ? parentInvoice . getAccountId ( ) : null ; }
public static void warn ( Throwable throwable ) { warn ( throwable , null ) ; }
public UnRegisterNodeManagerResponseProto getProto ( ) { if ( rebuild ) { mergeLocalToProto ( ) ; } proto = viaProto ? proto : builder . build ( ) ; viaProto = true ; return proto ; }
public View onCreateThumbnailView ( Context context ) { throw new RuntimeException ( "Stub!" ) ; }
protected static XposedHookLoadPackageInner newIntance ( ) { return new XposedHookLoadPackageInner ( ) ; }
public static Set < String > findTablesInExpression ( String exprStr ) throws JSQLParserException { TablesNamesFinder < ? > tablesNamesFinder = new TablesNamesFinder < > ( ) ; return tablesNamesFinder . getTables ( CCJSqlParserUtil . parseExpression ( exprStr ) ) ; }
private Map < String , Object > mediaStreamToMap ( MediaStream stream ) { ConstraintsMap params = new ConstraintsMap ( ) ; params . putString ( "streamId" , stream . getId ( ) ) ; params . putString ( "ownerTag" , id ) ; ConstraintsArray audioTracks = new ConstraintsArray ( ) ; ConstraintsArray videoTracks = new ConstraintsArray ( ) ; for ( MediaStreamTrack track : stream . audioTracks ) { audioTracks . pushMap ( new ConstraintsMap ( mediaTrackToMap ( track ) ) ) ; } for ( MediaStreamTrack track : stream . videoTracks ) { videoTracks . pushMap ( new ConstraintsMap ( mediaTrackToMap ( track ) ) ) ; } params . putArray ( "audioTracks" , audioTracks . toArrayList ( ) ) ; params . putArray ( "videoTracks" , videoTracks . toArrayList ( ) ) ; return params . toMap ( ) ; }
default JSONMap < M , L > puts ( Object value ) { put ( value ) ; return this ; }
public static boolean isSQLJoin ( Join < ? , ? , ? > j ) { return j != null && j . isSQLJoin ( ) ; }
public final String getMimeType ( int idx ) { if ( idx >= this . mimeTypeList . length ) return "" ; return this . mimeTypeList [ idx ] ; }
public void addInnerClass ( InnerClass innerClass ) { innerClasses . add ( innerClass ) ; }
public int getLineStyleDashLength ( ) { return mLineStyleDashLength ; }
public NormalGraphPanel getSecondaryPanel ( ) { return secondaryPanel ; }
public String toVarName ( String name ) { if ( nameMapping . containsKey ( name ) ) { return nameMapping . get ( name ) ; } name = sanitizeName ( name ) ; name = name . replace ( "$" , "" ) ; if ( name . matches ( "^[A-Z_]*$" ) ) { name = name . toLowerCase ( Locale . ROOT ) ; } name = underscore ( name ) ; name = name . replaceAll ( "^_*" , "" ) ; if ( isReservedWord ( name ) || name . matches ( "^\\d.*" ) ) { name = escapeReservedWord ( name ) ; } return name ; }
abstract JobLifeCycle autoBuild ( ) ; public final JobLifeCycle build ( ) { JobLifeCycle jobLifeCycle = autoBuild ( ) ; if ( jobLifeCycle . state ( ) . equals ( State . ENDED ) ) { Preconditions . checkArgument ( jobLifeCycle . endReason ( ) != null , "End reason required when JobState is ENDED" ) ; } return jobLifeCycle ; }
public void paint ( Level level ) { super . paint ( level ) ; int exit ; int tries = 30 ; boolean valid ; do { exit = level . pointToCell ( random ( 2 ) ) ; if ( tries -- > 0 ) { valid = level . map [ exit ] != Terrain . WALL && level . findMob ( exit ) == null ; } else { valid = false ; for ( int i : PathFinder . NEIGHBOURS4 ) { if ( level . map [ exit + i ] != Terrain . WALL && level . map [ exit + i ] != Terrain . REGION_DECO ) { valid = true ; } } valid = valid && level . findMob ( exit ) == null ; } } while ( ! valid ) ; Painter . set ( level , exit , Terrain . EXIT ) ; for ( int i : PathFinder . NEIGHBOURS8 ) { Painter . set ( level , exit + i , Terrain . EMPTY ) ; } level . transitions . add ( new LevelTransition ( level , exit , LevelTransition . Type . REGULAR_EXIT ) ) ; }
protected int getTickLength ( ) { return UIScale . scale ( super . getTickLength ( ) ) ; }
public < V > Map < String , V > get ( String ... keys ) { RFuture < Map < String , V > > future = getAsync ( keys ) ; return commandExecutor . get ( future ) ; }
public void draw ( Batch spriteBatch ) { Array < TextureRegion > regions = font . getRegions ( ) ; for ( int j = 0 , n = pageVertices . length ; j < n ; j ++ ) { if ( idx [ j ] > 0 ) { float [ ] vertices = pageVertices [ j ] ; spriteBatch . draw ( regions . get ( j ) . getTexture ( ) , vertices , 0 , idx [ j ] ) ; } } }
private String getOriginalSignatureFromAsset ( Context context ) { return FileUtils . readTextFromAssets ( context , SIGNATURE_INFO_ASSET_PATH ) ; }
public LiveData < Boolean > hasMessage ( ) { return hasMessageLiveData ; }
public < W extends WWidget > Cell < W > add ( W widget ) { return window . add ( widget ) ; }
private void cancelDotScaleAnim ( ) { if ( mDotScaleAnim != null ) { mDotScaleAnim . cancel ( ) ; } }
public void notifyDataSetChanged ( ) { super . notifyDataSetChanged ( ) ; if ( ( playlist . size ( ) > 1 ) != listViewIsVisible ) { listViewIsVisible = playlist . size ( ) > 1 ; if ( listViewIsVisible ) { listView . setVisibility ( View . VISIBLE ) ; listView . setTranslationY ( AndroidUtilities . displaySize . y ) ; listView . animate ( ) . translationY ( 0 ) . setUpdateListener ( a -> containerView . invalidate ( ) ) . setDuration ( 420 ) . setInterpolator ( CubicBezierInterpolator . EASE_OUT_QUINT ) . start ( ) ; } else { listView . animate ( ) . translationY ( AndroidUtilities . displaySize . y ) . setUpdateListener ( a -> containerView . invalidate ( ) ) . setDuration ( 420 ) . setInterpolator ( CubicBezierInterpolator . EASE_OUT_QUINT ) . withEndAction ( ( ) -> listView . setVisibility ( View . GONE ) ) . start ( ) ; } } if ( playlist . size ( ) > 1 ) { playerLayout . setBackgroundColor ( getThemedColor ( Theme . key_player_background ) ) ; playerShadow . setVisibility ( View . VISIBLE ) ; listView . setPadding ( 0 , listView . getPaddingTop ( ) , 0 , dp ( 179 + 52 ) ) ; } else { playerLayout . setBackgroundColor ( getThemedColor ( Theme . key_player_background ) ) ; playerShadow . setVisibility ( View . VISIBLE ) ; listView . setPadding ( 0 , listView . getPaddingTop ( ) , 0 , 0 ) ; } updateEmptyView ( ) ; }
public Builder clientSetInfoConfig ( ClientSetInfoConfig setInfoConfig ) { this . clientSetInfoConfig = setInfoConfig ; return this ; }
public static String copyToString ( InputStream in , Charset encoding ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( 4096 ) ; copy ( in , out ) ; return out . toString ( encoding . name ( ) ) ; }
private void writerServiceEnvironment ( IndentingWriter writer , Map < String , String > environment ) { if ( environment . isEmpty ( ) ) { return ; } writer . println ( "environment:" ) ; writer . indented ( ( ) -> { for ( Map . Entry < String , String > env : environment . entrySet ( ) ) { writer . println ( "- '%s=%s'" . formatted ( env . getKey ( ) , env . getValue ( ) ) ) ; } } ) ; }
public void endArray ( ) throws IOException { delegate . readEndArray ( ) ; }
String getCountQueryProjection ( ) { String countProjection = getAnnotationValue ( "countProjection" , String . class ) ; return StringUtils . hasText ( countProjection ) ? countProjection : null ; }
public String createSourcePropertyErrorMessage ( ) { return conditionallyCapitalizedElementType ( ) + " \"" + getSourceType ( ) . describe ( ) + " " + stripBrackets ( getDottedSourceElement ( ) ) + "\"" ; }
String stringifyNotNull ( Binary value ) { try { WKBReader reader = new WKBReader ( ) ; Geometry geometry = reader . read ( value . getBytesUnsafe ( ) ) ; return geometry . toText ( ) ; } catch ( ParseException e ) { return BINARY_INVALID ; } }
public Criteria andAddTimeGreaterThanOrEqualToColumn ( LitemallIssue . Column column ) { addCriterion ( new StringBuilder ( "add_time >= " ) . append ( column . getEscapedColumnName ( ) ) . toString ( ) ) ; return ( Criteria ) this ; }
public String getJavaHome ( ) { return javaHome ; }
public String getGlobalRouteAddress ( ) { RuleEntity ruleEntity = pluginAdapter . getRule ( ) ; if ( ruleEntity != null ) { StrategyEntity strategyEntity = ruleEntity . getStrategyEntity ( ) ; if ( strategyEntity != null ) { return strategyEntity . getAddressValue ( ) ; } } return null ; }
public Map < String , Object > toKarateJson ( ) { Map < String , Object > map = new HashMap < > ( ) ; map . put ( "name" , feature . getName ( ) ) ; map . put ( "description" , feature . getDescription ( ) ) ; map . put ( "durationMillis" , getDurationMillis ( ) ) ; map . put ( "passedCount" , getPassedCount ( ) ) ; map . put ( "failedCount" , getFailedCount ( ) ) ; map . put ( "packageQualifiedName" , feature . getPackageQualifiedName ( ) ) ; map . put ( "relativePath" , feature . getResource ( ) . getRelativePath ( ) ) ; if ( resultDate == null ) { resultDate = ReportUtils . getDateString ( ) ; } map . put ( "resultDate" , resultDate ) ; map . put ( "prefixedPath" , feature . getResource ( ) . getPrefixedPath ( ) ) ; List < Map < String , Object > > list = new ArrayList < > ( scenarioResults . size ( ) ) ; map . put ( "scenarioResults" , list ) ; for ( ScenarioResult sr : scenarioResults ) { list . add ( sr . toKarateJson ( ) ) ; } if ( callArg != null ) { String json = JsonUtils . toJsonSafe ( callArg , false ) ; map . put ( "callArg" , JsonUtils . fromJson ( json ) ) ; } map . put ( "loopIndex" , loopIndex ) ; map . put ( "callDepth" , callDepth ) ; return map ; }
public void setBootstrapResolverRefreshIntervalSeconds ( int bootstrapResolverRefreshIntervalSeconds ) { this . bootstrapResolverRefreshIntervalSeconds = bootstrapResolverRefreshIntervalSeconds ; }
public Date getStartTime ( ) { return startTime ; }
public boolean isTest ( ) { return isTest ; }
FormatterFunc . Closeable toFunc ( ) { ProcessRunner runner = new ProcessRunner ( ) ; return FormatterFunc . Closeable . of ( runner , this :: format ) ; }
public < X0 > Sextet < A , B , C , D , E , X0 > add ( final X0 value0 ) { return addAt5 ( value0 ) ; }
public HandlerWrapper build ( Map < String , Object > config ) { return new Wrapper ( Predicates . truePredicate ( ) ) ; }
protected PartDContractID getRandomContractID ( RandomNumberGenerator rand ) { if ( rand . randInt ( 100 ) < 30 ) { return null ; } return partDContractIDs [ rand . randInt ( partDContractIDs . length ) ] ; }
protected void setControllerAnimated ( ViewController < ? > controller , boolean asForward , boolean saveFirst ) { if ( navigationController != null ) { navigationController . setControllerAnimated ( controller , asForward , saveFirst ) ; } }
public Optional < ExecutionWriterTarget > getWriterTarget ( ) { return writerTarget ; }
public void open ( ReadableMap options ) throws ActivityNotFoundException { System . out . println ( getPackage ( ) ) ; if ( getPackage ( ) != null || getDefaultWebLink ( ) != null || getPlayStoreLink ( ) != null ) { if ( this . isPackageInstalled ( getPackage ( ) , reactContext ) ) { System . out . println ( "INSTALLED" ) ; if ( getComponentClass ( ) != null ) { ComponentName cn = new ComponentName ( getPackage ( ) , getComponentClass ( ) ) ; this . getIntent ( ) . setComponent ( cn ) ; } else { this . getIntent ( ) . setPackage ( getPackage ( ) ) ; } super . open ( options ) ; return ; } else { System . out . println ( "NOT INSTALLED" ) ; String url = "" ; if ( getDefaultWebLink ( ) != null ) { url = getDefaultWebLink ( ) . replace ( "{url}" , this . urlEncode ( options . getString ( "url" ) ) ) . replace ( "{message}" , this . urlEncode ( options . getString ( "message" ) ) ) ; } else if ( getPlayStoreLink ( ) != null ) { url = getPlayStoreLink ( ) ; } else { } this . setIntent ( new Intent ( new Intent ( "android.intent.action.VIEW" , Uri . parse ( url ) ) ) ) ; } } super . open ( options ) ; }
public int getItemCount ( ) { return result . getUrl ( ) . getValues ( ) . size ( ) ; }
JobDetails getJobDetails ( IocJobLambda < ? > lambda ) { return initOrGetJobDetails ( ( ) -> jobDetailsGeneratorDelegate . toJobDetails ( lambda ) , ( ) -> initJobParameterRetrievers ( jobDetails , lambda , Optional . empty ( ) ) , ( ) -> getCachedJobDetails ( lambda , Optional . empty ( ) ) ) ; }
public ServerHolder next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } ServerHolder previous = nextEligible ; delegate . advanceCursor ( ) ; nextEligible = search ( ) ; return previous ; }
public boolean matches ( MockServerLogger mockServerLogger , MatchDifference context , String json ) { if ( schemaJsonNode != null ) { try { if ( isNotBlank ( type ) && type . equals ( "string" ) && isNotBlank ( json ) && ! json . startsWith ( "\"" ) && ! json . endsWith ( "\"" ) ) { json = "\"" + json + "\"" ; } String validationErrors = validate ( json ) ; boolean result = isNot ( ) != validationErrors . isEmpty ( ) ; if ( ! result && context != null ) { context . addDifference ( mockServerLogger , "schema match failed expect:{}found:{}errors:{}" , this . json , json , validationErrors ) ; } return result ; } catch ( Throwable throwable ) { MOCK_SERVER_LOGGER . logEvent ( new LogEntry ( ) . setLogLevel ( Level . ERROR ) . setMessageFormat ( "exception validating JSON" ) . setThrowable ( throwable ) ) ; if ( ! isNot ( ) && context != null ) { context . addDifference ( mockServerLogger , "schema match failed expect:{}found error:{}for:{}" , this . json , throwable . getMessage ( ) , json ) ; } } return isNot ( ) ; } else { return ! isNot ( ) ; } }
private String decodeURIComponent ( String string ) { try { return URLDecoder . decode ( string , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { throw new IllegalStateException ( "Unexpected UTF-8 encoding error." , e ) ; } }
public void setRawDate ( String s ) { rawDate = s ; }
public void open ( StatisticRegistry < Solution_ > registry , Tags runTag , Solver < Solution_ > solver ) { registry . addListener ( SolverMetric . BEST_SCORE , timestamp -> registry . extractScoreFromMeters ( SolverMetric . BEST_SCORE , runTag , score -> pointList . add ( new BestScoreStatisticPoint ( timestamp , score ) ) ) ) ; }
public static IWindowManager asInterface ( IBinder obj ) { throw new UnsupportedOperationException ( ) ; }
public static Scope maybeNewScope ( boolean scopesEnabled , Scope existingScope , JFlexStackingLexer lexer , Definitions defs ) { if ( scopesEnabled && existingScope == null ) { int line = lexer . getLineNumber ( ) ; return Optional . ofNullable ( defs ) . map ( objDefs -> objDefs . getTags ( line ) ) . stream ( ) . flatMap ( Collection :: stream ) . filter ( tag -> tag . type . startsWith ( "function" ) || tag . type . startsWith ( "method" ) ) . findFirst ( ) . map ( tag -> new Scope ( tag . line , tag . line , tag . symbol , tag . namespace , tag . signature ) ) . orElse ( null ) ; } return null ; }
public < T > HttpResponse < T > send ( HttpRequest request , HttpResponse . BodyHandler < T > handler ) throws IOException , InterruptedException { return retryHandler . call ( delegate , request , handler ) ; }
public long getAverageRequestTime ( ) { lock . lock ( ) ; try { return requestCount == 0 ? 0 : accumulatedRequestTime / requestCount ; } finally { lock . unlock ( ) ; } }
public void actionPerformed ( java . awt . event . ActionEvent evt ) { clearButtonActionPerformed ( evt ) ; }
public List < ProfilesGroup > parsePredefinedEngines ( String content ) { try { return parsePredefinedEnginesImpl ( content ) ; } catch ( JSONException e ) { LOG . error ( "Error trying parse JSON: " + e . getMessage ( ) ) ; } return null ; }
protected void disconnect ( ) { super . disconnect ( ) ; }
public void updateOrderStatus ( @ PathVariable final Long id , @ Valid @ RequestBody String status , @ ApiIgnore MerchantStore merchantStore , @ ApiIgnore Language language ) { String user = authorizationUtils . authenticatedUser ( ) ; authorizationUtils . authorizeUser ( user , Stream . of ( Constants . GROUP_SUPERADMIN , Constants . GROUP_ADMIN , Constants . GROUP_ADMIN_ORDER , Constants . GROUP_ADMIN_RETAIL ) . collect ( Collectors . toList ( ) ) , merchantStore ) ; Order order = orderService . getOrder ( id , merchantStore ) ; if ( order == null ) { throw new GenericRuntimeException ( "412" , "Order not found [" + id + "]" ) ; } OrderStatus statusEnum = OrderStatus . valueOf ( status ) ; orderFacade . updateOrderStatus ( order , statusEnum , merchantStore ) ; return ; }
public < T > void remove ( Class < T > clazz , String id ) { if ( clazz == null ) { Log . e ( TAG , "remove  clazz == null >> return;" ) ; return ; } new Cache < T > ( clazz , context , getListPath ( clazz ) ) . remove ( id ) ; }
public static PlaylistCreationDialog newInstance ( final List < StreamEntity > streamEntities ) { final PlaylistCreationDialog dialog = new PlaylistCreationDialog ( ) ; dialog . setStreamEntities ( streamEntities ) ; return dialog ; }
public String getLoginName ( ) { return loginName ; }
public Criteria andSalesManLessThanOrEqualTo ( String value ) { addCriterion ( "sales_man <=" , value , "salesMan" ) ; return ( Criteria ) this ; }
public String getWorkspaceName ( ) { return workspaceName ; }
public Criteria andOtherMoneyIn ( List < BigDecimal > values ) { addCriterion ( "other_money in" , values , "otherMoney" ) ; return ( Criteria ) this ; }
public double getUsagePercentage ( ) { return usagePercentage ; }
public Criteria andReportObjectGreaterThanOrEqualTo ( String value ) { addCriterion ( "report_object >=" , value , "reportObject" ) ; return ( Criteria ) this ; }
public String toString ( ) { return stringPrefix ( ) + "(" + ( isEmpty ( ) ? "" : "?" ) + ")" ; }
public int getBatchRows ( ) { Integer rows = options . getInt ( KEY_MAX_BATCH_ROWS ) ; return null == rows ? BATCH_ROWS : rows ; }
private void handleMultiChoiceConstructorConfiguration ( JsonNode node , JDefinedClass instanceClass , Schema currentSchema ) { boolean requiresConstructors = false ; Map < String , String > requiredClassProperties = null ; Map < String , String > classProperties = null ; Map < String , String > requiredCombinedSuperProperties = null ; Map < String , String > combinedSuperProperties = null ; GenerationConfig generationConfig = ruleFactory . getGenerationConfig ( ) ; boolean includeCopyConstructor = generationConfig . isIncludeCopyConstructor ( ) ; boolean includeAllPropertiesConstructor = generationConfig . isIncludeAllPropertiesConstructor ( ) ; boolean includeRequiredPropertiesConstructor = generationConfig . isIncludeRequiredPropertiesConstructor ( ) ; if ( includeAllPropertiesConstructor || includeCopyConstructor ) { classProperties = getConstructorProperties ( node , false ) ; combinedSuperProperties = getSuperTypeConstructorPropertiesRecursive ( node , currentSchema , false ) ; requiresConstructors = requiresConstructors || ! classProperties . isEmpty ( ) || ! combinedSuperProperties . isEmpty ( ) ; } if ( includeRequiredPropertiesConstructor ) { requiredClassProperties = getConstructorProperties ( node , true ) ; requiredCombinedSuperProperties = getSuperTypeConstructorPropertiesRecursive ( node , currentSchema , true ) ; requiresConstructors = requiresConstructors || ! requiredClassProperties . isEmpty ( ) || ! requiredCombinedSuperProperties . isEmpty ( ) ; } if ( requiresConstructors ) { generateNoArgsConstructor ( instanceClass ) ; if ( includeCopyConstructor ) { addCopyConstructor ( instanceClass , classProperties , combinedSuperProperties ) ; } if ( includeAllPropertiesConstructor && ( classProperties . size ( ) + combinedSuperProperties . size ( ) ) > 0 ) { addFieldsConstructor ( instanceClass , classProperties , combinedSuperProperties ) ; } if ( includeRequiredPropertiesConstructor && ( requiredClassProperties . size ( ) + requiredCombinedSuperProperties . size ( ) ) > 0 ) { addFieldsConstructor ( instanceClass , requiredClassProperties , requiredCombinedSuperProperties ) ; } } }
private void recordArchive ( ) { double limits ; try { limits = Double . parseDouble ( sharedPreferences . getString ( "setting_pos_history" , getResources ( ) . getString ( R . string . history_expiration ) ) ) ; } catch ( NumberFormatException e ) { limits = 7 ; } final long weekSecond = ( long ) ( limits * 24 * 60 * 60 ) ; try { mHistoryLocationDB . delete ( DataBaseHistoryLocation . TABLE_NAME , DataBaseHistoryLocation . DB_COLUMN_TIMESTAMP + " < ?" , new String [ ] { Long . toString ( System . currentTimeMillis ( ) / 1000 - weekSecond ) } ) ; } catch ( Exception e ) { Log . e ( "HistoryActivity" , "ERROR - recordArchive" ) ; } }
public Criteria andAnswerNotBetween ( String value1 , String value2 ) { addCriterion ( "answer not between" , value1 , value2 , "answer" ) ; return ( Criteria ) this ; }
public boolean isPollComplete ( ) { return isPollComplete ; }
protected final static void inferPdfInputPath ( final GrobidMainArgs pGbdArgs ) { String tmpFilePath ; if ( pGbdArgs . getPath2Input ( ) == null ) { tmpFilePath = new File ( "." ) . getAbsolutePath ( ) ; LOGGER . info ( "No path set for the input directory. Using: " + tmpFilePath ) ; pGbdArgs . setPath2Input ( tmpFilePath ) ; } }
public MappeableContainerPointer clone ( ) { try { return ( MappeableContainerPointer ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { return null ; } }
Short update ( Short dst , Short src ) { if ( src == null ) { return dst ; } if ( dst == null ) { return src ; } int ret = dst + src ; return ( short ) ret ; }
public boolean hasChapAuthSession ( ) { return this . chapAuthSession != null ; }
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { int width = MeasureSpec . getSize ( widthMeasureSpec ) ; int availWidth = Math . max ( 0 , width - Screen . dp ( 12f ) * 2 ) ; if ( this . lastAvailWidth != availWidth ) { this . lastAvailWidth = availWidth ; layoutTexts ( availWidth ) ; } int height = calculateHeight ( ) ; super . onMeasure ( widthMeasureSpec , MeasureSpec . makeMeasureSpec ( height , MeasureSpec . EXACTLY ) ) ; }
public Entry < K , V > next ( ) { getNextIfNecessary ( ) ; if ( this . next == null ) { throw new NoSuchElementException ( ) ; } this . last = this . next ; this . next = null ; return this . last ; }
public void hessian ( Blackhole bh ) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; Hessian2Output hessian2Output = new Hessian2Output ( byteArrayOutputStream ) ; hessian2Output . writeObject ( mc ) ; hessian2Output . flush ( ) ; bh . consume ( byteArrayOutputStream . toByteArray ( ) ) ; }
public String getTitle ( ) { return title ; }
public Criteria andAccountMoneyListNotBetween ( String value1 , String value2 ) { addCriterion ( "account_money_list not between" , value1 , value2 , "accountMoneyList" ) ; return ( Criteria ) this ; }
private void visitTypeInsn ( final int opcode , final String type ) { lastBytecodeOffset = code . length ; Symbol typeSymbol = symbolTable . addConstantUtf8Reference ( 7 , type ) ; code . put12 ( opcode , typeSymbol . index ) ; if ( currentBasicBlock != null ) { currentBasicBlock . frame . execute ( opcode , lastBytecodeOffset , typeSymbol , symbolTable ) ; } }
public GenericTableBase createTableOrViewImpl ( @ NotNull GenericStructContainer container , @ Nullable String tableName , @ Nullable String tableType , @ Nullable JDBCResultSet dbResult ) { if ( tableType != null && isView ( tableType ) ) { return new ClickhouseView ( container , tableName , tableType , dbResult ) ; } else { return new ClickhouseTable ( container , tableName , tableType , dbResult ) ; } }
public Map < String , Object > getJsonStructure ( boolean verbose ) { Map < String , Object > execState = new HashMap < > ( ) ; execState . put ( STATE , _state ) ; if ( _recentlyDemotedBrokers != null && ! _recentlyDemotedBrokers . isEmpty ( ) ) { execState . put ( RECENTLY_DEMOTED_BROKERS , _recentlyDemotedBrokers ) ; } if ( _recentlyRemovedBrokers != null && ! _recentlyRemovedBrokers . isEmpty ( ) ) { execState . put ( RECENTLY_REMOVED_BROKERS , _recentlyRemovedBrokers ) ; } Map < ExecutionTaskState , Integer > interBrokerPartitionMovementStats ; Map < ExecutionTaskState , Integer > intraBrokerPartitionMovementStats ; switch ( _state ) { case NO_TASK_IN_PROGRESS : break ; case STARTING_EXECUTION : case INITIALIZING_PROPOSAL_EXECUTION : case GENERATING_PROPOSALS_FOR_EXECUTION : populateUuidFieldInJsonStructure ( execState , _uuid ) ; execState . put ( TRIGGERED_TASK_REASON , _reason ) ; break ; case LEADER_MOVEMENT_TASK_IN_PROGRESS : populateUuidFieldInJsonStructure ( execState , _uuid ) ; execState . put ( TRIGGERED_TASK_REASON , _reason ) ; execState . put ( MAXIMUM_BROKER_LEADER_MOVEMENT_CONCURRENCY , _executionConcurrencySummary . getMaxExecutionConcurrency ( ConcurrencyType . LEADERSHIP_BROKER ) ) ; execState . put ( MINIMUM_BROKER_LEADER_MOVEMENT_CONCURRENCY , _executionConcurrencySummary . getMinExecutionConcurrency ( ConcurrencyType . LEADERSHIP_BROKER ) ) ; execState . put ( AVERAGE_BROKER_LEADER_MOVEMENT_CONCURRENCY , _executionConcurrencySummary . getAvgExecutionConcurrency ( ConcurrencyType . LEADERSHIP_BROKER ) ) ; execState . put ( CLUSTER_LEADER_MOVEMENT_CONCURRENCY , _executionConcurrencySummary . getClusterLeadershipMovementConcurrency ( ) ) ; execState . put ( NUM_PENDING_LEADERSHIP_MOVEMENTS , _executionTasksSummary . taskStat ( ) . get ( LEADER_ACTION ) . get ( ExecutionTaskState . PENDING ) ) ; execState . put ( NUM_FINISHED_LEADERSHIP_MOVEMENTS , numFinishedMovements ( LEADER_ACTION ) ) ; execState . put ( NUM_TOTAL_LEADERSHIP_MOVEMENTS , numTotalMovements ( LEADER_ACTION ) ) ; if ( verbose ) { execState . put ( PENDING_LEADERSHIP_MOVEMENT , getTaskDetails ( LEADER_ACTION , ExecutionTaskState . PENDING ) ) ; } break ; case INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS : interBrokerPartitionMovementStats = _executionTasksSummary . taskStat ( ) . get ( INTER_BROKER_REPLICA_ACTION ) ; populateUuidFieldInJsonStructure ( execState , _uuid ) ; execState . put ( TRIGGERED_TASK_REASON , _reason ) ; execState . put ( MAXIMUM_CONCURRENT_INTER_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getMaxExecutionConcurrency ( ConcurrencyType . INTER_BROKER_REPLICA ) ) ; execState . put ( MINIMUM_CONCURRENT_INTER_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getMinExecutionConcurrency ( ConcurrencyType . INTER_BROKER_REPLICA ) ) ; execState . put ( AVERAGE_CONCURRENT_INTER_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getAvgExecutionConcurrency ( ConcurrencyType . INTER_BROKER_REPLICA ) ) ; execState . put ( NUM_IN_PROGRESS_INTER_BROKER_PARTITION_MOVEMENTS , interBrokerPartitionMovementStats . get ( ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( NUM_ABORTING_INTER_BROKER_PARTITION_MOVEMENTS , interBrokerPartitionMovementStats . get ( ExecutionTaskState . ABORTING ) ) ; execState . put ( NUM_PENDING_INTER_BROKER_PARTITION_MOVEMENTS , interBrokerPartitionMovementStats . get ( ExecutionTaskState . PENDING ) ) ; execState . put ( NUM_FINISHED_INTER_BROKER_PARTITION_MOVEMENTS , numFinishedMovements ( INTER_BROKER_REPLICA_ACTION ) ) ; execState . put ( NUM_TOTAL_INTER_BROKER_PARTITION_MOVEMENTS , numTotalMovements ( INTER_BROKER_REPLICA_ACTION ) ) ; execState . put ( FINISHED_INTER_BROKER_DATA_MOVEMENT , _executionTasksSummary . finishedInterBrokerDataMovementInMB ( ) ) ; execState . put ( TOTAL_INTER_BROKER_DATA_TO_MOVE , numTotalInterBrokerDataToMove ( ) ) ; if ( verbose ) { execState . put ( IN_PROGRESS_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( PENDING_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . PENDING ) ) ; execState . put ( ABORTING_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . ABORTING ) ) ; execState . put ( ABORTED_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . ABORTED ) ) ; execState . put ( DEAD_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . DEAD ) ) ; execState . put ( COMPLETED_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . COMPLETED ) ) ; } break ; case INTRA_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS : intraBrokerPartitionMovementStats = _executionTasksSummary . taskStat ( ) . get ( INTRA_BROKER_REPLICA_ACTION ) ; populateUuidFieldInJsonStructure ( execState , _uuid ) ; execState . put ( TRIGGERED_TASK_REASON , _reason ) ; execState . put ( MAXIMUM_CONCURRENT_INTRA_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getMaxExecutionConcurrency ( ConcurrencyType . INTRA_BROKER_REPLICA ) ) ; execState . put ( MINIMUM_CONCURRENT_INTRA_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getMinExecutionConcurrency ( ConcurrencyType . INTRA_BROKER_REPLICA ) ) ; execState . put ( AVERAGE_CONCURRENT_INTRA_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getAvgExecutionConcurrency ( ConcurrencyType . INTRA_BROKER_REPLICA ) ) ; execState . put ( NUM_IN_PROGRESS_INTRA_BROKER_PARTITION_MOVEMENTS , intraBrokerPartitionMovementStats . get ( ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( NUM_ABORTING_INTRA_BROKER_PARTITION_MOVEMENTS , intraBrokerPartitionMovementStats . get ( ExecutionTaskState . ABORTING ) ) ; execState . put ( NUM_PENDING_INTRA_BROKER_PARTITION_MOVEMENTS , intraBrokerPartitionMovementStats . get ( ExecutionTaskState . PENDING ) ) ; execState . put ( NUM_FINISHED_INTRA_BROKER_PARTITION_MOVEMENTS , numFinishedMovements ( INTRA_BROKER_REPLICA_ACTION ) ) ; execState . put ( NUM_TOTAL_INTRA_BROKER_PARTITION_MOVEMENTS , numTotalMovements ( INTRA_BROKER_REPLICA_ACTION ) ) ; execState . put ( FINISHED_INTRA_BROKER_DATA_MOVEMENT , _executionTasksSummary . finishedIntraBrokerDataMovementInMB ( ) ) ; execState . put ( TOTAL_INTRA_BROKER_DATA_TO_MOVE , numTotalIntraBrokerDataToMove ( ) ) ; if ( verbose ) { execState . put ( IN_PROGRESS_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( PENDING_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . PENDING ) ) ; execState . put ( ABORTING_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . ABORTING ) ) ; execState . put ( ABORTED_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . ABORTED ) ) ; execState . put ( DEAD_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . DEAD ) ) ; execState . put ( COMPLETED_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . COMPLETED ) ) ; } break ; case STOPPING_EXECUTION : interBrokerPartitionMovementStats = _executionTasksSummary . taskStat ( ) . get ( INTER_BROKER_REPLICA_ACTION ) ; intraBrokerPartitionMovementStats = _executionTasksSummary . taskStat ( ) . get ( INTRA_BROKER_REPLICA_ACTION ) ; populateUuidFieldInJsonStructure ( execState , _uuid ) ; execState . put ( TRIGGERED_TASK_REASON , _reason ) ; execState . put ( MAXIMUM_CONCURRENT_INTER_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getMaxExecutionConcurrency ( ConcurrencyType . INTER_BROKER_REPLICA ) ) ; execState . put ( MAXIMUM_CONCURRENT_INTRA_BROKER_PARTITION_MOVEMENTS_PER_BROKER , _executionConcurrencySummary . getMaxExecutionConcurrency ( ConcurrencyType . INTRA_BROKER_REPLICA ) ) ; execState . put ( MAXIMUM_BROKER_LEADER_MOVEMENT_CONCURRENCY , _executionConcurrencySummary . getMaxExecutionConcurrency ( ConcurrencyType . LEADERSHIP_BROKER ) ) ; execState . put ( CLUSTER_LEADER_MOVEMENT_CONCURRENCY , _executionConcurrencySummary . getClusterLeadershipMovementConcurrency ( ) ) ; execState . put ( NUM_CANCELLED_LEADERSHIP_MOVEMENTS , _executionTasksSummary . taskStat ( ) . get ( LEADER_ACTION ) . get ( ExecutionTaskState . PENDING ) ) ; execState . put ( NUM_IN_PROGRESS_INTER_BROKER_PARTITION_MOVEMENTS , interBrokerPartitionMovementStats . get ( ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( NUM_ABORTING_INTER_BROKER_PARTITION_MOVEMENTS , interBrokerPartitionMovementStats . get ( ExecutionTaskState . ABORTING ) ) ; execState . put ( NUM_CANCELLED_INTER_BROKER_PARTITION_MOVEMENTS , interBrokerPartitionMovementStats . get ( ExecutionTaskState . PENDING ) ) ; execState . put ( NUM_IN_PROGRESS_INTRA_BROKER_PARTITION_MOVEMENTS , intraBrokerPartitionMovementStats . get ( ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( NUM_ABORTING_INTRA_BROKER_PARTITION_MOVEMENTS , intraBrokerPartitionMovementStats . get ( ExecutionTaskState . ABORTING ) ) ; execState . put ( NUM_CANCELLED_INTRA_BROKER_PARTITION_MOVEMENTS , intraBrokerPartitionMovementStats . get ( ExecutionTaskState . PENDING ) ) ; if ( verbose ) { execState . put ( CANCELLED_LEADERSHIP_MOVEMENT , getTaskDetails ( LEADER_ACTION , ExecutionTaskState . PENDING ) ) ; execState . put ( CANCELLED_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . PENDING ) ) ; execState . put ( IN_PROGRESS_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( ABORTING_INTER_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTER_BROKER_REPLICA_ACTION , ExecutionTaskState . ABORTING ) ) ; execState . put ( CANCELLED_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . PENDING ) ) ; execState . put ( IN_PROGRESS_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . IN_PROGRESS ) ) ; execState . put ( ABORTING_INTRA_BROKER_PARTITION_MOVEMENT , getTaskDetails ( INTRA_BROKER_REPLICA_ACTION , ExecutionTaskState . ABORTING ) ) ; } break ; default : execState . clear ( ) ; execState . put ( ERROR , "ILLEGAL_STATE_EXCEPTION" ) ; break ; } return execState ; }
public void onShowCustomView ( View view , CustomViewCallback callback ) { if ( customView != null || PipVideoOverlay . isVisible ( ) ) { callback . onCustomViewHidden ( ) ; return ; } exitFromPip ( ) ; customView = view ; getSheetContainer ( ) . setVisibility ( View . INVISIBLE ) ; fullscreenVideoContainer . setVisibility ( View . VISIBLE ) ; fullscreenVideoContainer . addView ( view , LayoutHelper . createFrame ( LayoutHelper . MATCH_PARENT , LayoutHelper . MATCH_PARENT ) ) ; customViewCallback = callback ; }
public void pause ( ) { if ( editorContext != null ) { editorContext . pause ( ) ; } }
public void onTabSelected ( final TabLayout . Tab selectedTab ) { if ( DEBUG ) { Log . d ( TAG , "onTabSelected() called with: selectedTab = [" + selectedTab + "]" ) ; } updateTitleForTab ( selectedTab . getPosition ( ) ) ; }
protected void onPostExecute ( SecretKey key ) { super . onPostExecute ( key ) ; _cb . onTaskFinished ( key ) ; }
private static void flattenInto ( Collection < ? > list , List < AtomicValue > values ) { for ( Object o : list ) { if ( o instanceof Collection ) { flattenInto ( ( Collection < ? > ) o , values ) ; } else { values . add ( getAtomicRepresentation ( o ) ) ; } } }
public int getInt ( int columnIndex ) { Object value = results [ resultsIndex ] [ columnIndex ] ; return value == null ? 0 : ( value instanceof Number ? ( ( Number ) value ) . intValue ( ) : Integer . parseInt ( value . toString ( ) ) ) ; }
public void printTo ( Writer out , int value ) throws IOException { iLeft . printTo ( out , value ) ; iRight . printTo ( out , value ) ; }
public boolean getBoolean ( String path ) { Object object = get ( path ) ; return convertObjectTo ( object , Boolean . class ) ; }
public void removeMetricsFavorite ( String userId , Long monitorId , String metricsName ) { metricsFavoriteDao . deleteByUserIdAndMonitorIdAndMetricsName ( userId , monitorId , metricsName ) ; }
public String getLoginUsername ( ) { return loginUsername ; }
public void printTo ( StringBuffer buf , ReadablePeriod period , Locale locale ) { buf . append ( iText ) ; }
public synchronized TextSize getTextSize ( ) { TextSize closestSize = null ; int smallestDelta = Integer . MAX_VALUE ; int textSize = getTextZoom ( ) ; for ( TextSize size : TextSize . values ( ) ) { int delta = Math . abs ( textSize - size . value ) ; if ( delta == 0 ) { return size ; } if ( delta < smallestDelta ) { smallestDelta = delta ; closestSize = size ; } } return closestSize != null ? closestSize : TextSize . NORMAL ; }
public void invokevirtual ( final String owner , final String name , final String descriptor ) { visitMethodInsn ( Opcodes . INVOKEVIRTUAL , owner , name , descriptor , false ) ; }
static QueueEntryHandler messageToText ( @ NotNull final WireType wireType ) { return new InternalMessageToTextQueueEntryHandler ( wireType ) ; }
public boolean isNonDeterministic ( ) { return true ; }
public boolean exists ( String path , String node ) { List < String > list = getChildren ( path ) ; return CollUtil . isNotEmpty ( list ) && list . contains ( node ) ; }
public int getIntrinsicWidth ( ) { return drawingDelegate . getPreferredWidth ( ) ; }
public static void main ( String [ ] args ) throws Exception { SpringApplication . run ( Application . class , args ) ; }
public void onAnimationEnd ( Animator animation ) { if ( fullscreenVideoContainer . getVisibility ( ) == View . VISIBLE ) { fullscreenVideoContainer . setAlpha ( 1.0f ) ; fullscreenVideoContainer . setVisibility ( View . INVISIBLE ) ; } switchInlineModeRunnable . run ( ) ; }
public void clear ( ) { this . rawList . clear ( ) ; }
public V1beta1ResourceClaimConsumerReference buildReservedFor ( int index ) { return this . reservedFor . get ( index ) . build ( ) ; }
public synchronized boolean isConsumer ( ImageConsumer ic ) { return ( ic == theConsumer ) ; }
public void start ( ) { LOGGER . debugOp ( "{}: Starting the controller loop" , name ) ; controllerThread . start ( ) ; }
public String toString ( ) { if ( visualElement != null ) return super . toString ( ) + "; " + visualElement ; else return super . toString ( ) ; }
public void remove ( ) { requireNonNull ( prev ) ; requireNonNull ( next ) ; prev . next = next ; next . prev = prev ; next = prev = null ; }
public Criteria andDefaultStatusBetween ( Integer value1 , Integer value2 ) { addCriterion ( "default_status between" , value1 , value2 , "defaultStatus" ) ; return ( Criteria ) this ; }
public void runOnce ( Context context ) { runOnce ( context , null , false ) ; }
protected boolean doMatch ( T target ) { List < TypeDescription > typeDescriptions = new ArrayList < TypeDescription > ( ) ; for ( TypeDefinition typeDefinition : target ) { typeDescriptions . add ( typeDefinition . asErasure ( ) ) ; } return matcher . matches ( typeDescriptions ) ; }
public Iterator < Entry < Grid , Grid > > mappingIterator ( ) { Map < Grid , Grid > ret = new LinkedHashMap < > ( ) ; mapping . forEach ( r -> { ret . put ( r . getFrom ( ) , r . getTo ( ) ) ; } ) ; return ret . entrySet ( ) . iterator ( ) ; }
private byte [ ] readBytes ( InputStream istream ) throws SQLException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte [ ] bytes = new byte [ 8192 ] ; try { int bytesRead ; while ( ( bytesRead = istream . read ( bytes ) ) > 0 ) { baos . write ( bytes , 0 , bytesRead ) ; } return baos . toByteArray ( ) ; } catch ( IOException cause ) { SQLException exception = new SQLException ( "Error reading stream" ) ; exception . initCause ( cause ) ; throw exception ; } }
public String adjustTemporaryTableName ( String desiredTableName ) { return desiredTableName ; }
public int elementPageWidth ( IBodyElement element ) { return 8295 ; }
private static ImmutableList < BundleModule > getBundleModules ( AppBundle appBundle , ImmutableSet < String > moduleNames ) { if ( moduleNames . contains ( ALL_MODULES_SHORTCUT ) ) { return appBundle . getModules ( ) . values ( ) . asList ( ) ; } return moduleNames . stream ( ) . map ( BundleModuleName :: create ) . map ( appBundle :: getModule ) . collect ( toImmutableList ( ) ) ; }
public Integer getGoodsCount ( ) { return goodsCount ; }
public final ViewController < ? > removeStackItemById ( int id ) { return navigationController != null ? navigationController . getStack ( ) . removeById ( id ) : null ; }
public int getPopupGravity ( ) { return mHelper . getPopupGravity ( ) ; }
AFreeplaneAction createAction ( Class < ? extends AFreeplaneAction > actionClass , String propertyName ) { try { return actionClass . getConstructor ( String . class ) . newInstance ( propertyName ) ; } catch ( Exception e ) { LogUtils . severe ( e ) ; return null ; } }
public void setCropFrameColor ( @ ColorInt int color ) { mOptionBundle . putInt ( EXTRA_CROP_FRAME_COLOR , color ) ; }
private void loadPrepDict ( ) { DictSegment _PrepDict = new DictSegment ( ( char ) 0 ) ; Path file = configuration . getPath ( getDictRoot ( ) , Dictionary . PATH_DIC_PREP ) ; loadDictFile ( _PrepDict , file , true , "Preposition" ) ; }
public static void debug ( @ Nullable Throwable throwable ) { debug ( throwable , null ) ; }
public static SqlSessionFactory sqlSessionFactory ( Class < ? > clazz ) { return GlobalConfigUtils . currentSessionFactory ( clazz ) ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof PolicyInformation ) ) return false ; PolicyInformation piOther = ( PolicyInformation ) other ; if ( ! policyIdentifier . equals ( piOther . getPolicyIdentifier ( ) ) ) return false ; return policyQualifiers . equals ( piOther . getPolicyQualifiers ( ) ) ; }
public static void logAnalyticsFromClient ( AnalyticEvent event ) { event . setLogSource ( AnalyticEvent . LOG_SOURCE_CLIENT ) ; if ( analyticsLogger . isInfoEnabled ( ) ) { analyticsLogger . info ( gson . toJson ( event ) ) ; } }
public String getQueueID ( ) { return queueID ; }
public int size ( ) { return ConcurrentReferenceHashMap . this . size ( ) ; }
private void flushIfOld ( long age , TimeUnit unit ) { long now = System . nanoTime ( ) ; if ( TimeUnit . NANOSECONDS . toMillis ( now - lastFlush ) > unit . toMillis ( age ) ) { internalFlush ( ) ; lastFlush = now ; } }
public boolean isOnLastTab ( ) { return getTabCount ( ) <= 0 ? false : getCurrentTabPosition ( ) >= getTabCount ( ) - 1 ; }
public void optimize ( SessionLocal session ) { super . optimize ( session ) ; if ( args . length < 1 ) { throw DbException . get ( ErrorCode . INVALID_PARAMETER_COUNT_2 , getName ( ) , ">0" ) ; } }
public Criteria andDeleteTimeNotBetween ( Long value1 , Long value2 ) { addCriterion ( "delete_time not between" , value1 , value2 , "deleteTime" ) ; return ( Criteria ) this ; }
public void setParameters ( Collection < CompoundVariable > parameters ) throws InvalidVariableException { checkParameterCount ( parameters , MIN_PARAMETER_COUNT , MAX_PARAMETER_COUNT ) ; values = parameters . toArray ( ) ; }
public Criteria andTotalPriceNotEqualTo ( BigDecimal value ) { addCriterion ( "total_price <>" , value , "totalPrice" ) ; return ( Criteria ) this ; }
protected String getAppConnName ( ) { return DolphinSchedulerAppConn . DOLPHINSCHEDULER_APPCONN_NAME ; }
void deleteAllReadPosts ( ) ; @ Query ( "SELECT id FROM read_posts WHERE id IN (:ids) AND username = :username" ) List < String > getReadPostsIdsByIds ( List < String > ids , String username ) ; default int getMaxReadPostEntrySize ( ) { return 20 + 10 + 8 ; }
public Double utilization ( ) { return _utilization ; }
public void setName ( String name ) { this . name = name ; if ( dataModel != null ) { dataModel . version ++ ; } }
public Criteria andCreateTimeLessThanOrEqualTo ( Long value ) { addCriterion ( "create_time <=" , value , "createTime" ) ; return ( Criteria ) this ; }
boolean equal ( Seq < FieldSpec > specs ) { if ( fields . size != specs . size ) return false ; for ( int i = 0 ; i < fields . size ; i ++ ) { RevisionField field = fields . get ( i ) ; FieldSpec spec = specs . get ( i ) ; if ( ! field . type . replace ( "mindustry.gen." , "" ) . equals ( spec . type . toString ( ) . replace ( "mindustry.gen." , "" ) ) ) { return false ; } } return true ; }
public Builder addProperty ( String key , String value ) { this . properties . put ( key , value ) ; return this ; }
private static IntentFilterManifestInfo parseIntentFilterFromXml ( @ NonNull XmlResourceParser parser ) throws IOException , XmlPullParserException { IntentFilterManifestInfo intentFilterInfo = new IntentFilterManifestInfo ( ) ; while ( true ) { int nextTagType = parser . next ( ) ; String tagName = parser . getName ( ) ; if ( nextTagType == XmlResourceParser . END_TAG && PermissionUtils . equalsString ( TAG_INTENT_FILTER , tagName ) ) { break ; } if ( nextTagType != XmlResourceParser . START_TAG ) { continue ; } if ( PermissionUtils . equalsString ( TAG_ACTION , tagName ) ) { intentFilterInfo . actionList . add ( parser . getAttributeValue ( ANDROID_NAMESPACE_URI , ATTR_NAME ) ) ; } else if ( PermissionUtils . equalsString ( TAG_CATEGORY , tagName ) ) { intentFilterInfo . categoryList . add ( parser . getAttributeValue ( ANDROID_NAMESPACE_URI , ATTR_NAME ) ) ; } } return intentFilterInfo ; }
public final String getArgument ( final int index ) { if ( this . arguments == null || index < 0 || index >= this . arguments . length ) { return null ; } else { return this . arguments [ index ] ; } }
public ResourcesHolder put ( String key , float value ) { mValues . put ( key , value ) ; return this ; }
private static boolean isHardwareBitmapCountReducedOnApi28ByB139097735 ( ) { if ( Build . VERSION . SDK_INT != Build . VERSION_CODES . P ) { return false ; } for ( String prefixOrModelName : Arrays . asList ( "GM1900" , "GM1901" , "GM1903" , "GM1911" , "GM1915" , "ONEPLUS A3000" , "ONEPLUS A3010" , "ONEPLUS A5010" , "ONEPLUS A5000" , "ONEPLUS A3003" , "ONEPLUS A6000" , "ONEPLUS A6003" , "ONEPLUS A6010" , "ONEPLUS A6013" ) ) { if ( Build . MODEL . startsWith ( prefixOrModelName ) ) { return true ; } } return false ; }
SELF withReturnType ( Optional < JavaTypeCreationProcess < JavaCodeUnit > > genericReturnType , JavaClassDescriptor rawReturnType ) { this . genericReturnType = genericReturnType ; this . rawReturnType = rawReturnType ; return self ( ) ; }
public void run ( ) { long scheduleTime = 0 ; while ( ! isShutdown . get ( ) ) { try { drainInputQueues ( ) ; int totalItems = processingOrder . size ( ) ; long now = System . currentTimeMillis ( ) ; if ( scheduleTime < now ) { scheduleTime = now + trafficShaper . transmissionDelay ( ) ; } if ( scheduleTime <= now ) { assignBatchWork ( ) ; assignSingleItemWork ( ) ; } if ( totalItems == processingOrder . size ( ) ) { Thread . sleep ( 10 ) ; } } catch ( InterruptedException ex ) { } catch ( Throwable e ) { logger . warn ( "Discovery AcceptorThread error" , e ) ; } } }
public void onSearchCollapse ( ) { if ( searching ) { searchWas = false ; searching = false ; setAllowNestedScroll ( true ) ; listAdapter . search ( null ) ; } }
public Node node ( String cluster , Integer nodeId ) throws ExecutionException , InterruptedException { checkIfClusterAndResourceAllowed ( cluster , nodeId . toString ( ) ) ; return findNode ( cluster , nodeId ) ; }
protected void copyRange ( int begin , int end , int newBegin ) { final int range = end - begin ; System . arraycopy ( this . keys , begin , this . keys , newBegin , range ) ; System . arraycopy ( this . values , begin , this . values , newBegin , range ) ; }
public BigDecimal hardScore ( int index ) { return hardScores [ index ] ; }
public String getDisplayName ( ) { return displayName ; }
public void initGui ( ) { super . initGui ( ) ; }
public Criteria andPostCodeLike ( String value ) { addCriterion ( "post_code like" , value , "postCode" ) ; return ( Criteria ) this ; }
QuickPopupConfig contentViewLayoutid ( int contentViewLayoutid ) { this . contentViewLayoutid = contentViewLayoutid ; return this ; }
public void execute ( ) { if ( stateManager . getActiveDatabase ( ) . isEmpty ( ) ) { dialogService . notify ( Localization . lang ( "This operation requires an open library." ) ) ; return ; } if ( stateManager . getSelectedEntries ( ) . size ( ) != 1 ) { dialogService . notify ( Localization . lang ( "This operation requires exactly one item to be selected." ) ) ; return ; } BibDatabaseContext databaseContext = stateManager . getActiveDatabase ( ) . get ( ) ; BibEntry entry = stateManager . getSelectedEntries ( ) . getFirst ( ) ; Optional < String > urlforDownload = getUrlForDownloadFromClipBoardOrEntry ( dialogService , entry ) ; if ( urlforDownload . isEmpty ( ) ) { return ; } try { URL url = URLUtil . create ( urlforDownload . get ( ) ) ; LinkedFileViewModel onlineFile = new LinkedFileViewModel ( new LinkedFile ( url , "" ) , entry , databaseContext , taskExecutor , dialogService , preferences ) ; onlineFile . download ( true ) ; } catch ( MalformedURLException exception ) { dialogService . showErrorDialogAndWait ( Localization . lang ( "Invalid URL" ) , exception ) ; } }
public List < OffsetPosition > detect ( String text ) { return detect ( text , new Language ( Language . EN ) ) ; }
private List < Local > rest ( List < Local > args ) { int first = 1 ; int last = args . size ( ) ; if ( last < first ) { return Collections . emptyList ( ) ; } else { return args . subList ( first , last ) ; } }
private static String getExcludeString ( List < TableName > tables ) { StringBuilder tableSb = new StringBuilder ( ) ; for ( int i = 1 ; i <= tables . size ( ) ; i ++ ) { TableName tableName = tables . get ( i - 1 ) ; if ( tableName . getDb ( ) == null ) { tableSb . append ( tableName . getTbl ( ) ) ; } else { tableSb . append ( tableName . getDb ( ) ) . append ( "." ) . append ( tableName . getTbl ( ) ) ; } if ( i != tables . size ( ) ) { tableSb . append ( "," ) ; } } return tableSb . toString ( ) ; }
public EndPoint unwrapEndPoint ( Response jettyResponse ) { return getEndpoint ( jettyResponse ) ; }
public List < String > getTables ( ) { return _tables ; }
protected Node visitShowCreate ( ShowCreate node , Void context ) { if ( node . getType ( ) == SCHEMA ) { CatalogSchemaName catalogSchemaName = createCatalogSchemaName ( session , node , Optional . of ( node . getName ( ) ) , metadata ) ; if ( ! metadataResolver . schemaExists ( catalogSchemaName ) ) { throw new SemanticException ( MISSING_SCHEMA , node , "Schema '%s' does not exist" , catalogSchemaName ) ; } Map < String , Object > properties = metadata . getSchemaProperties ( session , catalogSchemaName ) ; Map < String , PropertyMetadata < ? > > allSchemaProperties = metadata . getSchemaPropertyManager ( ) . getAllProperties ( ) . get ( getConnectorIdOrThrow ( session , metadata , catalogSchemaName . getCatalogName ( ) ) ) ; List < Property > propertyNodes = buildProperties ( "schema " + catalogSchemaName , INVALID_SCHEMA_PROPERTY , properties , allSchemaProperties ) ; CreateSchema createSchema = new CreateSchema ( node . getName ( ) , false , propertyNodes ) ; return singleValueQuery ( "Create Schema" , formatSql ( createSchema , Optional . of ( parameters ) ) . trim ( ) ) ; } QualifiedObjectName objectName = createQualifiedObjectName ( session , node , node . getName ( ) , metadata ) ; Optional < ViewDefinition > viewDefinition = metadataResolver . getView ( objectName ) ; Optional < MaterializedViewDefinition > materializedViewDefinition = metadataResolver . getMaterializedView ( objectName ) ; if ( node . getType ( ) == VIEW ) { if ( ! viewDefinition . isPresent ( ) ) { if ( materializedViewDefinition . isPresent ( ) ) { throw new SemanticException ( NOT_SUPPORTED , node , "Relation '%s' is a materialized view, not a view" , objectName ) ; } if ( metadataResolver . getTableHandle ( objectName ) . isPresent ( ) ) { throw new SemanticException ( NOT_SUPPORTED , node , "Relation '%s' is a table, not a view" , objectName ) ; } throw new SemanticException ( MISSING_TABLE , node , "View '%s' does not exist" , objectName ) ; } Query query = parseView ( viewDefinition . get ( ) . getOriginalSql ( ) , objectName , node ) ; accessControl . checkCanShowCreateTable ( session . getRequiredTransactionId ( ) , session . getIdentity ( ) , session . getAccessControlContext ( ) , objectName ) ; ViewSecurity security = ( viewDefinition . get ( ) . isRunAsInvoker ( ) ) ? INVOKER : DEFINER ; String sql = formatSql ( new CreateView ( getQualifiedName ( node , objectName ) , query , false , Optional . of ( security ) ) , Optional . of ( parameters ) ) . trim ( ) ; return singleValueQuery ( "Create View" , sql ) ; } if ( node . getType ( ) == MATERIALIZED_VIEW ) { Optional < TableHandle > tableHandle = metadataResolver . getTableHandle ( objectName ) ; if ( ! materializedViewDefinition . isPresent ( ) ) { if ( viewDefinition . isPresent ( ) ) { throw new SemanticException ( NOT_SUPPORTED , node , "Relation '%s' is a view, not a materialized view" , objectName ) ; } if ( tableHandle . isPresent ( ) ) { throw new SemanticException ( NOT_SUPPORTED , node , "Relation '%s' is a table, not a materialized view" , objectName ) ; } throw new SemanticException ( MISSING_TABLE , node , "Materialized view '%s' does not exist" , objectName ) ; } Query query = parseView ( materializedViewDefinition . get ( ) . getOriginalSql ( ) , objectName , node ) ; accessControl . checkCanShowCreateTable ( session . getRequiredTransactionId ( ) , session . getIdentity ( ) , session . getAccessControlContext ( ) , objectName ) ; ConnectorTableMetadata connectorTableMetadata = metadata . getTableMetadata ( session , tableHandle . get ( ) ) . getMetadata ( ) ; Map < String , Object > properties = connectorTableMetadata . getProperties ( ) ; Map < String , PropertyMetadata < ? > > allTableProperties = metadata . getTablePropertyManager ( ) . getAllProperties ( ) . get ( tableHandle . get ( ) . getConnectorId ( ) ) ; List < Property > propertyNodes = buildProperties ( "materialized view " + objectName , INVALID_TABLE_PROPERTY , properties , allTableProperties ) ; Optional < ViewSecurity > security = SystemSessionProperties . isLegacyMaterializedViews ( session ) ? Optional . empty ( ) : materializedViewDefinition . get ( ) . getSecurityMode ( ) ; CreateMaterializedView createMaterializedView = new CreateMaterializedView ( Optional . empty ( ) , getQualifiedName ( node , objectName ) , query , false , security , propertyNodes , connectorTableMetadata . getComment ( ) ) ; return singleValueQuery ( "Create Materialized View" , formatSql ( createMaterializedView , Optional . of ( parameters ) ) . trim ( ) ) ; } if ( node . getType ( ) == TABLE ) { if ( viewDefinition . isPresent ( ) ) { throw new SemanticException ( NOT_SUPPORTED , node , "Relation '%s' is a view, not a table" , objectName ) ; } if ( materializedViewDefinition . isPresent ( ) ) { throw new SemanticException ( NOT_SUPPORTED , node , "Relation '%s' is a materialized view, not a table" , objectName ) ; } Optional < TableHandle > tableHandle = metadataResolver . getTableHandle ( objectName ) ; if ( ! tableHandle . isPresent ( ) ) { throw new SemanticException ( MISSING_TABLE , node , "Table '%s' does not exist" , objectName ) ; } accessControl . checkCanShowCreateTable ( session . getRequiredTransactionId ( ) , session . getIdentity ( ) , session . getAccessControlContext ( ) , objectName ) ; ConnectorTableMetadata connectorTableMetadata = metadata . getTableMetadata ( session , tableHandle . get ( ) ) . getMetadata ( ) ; Set < String > notNullColumns = connectorTableMetadata . getTableConstraintsHolder ( ) . getTableConstraints ( ) . stream ( ) . filter ( constraint -> constraint instanceof NotNullConstraint ) . map ( constraint -> constraint . getColumns ( ) . stream ( ) . findFirst ( ) . get ( ) ) . collect ( toImmutableSet ( ) ) ; Map < String , PropertyMetadata < ? > > allColumnProperties = metadata . getColumnPropertyManager ( ) . getAllProperties ( ) . get ( tableHandle . get ( ) . getConnectorId ( ) ) ; List < ColumnMetadata > allowedColumns = new ArrayList < > ( ) ; allowedColumns = accessControl . filterColumns ( session . getRequiredTransactionId ( ) , session . getIdentity ( ) , session . getAccessControlContext ( ) , objectName , connectorTableMetadata . getColumns ( ) ) ; List < TableElement > columns = allowedColumns . stream ( ) . filter ( column -> ! column . isHidden ( ) ) . map ( column -> { List < Property > propertyNodes = buildProperties ( toQualifiedName ( objectName , Optional . of ( column . getName ( ) ) ) , INVALID_COLUMN_PROPERTY , column . getProperties ( ) , allColumnProperties ) ; return new ColumnDefinition ( QueryUtil . quotedIdentifier ( column . getName ( ) ) , column . getType ( ) . getDisplayName ( ) , column . isNullable ( ) && ! notNullColumns . contains ( column . getName ( ) ) , propertyNodes , Optional . ofNullable ( column . getComment ( ) . orElse ( null ) ) ) ; } ) . collect ( toList ( ) ) ; Map < String , Object > properties = connectorTableMetadata . getProperties ( ) ; Map < String , PropertyMetadata < ? > > allTableProperties = metadata . getTablePropertyManager ( ) . getAllProperties ( ) . get ( tableHandle . get ( ) . getConnectorId ( ) ) ; List < Property > propertyNodes = buildProperties ( "table " + objectName , INVALID_TABLE_PROPERTY , properties , allTableProperties ) ; columns . addAll ( connectorTableMetadata . getTableConstraintsHolder ( ) . getTableConstraints ( ) . stream ( ) . map ( constraint -> { if ( constraint instanceof PrimaryKeyConstraint ) { return Optional . of ( new ConstraintSpecification ( constraint . getName ( ) , constraint . getColumns ( ) . stream ( ) . collect ( toImmutableList ( ) ) , PRIMARY_KEY , constraint . isEnabled ( ) , constraint . isRely ( ) , constraint . isEnforced ( ) ) ) ; } else if ( constraint instanceof UniqueConstraint ) { return Optional . of ( new ConstraintSpecification ( constraint . getName ( ) , constraint . getColumns ( ) . stream ( ) . collect ( toImmutableList ( ) ) , UNIQUE , constraint . isEnabled ( ) , constraint . isRely ( ) , constraint . isEnforced ( ) ) ) ; } return Optional . empty ( ) ; } ) . filter ( Optional :: isPresent ) . map ( Optional :: get ) . map ( ConstraintSpecification . class :: cast ) . collect ( toImmutableList ( ) ) ) ; CreateTable createTable = new CreateTable ( QualifiedName . of ( objectName . getCatalogName ( ) , objectName . getSchemaName ( ) , objectName . getObjectName ( ) ) , columns , false , propertyNodes , connectorTableMetadata . getComment ( ) ) ; return singleValueQuery ( "Create Table" , formatSql ( createTable , Optional . of ( parameters ) ) . trim ( ) ) ; } throw new UnsupportedOperationException ( "SHOW CREATE only supported for tables and views" ) ; }
private void updateHasStatusAndNavBars ( Display display , boolean hasStatusAndNavBars ) { if ( mHasStatusAndNavBars == hasStatusAndNavBars ) { return ; } mHasStatusAndNavBars = hasStatusAndNavBars ; if ( mDisplayId != Display . DEFAULT_DISPLAY ) { setDisplayLayout ( mContext , createLayout ( mContext , display ) ) ; } }
private static int trimBegin ( String str , int beginIndex , int endIndex ) { while ( beginIndex < endIndex && str . charAt ( beginIndex ) <= ' ' ) beginIndex ++ ; return beginIndex ; }
default boolean keepAspectRatio ( ) { return false ; }
public List < TxnMeta > getSlowTransactions ( long timeout ) { return null ; }
public boolean isKeyWord ( ) { return type == Tokenizer . KEYWORD ; }
public HttpError buildObject ( ) { return new HttpError ( ) . withDelay ( ( delay != null ? delay . buildObject ( ) : null ) ) . withDropConnection ( dropConnection ) . withResponseBytes ( responseBytes ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || getClass ( ) != o . getClass ( ) ) return false ; BuiltValueSerializer that = ( BuiltValueSerializer ) o ; return isArray == that . isArray && uniqueItems == that . uniqueItems && isMap == that . isMap && isNullable == that . isNullable && dataType . equals ( that . dataType ) ; }
private static ByteBuffer packBinary ( @ Nonnull ByteBuffer buffer , @ Nonnull String value ) { byte [ ] encoded = value . getBytes ( StandardCharsets . UTF_8 ) ; buffer = realloc ( buffer , encoded . length * 4 + 5 ) ; buffer . put ( BINARY ) ; buffer . putInt ( encoded . length ) ; buffer . put ( encoded ) ; return buffer ; }
public SessionsBody partialSessionId ( String partialSessionId ) { this . partialSessionId = partialSessionId ; return this ; }
public boolean remove ( Object o ) { boolean propertyExists = delegate . remove ( o ) ; if ( propertyExists ) { deleteProperty ( ( String ) ( ( Entry < K , V > ) o ) . getKey ( ) , ( String ) ( ( Entry < K , V > ) o ) . getValue ( ) ) ; } return propertyExists ; }
public void addImage ( Image image ) throws Exception { addImage ( image , 0.8f ) ; }
String update ( String dst , String src ) { if ( src == null ) { return dst ; } if ( dst == null ) { return src ; } return dst . compareTo ( src ) > 0 ? dst : src ; }
public Object getComponent ( ) { return getMenuItem ( ) ; }
public Criteria andNumNotBetween ( Long value1 , Long value2 ) { addCriterion ( "num not between" , value1 , value2 , "num" ) ; return ( Criteria ) this ; }
public ConfirmPopupView asConfirm ( CharSequence title , CharSequence content , OnConfirmListener confirmListener ) { return asConfirm ( title , content , null , null , confirmListener , null , false , 0 ) ; }
public boolean isSuspended ( ) { return this == PASS_THUNK ; }
public ListenableFuture < ? > reserveMemory ( String allocationTag , long delta , boolean enforceBroadcastMemoryLimit ) { if ( enforceBroadcastMemoryLimit ) { updateBroadcastMemoryFunction . accept ( delta , allocationTag ) ; } ListenableFuture < ? > future = reserveMemoryFunction . apply ( allocationTag , delta ) ; return future ; }
public SecurityScheme bearerFormat ( String bearerFormat ) { this . bearerFormat = bearerFormat ; return this ; }
public < R > R get ( String attributeKey ) { return ( R ) attributes . get ( attributeKey ) ; }
public boolean accept ( File file ) { String extName = file . getName ( ) . toLowerCase ( ) ; if ( file . isDirectory ( ) ) return true ; for ( String fileExt : fileExts ) { if ( extName . endsWith ( fileExt ) ) return true ; } return false ; }
< U > IndexedSeq < T > sortBy ( @ NonNull Comparator < ? super U > comparator , Function < ? super T , ? extends U > mapper ) ; @ Override Tuple2 < ? extends IndexedSeq < T > , ? extends IndexedSeq < T > > span ( @ NonNull Predicate < ? super T > predicate ) ; @ Override default boolean startsWith ( @ NonNull Iterable < ? extends T > that , int offset ) { Objects . requireNonNull ( that , "that is null" ) ; if ( offset < 0 ) { return false ; } if ( that instanceof IndexedSeq ) { IndexedSeq < ? extends T > thatIndexedSeq = ( IndexedSeq < ? extends T > ) that ; int i = offset ; int j = 0 ; int thisLen = length ( ) ; int thatLen = thatIndexedSeq . length ( ) ; while ( i < thisLen && j < thatLen && Objects . equals ( this . get ( i ) , thatIndexedSeq . get ( j ) ) ) { i ++ ; j ++ ; } return j == thatLen ; } else { int i = offset ; int thisLen = length ( ) ; java . util . Iterator < ? extends T > thatElems = that . iterator ( ) ; while ( i < thisLen && thatElems . hasNext ( ) ) { if ( ! Objects . equals ( this . get ( i ) , thatElems . next ( ) ) ) { return false ; } i ++ ; } return ! thatElems . hasNext ( ) ; } }
public String getClassName ( ) { return readClass ( header + 2 , new char [ maxStringLength ] ) ; }
protected List < NameValuePair > getQueryNVP ( ) { List < NameValuePair > nvps = parse ( this . base ) ; List < NameValuePair > newList = new ArrayList < NameValuePair > ( ) ; if ( nvps != null ) newList . addAll ( nvps ) ; return newList ; }
public void setVolume ( float left , float right ) { if ( mediaPlayer != null ) { mediaPlayer . setVolume ( left , right ) ; } }
public void initialize ( ) { if ( BuildConfig . DEBUG ) Log . d ( LOGTAG , "Native module init" ) ; startFcmIntentService ( FcmInstanceIdRefreshHandlerService . EXTRA_IS_APP_INIT ) ; final IPushNotificationsDrawer notificationsDrawer = PushNotificationsDrawer . get ( getReactApplicationContext ( ) . getApplicationContext ( ) ) ; notificationsDrawer . onAppInit ( ) ; }
public int position ( ) { return position ; }
public void generateMessageHeaderStub ( ) throws IOException { generateComposite ( ir . headerStructure ( ) . tokens ( ) ) ; }
public void windowClosed ( WindowEvent event ) { System . exit ( 0 ) ; }
public JobMapper jobMapper ( JsonMapper jobRunrJsonMapper ) { return new JobMapper ( jobRunrJsonMapper ) ; }
public void fail_if_projectAnalysisToken_created_without_project_permission ( ) { userLogin ( ) ; String projectKey = db . components ( ) . insertPublicProject ( ) . getProjectDto ( ) . getKey ( ) ; assertThatThrownBy ( ( ) -> newRequest ( null , "token 1" , PROJECT_ANALYSIS_TOKEN , projectKey ) ) . isInstanceOf ( ForbiddenException . class ) . hasMessage ( "Insufficient privileges" ) ; }
private void onPlayClicked ( ) { if ( playButton . isSelected ( ) ) { pauseTTS ( ) ; } else { playTTS ( false ) ; } settingDrawer . close ( ) ; }
public Scope visitScope ( Scope scope ) { return scope ; }
public int getUnderrunCount ( ) { return originalTrack . getUnderrunCount ( ) ; }
public static void waitAll ( CompletableFuture < ? > ... tasks ) { try { CompletableFuture . allOf ( tasks ) . get ( ) ; } catch ( InterruptedException | ExecutionException e ) { throw new ThreadException ( e ) ; } }
public String patternCorrection ( String pattern ) { boolean checkEnding = pattern . endsWith ( "/i" ) || pattern . endsWith ( "/g" ) || pattern . endsWith ( "/m" ) ; if ( checkEnding ) pattern = pattern . substring ( 0 , pattern . length ( ) - 2 ) ; if ( pattern . endsWith ( "/" ) ) pattern = pattern . substring ( 0 , pattern . length ( ) - 1 ) ; if ( pattern . startsWith ( "/" ) ) pattern = pattern . substring ( 1 ) ; return pattern ; }
public void setGuideLineWidth ( float guideLineWidth ) { this . mGuideLineWidth = guideLineWidth ; }
private Pair < INDArray [ ] , INDArray [ ] > convertMiniBatchFeatures ( List < Pair < List < String > , String > > tokensAndLabelList , int outLength , long [ ] segIdOnesFrom ) { int mbPadded = padMinibatches ? minibatchSize : tokensAndLabelList . size ( ) ; int [ ] [ ] outIdxs = new int [ mbPadded ] [ outLength ] ; int [ ] [ ] outMask = new int [ mbPadded ] [ outLength ] ; int [ ] [ ] outSegmentId = null ; if ( featureArrays == FeatureArrays . INDICES_MASK_SEGMENTID ) outSegmentId = new int [ mbPadded ] [ outLength ] ; for ( int i = 0 ; i < tokensAndLabelList . size ( ) ; i ++ ) { Pair < List < String > , String > p = tokensAndLabelList . get ( i ) ; List < String > t = p . getFirst ( ) ; for ( int j = 0 ; j < outLength && j < t . size ( ) ; j ++ ) { Preconditions . checkState ( vocabMap . containsKey ( t . get ( j ) ) , "Unknown token encountered: token \"%s\" is not in vocabulary" , t . get ( j ) ) ; int idx = vocabMap . get ( t . get ( j ) ) ; outIdxs [ i ] [ j ] = idx ; outMask [ i ] [ j ] = 1 ; if ( segIdOnesFrom != null && j >= segIdOnesFrom [ i ] ) outSegmentId [ i ] [ j ] = 1 ; } } INDArray outIdxsArr = Nd4j . createFromArray ( outIdxs ) ; INDArray outMaskArr = Nd4j . createFromArray ( outMask ) ; INDArray outSegmentIdArr ; INDArray [ ] f ; INDArray [ ] fm ; if ( featureArrays == FeatureArrays . INDICES_MASK_SEGMENTID ) { outSegmentIdArr = Nd4j . createFromArray ( outSegmentId ) ; f = new INDArray [ ] { outIdxsArr , outSegmentIdArr } ; fm = new INDArray [ ] { outMaskArr , null } ; } else { f = new INDArray [ ] { outIdxsArr } ; fm = new INDArray [ ] { outMaskArr } ; } return new Pair < > ( f , fm ) ; }
protected Function < CompletableFuture < O > , O > futureConverter ( ) { return futureConverter ; }
public static boolean matches ( MediaInfo info , RemoteMedia media ) { if ( info == null || media == null ) { return false ; } if ( ! TextUtils . equals ( info . getContentId ( ) , media . getStreamUrl ( ) ) ) { return false ; } MediaMetadata metadata = info . getMetadata ( ) ; return metadata != null && TextUtils . equals ( metadata . getString ( KEY_EPISODE_IDENTIFIER ) , media . getEpisodeIdentifier ( ) ) && TextUtils . equals ( metadata . getString ( KEY_FEED_URL ) , media . getFeedUrl ( ) ) ; }
protected boolean onCustomLayout ( View view , int left , int top , int right , int bottom ) { if ( view == videoView . getControlsView ( ) ) { updateTextureViewPosition ( ) ; } return false ; }
public String toString ( ) { return "LakeSoulSplit:" + id + "[" + files . stream ( ) . map ( Object :: toString ) . collect ( Collectors . joining ( ", " ) ) + "]" ; }
public NDArray stopGradient ( ) { throw new UnsupportedOperationException ( UNSUPPORTED_MSG ) ; }
public void doFilter ( BaseNotifyCtx context , Invoker < BaseNotifyCtx > nextInvoker ) { ExecutorWrapper executorWrapper = context . getExecutorWrapper ( ) ; NotifyItem notifyItem = context . getNotifyItem ( ) ; if ( Objects . isNull ( notifyItem ) || ! satisfyBaseCondition ( notifyItem , executorWrapper ) ) { log . debug ( "DynamicTp notify, no platforms configured or notification is not enabled, threadPoolName: {}" , executorWrapper . getThreadPoolName ( ) ) ; return ; } nextInvoker . invoke ( context ) ; }
public ExitMessage newExitMessage ( final Object result , final EntryMessage message ) { return new SimpleExitMessage ( exitText , result , message ) ; }
public boolean matches ( Record record ) { return record . content . equals ( message ) ; }
public boolean handleMessage ( Message msg ) { long minFrameDelay = - 1 ; for ( Target target : targets ) { long frameDelay = target . onInvalidateTarget ( this ) ; if ( frameDelay != - 1 ) { if ( minFrameDelay == - 1 || frameDelay < minFrameDelay ) { minFrameDelay = frameDelay ; } } } if ( isLooping ) { handler . sendMessageDelayed ( Message . obtain ( handler , 0 ) , Math . max ( getFrameDelay ( ) , minFrameDelay ) ) ; } return true ; }
public void draw ( Batch spriteBatch , float alphaModulation ) { if ( alphaModulation == 1 ) { draw ( spriteBatch ) ; return ; } Color color = getColor ( ) ; float oldAlpha = color . a ; color . a *= alphaModulation ; setColors ( color ) ; draw ( spriteBatch ) ; color . a = oldAlpha ; setColors ( color ) ; }
public static BlockTransferInfo createMove ( BlockStoreLocation srcLocation , long srcBlockId , BlockStoreLocation dstLocation ) { return new BlockTransferInfo ( srcLocation , srcBlockId , dstLocation , INVALID ) ; }
public < X0 , X1 , X2 , X3 , X4 > Decade < A , X0 , X1 , X2 , X3 , X4 , B , C , D , E > addAt1 ( final Quintet < X0 , X1 , X2 , X3 , X4 > tuple ) { return addAt1 ( tuple . getValue0 ( ) , tuple . getValue1 ( ) , tuple . getValue2 ( ) , tuple . getValue3 ( ) , tuple . getValue4 ( ) ) ; }
private void showRenameDialog ( final PlaylistMetadataEntry selectedItem ) { final DialogEditTextBinding dialogBinding = DialogEditTextBinding . inflate ( getLayoutInflater ( ) ) ; dialogBinding . dialogEditText . setHint ( R . string . name ) ; dialogBinding . dialogEditText . setInputType ( InputType . TYPE_CLASS_TEXT ) ; dialogBinding . dialogEditText . setText ( selectedItem . getOrderingName ( ) ) ; new AlertDialog . Builder ( activity ) . setView ( dialogBinding . getRoot ( ) ) . setPositiveButton ( R . string . rename_playlist , ( dialog , which ) -> changeLocalPlaylistName ( selectedItem . getUid ( ) , dialogBinding . dialogEditText . getText ( ) . toString ( ) ) ) . setNegativeButton ( R . string . cancel , null ) . show ( ) ; }
public List < On > getOnList ( ) { return onList ; }
protected Status parseStatus ( final String outcome ) { if ( Objects . isNull ( outcome ) ) { return Status . UNKNOWN ; } switch ( outcome . toLowerCase ( ) ) { case "passed" : return Status . PASSED ; case "failed" : return Status . FAILED ; case "notexecuted" : return Status . SKIPPED ; default : return Status . UNKNOWN ; } }
public BigInteger getSerialNumber ( ) { return cert . getSerialNumber ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; uninstallWindowListeners ( ) ; window = SwingUtilities . getWindowAncestor ( this ) ; if ( window != null ) { frameStateChanged ( ) ; activeChanged ( window . isActive ( ) ) ; updateIcon ( ) ; titleLabel . setText ( getWindowTitle ( ) ) ; installWindowListeners ( ) ; } updateNativeTitleBarHeightAndHitTestSpotsLater ( ) ; }
protected void assertExpected ( String found , String expected ) throws ParserException { if ( ! found . equals ( expected ) ) { throw new ParserException ( "Expected " + expected + ", found " + found ) ; } }
private SpockExecutionException createDifferentNumberOfDataValuesException ( DataProviderInfo provider , boolean hasNext ) { String msg = String . format ( "Data provider for variable '%s' has %s values than previous data provider(s)" , provider . getDataVariables ( ) . get ( 0 ) , hasNext ? "more" : "fewer" ) ; SpockExecutionException exception = new SpockExecutionException ( msg ) ; FeatureInfo feature = provider . getParent ( ) ; SpecInfo spec = feature . getParent ( ) ; StackTraceElement elem = new StackTraceElement ( spec . getReflection ( ) . getName ( ) , feature . getName ( ) , spec . getFilename ( ) , provider . getLine ( ) ) ; exception . setStackTrace ( new StackTraceElement [ ] { elem } ) ; return exception ; }
public < E extends RealmModel > void updateEmbeddedObject ( Realm realm , E unmanagedObject , E managedObject , Map < RealmModel , RealmObjectProxy > cache , Set < ImportFlag > flags ) { checkSchemaHasClass ( Util . getOriginalModelClass ( managedObject . getClass ( ) ) ) ; originalMediator . updateEmbeddedObject ( realm , unmanagedObject , managedObject , cache , flags ) ; }
public void mediaStreamCreate ( String id ) { ThreadUtils . runOnExecutor ( ( ) -> { MediaStream mediaStream = mFactory . createLocalMediaStream ( id ) ; localStreams . put ( id , mediaStream ) ; } ) ; }
public N getNode ( PK id ) { return cache . get ( id ) ; }
public boolean onOptionsItemSelected ( MenuItem item ) { switch ( item . getItemId ( ) ) { case android . R . id . home : Log . i ( TAG , "Up" ) ; NavUtils . navigateUpFromSameTask ( this ) ; return true ; default : return super . onOptionsItemSelected ( item ) ; } }
private static String parse ( String value , Predicate < Character > predicate ) { Assert . hasText ( value , "Value [%s] must not be null or empty" . formatted ( value ) ) ; StringBuilder builder = new StringBuilder ( ) ; for ( char character : value . toCharArray ( ) ) { if ( predicate . test ( character ) ) { builder . append ( character ) ; } } return builder . toString ( ) ; }
public IntRangesBuffer getBuffer3 ( CompilationBuffer compilationBuffer ) { return compilationBuffer . getIntRangesBuffer3 ( ) ; }
public URIBuilder setPort ( int port ) throws URISyntaxException { this . base = new URI ( base . getScheme ( ) , base . getUserInfo ( ) , base . getHost ( ) , port , base . getPath ( ) , base . getQuery ( ) , base . getFragment ( ) ) ; return this ; }
private static boolean isGlobMeta ( char c ) { return globMetaChars . indexOf ( c ) != - 1 ; }
public DeviceProfile saveDeviceProfile ( DeviceProfile deviceProfile , boolean doValidate , boolean publishSaveEvent ) { log . trace ( "Executing saveDeviceProfile [{}]" , deviceProfile ) ; if ( deviceProfile . getProfileData ( ) != null && deviceProfile . getProfileData ( ) . getProvisionConfiguration ( ) instanceof X509CertificateChainProvisionConfiguration ) { X509CertificateChainProvisionConfiguration x509Configuration = ( X509CertificateChainProvisionConfiguration ) deviceProfile . getProfileData ( ) . getProvisionConfiguration ( ) ; if ( x509Configuration . getProvisionDeviceSecret ( ) != null ) { formatDeviceProfileCertificate ( deviceProfile , x509Configuration ) ; } } DeviceProfile oldDeviceProfile = null ; if ( doValidate ) { oldDeviceProfile = deviceProfileValidator . validate ( deviceProfile , DeviceProfile :: getTenantId ) ; } else if ( deviceProfile . getId ( ) != null ) { oldDeviceProfile = findDeviceProfileById ( deviceProfile . getTenantId ( ) , deviceProfile . getId ( ) , false ) ; } DeviceProfile savedDeviceProfile ; try { imageService . replaceBase64WithImageUrl ( deviceProfile , "device profile" ) ; savedDeviceProfile = deviceProfileDao . saveAndFlush ( deviceProfile . getTenantId ( ) , deviceProfile ) ; publishEvictEvent ( new DeviceProfileEvictEvent ( savedDeviceProfile . getTenantId ( ) , savedDeviceProfile . getName ( ) , oldDeviceProfile != null ? oldDeviceProfile . getName ( ) : null , savedDeviceProfile . getId ( ) , savedDeviceProfile . isDefault ( ) , oldDeviceProfile != null ? oldDeviceProfile . getProvisionDeviceKey ( ) : null , savedDeviceProfile ) ) ; eventPublisher . publishEvent ( SaveEntityEvent . builder ( ) . tenantId ( savedDeviceProfile . getTenantId ( ) ) . entityId ( savedDeviceProfile . getId ( ) ) . entity ( savedDeviceProfile ) . oldEntity ( oldDeviceProfile ) . created ( oldDeviceProfile == null ) . broadcastEvent ( publishSaveEvent ) . build ( ) ) ; } catch ( Exception t ) { handleEvictEvent ( new DeviceProfileEvictEvent ( deviceProfile . getTenantId ( ) , deviceProfile . getName ( ) , oldDeviceProfile != null ? oldDeviceProfile . getName ( ) : null , null , deviceProfile . isDefault ( ) , oldDeviceProfile != null ? oldDeviceProfile . getProvisionDeviceKey ( ) : null ) ) ; String unqProvisionKeyErrorMsg = DeviceProfileProvisionType . X509_CERTIFICATE_CHAIN . equals ( deviceProfile . getProvisionType ( ) ) ? "Device profile with such certificate already exists!" : "Device profile with such provision device key already exists!" ; checkConstraintViolation ( t , Map . of ( "device_profile_name_unq_key" , DEVICE_PROFILE_WITH_SUCH_NAME_ALREADY_EXISTS , "device_provision_key_unq_key" , unqProvisionKeyErrorMsg , "device_profile_external_id_unq_key" , "Device profile with such external id already exists!" ) ) ; throw t ; } if ( oldDeviceProfile != null && ! oldDeviceProfile . getName ( ) . equals ( deviceProfile . getName ( ) ) ) { PageLink pageLink = new PageLink ( 100 ) ; PageData < Device > pageData ; do { pageData = deviceDao . findDevicesByTenantIdAndProfileId ( deviceProfile . getTenantId ( ) . getId ( ) , deviceProfile . getUuidId ( ) , pageLink ) ; for ( Device device : pageData . getData ( ) ) { device . setType ( deviceProfile . getName ( ) ) ; deviceService . saveDevice ( device ) ; } pageLink = pageLink . nextPageLink ( ) ; } while ( pageData . hasNext ( ) ) ; } return savedDeviceProfile ; }
protected static boolean showStackRaw ( ) { return ! getPreference ( "filterstack" ) . equals ( "true" ) || fgFilterStack == false ; }
public static void callbackReject ( String err ) { if ( callback != null ) { callback . reject ( err ) ; } callback = null ; }
private < V > BaseProperty < V > addProperty ( PropertyKey pkey , V value , Supplier < Collection < V > > supplier ) { assert pkey . cardinality ( ) . multiple ( ) ; BaseProperty < Collection < V > > property ; if ( this . hasProperty ( pkey . id ( ) ) ) { property = this . getProperty ( pkey . id ( ) ) ; } else { property = this . newProperty ( pkey , supplier . get ( ) ) ; this . addProperty ( property ) ; } Collection < V > values ; if ( pkey . cardinality ( ) == Cardinality . SET ) { if ( value instanceof Set ) { values = ( Set < V > ) value ; } else { values = CollectionUtil . toSet ( value ) ; } } else { assert pkey . cardinality ( ) == Cardinality . LIST ; if ( value instanceof List ) { values = ( List < V > ) value ; } else { values = CollectionUtil . toList ( value ) ; } } property . value ( ) . addAll ( values ) ; return ( BaseProperty ) property ; }
public Criteria andMemberIconNotLike ( String value ) { addCriterion ( "member_icon not like" , value , "memberIcon" ) ; return ( Criteria ) this ; }
private static String getStackTraceString ( @ Nullable Throwable tr ) { if ( tr == null ) { return "" ; } final String stackTrace = Log . getStackTraceString ( tr ) ; return stackTrace ; }
public void visitEnd ( ) { if ( mv != null ) { mv . visitEnd ( ) ; } }
public ControlledFragmentAssembler . Action onFragment ( final DirectBuffer buffer , final int offset , final int length , final Header header ) { if ( isPollComplete ) { return Action . ABORT ; } messageHeaderDecoder . wrap ( buffer , offset ) ; final int schemaId = messageHeaderDecoder . schemaId ( ) ; if ( schemaId != MessageHeaderDecoder . SCHEMA_ID ) { return Action . CONTINUE ; } templateId = messageHeaderDecoder . templateId ( ) ; switch ( templateId ) { case SessionMessageHeaderDecoder . TEMPLATE_ID : sessionMessageHeaderDecoder . wrap ( buffer , offset + MessageHeaderDecoder . ENCODED_LENGTH , messageHeaderDecoder . blockLength ( ) , messageHeaderDecoder . version ( ) ) ; leadershipTermId = sessionMessageHeaderDecoder . leadershipTermId ( ) ; clusterSessionId = sessionMessageHeaderDecoder . clusterSessionId ( ) ; isPollComplete = true ; return Action . BREAK ; case SessionEventDecoder . TEMPLATE_ID : sessionEventDecoder . wrap ( buffer , offset + MessageHeaderDecoder . ENCODED_LENGTH , messageHeaderDecoder . blockLength ( ) , messageHeaderDecoder . version ( ) ) ; clusterSessionId = sessionEventDecoder . clusterSessionId ( ) ; correlationId = sessionEventDecoder . correlationId ( ) ; leadershipTermId = sessionEventDecoder . leadershipTermId ( ) ; leaderMemberId = sessionEventDecoder . leaderMemberId ( ) ; eventCode = sessionEventDecoder . code ( ) ; version = sessionEventDecoder . version ( ) ; leaderHeartbeatTimeoutNs = leaderHeartbeatTimeoutNs ( sessionEventDecoder ) ; detail = sessionEventDecoder . detail ( ) ; isPollComplete = true ; egressImage = ( Image ) header . context ( ) ; return Action . BREAK ; case NewLeaderEventDecoder . TEMPLATE_ID : newLeaderEventDecoder . wrap ( buffer , offset + MessageHeaderDecoder . ENCODED_LENGTH , messageHeaderDecoder . blockLength ( ) , messageHeaderDecoder . version ( ) ) ; clusterSessionId = newLeaderEventDecoder . clusterSessionId ( ) ; leadershipTermId = newLeaderEventDecoder . leadershipTermId ( ) ; leaderMemberId = newLeaderEventDecoder . leaderMemberId ( ) ; detail = newLeaderEventDecoder . ingressEndpoints ( ) ; isPollComplete = true ; egressImage = ( Image ) header . context ( ) ; return Action . BREAK ; case ChallengeDecoder . TEMPLATE_ID : challengeDecoder . wrap ( buffer , offset + MessageHeaderDecoder . ENCODED_LENGTH , messageHeaderDecoder . blockLength ( ) , messageHeaderDecoder . version ( ) ) ; final int encodedChallengeLength = challengeDecoder . encodedChallengeLength ( ) ; encodedChallenge = 0 == encodedChallengeLength ? ArrayUtil . EMPTY_BYTE_ARRAY : new byte [ encodedChallengeLength ] ; challengeDecoder . getEncodedChallenge ( encodedChallenge , 0 , encodedChallengeLength ) ; clusterSessionId = challengeDecoder . clusterSessionId ( ) ; correlationId = challengeDecoder . correlationId ( ) ; isPollComplete = true ; return Action . BREAK ; } return Action . CONTINUE ; }
public boolean isAvailable ( ) { synchronized ( this ) { return mIsAvailable ; } }
public static void main ( String [ ] args ) { if ( args . length != 1 ) { System . out . println ( "Usage: " ) ; System . out . println ( "    TrueTypeParser <filename>" ) ; System . exit ( - 1 ) ; } try { RandomAccessFile raf = new RandomAccessFile ( args [ 0 ] , "r" ) ; int size = ( int ) raf . length ( ) ; byte [ ] data = new byte [ size ] ; raf . readFully ( data ) ; TrueTypeFont ttp = TrueTypeFont . parseFont ( data ) ; System . out . println ( ttp ) ; InputStream fontStream = new ByteArrayInputStream ( ttp . writeFont ( ) ) ; @ SuppressWarnings ( "unused" ) Font f = Font . createFont ( Font . TRUETYPE_FONT , fontStream ) ; raf . close ( ) ; } catch ( Exception e ) { BaseWatchable . getErrorHandler ( ) . publishException ( e ) ; } }
private static TableToken getTableToken ( ExpressionNode tableNameExpr , SqlExecutionContext executionContext , Path path , SqlException notExistsError ) throws SqlException { final TableToken tableToken = executionContext . getTableTokenIfExists ( tableNameExpr . token ) ; if ( executionContext . getTableStatus ( path , tableToken ) != TableUtils . TABLE_EXISTS ) { throw notExistsError ; } return tableToken ; }
public int size ( ) { return mValues . size ( ) ; }
private int getTop ( ) { return blurViewLocation [ 1 ] - targetLocation [ 1 ] ; }
static boolean tuneG1GCHeapRegion ( final Map < String , JvmOption > finalJvmOptions , final boolean tuneG1GCForSmallHeap ) { return tuneG1GCForSmallHeap && usingG1GcWithoutCommandLineOriginOption ( finalJvmOptions , "G1HeapRegionSize" ) ; }
private static List < BarcodeFormat > getDefaultFormats ( ) { List < BarcodeFormat > list = new ArrayList < > ( ) ; list . add ( BarcodeFormat . QR_CODE ) ; list . add ( BarcodeFormat . UPC_A ) ; list . add ( BarcodeFormat . EAN_13 ) ; list . add ( BarcodeFormat . CODE_128 ) ; return list ; }
private static String getRefinedIntegerType ( String format ) { if ( format == null || format . equals ( INT64_CRD_TYPE ) ) { return INT64_CRD_TYPE ; } else if ( format . equals ( INT32_CRD_TYPE ) ) { return INT32_CRD_TYPE ; } else { throw new JavaGeneratorException ( "Unsupported format for integer found " + format ) ; } }
private int readMethod ( final ClassVisitor classVisitor , final Context context , final int methodInfoOffset ) { char [ ] charBuffer = context . charBuffer ; int currentOffset = methodInfoOffset ; context . currentMethodAccessFlags = readUnsignedShort ( currentOffset ) ; context . currentMethodName = readUTF8 ( currentOffset + 2 , charBuffer ) ; context . currentMethodDescriptor = readUTF8 ( currentOffset + 4 , charBuffer ) ; currentOffset += 6 ; int codeOffset = 0 ; int exceptionsOffset = 0 ; String [ ] exceptions = null ; boolean synthetic = false ; int signatureIndex = 0 ; int runtimeVisibleAnnotationsOffset = 0 ; int runtimeInvisibleAnnotationsOffset = 0 ; int runtimeVisibleParameterAnnotationsOffset = 0 ; int runtimeInvisibleParameterAnnotationsOffset = 0 ; int runtimeVisibleTypeAnnotationsOffset = 0 ; int runtimeInvisibleTypeAnnotationsOffset = 0 ; int annotationDefaultOffset = 0 ; int methodParametersOffset = 0 ; Attribute attributes = null ; int attributesCount = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; while ( attributesCount -- > 0 ) { String attributeName = readUTF8 ( currentOffset , charBuffer ) ; int attributeLength = readInt ( currentOffset + 2 ) ; currentOffset += 6 ; if ( Constants . CODE . equals ( attributeName ) ) { if ( ( context . parsingOptions & SKIP_CODE ) == 0 ) { codeOffset = currentOffset ; } } else if ( Constants . EXCEPTIONS . equals ( attributeName ) ) { exceptionsOffset = currentOffset ; exceptions = new String [ readUnsignedShort ( exceptionsOffset ) ] ; int currentExceptionOffset = exceptionsOffset + 2 ; for ( int i = 0 ; i < exceptions . length ; ++ i ) { exceptions [ i ] = readClass ( currentExceptionOffset , charBuffer ) ; currentExceptionOffset += 2 ; } } else if ( Constants . SIGNATURE . equals ( attributeName ) ) { signatureIndex = readUnsignedShort ( currentOffset ) ; } else if ( Constants . DEPRECATED . equals ( attributeName ) ) { context . currentMethodAccessFlags |= Opcodes . ACC_DEPRECATED ; } else if ( Constants . RUNTIME_VISIBLE_ANNOTATIONS . equals ( attributeName ) ) { runtimeVisibleAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS . equals ( attributeName ) ) { runtimeVisibleTypeAnnotationsOffset = currentOffset ; } else if ( Constants . ANNOTATION_DEFAULT . equals ( attributeName ) ) { annotationDefaultOffset = currentOffset ; } else if ( Constants . SYNTHETIC . equals ( attributeName ) ) { synthetic = true ; context . currentMethodAccessFlags |= Opcodes . ACC_SYNTHETIC ; } else if ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS . equals ( attributeName ) ) { runtimeInvisibleAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS . equals ( attributeName ) ) { runtimeInvisibleTypeAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS . equals ( attributeName ) ) { runtimeVisibleParameterAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS . equals ( attributeName ) ) { runtimeInvisibleParameterAnnotationsOffset = currentOffset ; } else if ( Constants . METHOD_PARAMETERS . equals ( attributeName ) ) { methodParametersOffset = currentOffset ; } else { Attribute attribute = readAttribute ( context . attributePrototypes , attributeName , currentOffset , attributeLength , charBuffer , - 1 , null ) ; attribute . nextAttribute = attributes ; attributes = attribute ; } currentOffset += attributeLength ; } MethodVisitor methodVisitor = classVisitor . visitMethod ( context . currentMethodAccessFlags , context . currentMethodName , context . currentMethodDescriptor , signatureIndex == 0 ? null : readUTF ( signatureIndex , charBuffer ) , exceptions ) ; if ( methodVisitor == null ) { return currentOffset ; } if ( methodVisitor instanceof MethodWriter ) { MethodWriter methodWriter = ( MethodWriter ) methodVisitor ; if ( methodWriter . canCopyMethodAttributes ( this , methodInfoOffset , currentOffset - methodInfoOffset , synthetic , ( context . currentMethodAccessFlags & Opcodes . ACC_DEPRECATED ) != 0 , signatureIndex , exceptionsOffset ) ) { return currentOffset ; } } if ( methodParametersOffset != 0 ) { int parametersCount = readByte ( methodParametersOffset ) ; int currentParameterOffset = methodParametersOffset + 1 ; while ( parametersCount -- > 0 ) { methodVisitor . visitParameter ( readUTF8 ( currentParameterOffset , charBuffer ) , readUnsignedShort ( currentParameterOffset + 2 ) ) ; currentParameterOffset += 4 ; } } if ( annotationDefaultOffset != 0 ) { AnnotationVisitor annotationVisitor = methodVisitor . visitAnnotationDefault ( ) ; readElementValue ( annotationVisitor , annotationDefaultOffset , null , charBuffer ) ; if ( annotationVisitor != null ) { annotationVisitor . visitEnd ( ) ; } } if ( runtimeVisibleAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeVisibleAnnotationsOffset ) ; int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( methodVisitor . visitAnnotation ( annotationDescriptor , true ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeInvisibleAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeInvisibleAnnotationsOffset ) ; int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( methodVisitor . visitAnnotation ( annotationDescriptor , false ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeVisibleTypeAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeVisibleTypeAnnotationsOffset ) ; int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { currentAnnotationOffset = readTypeAnnotationTarget ( context , currentAnnotationOffset ) ; String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( methodVisitor . visitTypeAnnotation ( context . currentTypeAnnotationTarget , context . currentTypeAnnotationTargetPath , annotationDescriptor , true ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeInvisibleTypeAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeInvisibleTypeAnnotationsOffset ) ; int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { currentAnnotationOffset = readTypeAnnotationTarget ( context , currentAnnotationOffset ) ; String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( methodVisitor . visitTypeAnnotation ( context . currentTypeAnnotationTarget , context . currentTypeAnnotationTargetPath , annotationDescriptor , false ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeVisibleParameterAnnotationsOffset != 0 ) { readParameterAnnotations ( methodVisitor , context , runtimeVisibleParameterAnnotationsOffset , true ) ; } if ( runtimeInvisibleParameterAnnotationsOffset != 0 ) { readParameterAnnotations ( methodVisitor , context , runtimeInvisibleParameterAnnotationsOffset , false ) ; } while ( attributes != null ) { Attribute nextAttribute = attributes . nextAttribute ; attributes . nextAttribute = null ; methodVisitor . visitAttribute ( attributes ) ; attributes = nextAttribute ; } if ( codeOffset != 0 ) { methodVisitor . visitCode ( ) ; readCode ( methodVisitor , context , codeOffset ) ; } methodVisitor . visitEnd ( ) ; return currentOffset ; }
public long add ( long instant , long value ) { return FieldUtils . safeAdd ( instant , value ) ; }
public int compareTo ( Item item ) { if ( item == null ) { return comparableQualifier ( value ) . compareTo ( RELEASE_VERSION_INDEX ) ; } switch ( item . getType ( ) ) { case INTEGER_ITEM : return - 1 ; case STRING_ITEM : return comparableQualifier ( value ) . compareTo ( comparableQualifier ( ( ( StringItem ) item ) . value ) ) ; case LIST_ITEM : return - 1 ; default : throw new IllegalArgumentException ( "invalid type: " + item . getType ( ) ) ; } }
public Criteria andCityLessThanOrEqualTo ( String value ) { addCriterion ( "city <=" , value , "city" ) ; return ( Criteria ) this ; }
public void putFloatArray ( @ Nullable String key , @ Nullable float [ ] value ) { super . putFloatArray ( key , value ) ; }
public void onApplyMarginInsets ( View child , LayoutParams params , Rect legacyInsets , Rect insets , Rect insetsWithoutIme ) { Views . setMargins ( params , insets . left , 0 , insets . right , 0 ) ; setBottomInset ( insetsWithoutIme . bottom ) ; }
public String toString ( ) { return getClass ( ) . getName ( ) + "[services=" + services + "]" ; }
public ScheduledExecutorService getRateLimitPool ( ) { return threadConfig . getRateLimitScheduler ( ) ; }
public Criteria andOrganIdIsNotNull ( ) { addCriterion ( "organ_id is not null" ) ; return ( Criteria ) this ; }
public Iterator < ServerHolder > getServersInTierToLoadSegment ( String tier , DataSegment segment ) { final CircularServerList iterator = tierToServers . get ( tier ) ; if ( iterator == null ) { return Collections . emptyIterator ( ) ; } return new EligibleServerIterator ( segment , iterator ) ; }
public int getOffsetY ( ) { return mHelper . getOffsetY ( ) ; }
public Collection < ClassLoaderVO > getMatchedClassLoaders ( ) { return matchedClassLoaders ; }
public static ArrayList < Fold > decode ( String foldData ) { ArrayList < Fold > results = new ArrayList < > ( ) ; String [ ] chunks = foldData . split ( "\n" ) ; for ( String chunk : chunks ) { if ( chunk . isEmpty ( ) ) continue ; String [ ] pieces = chunk . split ( "\\|" ) ; results . add ( new Fold ( Integer . parseInt ( pieces [ 0 ] ) , Integer . parseInt ( pieces [ 1 ] ) , Integer . parseInt ( pieces [ 2 ] ) , Integer . parseInt ( pieces [ 3 ] ) , "..." ) ) ; } return results ; }
protected int getToolbarViewId ( ) { return R . id . route_menu_top_shadow_all ; }
public int nativeType ( ) { return nativeType ; }
public Criteria andPhoneNumberEqualTo ( String value ) { addCriterion ( "phone_number =" , value , "phoneNumber" ) ; return ( Criteria ) this ; }
public void setDefaultGroupPerm ( byte defaultGroupPerm ) { this . defaultGroupPerm = defaultGroupPerm ; }
public CommonResult < Boolean > resetUserPassword ( @ RequestBody @ Valid AppMemberUserResetPasswordReqVO reqVO ) { userService . resetUserPassword ( reqVO ) ; return success ( true ) ; }
public boolean handles ( @ NonNull GlideUrl url ) { return true ; }
public static Typeface createFromFile ( @ Nullable String path ) { Preconditions . checkNotNull ( path ) ; return createFromFile ( new File ( path ) ) ; }
public DateTimeFormatterBuilder appendFractionOfDay ( int minDigits , int maxDigits ) { return appendFraction ( DateTimeFieldType . dayOfYear ( ) , minDigits , maxDigits ) ; }
public int getId ( ) { return mId ; }
public final PopupLayout showOptions ( int [ ] ids , String [ ] titles ) { return showOptions ( null , ids , titles , null , null , null ) ; }
public Object parseObject ( final String source ) throws ParseException { return parse ( source ) ; }
public CorrelatedMessageSubscriptionFilter correlationTime ( final OffsetDateTime correlationTime ) { return correlationTime ( f -> f . eq ( correlationTime ) ) ; }
protected String getShapeName ( SimpleFeatureType schema , String geometryName , String geometryType ) { FeatureTypeInfo ftInfo = getFeatureTypeInfo ( schema ) ; String fileName = new FileNameSource ( getClass ( ) ) . getShapeName ( ftInfo , geometryName , geometryType ) ; return fileName ; }
public DeviceProfile findDefaultDeviceProfile ( TenantId tenantId ) { log . trace ( "Executing findDefaultDeviceProfile tenantId [{}]" , tenantId ) ; validateId ( tenantId , id -> INCORRECT_TENANT_ID + id ) ; return cache . getAndPutInTransaction ( DeviceProfileCacheKey . forDefaultProfile ( tenantId ) , ( ) -> deviceProfileDao . findDefaultDeviceProfile ( tenantId ) , true ) ; }
public ServletContext getServletContext ( ) { return getServletHandler ( ) . getServletContext ( ) ; }
private static List < String > getRemoteWords ( String location , Runnable runnable ) { runnable . run ( ) ; return AccessController . doPrivileged ( ( PrivilegedAction < List < String > > ) ( ) -> { return getRemoteWordsUnprivileged ( location ) ; } ) ; }
public MattermostNotifier mattermostNotifier ( InstanceRepository repository , NotifierProxyProperties proxyProperties ) { return new MattermostNotifier ( repository , createNotifierRestTemplate ( proxyProperties ) ) ; }
public void onDisplayAdded ( int displayId ) { mMainExecutor . execute ( ( ) -> { DisplayController . this . onDisplayAdded ( displayId ) ; } ) ; }
private void PlayRecFile ( String fileName ) { if ( fileName == null || fileName . isEmpty ( ) ) return ; if ( fileList == null ) return ; String filePath = null ; for ( int i = 0 ; i < fileList . size ( ) ; ++ i ) { ArrayList < String > item = fileList . get ( i ) ; if ( item . get ( 0 ) != null && item . get ( 0 ) == fileName ) { filePath = item . get ( 1 ) ; break ; } } if ( filePath != null && ! filePath . isEmpty ( ) ) { Log . i ( Tag , "PlayRecFile name:" + fileName + " path:" + filePath ) ; Intent intent = new Intent ( ) ; intent . setClass ( RecorderManager . this , RecorderPlayback . class ) ; intent . putExtra ( "RecorderFilePath" , filePath ) ; startActivity ( intent ) ; } }
public B instantiate ( ) { element . setInstantiate ( true ) ; return myself ; }
public TimeFragmentVO getTimeFragment ( ) { return timeFragment ; }
public Criteria andAnswerLessThanOrEqualTo ( String value ) { addCriterion ( "answer <=" , value , "answer" ) ; return ( Criteria ) this ; }
public void characters ( char [ ] buffer , int start , int length ) { if ( textBegin ) accumulator . append ( buffer , start , length ) ; }
