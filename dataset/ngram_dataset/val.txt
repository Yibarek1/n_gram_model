protected void pushContext ( TreeContext ctx ) { treeContextStack . push ( ctx ) ; }
public void runOnce ( Context context , Feed feed , boolean nextPage ) { lastManualRefreshTime = System . currentTimeMillis ( ) ; lastManualRefreshFeedId = feed != null ? feed . getId ( ) : - 1 ; OneTimeWorkRequest . Builder workRequest = new OneTimeWorkRequest . Builder ( FeedUpdateWorker . class ) . setInitialDelay ( 0L , TimeUnit . MILLISECONDS ) . setExpedited ( OutOfQuotaPolicy . RUN_AS_NON_EXPEDITED_WORK_REQUEST ) . addTag ( WORK_TAG_FEED_UPDATE ) ; if ( feed == null || ! feed . isLocalFeed ( ) ) { workRequest . setConstraints ( new Constraints . Builder ( ) . setRequiredNetworkType ( NetworkType . CONNECTED ) . build ( ) ) ; } Data . Builder builder = new Data . Builder ( ) ; builder . putBoolean ( EXTRA_EVEN_ON_MOBILE , true ) ; builder . putBoolean ( EXTRA_MANUAL , true ) ; if ( feed != null ) { builder . putLong ( EXTRA_FEED_ID , feed . getId ( ) ) ; builder . putBoolean ( EXTRA_NEXT_PAGE , nextPage ) ; } workRequest . setInputData ( builder . build ( ) ) ; WorkManager . getInstance ( context ) . enqueueUniqueWork ( WORK_ID_FEED_UPDATE_MANUAL , ExistingWorkPolicy . REPLACE , workRequest . build ( ) ) ; }
public static EncodingFactory createFactory ( final ClassIntrospecter classIntrospecter , final Class < ? extends Decoder > [ ] decoders , final Class < ? extends Encoder > [ ] encoders ) throws DeploymentException { return createFactory ( classIntrospecter , Arrays . asList ( decoders ) , Arrays . asList ( encoders ) ) ; }
public TraverserResult depthFirst ( final GraphQLTypeVisitor graphQLTypeVisitor , Collection < ? extends GraphQLSchemaElement > roots ) { return depthFirst ( initTraverser ( ) , new TraverserDelegateVisitor ( graphQLTypeVisitor ) , roots ) ; }
public < S > Void visit ( GreaterThan greaterThan , S context ) { visitBinaryExpression ( greaterThan ) ; return null ; }
public void setLoginUsername ( String loginUsername ) { this . loginUsername = loginUsername ; }
public ZipBuilder addFile ( ZipPath toPath , ByteSource content , EntryOption ... options ) { return addEntryInternal ( toPath , Entry . builder ( ) . setIsDirectory ( false ) . setContent ( content ) . setOptions ( ImmutableSet . copyOf ( options ) ) . build ( ) ) ; }
public void setAddTime ( LocalDateTime addTime ) { this . addTime = addTime ; }
public Integer getNextQuantity ( ) { return nextQuantity ; }
public static int getInt ( String key , int def ) { return native_get_int ( key , def ) ; }
public void setVersion ( final String version ) { this . version = version ; }
default String getUserIdInKey ( ) { return KEY_USER_ID_IN ; }
public String toString ( ) { return "RdsBackupPolicy [BackupRetentionPeriod=" + BackupRetentionPeriod + ", PreferredBackupTime=" + PreferredBackupTime + ", PreferredBackupPeriod=" + PreferredBackupPeriod + ", BackupLog=" + BackupLog + ", LogBackupRetentionPeriod=" + LogBackupRetentionPeriod + "]" ; }
void callNative ( final NetworkRequest < ? > callback ) { String filterString = JniBsonProtocol . encode ( filter , codecRegistry ) ; String projectionString = encodedEmptyDocument ; String sortString = encodedEmptyDocument ; if ( options == null ) { nativeFind ( FIND , osMongoCollection . getNativePtr ( ) , filterString , projectionString , sortString , 0 , callback ) ; } else { projectionString = JniBsonProtocol . encode ( options . getProjection ( ) , codecRegistry ) ; sortString = JniBsonProtocol . encode ( options . getSort ( ) , codecRegistry ) ; nativeFind ( FIND_WITH_OPTIONS , osMongoCollection . getNativePtr ( ) , filterString , projectionString , sortString , options . getLimit ( ) , callback ) ; } }
public String createHashWithSalt ( String password ) { try { return createHashWithSalt ( ResourceDistributor . getAppForTesting ( ) . toAppIdentifier ( ) , password ) ; } catch ( TenantOrAppNotFoundException e ) { throw new IllegalStateException ( e ) ; } }
public int getProtoIdsSize ( ) { return protoIdsSize ; }
public Response invoke ( HttpRequest request ) { this . request = request ; RequestBuilder requestBuilder = RequestBuilder . create ( request . getMethod ( ) ) . setUri ( request . getUrl ( ) ) ; if ( request . getBody ( ) != null ) { EntityBuilder entityBuilder = EntityBuilder . create ( ) . setBinary ( request . getBody ( ) ) ; List < String > transferEncoding = request . getHeaderValues ( HttpConstants . HDR_TRANSFER_ENCODING ) ; if ( transferEncoding != null ) { for ( String te : transferEncoding ) { if ( te == null ) { continue ; } if ( te . contains ( "chunked" ) ) { entityBuilder . chunked ( ) ; } if ( te . contains ( "gzip" ) ) { entityBuilder . gzipCompress ( ) ; } } request . removeHeader ( HttpConstants . HDR_TRANSFER_ENCODING ) ; } requestBuilder . setEntity ( entityBuilder . build ( ) ) ; } if ( request . getHeaders ( ) != null ) { request . getHeaders ( ) . forEach ( ( k , vals ) -> vals . forEach ( v -> requestBuilder . addHeader ( k , v ) ) ) ; } CloseableHttpResponse httpResponse ; byte [ ] bytes ; try ( CloseableHttpClient client = clientBuilder . build ( ) ) { httpResponse = client . execute ( requestBuilder . build ( ) ) ; HttpEntity responseEntity = httpResponse . getEntity ( ) ; if ( responseEntity == null || responseEntity . getContent ( ) == null ) { bytes = Constants . ZERO_BYTES ; } else { InputStream is = responseEntity . getContent ( ) ; Header contentEncoding = httpResponse . getFirstHeader ( HttpConstants . HDR_CONTENT_ENCODING ) ; if ( contentEncoding != null ) { String encoding = contentEncoding . getValue ( ) ; if ( "br" . equalsIgnoreCase ( encoding ) ) { is = new BrotliInputStream ( is ) ; } } bytes = FileUtils . toBytes ( is ) ; } request . setEndTime ( System . currentTimeMillis ( ) ) ; httpResponse . close ( ) ; } catch ( Exception e ) { if ( e instanceof ClientProtocolException && e . getCause ( ) != null ) { throw new RuntimeException ( e . getCause ( ) ) ; } else { throw new RuntimeException ( e ) ; } } int statusCode = httpResponse . getStatusLine ( ) . getStatusCode ( ) ; Map < String , List < String > > headers = toHeaders ( httpResponse ) ; List < Cookie > storedCookies = cookieStore . getCookies ( ) ; Header [ ] requestCookieHeaders = httpResponse . getHeaders ( HttpConstants . HDR_SET_COOKIE ) ; List < String > mergedCookieValues = new ArrayList ( requestCookieHeaders . length ) ; Set < String > alreadyMerged = new HashSet ( requestCookieHeaders . length ) ; for ( Header ch : requestCookieHeaders ) { String requestCookieValue = ch . getValue ( ) ; io . netty . handler . codec . http . cookie . Cookie c = ClientCookieDecoder . LAX . decode ( requestCookieValue ) ; if ( c != null ) { mergedCookieValues . add ( requestCookieValue ) ; alreadyMerged . add ( c . name ( ) ) ; } } for ( Cookie c : storedCookies ) { if ( c . getValue ( ) != null ) { String name = c . getName ( ) ; if ( alreadyMerged . contains ( name ) ) { continue ; } Map < String , Object > map = new HashMap ( ) ; map . put ( Cookies . NAME , name ) ; map . put ( Cookies . VALUE , c . getValue ( ) ) ; map . put ( Cookies . DOMAIN , c . getDomain ( ) ) ; if ( c . getExpiryDate ( ) != null ) { map . put ( Cookies . MAX_AGE , c . getExpiryDate ( ) . getTime ( ) ) ; } map . put ( Cookies . SECURE , c . isSecure ( ) ) ; io . netty . handler . codec . http . cookie . Cookie nettyCookie = Cookies . fromMap ( map ) ; String cookieValue = ServerCookieEncoder . LAX . encode ( nettyCookie ) ; mergedCookieValues . add ( cookieValue ) ; } } headers . put ( HttpConstants . HDR_SET_COOKIE , mergedCookieValues ) ; cookieStore . clear ( ) ; Response response = new Response ( statusCode , headers , bytes ) ; httpLogger . logResponse ( getConfig ( ) , request , response ) ; return response ; }
public DurationFieldType getType ( ) { return DurationFieldType . millis ( ) ; }
public String getReason ( ) { return reason ; }
private void registerConnsListener ( ) { if ( ! listenerSet ) { ConnectionsRegister reg = CaptureService . getConnsRegister ( ) ; if ( reg != null ) { reg . addListener ( this ) ; listenerSet = true ; } } }
public static String convertToString ( Object parsedValue , Type type ) { if ( parsedValue == null ) { return null ; } if ( type == null ) { return parsedValue . toString ( ) ; } switch ( type ) { case BOOLEAN : case SHORT : case INT : case LONG : case DOUBLE : case STRING : case PASSWORD : return parsedValue . toString ( ) ; case LIST : List < ? > valueList = ( List < ? > ) parsedValue ; return Utils . join ( valueList , "," ) ; case CLASS : Class < ? > clazz = ( Class < ? > ) parsedValue ; return clazz . getName ( ) ; default : throw new IllegalStateException ( "Unknown type." ) ; } }
public int hashCode ( ) { return Objects . hash ( eventId , eventDefinitionType , eventDefinitionId , originContext , eventTimestamp , processingTimestamp , timerangeStart , timerangeEnd , streams , sourceStreams , message , source , keyTuple , priority , alert , fields , groupByFields , aggregationConditions , scores , replayInfo ) ; }
public K getKey ( ) { return key ; }
public static boolean isQuestDB ( String db ) { return DATABASE_QUESTDB . equals ( db ) ; }
public void setIgnoreUnresolvableNestedPlaceholders ( boolean ignoreUnresolvableNestedPlaceholders ) { this . ignoreUnresolvableNestedPlaceholders = ignoreUnresolvableNestedPlaceholders ; }
public String getName ( ) { return "RNBridgeModule" ; }
public void setForceHandleAudioRouting ( @ Nullable Boolean force ) { if ( force != null && audioSwitch != null ) { this . forceHandleAudioRouting = force ; Objects . requireNonNull ( audioSwitch ) . setForceHandleAudioRouting ( this . forceHandleAudioRouting ) ; } }
public Criteria andIdNotEqualTo ( Integer value ) { addCriterion ( "id <>" , value , "id" ) ; return ( Criteria ) this ; }
public void setMockURL ( String key , URLGetter urlGetter ) { urlMap . put ( key , urlGetter ) ; }
protected String getFeedURL ( ) { return getModel ( ) . getFeedURL ( ) ; }
public void updateAddresses ( List < EquivalentAddressGroup > addrs ) { delegate ( ) . updateAddresses ( addrs ) ; }
public List < DebuggingView . DVFrame > getFrames ( ) { CPPFrame [ ] stack = getStack ( ) ; if ( stack != null ) { return new FrameList ( stack , 0 , stack . length ) ; } else { return Collections . emptyList ( ) ; } }
public Object getIdIn ( ) { return idIn ; }
private static IgnoreStrategy buildIgnoreStrategy ( String name , InterceptorIgnore ignore ) { return IgnoreStrategy . builder ( ) . tenantLine ( getBoolean ( "tenantLine" , name , ignore . tenantLine ( ) ) ) . dynamicTableName ( getBoolean ( "dynamicTableName" , name , ignore . dynamicTableName ( ) ) ) . blockAttack ( getBoolean ( "blockAttack" , name , ignore . blockAttack ( ) ) ) . illegalSql ( getBoolean ( "illegalSql" , name , ignore . illegalSql ( ) ) ) . dataPermission ( getBoolean ( "dataPermission" , name , ignore . dataPermission ( ) ) ) . others ( getOthers ( name , ignore . others ( ) ) ) . build ( ) ; }
private static void write ( Path path , String html ) throws IOException { if ( ! Files . exists ( path ) ) { Path parent = path . getParent ( ) ; if ( ! Files . exists ( parent ) ) { Files . createDirectory ( parent ) ; } Files . createFile ( path ) ; } Files . write ( path , html . getBytes ( StandardCharsets . UTF_8 ) ) ; LogUtils . log ( "html write to %s" , path . toString ( ) ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof Symbol ) ) return false ; Symbol symbol = ( Symbol ) o ; return Util . equals ( ns , symbol . ns ) && name . equals ( symbol . name ) ; }
public Criteria andCreateTimeNotEqualTo ( Date value ) { addCriterion ( "create_time <>" , value , "createTime" ) ; return ( Criteria ) this ; }
public String [ ] getAffixes ( ) { return iLeftRightCombinations . clone ( ) ; }
public int getAlertCount ( ) { if ( alertThreadGroup != null ) { return alertThreadGroup . getAlertCount ( ) ; } else { return 0 ; } }
private void showFirewallPurchaseDialog ( ) { new AlertDialog . Builder ( requireContext ( ) ) . setTitle ( R . string . paid_feature ) . setMessage ( Utils . getText ( requireContext ( ) , R . string . firewall_purchase_msg , getString ( R . string . no_root_firewall ) ) ) . setPositiveButton ( R . string . show_me , ( dialogInterface , i ) -> { } ) . setNegativeButton ( R . string . cancel_action , ( dialogInterface , i ) -> { } ) . show ( ) ; }
protected ConcurrentException getTypedException ( final Exception e ) { return new ConcurrentException ( e ) ; }
public void setTextColorRes ( @ IdRes int viewId , @ ColorRes int colorRes ) { View view = findViewById ( viewId ) ; if ( view instanceof TextView ) { ( ( TextView ) view ) . setTextColor ( ContextCompat . getColor ( itemView . getContext ( ) , colorRes ) ) ; } }
Disk addDeadDisk ( String logdir ) { Disk disk = new Disk ( logdir , this , - 1 ) ; _diskByLogdir . put ( logdir , disk ) ; return disk ; }
public String comment ( ) { return comment ; }
public static ExecutorState operationInProgress ( State state , ExecutionTasksSummary executionTasksSummary , ExecutionConcurrencySummary executionConcurrencySummary , String uuid , String reason , Set < Integer > recentlyDemotedBrokers , Set < Integer > recentlyRemovedBrokers , boolean isTriggeredByUserRequest ) { if ( ! IN_PROGRESS_STATES . contains ( state ) ) { throw new IllegalArgumentException ( String . format ( "%s is not an operation-in-progress executor state %s." , state , IN_PROGRESS_STATES ) ) ; } return new ExecutorState ( state , executionTasksSummary , executionConcurrencySummary , uuid , reason , recentlyDemotedBrokers , recentlyRemovedBrokers , isTriggeredByUserRequest ) ; }
public Msghdr msg_control ( @ NativeType ( "void *" ) ByteBuffer value ) { nmsg_control ( address ( ) , value ) ; return this ; }
public Criteria andTypeEqualTo ( Integer value ) { addCriterion ( "type =" , value , "type" ) ; return ( Criteria ) this ; }
public boolean equals ( Object partial ) { if ( this == partial ) { return true ; } if ( partial instanceof ReadablePartial == false ) { return false ; } ReadablePartial other = ( ReadablePartial ) partial ; if ( size ( ) != other . size ( ) ) { return false ; } for ( int i = 0 , isize = size ( ) ; i < isize ; i ++ ) { if ( getValue ( i ) != other . getValue ( i ) || getFieldType ( i ) != other . getFieldType ( i ) ) { return false ; } } return FieldUtils . equals ( getChronology ( ) , other . getChronology ( ) ) ; }
private FileRequest getLocalRepositoryFileRequest ( String name ) { FileRequest request = new FileRequest ( ) ; request . setFolder ( LocalRepositoryDir . getPluginDir ( ) ) ; request . setFileName ( name ) ; return request ; }
private ListItem header ( CharSequence text ) { return new ListItem ( ListItem . TYPE_HEADER , 0 , 0 , text , false ) ; }
public void accumulateBug ( BugInstance sourceLine , BytecodeScanningDetector visitor ) { bugInstancesByPc . put ( visitor . getPC ( ) , sourceLine ) ; bugInstancesByNextPc . put ( visitor . getNextPC ( ) , sourceLine ) ; }
public static int encodeIsoChars ( final CharSequence charArray , int charIndex , final byte [ ] byteArray , int byteIndex , final int length ) { int i = 0 ; for ( ; i < length ; i ++ ) { final char c = charArray . charAt ( charIndex ++ ) ; if ( c > 255 ) { break ; } byteArray [ ( byteIndex ++ ) ] = ( ( byte ) c ) ; } return i ; }
List < TypeSignature > getParameterTypeSignatures ( ) { return parameterTypeSignatures ; }
public static void nonNull ( Object object ) throws ValidationException { if ( object == null ) { throw new ValidationException ( AppI18n . get ( "valueMustNotBeEmpty" ) ) ; } }
public static CoinSelector get ( ) { return new AllowUnconfirmedCoinSelector ( ) ; }
public void onAttach ( @ NonNull Context context ) { super . onAttach ( context ) ; mActivity = ( MainActivity ) context ; }
public void setOriginValue ( String originValue ) { this . originValue = originValue ; }
public void onAnimationEnd ( Animator animation ) { mBubbleBarExpandedView . setAnimating ( false ) ; }
private DeleteFile findDV ( long seq , DataFile dataFile ) { if ( dvByPath == null ) { return null ; } DeleteFile dv = dvByPath . get ( dataFile . location ( ) ) ; if ( dv != null ) { ValidationException . check ( dv . dataSequenceNumber ( ) >= seq , "DV data sequence number (%s) must be greater than or equal to data file sequence number (%s)" , dv . dataSequenceNumber ( ) , seq ) ; } return dv ; }
public AtmosphereConfig getAtmosphereConfig ( ) { return config ; }
public void handle ( final RequestContext context ) { final JSONObject requestJSONObject = context . requestJSON ( ) ; final String userURL = requestJSONObject . optString ( User . USER_URL ) ; if ( StringUtils . isNotBlank ( userURL ) && invalidUserURL ( userURL ) ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , "URL" + langPropsService . get ( "colonLabel" ) + langPropsService . get ( "invalidUserURLLabel" ) ) ) ; context . abort ( ) ; return ; } final String userQQ = requestJSONObject . optString ( UserExt . USER_QQ ) ; if ( StringUtils . isNotBlank ( userQQ ) && ( ! Strings . isNumeric ( userQQ ) || userQQ . length ( ) > MAX_USER_QQ_LENGTH ) ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , langPropsService . get ( "invalidUserQQLabel" ) ) ) ; context . abort ( ) ; return ; } final String userNickname = requestJSONObject . optString ( UserExt . USER_NICKNAME ) ; if ( StringUtils . isNotBlank ( userNickname ) && userNickname . length ( ) > MAX_USER_NICKNAME_LENGTH ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , langPropsService . get ( "invalidUserNicknameLabel" ) ) ) ; context . abort ( ) ; return ; } final String userIntro = requestJSONObject . optString ( UserExt . USER_INTRO ) ; if ( StringUtils . isNotBlank ( userIntro ) && userIntro . length ( ) > MAX_USER_INTRO_LENGTH ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , langPropsService . get ( "invalidUserIntroLabel" ) ) ) ; context . abort ( ) ; return ; } final int userCommentViewMode = requestJSONObject . optInt ( UserExt . USER_COMMENT_VIEW_MODE ) ; if ( userCommentViewMode != UserExt . USER_COMMENT_VIEW_MODE_C_REALTIME && userCommentViewMode != UserExt . USER_COMMENT_VIEW_MODE_C_TRADITIONAL ) { requestJSONObject . put ( UserExt . USER_COMMENT_VIEW_MODE , UserExt . USER_COMMENT_VIEW_MODE_C_TRADITIONAL ) ; } final String tagErrMsg = langPropsService . get ( "selfTagLabel" ) + langPropsService . get ( "colonLabel" ) + langPropsService . get ( "tagsErrorLabel" ) ; String userTags = requestJSONObject . optString ( UserExt . USER_TAGS ) ; if ( StringUtils . isNotBlank ( userTags ) ) { userTags = Tag . formatTags ( userTags ) ; String [ ] tagTitles = userTags . split ( "," ) ; if ( null == tagTitles || 0 == tagTitles . length ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , tagErrMsg ) ) ; context . abort ( ) ; return ; } tagTitles = new LinkedHashSet < > ( Arrays . asList ( tagTitles ) ) . toArray ( new String [ 0 ] ) ; final StringBuilder tagBuilder = new StringBuilder ( ) ; for ( int i = 0 ; i < tagTitles . length ; i ++ ) { final String tagTitle = tagTitles [ i ] . trim ( ) ; if ( StringUtils . isBlank ( tagTitle ) ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , tagErrMsg ) ) ; context . abort ( ) ; return ; } if ( Tag . containsWhiteListTags ( tagTitle ) ) { tagBuilder . append ( tagTitle ) . append ( "," ) ; continue ; } if ( ! Tag . TAG_TITLE_PATTERN . matcher ( tagTitle ) . matches ( ) ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , tagErrMsg ) ) ; context . abort ( ) ; return ; } if ( tagTitle . length ( ) > Tag . MAX_TAG_TITLE_LENGTH ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , tagErrMsg ) ) ; context . abort ( ) ; return ; } final JSONObject currentUser = Sessions . getUser ( ) ; if ( ! Role . ROLE_ID_C_ADMIN . equals ( currentUser . optString ( User . USER_ROLE ) ) && ArrayUtils . contains ( Symphonys . RESERVED_TAGS , tagTitle ) ) { context . renderJSON ( new JSONObject ( ) . put ( Keys . MSG , langPropsService . get ( "selfTagLabel" ) + langPropsService . get ( "colonLabel" ) + langPropsService . get ( "articleTagReservedLabel" ) + " [" + tagTitle + "]" ) ) ; context . abort ( ) ; return ; } tagBuilder . append ( tagTitle ) . append ( "," ) ; } if ( tagBuilder . length ( ) > 0 ) { tagBuilder . deleteCharAt ( tagBuilder . length ( ) - 1 ) ; } requestJSONObject . put ( UserExt . USER_TAGS , tagBuilder . toString ( ) ) ; } context . handle ( ) ; }
public float getInterpolation ( float input ) { input -- ; return ( float ) Math . pow ( input , 3 ) + 1f ; }
public int getLeapAmount ( long instant ) { return getWrappedField ( ) . getLeapAmount ( instant ) ; }
public void startElement ( String namespaceURI , String localName , String qName , Attributes atts ) throws SAXException { if ( qName . equals ( "page" ) ) { int length = atts . getLength ( ) ; for ( int i = 0 ; i < length ; i ++ ) { String name = atts . getQName ( i ) ; String value = atts . getValue ( i ) ; if ( name != null ) { if ( name . equals ( "id" ) ) { PageID = value ; if ( page > 4000 ) { page = 0 ; } if ( page == 0 ) { try { if ( writer != null ) writer . close ( ) ; File file = new File ( path + "text-" + fileCount + ".txt" ) ; System . out . println ( path + "text-" + fileCount + ".txt" ) ; OutputStream os = new FileOutputStream ( file , false ) ; writer = new OutputStreamWriter ( os , "UTF-8" ) ; fileCount ++ ; } catch ( Exception e ) { throw new GrobidException ( "An exception occured while running Grobid." , e ) ; } } page ++ ; } } } } else if ( qName . equals ( "text" ) ) { textBegin = true ; accumulator . setLength ( 0 ) ; } else { } }
public IRTMPEvent decodeAbort ( IoBuffer in ) { return new Abort ( in . getInt ( ) ) ; }
public Document getDocument ( String fileName ) throws Exception { return new Document ( fileName ) ; }
protected SessionsSecurityManager securityManager ( List < Realm > realms ) { return super . securityManager ( realms ) ; }
private static double cam02 ( int p1 , int p2 , double [ ] vc ) { double [ ] c1 = jmh2ucs ( camlch ( p1 , vc ) ) ; double [ ] c2 = jmh2ucs ( camlch ( p2 , vc ) ) ; return scalar ( c1 , c2 ) ; }
protected void doCompaction ( CompactionPlanEvent event , Collector < CompactionCommitEvent > collector , boolean needReloadMetaClient , FlinkCompactionMetrics compactionMetrics ) throws Exception { compactionMetrics . startCompaction ( ) ; HoodieFlinkMergeOnReadTableCompactor < ? > compactor = new HoodieFlinkMergeOnReadTableCompactor < > ( ) ; HoodieTableMetaClient metaClient = table . getMetaClient ( ) ; if ( needReloadMetaClient ) { metaClient . reload ( ) ; } CompactionUtil . setAvroSchema ( writeClient . getConfig ( ) , metaClient ) ; List < WriteStatus > writeStatuses = compactor . compact ( writeClient . getConfig ( ) , event . getOperation ( ) , event . getCompactionInstantTime ( ) , table . getTaskContextSupplier ( ) , createReaderContext ( needReloadMetaClient ) , table ) ; compactionMetrics . endCompaction ( ) ; collector . collect ( createCommitEvent ( event , writeStatuses ) ) ; }
public JavaWildcardType build ( OWNER owner , Iterable < JavaTypeVariable < ? > > allTypeParametersInContext , ImportedClasses importedClasses ) { this . owner = owner ; this . allTypeParametersInContext = allTypeParametersInContext ; this . importedClasses = importedClasses ; return createWildcardType ( this ) ; }
protected void onPostExecute ( Throwable ex ) { if ( running ) { if ( ex == null ) { Toast . makeText ( ActivitySettings . this , R . string . msg_completed , Toast . LENGTH_LONG ) . show ( ) ; ServiceSinkhole . reloadStats ( "import" , ActivitySettings . this ) ; recreate ( ) ; } else Toast . makeText ( ActivitySettings . this , ex . toString ( ) , Toast . LENGTH_LONG ) . show ( ) ; } }
public static int getUint16 ( final byte [ ] buff , int offset ) { return ( ( ( buff [ offset ++ ] ) & 0x000000FF ) | ( ( buff [ offset ] << 8 ) & 0x0000FF00 ) ) ; }
public INDArray segmentMin ( INDArray data , INDArray segmentIds ) { NDValidation . validateNumerical ( "segmentMin" , "segmentIds" , segmentIds ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . transforms . custom . segment . SegmentMin ( data , segmentIds ) ) [ 0 ] ; }
private void SaveInputUrl ( String url ) { playbackUrl = "" ; if ( url == null ) return ; if ( url . length ( ) < 8 ) { Log . e ( TAG , "Input full url error:" + url ) ; return ; } if ( ! url . startsWith ( "rtmp://" ) && ! url . startsWith ( "rtsp://" ) ) { Log . e ( TAG , "Input full url error:" + url ) ; return ; } btnStartStopPlayback . setEnabled ( true ) ; playbackUrl = url ; Log . i ( TAG , "Input full url:" + url ) ; }
public void setData ( List < ? > data ) { throw new UnsupportedOperationException ( "Use setRange instead" ) ; }
static boolean checkMessage ( IMessage message ) { return message != null && message . getId ( ) != null && message . getUser ( ) != null && message . getUser ( ) . getId ( ) != null && message . getText ( ) != null ; }
public int getMultiplier ( ) { return this . multiplier ; }
public List < StreamInfo > getStreamInfoList ( String streamId ) { long startTime = System . nanoTime ( ) ; List < StreamInfo > streamInfoList = new ArrayList < > ( ) ; synchronized ( broadcastLock ) { streamInfoList = datastore . find ( StreamInfo . class ) . filter ( Filters . eq ( STREAM_ID , streamId ) ) . iterator ( ) . toList ( ) ; } recordQueryDuration ( startTime , "getStreamInfoList" ) ; return streamInfoList ; }
public JComponent getComponent ( ) { return impl . getComponent ( ) ; }
protected void onLayout ( boolean changed , int l , int t , int r , int b ) { super . onLayout ( changed , l , t , r , b ) ; if ( first && getMeasuredWidth ( ) > 0 && getMeasuredHeight ( ) > 0 ) { first = false ; Keyboard . show ( inputView . getEditText ( ) ) ; } }
public void analyzeDependency ( Dependency dependency , Engine engine ) throws AnalysisException { if ( dependency . isVirtual ( ) ) { return ; } try ( InputStream fis = new FileInputStream ( dependency . getActualFile ( ) ) ) { final byte [ ] fileContent = IOUtils . toByteArray ( fis ) ; final ScannerFacade scanner = new ScannerFacade ( jsRepository ) ; final List < JsLibraryResult > results ; try { results = scanner . scanScript ( dependency . getActualFile ( ) . getAbsolutePath ( ) , fileContent , 0 ) ; } catch ( StackOverflowError ex ) { final String msg = String . format ( "An error occured trying to analyze %s. " + "To resolve this error please try increasing the Java stack size to " + "8mb and re-run dependency-check:%n%n" + "(win) : set JAVA_OPTS=\"-Xss8192k\"%n" + "(*nix): export JAVA_OPTS=\"-Xss8192k\"%n%n" , dependency . getDisplayFileName ( ) ) ; throw new AnalysisException ( msg , ex ) ; } if ( results . size ( ) > 0 ) { for ( JsLibraryResult libraryResult : results ) { final JsLibrary lib = libraryResult . getLibrary ( ) ; dependency . setName ( lib . getName ( ) ) ; dependency . setVersion ( libraryResult . getDetectedVersion ( ) ) ; try { final PackageURL purl = PackageURLBuilder . aPackageURL ( ) . withType ( "javascript" ) . withName ( lib . getName ( ) ) . withVersion ( libraryResult . getDetectedVersion ( ) ) . build ( ) ; dependency . addSoftwareIdentifier ( new PurlIdentifier ( purl , Confidence . HIGHEST ) ) ; } catch ( MalformedPackageURLException ex ) { LOGGER . debug ( "Unable to build package url for retireJS" , ex ) ; final GenericIdentifier id = new GenericIdentifier ( "javascript:" + lib . getName ( ) + "@" + libraryResult . getDetectedVersion ( ) , Confidence . HIGHEST ) ; dependency . addSoftwareIdentifier ( id ) ; } dependency . addEvidence ( EvidenceType . VERSION , "RetireJS" , "version" , libraryResult . getDetectedVersion ( ) , Confidence . HIGH ) ; dependency . addEvidence ( EvidenceType . PRODUCT , "RetireJS" , "name" , libraryResult . getLibrary ( ) . getName ( ) , Confidence . HIGH ) ; dependency . addEvidence ( EvidenceType . VENDOR , "RetireJS" , "name" , libraryResult . getLibrary ( ) . getName ( ) , Confidence . HIGH ) ; final List < Vulnerability > vulns = new ArrayList < > ( ) ; final JsVulnerability jsVuln = libraryResult . getVuln ( ) ; if ( jsVuln . getIdentifiers ( ) . containsKey ( "CVE" ) || jsVuln . getIdentifiers ( ) . containsKey ( "osvdb" ) ) { for ( Map . Entry < String , List < String > > entry : jsVuln . getIdentifiers ( ) . entrySet ( ) ) { final String key = entry . getKey ( ) ; final List < String > value = entry . getValue ( ) ; if ( "CVE" . equals ( key ) ) { for ( String cve : value ) { Vulnerability vuln = engine . getDatabase ( ) . getVulnerability ( StringUtils . trim ( cve ) ) ; if ( vuln == null ) { vuln = new Vulnerability ( ) ; vuln . setName ( cve ) ; vuln . setUnscoredSeverity ( jsVuln . getSeverity ( ) ) ; vuln . setSource ( Vulnerability . Source . RETIREJS ) ; } jsVuln . getInfo ( ) . stream ( ) . map ( ( info ) -> { if ( UrlValidator . getInstance ( ) . isValid ( info ) ) { return new Reference ( info , "info" , info ) ; } return new Reference ( info , "info" , null ) ; } ) . forEach ( vuln :: addReference ) ; vulns . add ( vuln ) ; } } else if ( "osvdb" . equals ( key ) ) { value . forEach ( ( osvdb ) -> { final Vulnerability vuln = new Vulnerability ( ) ; vuln . setName ( osvdb ) ; vuln . setSource ( Vulnerability . Source . RETIREJS ) ; vuln . setUnscoredSeverity ( jsVuln . getSeverity ( ) ) ; jsVuln . getInfo ( ) . stream ( ) . map ( ( info ) -> { if ( UrlValidator . getInstance ( ) . isValid ( info ) ) { return new Reference ( info , "info" , info ) ; } return new Reference ( info , "info" , null ) ; } ) . forEach ( vuln :: addReference ) ; vulns . add ( vuln ) ; } ) ; } dependency . addVulnerabilities ( vulns ) ; } } else { final Vulnerability individualVuln = new Vulnerability ( ) ; for ( Map . Entry < String , List < String > > entry : jsVuln . getIdentifiers ( ) . entrySet ( ) ) { final String key = entry . getKey ( ) ; final List < String > value = entry . getValue ( ) ; if ( null != key ) { switch ( key ) { case "summary" : if ( null == individualVuln . getName ( ) ) { individualVuln . setName ( value . get ( 0 ) ) ; } individualVuln . setDescription ( value . get ( 0 ) ) ; break ; case "issue" : individualVuln . setName ( libraryResult . getLibrary ( ) . getName ( ) + " issue: " + value . get ( 0 ) ) ; if ( UrlValidator . getInstance ( ) . isValid ( value . get ( 0 ) ) ) { individualVuln . addReference ( key , key , value . get ( 0 ) ) ; } else { individualVuln . addReference ( key , value . get ( 0 ) , null ) ; } break ; case "bug" : individualVuln . setName ( libraryResult . getLibrary ( ) . getName ( ) + " bug: " + value . get ( 0 ) ) ; if ( UrlValidator . getInstance ( ) . isValid ( value . get ( 0 ) ) ) { individualVuln . addReference ( key , key , value . get ( 0 ) ) ; } else { individualVuln . addReference ( key , value . get ( 0 ) , null ) ; } break ; case "pr" : individualVuln . setName ( libraryResult . getLibrary ( ) . getName ( ) + " pr: " + value . get ( 0 ) ) ; if ( UrlValidator . getInstance ( ) . isValid ( value . get ( 0 ) ) ) { individualVuln . addReference ( key , key , value . get ( 0 ) ) ; } else { individualVuln . addReference ( key , value . get ( 0 ) , null ) ; } break ; default : if ( UrlValidator . getInstance ( ) . isValid ( value . get ( 0 ) ) ) { individualVuln . addReference ( key , key , value . get ( 0 ) ) ; } else { individualVuln . addReference ( key , value . get ( 0 ) , null ) ; } break ; } } } if ( StringUtils . isBlank ( individualVuln . getName ( ) ) ) { individualVuln . setName ( "Vulnerability in " + libraryResult . getLibrary ( ) . getName ( ) ) ; } individualVuln . setSource ( Vulnerability . Source . RETIREJS ) ; individualVuln . setUnscoredSeverity ( jsVuln . getSeverity ( ) ) ; jsVuln . getInfo ( ) . stream ( ) . map ( ( info ) -> { if ( UrlValidator . getInstance ( ) . isValid ( info ) ) { return new Reference ( info , "info" , info ) ; } return new Reference ( info , "info" , null ) ; } ) . forEach ( individualVuln :: addReference ) ; dependency . addVulnerability ( individualVuln ) ; } } } else if ( getSettings ( ) . getBoolean ( Settings . KEYS . ANALYZER_RETIREJS_FILTER_NON_VULNERABLE , false ) ) { engine . removeDependency ( dependency ) ; } } catch ( IOException | DatabaseException e ) { throw new AnalysisException ( e ) ; } }
private static void overclockRenderer ( ClassNode node , boolean isObfuscated ) { final String methodName = isObfuscated ? "as" : "runGameLoop" ; final String methodDescriptor = "()V" ; System . out . println ( "MALMO: Found Minecraft, attempting to transform it" ) ; for ( MethodNode method : node . methods ) { if ( method . name . equals ( methodName ) && method . desc . equals ( methodDescriptor ) ) { System . out . println ( "MALMO: Found Minecraft.runGameLoop() method, attempting to transform it" ) ; for ( AbstractInsnNode instruction : method . instructions . toArray ( ) ) { if ( instruction . getOpcode ( ) == Opcodes . INVOKEVIRTUAL ) { MethodInsnNode visitMethodNode = ( MethodInsnNode ) instruction ; if ( visitMethodNode . name . equals ( isObfuscated ? "h" : "updateDisplay" ) ) { visitMethodNode . owner = "com/microsoft/Malmo/Utils/TimeHelper" ; if ( isObfuscated ) { visitMethodNode . name = "updateDisplay" ; } visitMethodNode . setOpcode ( Opcodes . INVOKESTATIC ) ; method . instructions . remove ( visitMethodNode . getPrevious ( ) ) ; System . out . println ( "MALMO: Hooked into call to Minecraft.updateDisplay()" ) ; } } } } } }
public boolean isNeedOrientationUtils ( ) { return mNeedOrientationUtils ; }
public String toString ( ) { return returnType + " " + getName ( ) + "(" + join ( parameters , ", " ) + ")" ; }
private void generateGroups ( final StringBuilder sb , final String parentMessageClassName , final List < Token > tokens , final FieldPrecedenceModel fieldPrecedenceModel , final String indent ) { for ( int i = 0 , size = tokens . size ( ) ; i < size ; i ++ ) { final Token groupToken = tokens . get ( i ) ; if ( groupToken . signal ( ) != Signal . BEGIN_GROUP ) { throw new IllegalStateException ( "tokens must begin with BEGIN_GROUP: token=" + groupToken ) ; } final String groupName = groupToken . name ( ) ; sb . append ( generateGroupProperty ( groupName , fieldPrecedenceModel , groupToken , indent + INDENT ) ) ; generateGroupClassHeader ( sb , groupName , parentMessageClassName , tokens , fieldPrecedenceModel , i , indent + INDENT ) ; i ++ ; i += tokens . get ( i ) . componentTokenCount ( ) ; final List < Token > fields = new ArrayList < > ( ) ; i = collectFields ( tokens , i , fields ) ; sb . append ( generateFields ( fieldPrecedenceModel , fields , indent + INDENT ) ) ; final List < Token > groups = new ArrayList < > ( ) ; i = collectGroups ( tokens , i , groups ) ; generateGroups ( sb , parentMessageClassName , groups , fieldPrecedenceModel , indent + INDENT ) ; final List < Token > varData = new ArrayList < > ( ) ; i = collectVarData ( tokens , i , varData ) ; sb . append ( generateVarData ( fieldPrecedenceModel , varData , indent + INDENT + INDENT ) ) ; appendGroupInstanceDisplay ( sb , fields , groups , varData , indent + TWO_INDENT ) ; sb . append ( indent ) . append ( INDENT + "}\n" ) ; }
public String toString ( ) { return ToStringHelper . name ( "AuthenticatorSelectionCriteria" ) . field ( "attachment" , attachment ) . field ( "requireResidentKey" , requireResidentKey ) . field ( "requireUserVerification" , requireUserVerification ) . field ( "residentKeyRequirement" , residentKeyRequirement ) . end ( ) ; }
public static Builder newObject ( GraphQLObjectType existing ) { return new Builder ( existing ) ; }
BaseGraph getBaseGraph ( ) ; int getNodes ( ) ; int getEdges ( ) ; NodeAccess getNodeAccess ( ) ; BBox getBounds ( ) ; EdgeIteratorState edge ( int a , int b ) ; EdgeIteratorState getEdgeIteratorState ( int edgeId , int adjNode ) ; EdgeIteratorState getEdgeIteratorStateForKey ( int edgeKey ) ; int getOtherNode ( int edge , int node ) ; boolean isAdjacentToNode ( int edge , int node ) ; AllEdgesIterator getAllEdges ( ) ; EdgeExplorer createEdgeExplorer ( EdgeFilter filter ) ; default EdgeExplorer createEdgeExplorer ( ) { return createEdgeExplorer ( EdgeFilter . ALL_EDGES ) ; }
public Criteria andSubjectCountGreaterThanOrEqualTo ( Integer value ) { addCriterion ( "subject_count >=" , value , "subjectCount" ) ; return ( Criteria ) this ; }
public void cancelSelection ( ) { synchronized ( mApplicationItems ) { for ( ApplicationItem item : getSelectedApplicationItems ( ) ) { int i = mApplicationItems . indexOf ( item ) ; if ( i != - 1 ) { mApplicationItems . get ( i ) . isSelected = false ; } } mSelectedPackageApplicationItemMap . clear ( ) ; } }
public JsonGenerator reset ( ) throws IOException { buffer . reset ( ) ; return jsonGenerator ; }
private static int idx ( int index ) { return IOV_SIZE * index ; }
public void visitLabel ( final Label label ) { if ( mv != null ) { mv . visitLabel ( label ) ; } }
public Collection < Node > takeNodes ( int nodesNeeded ) { HashSet < Node > ret = new HashSet < > ( ) ; Iterator < Node > it = nodes . iterator ( ) ; while ( it . hasNext ( ) && nodesNeeded > ret . size ( ) ) { Node n = it . next ( ) ; ret . add ( n ) ; totalSlots -= n . totalSlotsFree ( ) ; it . remove ( ) ; } return ret ; }
public static String getHumanFeedbackTip ( String nodeUuid , List < WorkflowNode > wfNodes ) { WorkflowNode wfNode = wfNodes . stream ( ) . filter ( item -> item . getUuid ( ) . equals ( nodeUuid ) ) . findFirst ( ) . orElse ( null ) ; if ( null == wfNode ) { return "" ; } String wfNodeNodeConfig = wfNode . getNodeConfig ( ) ; if ( StrUtil . isBlank ( wfNodeNodeConfig ) ) { return "" ; } Map < String , Object > map = JsonUtil . toMap ( wfNodeNodeConfig ) ; Object tip = map . getOrDefault ( "tip" , "" ) ; return String . valueOf ( tip ) ; }
public Enumeration < String > getHeaderNames ( ) { ServerHttpRequest request = getServerHttpRequest ( ) ; if ( request == null ) { return null ; } Set < String > headerNameSet = request . getHeaders ( ) . keySet ( ) ; return Collections . enumeration ( headerNameSet ) ; }
public Builder metadataColumn ( String metadataColumn ) { this . metadataColumn = metadataColumn ; return this ; }
public void setBackFromFullScreenListener ( OnClickListener backFromFullScreenListener ) { this . mBackFromFullScreenListener = backFromFullScreenListener ; }
public Reader getReader ( long oneBasedOffset , long length ) { return null ; }
protected final void doProcess ( final ITemplateContext context , final IProcessableElementTag tag , final AttributeName attributeName , final String attributeValue , final Object expressionResult , final IElementTagStructureHandler structureHandler ) { String newAttributeValue = HtmlEscape . escapeHtml4Xml ( expressionResult == null ? "" : expressionResult . toString ( ) ) ; newAttributeValue = RequestDataValueProcessorUtils . processUrl ( context , newAttributeValue ) ; StandardProcessorUtils . replaceAttribute ( structureHandler , attributeName , this . targetAttributeDefinition , ATTR_NAME , ( newAttributeValue == null ? "" : newAttributeValue ) ) ; }
public void incrementRecord ( ) { this . skipRecord ++ ; }
public @ Nullable ScalingUtils . ScaleType getActualImageScaleType ( ) { return mActualImageScaleType ; }
public static HttpServletRequest getRequest ( ) { return getRequestAttributes ( ) . getRequest ( ) ; }
public V getIfPresent ( Object key ) { MutableInt timestamp = timestamps . get ( key ) ; if ( timestamp == null ) return null ; if ( timestamp . intValue ( ) < ticks ( ) - ticksUntilTimeout ) { timestamps . remove ( key ) ; map . remove ( key ) ; return null ; } if ( resetTimerOnAccess ) timestamp . setValue ( ticks ( ) ) ; return map . get ( key ) ; }
public String toString ( ) { return "PT" + String . valueOf ( getValue ( ) ) + "S" ; }
public void putSize ( @ Nullable String key , @ Nullable Size value ) { unparcel ( ) ; mMap . put ( key , value ) ; }
protected void applySearchTransformFactor ( float factor , boolean isOpening ) { }
static String getRootDomain ( Context context , String host ) { if ( host == null ) return null ; String tld = getTld ( context , host ) ; if ( tld == null ) return null ; if ( tld . equalsIgnoreCase ( host ) ) return null ; int len = host . length ( ) - tld . length ( ) - 1 ; if ( len < 0 ) { Log . e ( "getRootDomain host=" + host + " tld=" + tld ) ; return null ; } int dot = host . substring ( 0 , len ) . lastIndexOf ( '.' ) ; if ( dot < 0 ) return host ; return host . substring ( dot + 1 ) ; }
public default List < Component > getTitleAs ( String type ) { ResourceLocation id = getId ( ) ; return ImmutableList . of ( Component . translatable ( id . getNamespace ( ) + ".schedule." + type + "." + id . getPath ( ) ) ) ; }
public void onDockerBuildProgressChange ( DockerBuildSnapshot snapshot ) { DOCKER_BUILD_PG_SNAPSHOTS . put ( app . getId ( ) , snapshot ) ; }
public void setSelectedUsers ( @ Nullable int [ ] selectedUsers ) { if ( selectedUsers == null ) { if ( mSelectedUsers == null ) { return ; } } else if ( mSelectedUsers != null ) { if ( mSelectedUsers . length == selectedUsers . length ) { boolean differs = false ; for ( int user : selectedUsers ) { if ( ! ArrayUtils . contains ( mSelectedUsers , user ) ) { differs = true ; break ; } } if ( ! differs ) { return ; } } } mSelectedUsers = selectedUsers ; cancelIfRunning ( ) ; mFilterResult = executor . submit ( this :: filterItemsByFlags ) ; }
private static < T > int findSlice ( IndexedSeq < T > source , IndexedSeq < T > slice , int index , int maxIndex ) { while ( index <= maxIndex ) { if ( source . startsWith ( slice , index ) ) { return index ; } index ++ ; } return - 1 ; }
public SettingBar setStartTextColor ( @ ColorInt int color ) { mStartView . setTextColor ( color ) ; return this ; }
public static String gainCondition ( boolean not , String condition ) { return gainCondition ( not , condition , false ) ; }
protected void onDraw ( Canvas c ) { if ( icon == null ) { return ; } final int viewWidth = getMeasuredWidth ( ) ; final int viewHeight = Screen . dp ( 92f ) ; final int centerX = viewWidth / 2 ; int centerY = viewHeight / 2 ; int offsetY = Screen . dp ( 16f ) ; if ( factor < .5f ) { if ( inviteLayout != null ) { c . save ( ) ; c . translate ( Screen . dp ( 12f ) , viewHeight + Screen . dp ( 14f ) ) ; Paints . getTextPaint15 ( ColorUtils . alphaColor ( 1f - factor / .5f , Theme . textDecent2Color ( ) ) ) ; inviteLayout . draw ( c ) ; c . restore ( ) ; } } else { if ( joinedLayout != null ) { c . save ( ) ; c . translate ( Screen . dp ( 12f ) , viewHeight + Screen . dp ( 20f ) ) ; Paints . getTextPaint15 ( ColorUtils . alphaColor ( ( factor - .5f ) / .5f , Theme . textDecent2Color ( ) ) ) ; joinedLayout . draw ( c ) ; c . restore ( ) ; } } if ( factor == 0f ) { Drawables . draw ( c , icon , centerX - icon . getMinimumWidth ( ) / 2 , centerY - icon . getMinimumHeight ( ) / 2 , Paints . getBackgroundIconPorterDuffPaint ( ) ) ; return ; } final long totalDuration = animator . getDuration ( ) ; final long time = ( long ) ( factor * ( float ) totalDuration ) ; if ( time < ICON_DURATION ) { float factor = 1f - ( ( float ) time / ( float ) ICON_DURATION ) ; Paint paint = Paints . getBackgroundIconPorterDuffPaint ( ) ; final boolean saved = factor != 1f ; if ( saved ) { paint . setAlpha ( ( int ) ( 255f * factor ) ) ; c . save ( ) ; float scale = .6f + .4f * factor ; c . scale ( scale , scale , centerX , centerY + offsetY ) ; } Drawables . draw ( c , icon , centerX - icon . getMinimumWidth ( ) / 2 , centerY - icon . getMinimumHeight ( ) / 2 , paint ) ; if ( saved ) { c . restore ( ) ; paint . setAlpha ( 255 ) ; } return ; } if ( avatarInfos == null ) { return ; } centerY += offsetY ; int avatarRadius = Screen . dp ( AVATAR_RADIUS ) ; int avatarSpacing = Screen . dp ( AVATAR_SPACING ) ; int avatarCount = avatarInfos . length ; int totalWidth = ( avatarRadius * 2 * avatarCount ) + ( avatarSpacing * ( avatarCount - 1 ) ) ; int cx = centerX - totalWidth / 2 + avatarRadius ; int i = 0 ; for ( AvatarInfo info : avatarInfos ) { long startTime = ICON_DURATION + ( START_DELAY * i ) ; if ( time < startTime ) { break ; } float factor = time < ( startTime + AVATAR_DURATION ) ? ( float ) ( time - startTime ) / ( float ) AVATAR_DURATION : 1f ; float scale = .6f + .4f * factor ; if ( factor < 1f ) { c . save ( ) ; c . scale ( scale , scale , cx , centerY ) ; } if ( i == 4 && moreCounter != null ) { c . drawCircle ( cx , centerY , avatarRadius , Paints . fillingPaint ( ColorUtils . alphaColor ( factor , Theme . getColor ( ColorId . avatarSavedMessages ) ) ) ) ; Paint paint = Paints . whiteMediumPaint ( COUNTER_MEDIUM_DP , false , false ) ; paint . setAlpha ( ( int ) ( 255f * factor ) ) ; int padding = Screen . dp ( 3f ) ; float textScale = counterWidth > avatarRadius * 2 - padding ? ( float ) ( avatarRadius * 2 - padding ) / counterWidth : 1f ; if ( textScale != 1f ) { c . save ( ) ; c . scale ( textScale , textScale , cx , centerY ) ; } c . drawText ( moreCounter , cx - counterWidth / 2 , centerY + Screen . dp ( 7f ) , paint ) ; if ( textScale != 1f ) { c . restore ( ) ; } paint . setAlpha ( 255 ) ; } else if ( info . imageFile == null ) { drawPlaceholder ( c , info , cx , centerY , factor ) ; } else { ImageReceiver receiver = receivers [ i ] ; receiver . setBounds ( cx - avatarRadius , centerY - avatarRadius , cx + avatarRadius , centerY + avatarRadius ) ; if ( receiver . needPlaceholder ( ) ) { if ( info . letters != null && ! TD . isFileLoaded ( info . imageFile . getFile ( ) ) ) { drawPlaceholder ( c , info , cx , centerY , factor ) ; } else { Paint paint = Paints . getPlaceholderPaint ( ) ; int alpha = paint . getAlpha ( ) ; if ( factor < 1f ) { paint . setAlpha ( ( int ) ( ( float ) alpha * factor ) ) ; } c . drawCircle ( cx , centerY , avatarRadius , paint ) ; if ( factor < 1f ) { paint . setAlpha ( alpha ) ; } } } if ( factor < 1f ) { receiver . setPaintAlpha ( receiver . getAlpha ( ) * factor ) ; } receiver . draw ( c ) ; if ( factor < 1f ) { receiver . restorePaintAlpha ( ) ; } } if ( factor < 1f ) { c . restore ( ) ; } cx += avatarRadius * 2 + avatarSpacing ; i ++ ; } }
public boolean requiresBitmap ( ) { return false ; }
private void sendExecuteFetch ( Transport . Connection connection , String action , final ShardFetchRequest request , SearchTask task , final SearchActionListener < FetchSearchResult > listener ) { transportService . sendChildRequest ( connection , action , request , task , new ConnectionCountingHandler < > ( listener , FetchSearchResult :: new , clientConnections , connection . getNode ( ) . getId ( ) ) ) ; }
public boolean isJavaConstant ( ) { return constant instanceof JavaConstant ; }
private void generateComponentProperties ( final LwComponent lwComponent , final InstrumentationClassFinder . PseudoClass componentClass , final GeneratorAdapter generator , final int componentLocal ) throws CodeGenerationException { final LwIntrospectedProperty [ ] introspectedProperties = lwComponent . getAssignedIntrospectedProperties ( ) ; for ( final LwIntrospectedProperty property : introspectedProperties ) { if ( property instanceof LwIntroComponentProperty ) { continue ; } final String propertyClass = property . getCodeGenPropertyClassName ( ) ; if ( myIgnoreCustomCreation ) { try { final String descriptor ; if ( propertyClass . equals ( Integer . class . getName ( ) ) ) { descriptor = "(I)V" ; } else if ( propertyClass . equals ( Boolean . class . getName ( ) ) ) { descriptor = "(Z)V" ; } else if ( propertyClass . equals ( Double . class . getName ( ) ) ) { descriptor = "(D)V" ; } else if ( propertyClass . equals ( Float . class . getName ( ) ) ) { descriptor = "(F)V" ; } else if ( propertyClass . equals ( Long . class . getName ( ) ) ) { descriptor = "(L)V" ; } else if ( propertyClass . equals ( Byte . class . getName ( ) ) ) { descriptor = "(B)V" ; } else if ( propertyClass . equals ( Short . class . getName ( ) ) ) { descriptor = "(S)V" ; } else if ( propertyClass . equals ( Character . class . getName ( ) ) ) { descriptor = "(C)V" ; } else { descriptor = "(L" + Class . forName ( propertyClass ) . getName ( ) . replace ( '.' , '/' ) + ";)V" ; } final InstrumentationClassFinder . PseudoMethod setter = componentClass . findMethodInHierarchy ( property . getWriteMethodName ( ) , descriptor ) ; if ( setter == null ) { continue ; } } catch ( Exception e ) { continue ; } } final PropertyCodeGenerator propGen = myPropertyCodeGenerators . get ( propertyClass ) ; try { if ( propGen != null && propGen . generateCustomSetValue ( lwComponent , componentClass , property , generator , this , componentLocal , myClassName ) ) { continue ; } } catch ( IOException | ClassNotFoundException e ) { throw new CodeGenerationException ( lwComponent . getId ( ) , e . getMessage ( ) , e ) ; } generator . loadLocal ( componentLocal ) ; Object value = lwComponent . getPropertyValue ( property ) ; Type setterArgType ; if ( propertyClass . equals ( Integer . class . getName ( ) ) ) { generator . push ( ( ( Integer ) value ) . intValue ( ) ) ; setterArgType = Type . INT_TYPE ; } else if ( propertyClass . equals ( Boolean . class . getName ( ) ) ) { generator . push ( ( ( Boolean ) value ) . booleanValue ( ) ) ; setterArgType = Type . BOOLEAN_TYPE ; } else if ( propertyClass . equals ( Double . class . getName ( ) ) ) { generator . push ( ( ( Double ) value ) . doubleValue ( ) ) ; setterArgType = Type . DOUBLE_TYPE ; } else if ( propertyClass . equals ( Float . class . getName ( ) ) ) { generator . push ( ( ( Float ) value ) . floatValue ( ) ) ; setterArgType = Type . FLOAT_TYPE ; } else if ( propertyClass . equals ( Long . class . getName ( ) ) ) { generator . push ( ( ( Long ) value ) . longValue ( ) ) ; setterArgType = Type . LONG_TYPE ; } else if ( propertyClass . equals ( Short . class . getName ( ) ) ) { generator . push ( ( ( Short ) value ) . intValue ( ) ) ; setterArgType = Type . SHORT_TYPE ; } else if ( propertyClass . equals ( Byte . class . getName ( ) ) ) { generator . push ( ( ( Byte ) value ) . intValue ( ) ) ; setterArgType = Type . BYTE_TYPE ; } else if ( propertyClass . equals ( Character . class . getName ( ) ) ) { generator . push ( ( ( Character ) value ) . charValue ( ) ) ; setterArgType = Type . CHAR_TYPE ; } else { if ( propGen == null ) { continue ; } propGen . generatePushValue ( generator , value ) ; setterArgType = typeFromClassName ( property . getPropertyClassName ( ) ) ; } Type declaringType = ( property . getDeclaringClassName ( ) != null ) ? typeFromClassName ( property . getDeclaringClassName ( ) ) : Type . getType ( componentClass . getDescriptor ( ) ) ; generator . invokeVirtual ( declaringType , new Method ( property . getWriteMethodName ( ) , Type . VOID_TYPE , new Type [ ] { setterArgType } ) ) ; } generateClientProperties ( lwComponent , componentClass , generator , componentLocal ) ; }
public void ensureAdditionalHasContainersCapacity ( int additionalSize ) { hasContainers . ensureCapacity ( hasContainers . size ( ) + additionalSize ) ; }
public long currentBytesUsed ( ) { return bytesUsed . get ( ) ; }
public void removeNameIDMappingService ( EndpointType endpt ) { this . nameIDMappingService . remove ( endpt ) ; }
public String getURI ( ) { return getName ( ) ; }
public static IkAnalyzerProvider getIkAnalyzerProvider ( IndexSettings indexSettings , Environment env , String name , Settings settings ) { return new IkAnalyzerProvider ( indexSettings , env , name , settings , false ) ; }
private void callSetupUI ( ) { if ( ! mySetupCalled ) { mv . visitVarInsn ( Opcodes . ALOAD , 0 ) ; mv . visitMethodInsn ( Opcodes . INVOKESPECIAL , myClassName , SETUP_METHOD_NAME , "()V" , false ) ; mySetupCalled = true ; } }
public String toString ( ) { return "FreePool of " + nodes . size ( ) + " nodes with " + totalSlots + " slots" ; }
public SessionController . ShardedGateway getShardedGateway ( ) { return getSessionController ( ) . getShardedGateway ( this ) ; }
public void serializeStaticRow ( Row row , SerializationHelper helper , DataOutputPlus out , int version ) throws IOException { assert row . isStatic ( ) ; serialize ( row , helper , out , 0 , version ) ; }
protected ByteBuffer getBytes ( int bufferIndex , String uri , Integer bufferLength ) throws IOException { return data . get ( bufferIndex ) ; }
private static List < String > doResourceListFolder ( File fFolder , List < String > files , FilenameFilter filter ) { int localLevel = testing ? lvl : lvl + 1 ; String subFolder = "" ; if ( fFolder . isDirectory ( ) ) { if ( files . size ( ) > 0 && ! FileManager . pathEquals ( fFolder . getPath ( ) , files . get ( 0 ) ) ) { subFolder = fFolder . getPath ( ) . substring ( files . get ( 0 ) . length ( ) + 1 ) . replace ( "\\" , "/" ) + "/" ; if ( filter != null && ! filter . accept ( new File ( files . get ( 0 ) , subFolder ) , "" ) ) { return files ; } } else { logp ( localLevel , "scanning folder:\n%s" , fFolder ) ; subFolder = "/" ; files . add ( subFolder ) ; } String [ ] subList = fFolder . list ( ) ; for ( String entry : subList ) { File fEntry = new File ( fFolder , entry ) ; if ( fEntry . isDirectory ( ) ) { files . add ( fEntry . getAbsolutePath ( ) . substring ( 1 + files . get ( 0 ) . length ( ) ) . replace ( "\\" , "/" ) + "/" ) ; doResourceListFolder ( fEntry , files , filter ) ; files . add ( subFolder ) ; } else { if ( filter != null && ! filter . accept ( fFolder , entry ) ) { continue ; } logp ( localLevel , "from %s adding: %s" , ( subFolder . isEmpty ( ) ? "." : subFolder ) , entry ) ; files . add ( fEntry . getAbsolutePath ( ) . substring ( 1 + fFolder . getPath ( ) . length ( ) ) ) ; } } } return files ; }
protected StrExprProcessor getStrExprProcessor ( ) { return new StrExprProcessor ( ) ; }
void addBound ( JavaTypeCreationProcess < OWNER > bound ) { upperBounds . add ( bound ) ; }
public void findPos ( Object key , IntArray out ) { throw new RuntimeException ( ) ; }
public WebStatFilter getWebStatFilter ( ) { return webStatFilter ; }
default SlashCommandData addOption ( @ Nonnull OptionType type , @ Nonnull String name , @ Nonnull String description , boolean required , boolean autoComplete ) { return addOptions ( new OptionData ( type , name , description ) . setRequired ( required ) . setAutoComplete ( autoComplete ) ) ; }
public Criteria andDetailAddressNotLike ( String value ) { addCriterion ( "detail_address not like" , value , "detailAddress" ) ; return ( Criteria ) this ; }
public static void longToOctets ( long address , byte [ ] octets , int offset ) { octets [ offset ] = ( byte ) ( 0xffL & ( address > > > 56 ) ) ; octets [ offset + 1 ] = ( byte ) ( 0xffL & ( address > > > 48 ) ) ; octets [ offset + 2 ] = ( byte ) ( 0xffL & ( address > > > 40 ) ) ; octets [ offset + 3 ] = ( byte ) ( 0xffL & ( address > > > 32 ) ) ; octets [ offset + 4 ] = ( byte ) ( 0xffL & ( address > > > 24 ) ) ; octets [ offset + 5 ] = ( byte ) ( 0xffL & ( address > > > 16 ) ) ; octets [ offset + 6 ] = ( byte ) ( 0xffL & ( address > > > 8 ) ) ; octets [ offset + 7 ] = ( byte ) ( 0xffL & address ) ; }
public void setRunningJobs ( Collection < JobInfo > runningJobs ) { this . runningJobs = runningJobs ; }
public TreeCache getCache ( final String path ) { return caches . get ( path ) ; }
public BasePopupWindow setPopupGravity ( GravityMode mode , int popupGravity ) { mHelper . setPopupGravity ( mode , popupGravity ) ; return this ; }
private Reference < K , V > [ ] createReferenceArray ( int size ) { return new Reference [ size ] ; }
public NDArray sub ( NDArray other ) { return getAlternativeArray ( ) . sub ( alternativeManager . from ( other ) ) ; }
public TimeTunnelModel setTimeFragment ( TimeFragmentVO timeFragment ) { this . timeFragment = timeFragment ; return this ; }
public String toJson ( ) { Map < String , Object > obj = new LinkedHashMap < > ( ) ; obj . put ( "ok" , ok ) ; if ( ! ok ) obj . put ( "error" , message ) ; obj . put ( "id" , id ) ; obj . put ( "version" , version ) ; obj . put ( "privileged" , privileged ) ; obj . put ( "services" , new ArrayList < > ( services ) ) ; LinkedHashSet < String > pset = new LinkedHashSet < > ( requiredPermNames ) ; if ( metas != null ) { for ( ExtensionMeta m : metas ) { for ( Permission p : m . getRequiredPermissions ( ) ) { pset . add ( p . name ( ) ) ; } } } obj . put ( "requiredPermissions" , new ArrayList < > ( pset ) ) ; return toJson ( obj ) ; }
public Socket openNioChannel ( InetSocketAddress remoteAddress , Supplier < NioSelector > supplier ) throws IOException { SocketChannel rawChannel = rawChannelFactory . openNioChannel ( ) ; setNonBlocking ( rawChannel ) ; NioSelector selector = supplier . get ( ) ; Socket channel = internalCreateChannel ( selector , rawChannel , createSocketConfig ( remoteAddress , false ) ) ; scheduleChannel ( channel , selector ) ; return channel ; }
public void onDestroy ( ) { super . onDestroy ( ) ; if ( mImageView != null ) mImageView . setImageDrawable ( null ) ; if ( mPreviewImage != null ) mPreviewImage . setImageDrawable ( null ) ; if ( ! OobeUtils . isInternationalBuild ( ) ) { } }
private ExecutorException exception ( ) { return new ExecutorException ( "Multiple type-aware handlers are registered and being looked up without type; javaType=" + javaType + ", jdbcType=" + jdbcType + ", type handlers=" + conflictedTypeHandlers . stream ( ) . map ( x -> x . getClass ( ) . getName ( ) ) . collect ( Collectors . joining ( "," ) ) ) ; }
private ApplicationItem getNewApplicationItem ( @ NonNull String packageName , @ NonNull List < App > apps ) { ApplicationItem item = new ApplicationItem ( ) ; int thisUser = UserHandleHidden . myUserId ( ) ; for ( App app : apps ) { if ( ! packageName . equals ( app . packageName ) ) { continue ; } if ( app . isInstalled ) { boolean newItem = item . packageName == null || ! item . isInstalled ; if ( item . packageName == null ) { item . packageName = app . packageName ; } item . userIds = ArrayUtils . appendInt ( item . userIds , app . userId ) ; item . isInstalled = true ; item . isOnlyDataInstalled = false ; item . openCount += app . openCount ; item . screenTime += app . screenTime ; if ( item . lastUsageTime == 0L || item . lastUsageTime < app . lastUsageTime ) { item . lastUsageTime = app . lastUsageTime ; } item . hasKeystore |= app . hasKeystore ; item . usesSaf |= app . usesSaf ; if ( app . ssaid != null ) { item . ssaid = app . ssaid ; } item . totalSize += app . codeSize + app . dataSize ; item . dataUsage += app . wifiDataUsage + app . mobileDataUsage ; if ( ! newItem && app . userId != thisUser ) { continue ; } } else { if ( item . packageName != null ) { continue ; } else { item . packageName = app . packageName ; item . isInstalled = false ; item . isOnlyDataInstalled = app . isOnlyDataInstalled ; item . hasKeystore |= app . hasKeystore ; } } item . flags = app . flags ; item . uid = app . uid ; item . debuggable = app . isDebuggable ( ) ; item . isUser = ! app . isSystemApp ( ) ; item . isDisabled = ! app . isEnabled ; item . label = app . packageLabel ; item . targetSdk = app . sdk ; item . versionName = app . versionName ; item . versionCode = app . versionCode ; item . sharedUserId = app . sharedUserId ; item . sha = new Pair < > ( app . certName , app . certAlgo ) ; item . firstInstallTime = app . firstInstallTime ; item . lastUpdateTime = app . lastUpdateTime ; item . hasActivities = app . hasActivities ; item . hasSplits = app . hasSplits ; item . blockedCount = app . rulesCount ; item . trackerCount = app . trackerCount ; item . lastActionTime = app . lastActionTime ; if ( item . backup == null ) { item . backup = BackupUtils . getLatestBackupMetadataFromDbNoLockValidate ( packageName ) ; } item . generateOtherInfo ( ) ; } if ( item . packageName == null ) { return null ; } return item ; }
public boolean isUsuallyFollowedBySpace ( final int code ) { return mSpacingAndPunctuations . isUsuallyFollowedBySpace ( code ) ; }
JavaConstructor construct ( JavaConstructorBuilder builder , ImportedClasses importedClasses ) { return DomainObjectCreationContext . createJavaConstructor ( builder ) ; }
public LogDetail getLogDetail ( ) { return logDetail ; }
public XWPFSection closelySectPr ( IBodyElement element ) { throw new UnsupportedOperationException ( ) ; }
public ResponseEntity < Void > postRunEventRaw ( OpenLineage . RunEvent openlineageRunEvent ) { Authentication authentication = AuthenticationContext . getAuthentication ( ) ; OperationContext opContext = OperationContext . asSession ( systemOperationContext , RequestContext . builder ( ) . buildOpenapi ( authentication . getActor ( ) . toUrnStr ( ) , request , "postRunEventRaw" , List . of ( ) ) , _authorizerChain , authentication , true ) ; log . info ( "PostRun received lineage event: {}" , openlineageRunEvent ) ; RunEventMapper runEventMapper = new RunEventMapper ( ) ; AuditStamp auditStamp = new AuditStamp ( ) . setActor ( UrnUtils . getUrn ( authentication . getActor ( ) . toUrnStr ( ) ) ) . setTime ( System . currentTimeMillis ( ) ) ; try { for ( MetadataChangeProposal mcp : runEventMapper . map ( openlineageRunEvent , this . _mappingConfig ) . collect ( Collectors . toList ( ) ) ) { log . info ( "Ingesting MCP: {}" , mcp ) ; _entityService . ingestProposal ( opContext , mcp , auditStamp , true ) ; } return new ResponseEntity < > ( HttpStatus . OK ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public void setInverted ( boolean inverted ) { invertedProperty . set ( inverted ) ; }
public Long getCount ( ) { return count ; }
public void setMax ( int max ) { this . max = max ; }
static PanicException methodNotInvocable ( Node where , UnresolvedSymbol symbol , Object self , Throwable cause ) throws PanicException { var ctx = EnsoContext . get ( where ) ; var payload = ctx . getBuiltins ( ) . error ( ) . makeNotInvokable ( symbol ) ; throw new PanicException ( ctx , payload , cause , where ) ; }
private CompactionCommitEvent createFailedCommitEvent ( CompactionPlanEvent event ) { return new CompactionCommitEvent ( event . getCompactionInstantTime ( ) , event . getOperation ( ) . getFileId ( ) , taskID , event . isMetadataTable ( ) , event . isLogCompaction ( ) ) ; }
public static void main ( String [ ] args ) { double radius = 2.0 ; Point2D circleCenter = new Point2D . Double ( 5 , 0 ) ; Point2D origin = new Point2D . Double ( 0 , 0 ) ; Point2D [ ] points = pointCircleTangentPoints ( circleCenter , radius , origin ) ; if ( points . length == 2 ) { Point2D pt1 = points [ 0 ] ; Point2D pt2 = points [ 1 ] ; System . out . println ( "Points found: " + pt1 + " " + pt2 ) ; } }
protected void writeStatic ( final Path outputDirectory ) { staticFiles . forEach ( resourceName -> { try ( InputStream is = Thread . currentThread ( ) . getContextClassLoader ( ) . getResourceAsStream ( resourceName ) ) { if ( Objects . isNull ( is ) ) { throw new ReportGenerationException ( String . format ( "Resource %s not found" , resourceName ) ) ; } Files . copy ( is , outputDirectory . resolve ( resourceName ) , StandardCopyOption . REPLACE_EXISTING ) ; } catch ( IOException e ) { LOGGER . error ( "Couldn't unpack report static" ) ; } } ) ; }
public < E extends RealmModel > E createDetachedCopy ( E realmObject , int maxDepth , Map < RealmModel , RealmObjectProxy . CacheData < RealmModel > > cache ) { checkSchemaHasClass ( Util . getOriginalModelClass ( realmObject . getClass ( ) ) ) ; return originalMediator . createDetachedCopy ( realmObject , maxDepth , cache ) ; }
public void flowFlatMapIterableAsFlow1 ( Blackhole bh ) { flowFlatMapIterableAsFlow1 . subscribe ( new PerfConsumer ( bh ) ) ; }
@ Override public int getSplitNum ( ) { Configuration conf = context . getConf ( ) ; int workergroupNumber = conf . getInt ( AngelConf . ANGEL_WORKERGROUP_NUMBER , AngelConf . DEFAULT_ANGEL_WORKERGROUP_NUMBER ) ; int taskNumInWorker = conf . getInt ( AngelConf . ANGEL_WORKER_TASK_NUMBER , AngelConf . DEFAULT_ANGEL_WORKER_TASK_NUMBER ) ; return workergroupNumber * taskNumInWorker ; }
public Planner getPlanner ( ) { return ( ( StreamTableEnvironmentImpl ) streamTableEnvironment ) . getPlanner ( ) ; }
public ProtoId [ ] getProtoId ( ) { return protoIds ; }
public PasswordSchema _default ( String _default ) { super . setDefault ( _default ) ; return this ; }
public HashMap < Integer , Pair < View . OnClickListener , Boolean > > getListenersHolderMap ( ) { return mListenersHolderMap ; }
public XmlResourceParser getMenu ( @ NonNull String resName ) { XmlResourceParser menu = InternalAccessor . getMenu ( resName ) ; if ( saveToResourcesHolder ) holder . put ( resName , menu ) ; return menu ; }
public static String getPrivateDnsSpecifier ( Context context ) { String dns_mode = Settings . Global . getString ( context . getContentResolver ( ) , "private_dns_mode" ) ; if ( "hostname" . equals ( dns_mode ) ) return Settings . Global . getString ( context . getContentResolver ( ) , "private_dns_specifier" ) ; else return null ; }
public void recycle ( ) { if ( ! pools . contains ( this ) ) { date = null ; valid = null ; select = null ; note = null ; pools . add ( this ) ; } }
public void onClick ( View v ) { if ( OobeUtils . isTabletLand ( ProvisionBaseActivity . this ) ) { onSkipAminStart ( ) ; return ; } if ( OobeUtils . needFastAnimation ( ) ) { updateButtonState ( false ) ; mHandler . postDelayed ( ( ) -> updateButtonState ( true ) , 5000L ) ; } else if ( ! isOtherAnimEnd ( ) ) { Log . w ( "OobeUtil2" , "other anim not end" ) ; return ; } else if ( ! isAnimEnded ( ) ) { Log . w ( "OobeUtil2" , "video anim not end" ) ; return ; } Log . d ( "OobeUtil2" , "begin start OOBSETTINGS" ) ; if ( mProvisionAnimHelper != null ) { mProvisionAnimHelper . setAnimY ( getTitleLayoutHeight ( ) ) ; mProvisionAnimHelper . goNextStep ( 1 ) ; } }
public Criteria andLinkNumberBetween ( String value1 , String value2 ) { addCriterion ( "link_number between" , value1 , value2 , "linkNumber" ) ; return ( Criteria ) this ; }
private static ExprNode parseSubstring ( String attr , Value < ? > initial , String filter , Position pos ) throws ParseException { if ( StringTools . isCharASCII ( filter , pos . start , '*' ) ) { SubstringNode node = new SubstringNode ( attr ) ; if ( initial != null && ! initial . isNull ( ) ) { String initialStr = initial . getString ( ) ; node . setInitial ( initialStr ) ; } pos . start ++ ; while ( true ) { Value < ? > assertionValue = parseAssertionValue ( filter , pos ) ; if ( StringTools . isCharASCII ( filter , pos . start , ')' ) ) { if ( ! assertionValue . isNull ( ) ) { String finalStr = assertionValue . getString ( ) ; node . setFinal ( finalStr ) ; } return node ; } else if ( StringTools . isCharASCII ( filter , pos . start , '*' ) ) { if ( ! assertionValue . isNull ( ) ) { String anyStr = assertionValue . getString ( ) ; node . addAny ( anyStr ) ; } pos . start ++ ; } else { throw new ParseException ( I18n . err ( I18n . ERR_04150 ) , pos . start ) ; } } } else { throw new ParseException ( I18n . err ( I18n . ERR_04150 ) , pos . start ) ; } }
public static void usage ( ) { System . out . println ( "Usage: run_synthea [options] [state [city]]" ) ; System . out . println ( "Options: [-s seed] [-cs clinicianSeed] [-p populationSize]" ) ; System . out . println ( "         [-ps singlePersonSeed]" ) ; System . out . println ( "         [-r referenceDate as YYYYMMDD]" ) ; System . out . println ( "         [-e endDate as YYYYMMDD]" ) ; System . out . println ( "         [-g gender] [-a minAge-maxAge]" ) ; System . out . println ( "         [-o overflowPopulation]" ) ; System . out . println ( "         [-c localConfigFilePath]" ) ; System . out . println ( "         [-d localModulesDirPath]" ) ; System . out . println ( "         [-i initialPopulationSnapshotPath]" ) ; System . out . println ( "         [-u updatedPopulationSnapshotPath]" ) ; System . out . println ( "         [-t updateTimePeriodInDays]" ) ; System . out . println ( "         [-f fixedRecordPath]" ) ; System . out . println ( "         [-k keepMatchingPatientsPath]" ) ; System . out . println ( "         [--config*=value]" ) ; System . out . println ( "          * any setting from src/main/resources/synthea.properties" ) ; System . out . println ( "Examples:" ) ; System . out . println ( "run_synthea Massachusetts" ) ; System . out . println ( "run_synthea Alaska Juneau" ) ; System . out . println ( "run_synthea -s 12345" ) ; System . out . println ( "run_synthea -p 1000" ) ; System . out . println ( "run_synthea -s 987 Washington Seattle" ) ; System . out . println ( "run_synthea -s 21 -p 100 Utah \"Salt Lake City\"" ) ; System . out . println ( "run_synthea -g M -a 60-65" ) ; System . out . println ( "run_synthea -p 10 --exporter.fhir.export=true" ) ; System . out . println ( "run_synthea --exporter.baseDirectory=\"./output_tx/\" Texas" ) ; }
public static String [ ] getGroupsForUserCommand ( final String user ) { return new String [ ] { "bash" , "-c" , "id -Gn " + user } ; }
public OrdinalsNested < A > withNewOrdinals ( ) { return new OrdinalsNested ( null ) ; }
public String getBasepath ( ) { return basepath ; }
public RestAIStreamClient . Builder apiKey ( String apiKeyValue ) { this . apiKey = apiKeyValue ; return this ; }
public boolean moveToFirst ( ) { return doMoveToPosition ( 0 ) ; }
public void updateById ( LitemallOrderGoods orderGoods ) { orderGoods . setUpdateTime ( LocalDateTime . now ( ) ) ; orderGoodsMapper . updateByPrimaryKeySelective ( orderGoods ) ; }
public static boolean isMethodExists ( String className , String methodName , Class < ? > ... parameterTypes ) { try { Class < ? > cls = Class . forName ( className ) ; cls . getMethod ( methodName , parameterTypes ) ; return true ; } catch ( ClassNotFoundException | NoSuchMethodException e ) { return false ; } }
void sendOkResponse ( final long correlationId , final long relevantId ) { sendResponse ( correlationId , relevantId , OK , null ) ; }
public SSLParameters sslParameters ( ) { return delegate . sslParameters ( ) ; }
private ImmutableList < ModuleSplit > generateAssetSlices ( AppBundle appBundle ) { ApkGenerationConfiguration assetSlicesGenerationConfiguration = getAssetSliceGenerationConfiguration ( ) ; AssetSlicesGenerator assetSlicesGenerator = new AssetSlicesGenerator ( appBundle , assetSlicesGenerationConfiguration , command . getAssetModulesVersionOverride ( ) ) ; return assetSlicesGenerator . generateAssetSlices ( ) ; }
private boolean isReturnsSingle ( Method method ) { return Single . class . isAssignableFrom ( method . getReturnType ( ) ) ; }
public void setIndex ( int position , int index ) { if ( index < 0 ) { throw new IllegalArgumentException ( "index < 0" ) ; } if ( hasIndex ( position ) ) { throw new IllegalStateException ( "index already set" ) ; } this . index [ position ] = index ; }
public void visit ( AlterSession alterSession ) { StatementVisitor . super . visit ( alterSession ) ; }
void addIfContainedInTryBlock ( RawAccessRecord rawRecord , JavaAccess < ? > access ) { if ( rawAccessesContainedInTryBlock . contains ( rawRecord ) ) { accessesContainedInTryBlock . add ( access ) ; } }
public void actionPerformed ( java . awt . event . ActionEvent evt ) { cancelButtonActionPerformed ( evt ) ; }
public void addSelectedEntry ( VaultEntry entry ) { if ( _focusedEntry != null ) { resetFocus ( ) ; } _selectedEntries . add ( entry ) ; updateDraggableStatus ( ) ; }
public Optional < TerminationMark > terminationMark ( ) { return routerTransaction . getTerminationMark ( ) ; }
protected void set ( final String name , final Element element , final AtomicInteger ref ) { final String value = getValueAttribute ( element ) ; if ( value == null ) { LOGGER . warn ( "No value for {} parameter, using default {}" , name , ref ) ; } else { try { ref . set ( Integer . parseInt ( value ) ) ; } catch ( NumberFormatException e ) { LOGGER . warn ( "{} parsing {} parameter, using default {}: {}" , e . getClass ( ) . getName ( ) , name , ref , e . getMessage ( ) , e ) ; } } }
private void mergeSchema ( List < ChatSchemaDto > schemaList , List < ChatModelSchema > defaultRecallSchema ) { if ( CollectionUtils . isEmpty ( defaultRecallSchema ) ) { return ; } Map < String , Set < String > > existMap = schemaList . stream ( ) . collect ( Collectors . groupingBy ( ChatSchemaDto :: getModelCode , Collectors . mapping ( ChatSchemaDto :: getColumnId , Collectors . toSet ( ) ) ) ) ; List < ChatSchemaDto > toAdd = defaultRecallSchema . stream ( ) . filter ( schema -> { Set < String > existColumns = existMap . getOrDefault ( schema . getModelCode ( ) , Collections . emptySet ( ) ) ; return ! existColumns . contains ( schema . getColumnId ( ) ) ; } ) . map ( m -> { ChatSchemaDto dto = new ChatSchemaDto ( ) ; BeanUtils . copyProperties ( m , dto ) ; return dto ; } ) . toList ( ) ; schemaList . addAll ( toAdd ) ; }
public Map < Column , Column > createSourceToDestinationKeyMapping ( Set < Pair < Column , Column > > assignments ) { String [ ] equations = getUnrestrictedJoinCondition ( ) . replaceAll ( "\\(|\\)" , " " ) . trim ( ) . split ( "\\s*\\b(a|A)(n|N)(d|D)\\b\\s*" ) ; Map < Column , Column > mapping = new LinkedHashMap < Column , Column > ( ) ; Set < Column > destinationColumns = new HashSet < Column > ( ) ; boolean isValid = true ; for ( String equation : equations ) { String hs [ ] = equation . split ( "\\s*=\\s*" ) ; if ( hs . length != 2 ) { return Collections . emptyMap ( ) ; } String lhs [ ] = hs [ 0 ] . split ( "\\s*\\.\\s*" ) ; String rhs [ ] = hs [ 1 ] . split ( "\\s*\\.\\s*" ) ; if ( lhs . length != 2 || rhs . length != 2 || lhs [ 0 ] . length ( ) != 1 || rhs [ 0 ] . length ( ) != 1 ) { return Collections . emptyMap ( ) ; } String dColumn = null , sColumn = null ; if ( "A" . equalsIgnoreCase ( lhs [ 0 ] ) ) { sColumn = lhs [ 1 ] ; } if ( "B" . equalsIgnoreCase ( lhs [ 0 ] ) ) { dColumn = lhs [ 1 ] ; } if ( "A" . equalsIgnoreCase ( rhs [ 0 ] ) ) { sColumn = rhs [ 1 ] ; } if ( "B" . equalsIgnoreCase ( rhs [ 0 ] ) ) { dColumn = rhs [ 1 ] ; } if ( sColumn == null || dColumn == null ) { return Collections . emptyMap ( ) ; } sColumn = Quoting . normalizeIdentifier ( sColumn ) ; dColumn = Quoting . normalizeIdentifier ( dColumn ) ; if ( reversed ) { String h = sColumn ; sColumn = dColumn ; dColumn = h ; } Column sourceColumn = null ; for ( Column c : source . getColumns ( ) ) { if ( Quoting . normalizeIdentifier ( c . name ) . equals ( sColumn ) ) { sourceColumn = c ; break ; } } Column destinationColumn = null ; for ( Column c : destination . getColumns ( ) ) { if ( Quoting . normalizeIdentifier ( c . name ) . equals ( dColumn ) ) { destinationColumn = c ; break ; } } if ( sourceColumn == null || destinationColumn == null ) { isValid = false ; } else { if ( assignments != null ) { assignments . add ( new Pair < Column , Column > ( sourceColumn , destinationColumn ) ) ; } if ( mapping . put ( sourceColumn , destinationColumn ) != null ) { isValid = false ; } if ( ! destinationColumns . add ( destinationColumn ) ) { isValid = false ; } } } if ( isValid ) { return mapping ; } else { return Collections . emptyMap ( ) ; } }
private static boolean isReadOnlyOrInConstructor ( ClientModelPropertyAccess property , JavaSettings settings ) { return property . isReadOnly ( ) || ( settings . isRequiredFieldsAsConstructorArgs ( ) && property . isRequired ( ) ) ; }
private static String extension ( File file ) { return file . getName ( ) . substring ( file . getName ( ) . lastIndexOf ( '.' ) + 1 ) ; }
public boolean equals ( java . lang . Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } return super . equals ( o ) ; }
public void clear ( ) { if ( ! cells . isEmpty ( ) ) { cells . clear ( ) ; invalidate ( ) ; } }
protected String getClassName ( ) { throw new IllegalArgumentException ( "getClassName() cannot be called here" ) ; }
public void modifyHandshake ( ServerEndpointConfig sec , HandshakeRequest request , HandshakeResponse response ) { try { if ( ! requests . offer ( request , 1 , TimeUnit . SECONDS ) ) { throw new RuntimeException ( "Timed out waiting for getEndpointInstance() to be called" ) ; } } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } }
public static boolean isSQLite ( String db ) { return DATABASE_SQLITE . equals ( db ) ; }
public byte [ ] scanKey ( Application parentApplication , long timestamp ) { Buffer buffer = new AutomaticBuffer ( ) ; buffer . putPadString ( parentApplication . getName ( ) , HbaseTableConstants . APPLICATION_NAME_MAX_LEN ) ; buffer . putShort ( ( short ) parentApplication . getServiceTypeCode ( ) ) ; long reverseTimestamp = LongInverter . invert ( timestamp ) ; buffer . putLong ( reverseTimestamp ) ; return buffer . getBuffer ( ) ; }
private static Properties loadSettings ( ) throws IOException { final Properties props = new Properties ( ) ; try ( final InputStream settings = Main . class . getResource ( "ls-benchmark.properties" ) . openStream ( ) ) { props . load ( settings ) ; } return props ; }
public String toJson ( ) { return gson . toJson ( this ) ; }
protected void checkDeviceCompatibleInternal ( DeviceTierTargeting targeting ) { if ( targeting . equals ( DeviceTierTargeting . getDefaultInstance ( ) ) ) { return ; } ImmutableSet < Integer > valuesAndAlternatives = Streams . concat ( targeting . getValueList ( ) . stream ( ) . map ( Int32Value :: getValue ) , targeting . getAlternativesList ( ) . stream ( ) . map ( Int32Value :: getValue ) ) . collect ( toImmutableSet ( ) ) ; checkArgument ( valuesAndAlternatives . contains ( getDeviceSpec ( ) . getDeviceTier ( ) . getValue ( ) ) , "The specified device tier '%s' does not match any of the available values: %s." , getDeviceSpec ( ) . getDeviceTier ( ) . getValue ( ) , valuesAndAlternatives . stream ( ) . map ( i -> i . toString ( ) ) . collect ( joining ( ", " ) ) ) ; }
public void close ( ) { if ( ! ObjectUtils . isEmpty ( closeThread . get ( ) ) ) { Runtime . getRuntime ( ) . removeShutdownHook ( closeThread . get ( ) ) ; } if ( isStarted . get ( ) ) { isStarted . set ( false ) ; try { this . close0 ( ) ; } catch ( Exception e ) { LOG . error ( "{} close error." , this . getClass ( ) . getSimpleName ( ) ) ; } } }
private boolean isReturnsCompletableFuture ( Method method ) { return CompletableFuture . class . isAssignableFrom ( method . getReturnType ( ) ) ; }
private void storeClassPath ( ) { if ( isJava9 ( ) ) { String separator = File . pathSeparator ; String cp = System . getProperty ( "java.class.path" ) ; classPathList = Arrays . asList ( cp . split ( separator ) ) ; } else { classPathActual . clear ( ) ; URLClassLoader sysLoader = ( URLClassLoader ) ClassLoader . getSystemClassLoader ( ) ; classPathActual = Arrays . asList ( sysLoader . getURLs ( ) ) ; classPathList . clear ( ) ; for ( URL urlPath : classPathActual ) { classPathList . add ( urlPath . toExternalForm ( ) ) ; } } }
public byte [ ] getValue ( ) { return value ; }
public static boolean isDatabricks ( String db ) { return DATABASE_DATABRICKS . equals ( db ) ; }
protected Color getThumbColor ( ) { Color foreground = slider . getForeground ( ) ; return ( foreground != defaultForeground ) ? foreground : thumbColor ; }
public OAuthFlows getFlows ( ) { return flows ; }
private AffinityTopologyVersion onAllReceived ( ) { assert Thread . holdsLock ( this ) ; assert futureMapped ( ) : this ; AffinityTopologyVersion remapTopVer0 = null ; if ( remapTopVer == null ) { if ( X . hasCause ( err , CachePartialUpdateCheckedException . class ) && X . hasCause ( err , ClusterTopologyCheckedException . class ) && storeFuture ( ) && -- remapCnt > 0 ) { ClusterTopologyCheckedException topErr = X . cause ( err , ClusterTopologyCheckedException . class ) ; if ( ! ( topErr instanceof ClusterTopologyServerNotFoundException ) ) { CachePartialUpdateCheckedException cause = X . cause ( err , CachePartialUpdateCheckedException . class ) ; assert cause != null && cause . topologyVersion ( ) != null : err ; remapTopVer0 = new AffinityTopologyVersion ( cause . topologyVersion ( ) . topologyVersion ( ) + 1 ) ; err = null ; } } } else remapTopVer0 = remapTopVer ; if ( remapTopVer0 != null ) { cctx . mvcc ( ) . removeAtomicFuture ( futId ) ; reqState = null ; topVer = AffinityTopologyVersion . ZERO ; futId = 0 ; remapTopVer = null ; } return remapTopVer0 ; }
private void incrementReadableBytes ( int increment ) { int nextReadableBytes = readableBytes + increment ; if ( nextReadableBytes < readableBytes ) { throw new IllegalStateException ( "buffer queue length overflow: " + readableBytes + " + " + increment ) ; } readableBytes = nextReadableBytes ; if ( tracker != null ) { tracker . incrementPendingOutboundBytes ( increment ) ; } }
protected SessionDataSet executeLastDataQuery ( List < String > paths , long time , long timeOut ) throws StatementExecutionException , IoTDBConnectionException , RedirectException { TSLastDataQueryReq tsLastDataQueryReq = new TSLastDataQueryReq ( sessionId , paths , time , statementId ) ; tsLastDataQueryReq . setFetchSize ( session . fetchSize ) ; tsLastDataQueryReq . setEnableRedirectQuery ( enableRedirect ) ; tsLastDataQueryReq . setTimeout ( timeOut ) ; RetryResult < TSExecuteStatementResp > result = callWithRetryAndReconnect ( ( ) -> { tsLastDataQueryReq . setSessionId ( sessionId ) ; tsLastDataQueryReq . setStatementId ( statementId ) ; return client . executeLastDataQueryV2 ( tsLastDataQueryReq ) ; } , TSExecuteStatementResp :: getStatus ) ; final TSExecuteStatementResp tsExecuteStatementResp = result . getResult ( ) ; if ( result . getRetryAttempts ( ) == 0 ) { RpcUtils . verifySuccessWithRedirection ( tsExecuteStatementResp . getStatus ( ) ) ; } else { RpcUtils . verifySuccess ( tsExecuteStatementResp . getStatus ( ) ) ; } return new SessionDataSet ( "" , tsExecuteStatementResp . getColumns ( ) , tsExecuteStatementResp . getDataTypeList ( ) , tsExecuteStatementResp . columnNameIndexMap , tsExecuteStatementResp . getQueryId ( ) , statementId , client , sessionId , tsExecuteStatementResp . queryResult , tsExecuteStatementResp . isIgnoreTimeStamp ( ) , tsExecuteStatementResp . moreData , zoneId , timeFactor , tsExecuteStatementResp . isSetTableModel ( ) && tsExecuteStatementResp . isTableModel ( ) , tsExecuteStatementResp . getColumnIndex2TsBlockColumnIndexList ( ) ) ; }
public boolean onContextItemSelected ( @ NonNull MenuItem item ) { Context ctx = requireContext ( ) ; ConnectionDescriptor conn = mAdapter . getSelectedItem ( ) ; MatchList whitelist = PCAPdroid . getInstance ( ) . getMalwareWhitelist ( ) ; MatchList fwWhitelist = PCAPdroid . getInstance ( ) . getFirewallWhitelist ( ) ; MatchList decryptionList = PCAPdroid . getInstance ( ) . getDecryptionList ( ) ; Blocklist blocklist = PCAPdroid . getInstance ( ) . getBlocklist ( ) ; boolean firewallPurchased = Billing . newInstance ( ctx ) . isPurchased ( Billing . FIREWALL_SKU ) ; boolean mask_changed = false ; boolean whitelist_changed = false ; boolean blocklist_changed = false ; boolean firewall_wl_changed = false ; boolean decryption_list_changed = false ; if ( conn == null ) return super . onContextItemSelected ( item ) ; int id = item . getItemId ( ) ; if ( id == R . id . select_connection ) { startSelectionMode ( conn ) ; return true ; } else if ( id == R . id . hide_app ) { mAdapter . mMask . addApp ( conn . uid ) ; mask_changed = true ; } else if ( id == R . id . hide_host ) { mAdapter . mMask . addHost ( conn . info ) ; mask_changed = true ; } else if ( id == R . id . hide_ip ) { mAdapter . mMask . addIp ( conn . dst_ip ) ; mask_changed = true ; } else if ( id == R . id . hide_proto ) { mAdapter . mMask . addProto ( conn . l7proto ) ; mask_changed = true ; } else if ( id == R . id . hide_domain ) { mAdapter . mMask . addHost ( Utils . getSecondLevelDomain ( conn . info ) ) ; mask_changed = true ; } else if ( id == R . id . hide_country ) { mAdapter . mMask . addCountry ( conn . country ) ; mask_changed = true ; } else if ( id == R . id . search_app ) { AppDescriptor app = mApps . getAppByUid ( conn . uid , 0 ) ; if ( app != null ) setQuery ( app . getPackageName ( ) ) ; else return super . onContextItemSelected ( item ) ; } else if ( id == R . id . search_host ) setQuery ( conn . info ) ; else if ( id == R . id . search_ip ) setQuery ( conn . dst_ip ) ; else if ( id == R . id . search_proto ) setQuery ( conn . l7proto ) ; else if ( id == R . id . mw_whitelist_app ) { whitelist . addApp ( conn . uid ) ; whitelist_changed = true ; } else if ( id == R . id . mw_whitelist_ip ) { whitelist . addIp ( conn . dst_ip ) ; whitelist_changed = true ; } else if ( id == R . id . mw_whitelist_host ) { whitelist . addHost ( conn . info ) ; whitelist_changed = true ; } else if ( id == R . id . dec_add_app ) { decryptionList . addApp ( conn . uid ) ; decryption_list_changed = true ; } else if ( id == R . id . dec_add_ip ) { decryptionList . addIp ( conn . dst_ip ) ; decryption_list_changed = true ; } else if ( id == R . id . dec_add_host ) { decryptionList . addHost ( conn . info ) ; decryption_list_changed = true ; } else if ( id == R . id . dec_rem_app ) { decryptionList . removeApp ( conn . uid ) ; decryption_list_changed = true ; } else if ( id == R . id . dec_rem_ip ) { decryptionList . removeIp ( ( mDecRemoveCidr != null ) ? mDecRemoveCidr : conn . dst_ip ) ; decryption_list_changed = true ; } else if ( id == R . id . dec_rem_host ) { decryptionList . removeHost ( conn . info ) ; decryption_list_changed = true ; } else if ( id == R . id . block_app ) { if ( firewallPurchased ) { blocklist . addApp ( conn . uid ) ; blocklist_changed = true ; } else showFirewallPurchaseDialog ( ) ; } else if ( id == R . id . block_ip ) { if ( firewallPurchased ) { blocklist . addIp ( conn . dst_ip ) ; blocklist_changed = true ; } else showFirewallPurchaseDialog ( ) ; } else if ( id == R . id . block_host ) { if ( firewallPurchased ) { blocklist . addHost ( conn . info ) ; blocklist_changed = true ; } else showFirewallPurchaseDialog ( ) ; } else if ( id == R . id . block_domain ) { if ( firewallPurchased ) { blocklist . addHost ( Utils . getSecondLevelDomain ( conn . info ) ) ; blocklist_changed = true ; } else showFirewallPurchaseDialog ( ) ; } else if ( id == R . id . block_country ) { if ( firewallPurchased ) { blocklist . addCountry ( conn . country ) ; blocklist_changed = true ; } else showFirewallPurchaseDialog ( ) ; } else if ( id == R . id . unblock_app_permanently ) { blocklist . removeApp ( conn . uid ) ; blocklist_changed = true ; } else if ( id == R . id . unblock_app_10m ) { blocklist_changed = blocklist . unblockAppForMinutes ( conn . uid , 10 ) ; } else if ( id == R . id . unblock_app_1h ) { blocklist_changed = blocklist . unblockAppForMinutes ( conn . uid , 60 ) ; } else if ( id == R . id . unblock_app_8h ) { blocklist_changed = blocklist . unblockAppForMinutes ( conn . uid , 480 ) ; } else if ( id == R . id . unblock_ip ) { blocklist . removeIp ( ( mUnblockCidr != null ) ? mUnblockCidr : conn . dst_ip ) ; blocklist_changed = true ; } else if ( id == R . id . unblock_host ) { blocklist . removeHost ( conn . info ) ; blocklist_changed = true ; } else if ( id == R . id . unblock_domain ) { blocklist . removeHost ( Utils . getSecondLevelDomain ( conn . info ) ) ; blocklist_changed = true ; } else if ( id == R . id . unblock_country ) { blocklist . removeCountry ( conn . country ) ; blocklist_changed = true ; } else if ( id == R . id . add_to_fw_whitelist ) { fwWhitelist . addApp ( conn . uid ) ; firewall_wl_changed = true ; } else if ( id == R . id . remove_from_fw_whitelist ) { fwWhitelist . removeApp ( conn . uid ) ; firewall_wl_changed = true ; } else if ( id == R . id . open_app_details ) { Intent intent = new Intent ( requireContext ( ) , AppDetailsActivity . class ) ; intent . putExtra ( AppDetailsActivity . APP_UID_EXTRA , conn . uid ) ; startActivity ( intent ) ; } else if ( id == R . id . copy_ip ) Utils . copyToClipboard ( ctx , conn . dst_ip ) ; else if ( id == R . id . copy_host ) Utils . copyToClipboard ( ctx , conn . info ) ; else if ( id == R . id . copy_url ) Utils . copyToClipboard ( ctx , conn . url ) ; else if ( id == R . id . copy_http_request ) Utils . copyToClipboard ( ctx , conn . getHttpRequest ( ) ) ; else if ( id == R . id . copy_http_response ) Utils . copyToClipboard ( ctx , conn . getHttpResponse ( ) ) ; else return super . onContextItemSelected ( item ) ; if ( mask_changed ) { mAdapter . mMask . save ( ) ; mAdapter . mFilter . showMasked = false ; refreshFilteredConnections ( ) ; } else if ( whitelist_changed ) { whitelist . save ( ) ; CaptureService . reloadMalwareWhitelist ( ) ; } else if ( firewall_wl_changed ) { fwWhitelist . save ( ) ; if ( CaptureService . isServiceActive ( ) ) CaptureService . requireInstance ( ) . reloadFirewallWhitelist ( ) ; } else if ( decryption_list_changed ) { decryptionList . save ( ) ; CaptureService . reloadDecryptionList ( ) ; } else if ( blocklist_changed ) blocklist . saveAndReload ( ) ; return true ; }
public Builder setVoterSet ( Optional < VoterSet > voterSet ) { this . voterSet = voterSet ; return this ; }
protected String getSource ( ) { return RemoteConstants . LABEL_SOURCE_SDK ; }
public CaffeineCache getSubscriberCache ( ) { if ( subscriberCache == null ) { subscriberCache = ( CaffeineCache ) cacheManager . getCache ( SUBSCRIBER_CACHE ) ; } return subscriberCache ; }
JobDetails getJobDetails ( JobLambda lambda ) { return initOrGetJobDetails ( ( ) -> jobDetailsGeneratorDelegate . toJobDetails ( lambda ) , ( ) -> initJobParameterRetrievers ( jobDetails , lambda , Optional . empty ( ) ) , ( ) -> getCachedJobDetails ( lambda , Optional . empty ( ) ) ) ; }
public long liveRowsCount ( ) { return addedRowsCount + existingRowsCount ; }
public Constant getConstant ( ) { return constant ; }
public void setKeepAliveTime ( long time , TimeUnit unit ) { getTomcatExecutor ( ) . setKeepAliveTime ( time , unit ) ; }
public EventHandlerGroup < T > after ( final EventProcessor ... processors ) { return new EventHandlerGroup < > ( this , consumerRepository , Util . getSequencesFor ( processors ) ) ; }
public int getQpcb_next_cell$length ( ) { return 32 ; }
public void ifnonnull ( final Label label ) { visitJumpInsn ( Opcodes . IFNONNULL , label ) ; }
public void onAddTrack ( RtpReceiver receiver , MediaStream [ ] mediaStreams ) { Log . d ( TAG , "onAddTrack" ) ; for ( MediaStream stream : mediaStreams ) { String streamId = stream . getId ( ) ; MediaStreamTrack track = receiver . track ( ) ; ConstraintsMap params = new ConstraintsMap ( ) ; params . putString ( "event" , "onAddTrack" ) ; params . putString ( "streamId" , streamId ) ; params . putString ( "ownerTag" , id ) ; params . putString ( "trackId" , track . id ( ) ) ; String trackId = track . id ( ) ; ConstraintsMap trackInfo = new ConstraintsMap ( ) ; trackInfo . putString ( "id" , trackId ) ; trackInfo . putString ( "label" , track . kind ( ) ) ; trackInfo . putString ( "kind" , track . kind ( ) ) ; trackInfo . putBoolean ( "enabled" , track . enabled ( ) ) ; trackInfo . putString ( "readyState" , track . state ( ) . toString ( ) ) ; trackInfo . putBoolean ( "remote" , true ) ; params . putMap ( "track" , trackInfo . toMap ( ) ) ; sendEvent ( params ) ; if ( "audio" . equals ( track . kind ( ) ) ) { AudioSwitchManager . instance . start ( ) ; } } ConstraintsMap params = new ConstraintsMap ( ) ; ConstraintsArray streams = new ConstraintsArray ( ) ; for ( int i = 0 ; i < mediaStreams . length ; i ++ ) { MediaStream stream = mediaStreams [ i ] ; streams . pushMap ( new ConstraintsMap ( mediaStreamToMap ( stream ) ) ) ; } params . putString ( "event" , "onTrack" ) ; params . putArray ( "streams" , streams . toArrayList ( ) ) ; params . putMap ( "track" , mediaTrackToMap ( receiver . track ( ) ) ) ; params . putMap ( "receiver" , rtpReceiverToMap ( receiver ) ) ; if ( this . configuration . sdpSemantics == PeerConnection . SdpSemantics . UNIFIED_PLAN ) { List < RtpTransceiver > transceivers = peerConnection . getTransceivers ( ) ; for ( RtpTransceiver transceiver : transceivers ) { if ( transceiver . getReceiver ( ) != null && receiver . id ( ) . equals ( transceiver . getReceiver ( ) . id ( ) ) ) { String transceiverId = transceiver . getMid ( ) ; if ( null == transceiverId ) { transceiverId = stateProvider . getNextStreamUUID ( ) ; this . transceivers . put ( transceiverId , transceiver ) ; } params . putMap ( "transceiver" , transceiverToMap ( transceiverId , transceiver ) ) ; } } } sendEvent ( params ) ; }
public Bitmap and ( Bitmap other ) { return new ImmutableConciseSetWrapper ( intersection ( bitmap , ( ( ImmutableConciseSetWrapper ) other ) . bitmap ) ) ; }
public Criteria andDiscountLessThan ( BigDecimal value ) { addCriterion ( "discount <" , value , "discount" ) ; return ( Criteria ) this ; }
public V1beta1AllocatedDeviceStatus buildFirstDevice ( ) { return this . devices . get ( 0 ) . build ( ) ; }
public void fastJSON2ObjDeTime ( Blackhole bh ) { for ( String student : strList ) { bh . consume ( com . alibaba . fastjson2 . JSON . parseObject ( student , Student . class ) ) ; } }
public Object getInternalSubchannel ( ) { return delegate ( ) . getInternalSubchannel ( ) ; }
public NDArray tan ( ) { return getAlternativeArray ( ) . tan ( ) ; }
public INDArray slice ( INDArray input , INDArray begin , INDArray size ) { NDValidation . validateInteger ( "slice" , "begin" , begin ) ; NDValidation . validateInteger ( "slice" , "size" , size ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . shape . Slice ( input , begin , size ) ) [ 0 ] ; }
public void setCertPath ( String certPath ) { this . certPath = certPath ; }
public Criteria andDefaultStatusIsNull ( ) { addCriterion ( "default_status is null" ) ; return ( Criteria ) this ; }
private void addOrUpdateSnapshot ( ) { if ( srcView == null ) return ; if ( snapshotView == null ) { snapshotView = new PhotoView ( getContext ( ) ) ; snapshotView . setEnabled ( false ) ; photoViewContainer . addView ( snapshotView ) ; snapshotView . setScaleType ( srcView . getScaleType ( ) ) ; snapshotView . setTranslationX ( rect . left ) ; snapshotView . setTranslationY ( rect . top ) ; XPopupUtils . setWidthHeight ( snapshotView , rect . width ( ) , rect . height ( ) ) ; } int realPosition = getRealPosition ( ) ; snapshotView . setTag ( realPosition ) ; setupPlaceholder ( ) ; if ( imageLoader != null ) imageLoader . loadSnapshot ( urls . get ( realPosition ) , snapshotView , srcView ) ; }
private static float lerp ( float v0 , float v1 , float t ) { return ( 1 - t ) * v0 + t * v1 ; }
protected void preCreateSteps ( ) throws IOException { startupMetadata . create ( OConstants . getVersion ( ) ) ; }
private void refreshToken ( ) { String thisToken = null ; for ( int i = 1 ; i <= RETRY_TIMES ; i ++ ) { try { thisToken = HttpUtil . get ( TOKEN_URL , getConfig ( ) . getTimeout ( ) ) ; if ( thisToken != null && ! thisToken . isEmpty ( ) ) { break ; } } catch ( Exception e ) { LOGGER . warn ( "get microsoft token failed,retrying " + i ) ; } } if ( thisToken == null || thisToken . isEmpty ( ) ) { throw new RuntimeException ( "it still fails after " + RETRY_TIMES + " retries" ) ; } Long thisExp = JSON . parseObject ( Base64 . getUrlDecoder ( ) . decode ( thisToken . split ( "\\." ) [ 1 ] ) ) . getLong ( "exp" ) ; token = thisToken ; exp = thisExp ; }
protected List < QuoteFeed > getAvailableFeeds ( ) { List < QuoteFeed > feeds = new ArrayList < > ( ) ; feeds . addAll ( Factory . getQuoteFeedProvider ( ) ) ; if ( getModel ( ) . getSecurity ( ) . getOnlineId ( ) == null ) feeds . remove ( Factory . getQuoteFeedProvider ( PortfolioReportQuoteFeed . ID ) ) ; return feeds ; }
public RestService getRegistryRestClient ( String clusterId ) throws InvalidClusterException { if ( ! this . clusterExists ( clusterId ) ) { throw new InvalidClusterException ( INVALID_CLUSTER + clusterId + "'" ) ; } Connection connection = this . getConnection ( clusterId ) ; if ( connection . getSchemaRegistry ( ) != null ) { RestService restService = new RestService ( connection . getSchemaRegistry ( ) . getUrl ( ) ) ; if ( connection . getSchemaRegistry ( ) . getProperties ( ) != null && ! connection . getSchemaRegistry ( ) . getProperties ( ) . isEmpty ( ) ) { Map < String , Object > sslConfigs = connection . getSchemaRegistry ( ) . getProperties ( ) . entrySet ( ) . stream ( ) . filter ( e -> e . getKey ( ) . startsWith ( "schema.registry." ) ) . collect ( Collectors . toMap ( e -> e . getKey ( ) . substring ( "schema.registry." . length ( ) ) , Map . Entry :: getValue ) ) ; SslFactory sslFactory = new SslFactory ( sslConfigs ) ; if ( sslFactory != null && sslFactory . sslContext ( ) != null ) { restService . setSslSocketFactory ( sslFactory . sslContext ( ) . getSocketFactory ( ) ) ; } } restService . setHttpHeaders ( Collections . singletonMap ( "Accept" , "application/json" ) ) ; if ( connection . getSchemaRegistry ( ) . getBasicAuthUsername ( ) != null ) { BasicAuthCredentialProvider basicAuthCredentialProvider = BasicAuthCredentialProviderFactory . getBasicAuthCredentialProvider ( new UserInfoCredentialProvider ( ) . alias ( ) , ImmutableMap . of ( "schema.registry.basic.auth.user.info" , connection . getSchemaRegistry ( ) . getBasicAuthUsername ( ) + ":" + connection . getSchemaRegistry ( ) . getBasicAuthPassword ( ) ) ) ; restService . setBasicAuthCredentialProvider ( basicAuthCredentialProvider ) ; } if ( connection . getSchemaRegistry ( ) . getProperties ( ) != null ) { restService . configure ( connection . getSchemaRegistry ( ) . getProperties ( ) ) ; } return restService ; } return null ; }
static boolean hasVisibleNoArgConstructor ( TypeElement type ) { return type . getKind ( ) . isInterface ( ) || constructorsIn ( type . getEnclosedElements ( ) ) . stream ( ) . anyMatch ( c -> c . getParameters ( ) . isEmpty ( ) && ! c . getModifiers ( ) . contains ( Modifier . PRIVATE ) ) ; }
private DataFilePathFactory pathFactory ( Identifier identifier , BinaryRow part ) { return pathFactoryMap . computeIfAbsent ( identifier , k -> new HashMap < > ( ) ) . computeIfAbsent ( part , k -> { FileStoreTable targetTable = ( FileStoreTable ) getTable ( identifier ) ; return targetTable . store ( ) . pathFactory ( ) . createDataFilePathFactory ( part , 0 ) ; } ) ; }
public boolean compactNotCompleted ( ) { return false ; }
abstract String getString ( ) ; @ SuppressWarnings ( "CheckReturnValue" ) void use ( ) { new ConservativeStyleDetectedBuilder ( ) . setValue ( 1 ) . setString ( "string" ) . addEm ( "em" ) . build ( ) ; }
public String getImage ( ) { return image ; }
protected List < Icon > createRenderedIcons ( FontMetrics fontMetrics ) { return createRenderedIconsFromDescription ( fontMetrics ) ; }
VideoTrack createVideoTrack ( AbstractVideoCaptureController videoCaptureController ) { videoCaptureController . initializeVideoCapturer ( ) ; VideoCapturer videoCapturer = videoCaptureController . videoCapturer ; if ( videoCapturer == null ) { return null ; } PeerConnectionFactory pcFactory = webRTCModule . mFactory ; EglBase . Context eglContext = EglUtils . getRootEglBaseContext ( ) ; SurfaceTextureHelper surfaceTextureHelper = SurfaceTextureHelper . create ( "CaptureThread" , eglContext ) ; if ( surfaceTextureHelper == null ) { Log . d ( TAG , "Error creating SurfaceTextureHelper" ) ; return null ; } String id = UUID . randomUUID ( ) . toString ( ) ; TrackCapturerEventsEmitter eventsEmitter = new TrackCapturerEventsEmitter ( webRTCModule , id ) ; videoCaptureController . setCapturerEventsListener ( eventsEmitter ) ; VideoSource videoSource = pcFactory . createVideoSource ( videoCapturer . isScreencast ( ) ) ; videoCapturer . initialize ( surfaceTextureHelper , reactContext , videoSource . getCapturerObserver ( ) ) ; VideoTrack track = pcFactory . createVideoTrack ( id , videoSource ) ; track . setEnabled ( true ) ; tracks . put ( id , new TrackPrivate ( track , videoSource , videoCaptureController , surfaceTextureHelper ) ) ; videoCaptureController . startCapture ( ) ; return track ; }
public void visit ( SubJoin subjoin ) { unknownTable ( ) ; }
public void setExecutorHandler ( String executorHandler ) { this . executorHandler = executorHandler ; }
boolean isPreviewUnfolded ( NodeModel node ) { return previewUnfoldedNode == node ; }
public void run ( ) { handleConnect ( sink , exchange ) ; }
public boolean isFlat ( ) { return this . flat ; }
public String getReading ( ) { return null ; }
public static < S > JSArray < S > of ( S ... items ) { JSArray < S > array = create ( items . length ) ; for ( int i = 0 ; i < items . length ; ++ i ) { array . set ( i , items [ i ] ) ; } return array ; }
public String getName ( ) { return fsrl != null ? fsrl . getName ( ) : provider . getName ( ) ; }
private void stopPubliser ( ) { Log . i ( PUSH_TAG , "onClick stop.." ) ; if ( audioRecord_ != null ) { Log . i ( PUSH_TAG , "surfaceDestroyed, call StopRecording.." ) ; audioRecord_ . Stop ( ) ; if ( audioRecordCallback_ != null ) { audioRecord_ . RemoveCallback ( audioRecordCallback_ ) ; audioRecordCallback_ = null ; } audioRecord_ = null ; } if ( libPublisher != null && publisherHandle != 0 ) { libPublisher . SmartPublisherStopPublisher ( publisherHandle ) ; libPublisher . SmartPublisherClose ( publisherHandle ) ; publisherHandle = 0 ; } isPushStart = false ; }
private JPanel createLoggingDetailPanel ( ) { final JPanel panel = new JPanel ( new GridLayout ( NUMBER_OF_ROWS_PANEL_2 , 1 , 5 , 5 ) ) ; panel . setBorder ( new TitledBorder ( "Detail" ) ) ; panel . add ( GuiUtils . createHorizontalNamedComponentPanel ( "Log level:" , LABEL_WIDTH , logLevel , ROW_HEIGHT ) ) ; return panel ; }
public void endOfStream ( ) { post ( eventSink :: endOfStream ) ; }
public int getIntegerProperty ( final String key , final int defaultValue ) { String value = null ; try { value = getProperty ( key ) ; if ( value != null ) { return Integer . parseInt ( value ) ; } } catch ( final Exception ex ) { LOGGER . warn ( "Error converting value {} of {} to an integer: {}" , value , key , ex . getMessage ( ) ) ; } return defaultValue ; }
public float getInterpolation ( float input ) { float s = 1.70158f ; input *= 2f ; if ( input < 1f ) { return 0.5f * ( input * input * ( ( ( s *= ( 1.525f ) ) + 1f ) * input - s ) ) ; } return 0.5f * ( ( input -= 2f ) * input * ( ( ( s *= ( 1.525f ) ) + 1f ) * input + s ) + 2f ) ; }
public String toString ( ) { return target . toString ( ) ; }
public APIBuffer pop ( ) { offset = stack [ -- stackDepth ] ; return this ; }
protected RequestTemplate resolve ( Object [ ] argv , RequestTemplate mutable , Map < String , Object > variables ) { boolean alwaysEncodeBody = mutable . methodMetadata ( ) . alwaysEncodeBody ( ) ; Object body = null ; if ( ! alwaysEncodeBody ) { body = argv [ metadata . bodyIndex ( ) ] ; if ( mutable . methodMetadata ( ) . isBodyRequired ( ) ) { checkArgument ( body != null , "Body parameter %s was null" , metadata . bodyIndex ( ) ) ; } } try { if ( alwaysEncodeBody ) { body = argv == null ? new Object [ 0 ] : argv ; encoder . encode ( body , Object [ ] . class , mutable ) ; } else { encoder . encode ( body , metadata . bodyType ( ) , mutable ) ; } } catch ( EncodeException e ) { throw e ; } catch ( RuntimeException e ) { throw new EncodeException ( e . getMessage ( ) , e ) ; } return super . resolve ( argv , mutable , variables ) ; }
public void setDateStr ( String dateStr ) { this . dateStr = dateStr ; }
static Unit parseUnit ( String value ) { String symbol = parseSymbol ( value ) ; return Arrays . stream ( values ( ) ) . filter ( unit -> unit . getSymbol ( ) . equalsIgnoreCase ( symbol ) ) . findFirst ( ) . orElseThrow ( ( ) -> new IllegalStateException ( "Value [%s] does not contain a valid time unit" . formatted ( value ) ) ) ; }
public static void setCompileEnv ( final BaseExpression exp , final Env compileEnv ) { exp . setCompileEnv ( compileEnv ) ; }
public < T > List < T > getList ( String path ) { return getAsList ( path ) ; }
Map < byte [ ] , byte [ ] > hgetAll ( byte [ ] key ) ; byte [ ] hrandfield ( byte [ ] key ) ; List < byte [ ] > hrandfield ( byte [ ] key , long count ) ; List < Map . Entry < byte [ ] , byte [ ] > > hrandfieldWithValues ( byte [ ] key , long count ) ; default ScanResult < Map . Entry < byte [ ] , byte [ ] > > hscan ( byte [ ] key , byte [ ] cursor ) { return hscan ( key , cursor , new ScanParams ( ) ) ; }
public int getActiveConnectionCount ( ) { lock . lock ( ) ; try { return activeConnections . size ( ) ; } finally { lock . unlock ( ) ; } }
public < S > StringBuilder visit ( PivotXml pivot , S context ) { List < Column > forColumns = pivot . getForColumns ( ) ; builder . append ( " PIVOT XML (" ) . append ( PlainSelect . getStringList ( pivot . getFunctionItems ( ) ) ) . append ( " FOR " ) . append ( PlainSelect . getStringList ( forColumns , true , forColumns != null && forColumns . size ( ) > 1 ) ) . append ( " IN (" ) ; if ( pivot . isInAny ( ) ) { builder . append ( "ANY" ) ; } else if ( pivot . getInSelect ( ) != null ) { builder . append ( pivot . getInSelect ( ) ) ; } else { builder . append ( PlainSelect . getStringList ( pivot . getInItems ( ) ) ) ; } builder . append ( "))" ) ; return builder ; }
public void item ( CommandParameters parameters , Player player , LocalSession localSession , @ Arg ( desc = "The type of item to use" ) BaseItem item , @ Arg ( desc = "The direction in which the item will be applied" , def = "up" ) @ Direction ( includeDiagonals = true ) com . sk89q . worldedit . util . Direction direction ) throws WorldEditException { player . print ( TextComponent . builder ( ) . append ( "WARNING: " , TextColor . RED , TextDecoration . BOLD ) . append ( TranslatableComponent . of ( "worldedit.brush.apply.item.warning" ) ) . build ( ) ) ; setApplyBrush ( parameters , player , localSession , new ItemUseFactory ( item , direction ) ) ; }
public ResponseEntity < Message < Void > > deleteCollector ( @ Parameter ( description = "collector name" , example = "demo-collector" ) @ RequestParam ( required = false ) List < String > collectors ) { this . collectorService . deleteRegisteredCollector ( collectors ) ; return ResponseEntity . ok ( Message . success ( "Delete success" ) ) ; }
public void invalidateAll ( ) { cache . invalidateAll ( ) ; cache . cleanUp ( ) ; }
public ClusteringBound < ? > buildBoundWith ( List < ByteBuffer > newValues , boolean isStart , boolean isInclusive ) { ByteBuffer [ ] buffers = Arrays . copyOf ( values , size + newValues . size ( ) ) ; int newSize = size ; for ( ByteBuffer value : newValues ) buffers [ newSize ++ ] = value ; return BufferClusteringBound . create ( ClusteringBound . boundKind ( isStart , isInclusive ) , buffers ) ; }
private static native void dump_memory_profile ( ) ; static { try { System . loadLibrary ( "netguard" ) ; } catch ( UnsatisfiedLinkError ignored ) { System . exit ( 1 ) ; } }
public boolean isAssignableBy ( ResolvedReferenceTypeDeclaration other ) { return isAssignableBy ( new ReferenceTypeImpl ( other ) ) ; }
void destroy ( ) { crypter = null ; }
public String consume ( ) throws IOException { jsonGenerator . flush ( ) ; String s = buffer . toString ( ) ; buffer . reset ( ) ; return s ; }
public VirtualMachine vm ( ) { return vm ; }
public String getRawDate ( ) { return rawDate ; }
public boolean equals ( String pkg , String name , String type , int id ) { return ( pkg == null || pkg . equals ( this . pkg ) ) && ( name == null || name . equals ( this . name ) ) && ( type == null || type . equals ( this . type ) ) && ( id == 0 || id == this . id ) ; }
public void setPeriod ( ReadableInterval interval ) { if ( interval == null ) { setPeriod ( 0L ) ; } else { Chronology chrono = DateTimeUtils . getChronology ( interval . getChronology ( ) ) ; setPeriod ( interval . getStartMillis ( ) , interval . getEndMillis ( ) , chrono ) ; } }
public String fieldSubstitute ( String aString , RowMetaInterface rowMeta , Object [ ] rowData ) throws KettleValueException { return null ; }
private < T > RetryResult < T > callWithRetryAndReconnect ( TFunction < T > rpc , Function < T , TSStatus > statusGetter ) { return callWithRetryAndReconnect ( rpc , t -> { final TSStatus status = statusGetter . apply ( t ) ; return status . isSetNeedRetry ( ) && status . isNeedRetry ( ) ; } , t -> statusGetter . apply ( t ) . getCode ( ) == TSStatusCode . PLAN_FAILED_NETWORK_PARTITION . getStatusCode ( ) ) ; }
private void internalLocalCleanup ( JobID jobId ) throws IOException { final File jobDir = new File ( BlobUtils . getStorageLocationPath ( storageDir . deref ( ) . getAbsolutePath ( ) , jobId ) ) ; FileUtils . deleteDirectory ( jobDir ) ; }
public boolean isWildcardColumn ( ) { return this . isWildcardColumn ; }
public void onCurrentIndexFinalized ( InfiniteRecyclerView < SimpleStringItem > v , int newYearIndex ) { monthColumn . view . checkFitsMinMax ( ) ; dayColumn . view . checkFitsMinMax ( ) ; }
public void fastJSON2ArraySeThroughput ( Blackhole bh ) { bh . consume ( com . alibaba . fastjson2 . JSON . toJSONString ( objList , JSONWriter . Feature . ReferenceDetection ) ) ; }
public synchronized void addEventListener ( ActivitiEventListener listenerToAdd ) { if ( listenerToAdd == null ) { throw new ActivitiIllegalArgumentException ( "Listener cannot be null." ) ; } if ( ! eventListeners . contains ( listenerToAdd ) ) { eventListeners . add ( listenerToAdd ) ; } }
public List < Variant > getVariants ( ) { List < Variant > superVariants = super . getVariants ( ) ; if ( superVariants == null ) { return null ; } List < Variant > variants = new LinkedList < > ( superVariants ) ; Form f = getRequest ( ) . getResourceRef ( ) . getQueryAsForm ( ) ; String format = f . getFirstValue ( "format" ) ; if ( "textedit" . equals ( format ) ) { if ( variants . isEmpty ( ) ) { try { File file = new File ( new URI ( getTargetUri ( ) ) ) ; if ( getEnhDirectory ( ) . allowsEdit ( file ) ) { file . createNewFile ( ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } superVariants = super . getVariants ( ) ; if ( superVariants == null ) { return null ; } variants = new LinkedList < > ( superVariants ) ; } ListIterator < Variant > iter = variants . listIterator ( ) ; while ( iter . hasNext ( ) ) { Variant v = iter . next ( ) ; if ( v instanceof FileRepresentation ) { File file = ( ( FileRepresentation ) v ) . getFile ( ) ; if ( getEnhDirectory ( ) . allowsEdit ( file ) ) { iter . remove ( ) ; v . setCharacterSet ( CharacterSet . UTF_8 ) ; iter . add ( new EditRepresentation ( ( FileRepresentation ) v , this ) ) ; } ; } } } else if ( "paged" . equals ( format ) ) { ListIterator < Variant > iter = variants . listIterator ( ) ; while ( iter . hasNext ( ) ) { Variant v = iter . next ( ) ; if ( v instanceof FileRepresentation ) { File file = ( ( FileRepresentation ) v ) . getFile ( ) ; if ( getEnhDirectory ( ) . allowsPaging ( file ) ) { iter . remove ( ) ; iter . add ( new PagedRepresentation ( ( FileRepresentation ) v , this , f . getFirstValue ( "pos" ) , f . getFirstValue ( "lines" ) , f . getFirstValue ( "reverse" ) ) ) ; } ; } } } else { ListIterator < Variant > iter = variants . listIterator ( ) ; while ( iter . hasNext ( ) ) { Variant v = iter . next ( ) ; v . setCharacterSet ( CharacterSet . UTF_8 ) ; } } return variants ; }
public int execute ( ) { try { SecurityUtils . reloginExpiringKeytabUser ( ) ; AtlasReplInfo atlasReplInfo = createAtlasReplInfo ( ) ; LOG . info ( "Dumping Atlas metadata of srcDb: {}, for TgtDb: {} to staging location: {}" , atlasReplInfo . getSrcDB ( ) , atlasReplInfo . getTgtDB ( ) , atlasReplInfo . getStagingDir ( ) ) ; AtlasDumpLogger replLogger = new AtlasDumpLogger ( atlasReplInfo . getSrcDB ( ) , atlasReplInfo . getStagingDir ( ) . toString ( ) ) ; replLogger . startLog ( ) ; Map < String , Long > metricMap = new HashMap < > ( ) ; metricMap . put ( ReplUtils . MetricName . ENTITIES . name ( ) , 0L ) ; work . getMetricCollector ( ) . reportStageStart ( getName ( ) , metricMap ) ; atlasRestClient = new AtlasRestClientBuilder ( atlasReplInfo . getAtlasEndpoint ( ) ) . getClient ( atlasReplInfo . getConf ( ) ) ; AtlasRequestBuilder atlasRequestBuilder = new AtlasRequestBuilder ( ) ; String entityGuid = checkHiveEntityGuid ( atlasRequestBuilder , atlasReplInfo . getSrcCluster ( ) , atlasReplInfo . getSrcDB ( ) ) ; long numBytesWritten = dumpAtlasMetaData ( atlasRequestBuilder , atlasReplInfo ) ; LOG . debug ( "Finished dumping atlas metadata, total:{} bytes written" , numBytesWritten ) ; long currentModifiedTime = getCurrentTimestamp ( atlasReplInfo , entityGuid ) ; createDumpMetadata ( atlasReplInfo , currentModifiedTime ) ; replLogger . endLog ( 0L ) ; work . getMetricCollector ( ) . reportStageEnd ( getName ( ) , Status . SUCCESS ) ; return 0 ; } catch ( RuntimeException e ) { LOG . error ( "RuntimeException while dumping atlas metadata" , e ) ; setException ( e ) ; try { ReplUtils . handleException ( true , e , work . getStagingDir ( ) . getParent ( ) . toString ( ) , work . getMetricCollector ( ) , getName ( ) , conf ) ; } catch ( Exception ex ) { LOG . error ( "Failed to collect replication metrics: " , ex ) ; } throw e ; } catch ( Exception e ) { LOG . error ( "Exception while dumping atlas metadata" , e ) ; setException ( e ) ; int errorCode = ErrorMsg . getErrorMsg ( e . getMessage ( ) ) . getErrorCode ( ) ; try { return ReplUtils . handleException ( true , e , work . getStagingDir ( ) . getParent ( ) . toString ( ) , work . getMetricCollector ( ) , getName ( ) , conf ) ; } catch ( Exception ex ) { LOG . error ( "Failed to collect replication metrics: " , ex ) ; return errorCode ; } } }
public InputStream getRaw ( @ NonNull String resName ) { InputStream stream = InternalAccessor . getRaw ( resName ) ; if ( saveToResourcesHolder ) holder . put ( resName , stream ) ; return stream ; }
public void startLoading ( final boolean forceLoad ) { super . startLoading ( forceLoad ) ; if ( debounceSaver != null ) { disposables . add ( debounceSaver . getDebouncedSaver ( ) ) ; debounceSaver . setNoChangesToSave ( ) ; } isLoadingComplete . set ( false ) ; getMergedOrderedPlaylists ( localPlaylistManager , remotePlaylistManager ) . onBackpressureLatest ( ) . observeOn ( AndroidSchedulers . mainThread ( ) ) . subscribe ( getPlaylistsSubscriber ( ) ) ; }
public final Mono < Void > rollback ( ReactiveTransaction transaction ) { if ( transaction . isCompleted ( ) ) { return Mono . error ( new IllegalTransactionStateException ( "Transaction is already completed - do not call commit or rollback more than once per transaction" ) ) ; } return TransactionSynchronizationManager . forCurrentTransaction ( ) . flatMap ( synchronizationManager -> { GenericReactiveTransaction reactiveTx = ( GenericReactiveTransaction ) transaction ; return processRollback ( synchronizationManager , reactiveTx ) ; } ) ; }
public final void lazySet ( T obj , V newValue ) { accessCheck ( obj ) ; valueCheck ( newValue ) ; U . putOrderedObject ( obj , offset , newValue ) ; }
public void destroy ( ) { for ( EntryHolder holder : _holders ) { holder . destroy ( ) ; } _view = null ; }
public String getSigAlgName ( ) { return cert . getSigAlgName ( ) ; }
public int getBackupsVersionCount ( ) { return _prefs . getInt ( "pref_backups_versions" , 5 ) ; }
private static Key [ ] [ ] sortKeysGrouped ( final List < Key > inKeys , final int maxPageCount ) { final ArrayList < Key > keys = new ArrayList < > ( inKeys ) ; Collections . sort ( keys , EMOJI_KEY_COMPARATOR ) ; final int pageCount = ( keys . size ( ) - 1 ) / maxPageCount + 1 ; final Key [ ] [ ] retval = new Key [ pageCount ] [ maxPageCount ] ; for ( int i = 0 ; i < keys . size ( ) ; ++ i ) { retval [ i / maxPageCount ] [ i % maxPageCount ] = keys . get ( i ) ; } return retval ; }
void loadNames ( ICUResourceBundle zoneStrings , String key ) { assert zoneStrings != null ; assert key != null ; assert key . length ( ) > 0 ; names = null ; try { zoneStrings . getAllItemsWithFallback ( key , this ) ; } catch ( MissingResourceException e ) { } }
private EhcacheLogMinerCache < String , String > createSchemaChangesCache ( EhcacheEvictionListener evictionListener ) { return new EhcacheLogMinerCache < > ( getCache ( SCHEMA_CHANGES_CACHE_NAME , String . class , String . class , evictionListener ) , SCHEMA_CHANGES_CACHE_NAME , evictionListener ) ; }
public static < E > E getObject ( Supplier < Log > supplier , List < E > list ) { if ( CollectionUtils . isNotEmpty ( list ) ) { int size = list . size ( ) ; if ( size > 1 ) { Log log = supplier . get ( ) ; log . warn ( String . format ( "Warn: execute Method There are  %s results." , size ) ) ; } return list . get ( 0 ) ; } return null ; }
public ValidErrorHandler getValidErrorHandler ( ) { return handler ; }
String render ( ) { return " " + sql + " " ; }
private Future < String > kubernetesBuildWaitForFinish ( Reconciliation reconciliation , String namespace , KafkaConnectBuild connectBuild ) { String buildPodName = KafkaConnectResources . buildPodName ( connectBuild . getCluster ( ) ) ; String containerName = KafkaConnectBuildUtils . getBuildContainerName ( connectBuild . getCluster ( ) , pfa . isOpenshift ( ) ) ; return podOperator . waitFor ( reconciliation , namespace , buildPodName , "complete" , 1_000 , connectBuildTimeoutMs , ( ignore1 , ignore2 ) -> kubernetesBuildPodFinished ( namespace , buildPodName , containerName ) ) . compose ( ignore -> podOperator . getAsync ( namespace , buildPodName ) ) . compose ( pod -> { if ( KafkaConnectBuildUtils . buildPodSucceeded ( pod , containerName ) ) { ContainerStateTerminated state = KafkaConnectBuildUtils . getConnectBuildContainerStateTerminated ( pod , containerName ) ; String image = state . getMessage ( ) . trim ( ) ; LOGGER . infoCr ( reconciliation , "Build completed successfully. New image is {}." , image ) ; return Future . succeededFuture ( image ) ; } else if ( KafkaConnectBuildUtils . buildPodFailed ( pod , buildPodName ) ) { ContainerStateTerminated state = KafkaConnectBuildUtils . getConnectBuildContainerStateTerminated ( pod , containerName ) ; LOGGER . warnCr ( reconciliation , "Build failed with code {}: {}" , state . getExitCode ( ) , state . getMessage ( ) ) ; } else { LOGGER . warnCr ( reconciliation , "Build failed - no container with name {}" , containerName ) ; } return Future . failedFuture ( "The Kafka Connect build failed" ) ; } ) ; }
public void setForceHideDot ( boolean forceHideDot ) { if ( mForceHideDot == forceHideDot ) { return ; } mForceHideDot = forceHideDot ; if ( forceHideDot ) { invalidate ( ) ; } else if ( hasDot ( ) ) { animateDotScale ( 0 , 1 ) ; } }
public String [ ] getExtensions ( ) { return new String [ ] { this . getIdentifier ( ) } ; }
public NDArray mod ( Number n ) { return getAlternativeArray ( ) . mod ( n ) ; }
public Fragment getItem ( final int position ) { final Tab tab = internalTabsList . get ( position ) ; final Fragment fragment ; try { fragment = tab . getFragment ( context ) ; } catch ( final Throwable t ) { return new BlankFragment ( new ErrorInfo ( t , UserAction . GETTING_MAIN_SCREEN_TAB , "Tab " + tab . getClass ( ) . getSimpleName ( ) + ":" + tab . getTabName ( context ) ) ) ; } if ( fragment instanceof BaseFragment ) { ( ( BaseFragment ) fragment ) . useAsFrontPage ( true ) ; } if ( fragment instanceof LocalPlaylistFragment ) { localPlaylistFragments . add ( ( LocalPlaylistFragment ) fragment ) ; } return fragment ; }
public PrettierStyle rpcReceive ( PrettierStyle before , RpcReceiveQueue q ) { return before . withId ( q . receiveAndGet ( before . getId ( ) , UUID :: fromString ) ) . withConfig ( q . receive ( before . getConfig ( ) ) ) . withPrettierVersion ( q . receive ( before . getPrettierVersion ( ) ) ) . withIgnored ( q . receive ( before . isIgnored ( ) ) ) ; }
public static boolean isFullUrl ( String uri ) { return uri != null && uri . matches ( schemeRegex ) ; }
private void addToCache ( GlyphLayout layout , float x , float y ) { int runCount = layout . runs . size ; if ( runCount == 0 ) return ; if ( pageVertices . length < font . regions . size ) setPageCount ( font . regions . size ) ; layouts . add ( layout ) ; requireGlyphs ( layout ) ; IntArray colors = layout . colors ; int colorsIndex = 0 , nextColorGlyphIndex = 0 , glyphIndex = 0 ; float lastColorFloatBits = 0 ; for ( int i = 0 ; i < runCount ; i ++ ) { GlyphRun run = layout . runs . get ( i ) ; Object [ ] glyphs = run . glyphs . items ; float [ ] xAdvances = run . xAdvances . items ; float gx = x + run . x , gy = y + run . y ; for ( int ii = 0 , nn = run . glyphs . size ; ii < nn ; ii ++ ) { if ( glyphIndex ++ == nextColorGlyphIndex ) { lastColorFloatBits = NumberUtils . intToFloatColor ( colors . get ( ++ colorsIndex ) ) ; nextColorGlyphIndex = ++ colorsIndex < colors . size ? colors . get ( colorsIndex ) : - 1 ; } gx += xAdvances [ ii ] ; addGlyph ( ( Glyph ) glyphs [ ii ] , gx , gy , lastColorFloatBits ) ; } } currentTint = Color . WHITE_FLOAT_BITS ; }
static Stream < Path > listSegmentPaths ( Path path ) throws IOException { return listFiles ( path , ".log" ) ; }
public void indent ( ) { this . indentationCount ++ ; }
public String getTriggerDescription ( ) { if ( getBranches ( ) != null ) return MessageFormat . format ( _T ( "pull request to branches \"{0}\" is discarded" ) , getBranches ( ) ) ; else return _T ( "pull request to any branch is discarded" ) ; }
public JavaType getValueType ( ) { return _containerType ; }
public void protobuf ( Blackhole bh ) throws Exception { bh . consume ( MediaContentTransform . forward ( mc ) . toByteArray ( ) ) ; }
public static < V > ObjectIntMapping < V > newObjectIntMapping ( boolean concurrent ) { return concurrent ? new ConcurrentObjectIntMapping < > ( ) : new SingleThreadObjectIntMapping < > ( ) ; }
public void bindData ( NovelDetail . NovelChapterBean target , ViewHolder < FragmentSingleNovelBinding > bindView , int position ) { String chapterContent = target . getChapterContent ( ) ; if ( position == 0 ) { bindView . baseBind . head . setVisibility ( View . VISIBLE ) ; } else { bindView . baseBind . head . setVisibility ( View . GONE ) ; } bindView . baseBind . chapter . setText ( target . getChapterName ( ) ) ; if ( position == allItems . size ( ) - 1 ) { bindView . baseBind . bottom . setVisibility ( View . VISIBLE ) ; bindView . baseBind . endText . setVisibility ( View . VISIBLE ) ; } else { bindView . baseBind . bottom . setVisibility ( View . GONE ) ; bindView . baseBind . endText . setVisibility ( View . GONE ) ; } bindView . baseBind . partIndex . setVisibility ( View . GONE ) ; bindView . baseBind . novelDetail . setText ( chapterContent ) ; bindView . baseBind . novelDetail . setTextSize ( textSize ) ; bindView . baseBind . chapter . setTextSize ( textSize ) ; bindView . baseBind . endText . setTextSize ( textSize ) ; bindView . baseBind . chapter . setTextColor ( textColor ) ; bindView . baseBind . novelDetail . setTextColor ( textColor ) ; bindView . baseBind . endText . setTextColor ( textColor ) ; }
public Object convert ( String value ) { return null ; }
public boolean isDisplayInTopology ( int displayId ) { return mDisplayTopology != null && mDisplayTopology . findDisplay ( displayId , mDisplayTopology . getRoot ( ) ) != null ; }
protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { ensureToolbar ( ) ; super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; final int mode = MeasureSpec . getMode ( heightMeasureSpec ) ; final int topInset = lastInsets != null ? lastInsets . getSystemWindowInsetTop ( ) : 0 ; if ( ( mode == MeasureSpec . UNSPECIFIED || forceApplySystemWindowInsetTop ) && topInset > 0 ) { topInsetApplied = topInset ; int newHeight = getMeasuredHeight ( ) + topInset ; heightMeasureSpec = MeasureSpec . makeMeasureSpec ( newHeight , MeasureSpec . EXACTLY ) ; super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } updateTitleFromToolbarIfNeeded ( ) ; if ( collapsingTitleEnabled && ! TextUtils . isEmpty ( collapsingTitleHelper . getText ( ) ) ) { final int originalHeight = getMeasuredHeight ( ) ; updateTextBounds ( 0 , 0 , getMeasuredWidth ( ) , originalHeight , true ) ; int expectedHeight = ( int ) ( topInsetApplied + expandedMarginTop + collapsingTitleHelper . getExpandedTextFullSingleLineHeight ( ) + ( TextUtils . isEmpty ( collapsingSubtitleHelper . getText ( ) ) ? 0 : expandedTitleSpacing + collapsingSubtitleHelper . getExpandedTextFullSingleLineHeight ( ) ) + expandedMarginBottom ) ; if ( expectedHeight > originalHeight ) { extraHeightForTitles = expectedHeight - originalHeight ; } else { extraHeightForTitles = 0 ; } if ( extraMultilineHeightEnabled ) { if ( collapsingTitleHelper . getExpandedMaxLines ( ) > 1 ) { int lineCount = collapsingTitleHelper . getExpandedLineCount ( ) ; if ( lineCount > 1 ) { int expandedTextHeight = Math . round ( collapsingTitleHelper . getExpandedTextFullSingleLineHeight ( ) ) ; extraMultilineTitleHeight = expandedTextHeight * ( lineCount - 1 ) ; } else { extraMultilineTitleHeight = 0 ; } } if ( collapsingSubtitleHelper . getExpandedMaxLines ( ) > 1 ) { int lineCount = collapsingSubtitleHelper . getExpandedLineCount ( ) ; if ( lineCount > 1 ) { int expandedTextHeight = Math . round ( collapsingSubtitleHelper . getExpandedTextFullSingleLineHeight ( ) ) ; extraMultilineSubtitleHeight = expandedTextHeight * ( lineCount - 1 ) ; } else { extraMultilineSubtitleHeight = 0 ; } } } if ( extraHeightForTitles + extraMultilineTitleHeight + extraMultilineSubtitleHeight > 0 ) { heightMeasureSpec = MeasureSpec . makeMeasureSpec ( originalHeight + extraHeightForTitles + extraMultilineTitleHeight + extraMultilineSubtitleHeight , MeasureSpec . EXACTLY ) ; super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; } } if ( toolbar != null ) { if ( toolbarDirectChild == null || toolbarDirectChild == this ) { setMinimumHeight ( getHeightWithMargins ( toolbar ) ) ; } else { setMinimumHeight ( getHeightWithMargins ( toolbarDirectChild ) ) ; } } if ( extraMultilineHeightEnabled && collapsingTitleHelper . getExpandedMaxLines ( ) > 1 && collapsingTitleHelper . getExpansionFraction ( ) == 1f ) { maybeSetPendingActionCollapsed ( ) ; } }
public String getMessage ( ) { if ( serviceId != null ) { return "Client '" + serviceId + "': " + super . getMessage ( ) ; } return super . getMessage ( ) ; }
public ConfigErrors errors ( ) { return configErrors ; }
public void setExcludeOnHttpCodes ( List < Integer > onHttpCodes ) { this . excludeOnHttpCodes = onHttpCodes ; }
public void setListener ( ButtonViewClickListener mListener ) { this . mListener = mListener ; }
protected void onImageUpdated ( ImageReceiver imageReceiver ) { final Bitmap b = imageReceiver . getBitmap ( ) ; final int padding = ( b != null && imageReceiver . hasImageLoaded ( ) || imageReceiver . hasBitmapImage ( ) ) ? AndroidUtilities . dp ( 64 ) : 0 ; setCustomPaddingRight ( padding , true ) ; if ( blurredView . getTag ( ) != null ) { bigAlbumConver . setImageBitmap ( b ) ; } }
public void checkServerTrusted ( X509Certificate [ ] certs , String authType ) { }
public String getCallNameForReport ( ) { String append = loopIndex == - 1 ? "" : "[" + loopIndex + "] " ; return append + displayName ; }
public static String toKebabCase ( CharSequence str ) { return toSymbolCase ( str , CharUtil . DASHED ) ; }
@ Nullable public AnimatableFloatValue getDashOffset ( ) { return dashOffset ; }
public List < IcebergPartitionSummary > partitions ( ) { return partitions ; }
private static void setReplacement ( int id , Object replacement , XResources res ) { String resDir = ( res != null ) ? res . mResDir : null ; if ( res == null ) { try { XposedInit . hookResources ( ) ; } catch ( Throwable throwable ) { throw new IllegalStateException ( "Failed to initialize resources hook" ) ; } } if ( id == 0 ) throw new IllegalArgumentException ( "id 0 is not an allowed resource identifier" ) ; else if ( resDir == null && id >= 0x7f000000 ) throw new IllegalArgumentException ( "ids >= 0x7f000000 are app specific and cannot be set for the framework" ) ; if ( replacement instanceof Drawable ) throw new IllegalArgumentException ( "Drawable replacements are deprecated since Xposed 2.1. Use DrawableLoader instead." ) ; if ( id < 0x7f000000 ) { int cacheKey = ( id & 0x00070000 ) > > 11 | ( id & 0xf8 ) > > 3 ; synchronized ( sSystemReplacementsCache ) { sSystemReplacementsCache [ cacheKey ] |= 1 << ( id & 7 ) ; } } else { int cacheKey = ( id & 0x00070000 ) > > 12 | ( id & 0x78 ) > > 3 ; synchronized ( res . mReplacementsCache ) { res . mReplacementsCache [ cacheKey ] |= 1 << ( id & 7 ) ; } } synchronized ( sReplacements ) { HashMap < String , Object > inner = sReplacements . get ( id ) ; if ( inner == null ) { inner = new HashMap < > ( ) ; sReplacements . put ( id , inner ) ; } inner . put ( resDir , replacement ) ; } }
public int bufferSizeLimitBytes ( ) { return bufferSizeLimitBytes ; }
public SetArgs pxAt ( long timestamp ) { this . pxAt = timestamp ; return this ; }
AllEdgesIterator getAllEdges ( ) ; EdgeExplorer createEdgeExplorer ( EdgeFilter filter ) ; default EdgeExplorer createEdgeExplorer ( ) { return createEdgeExplorer ( EdgeFilter . ALL_EDGES ) ; }
public void setIsLand ( int IsLand ) { this . mIsLand = IsLand ; }
public void onAttach ( Context context ) { super . onAttach ( context ) ; ctx = context ; }
private Bitmap convertOutputBufferToBitmap ( ByteBuffer outImgData ) { if ( outImgData == null ) { return null ; } outImgData . rewind ( ) ; Bitmap bitmap_out = Bitmap . createBitmap ( desiredSize , desiredSize , Bitmap . Config . ARGB_8888 ) ; int [ ] pixels = new int [ desiredSize * desiredSize ] ; for ( int i = 0 ; i < desiredSize * desiredSize ; i ++ ) { float val = outImgData . getFloat ( ) ; if ( val > 0.2 ) { pixels [ i ] = 0xFFFFFFFF ; } else { pixels [ i ] = 0xFF000000 ; } } bitmap_out . setPixels ( pixels , 0 , desiredSize , 0 , 0 , desiredSize , desiredSize ) ; return bitmap_out ; }
public static String toExportString ( Object o , char escapeChar ) { if ( o == null ) { return null ; } else if ( o instanceof java . sql . Date ) { return DateFormatFactory . get ( ) . getDateFormat ( ) . format ( ( Date ) o ) ; } else if ( o instanceof java . sql . Timestamp ) { return DateFormatFactory . get ( ) . getDateTimeFormat ( ) . format ( ( Date ) o ) ; } else if ( o instanceof java . sql . Time ) { return DateFormatFactory . get ( ) . getTimeFormat ( ) . format ( ( Date ) o ) ; } else if ( o instanceof String ) { if ( escapeChar == '"' ) { return Escape . addExcelQuote ( ( String ) o ) ; } else { return Escape . addEscAndQuote ( ( String ) o , escapeChar ) ; } } else if ( o instanceof Sequence ) { return JSONUtil . toJSON ( ( Sequence ) o ) ; } else if ( o instanceof byte [ ] ) { return new String ( ( byte [ ] ) o ) ; } else if ( o instanceof BaseRecord ) { return JSONUtil . toJSON ( ( BaseRecord ) o ) ; } else { return o . toString ( ) ; } }
public void setMarkerInCenter ( boolean markerInCenter ) { this . mMarkerInCenter = markerInCenter ; initTimeline ( ) ; }
protected boolean isVerticalVideo ( ) { boolean isVertical = false ; int videoHeight = getCurrentVideoHeight ( ) ; int videoWidth = getCurrentVideoWidth ( ) ; Debuger . printfLog ( "GSYVideoBase isVerticalVideo  videoHeight " + videoHeight + " videoWidth " + videoWidth ) ; Debuger . printfLog ( "GSYVideoBase isVerticalVideo  mRotate " + mRotate ) ; if ( videoHeight > 0 && videoWidth > 0 ) { if ( mRotate == 90 || mRotate == 270 ) { isVertical = videoWidth > videoHeight ; } else { isVertical = videoHeight > videoWidth ; } } return isVertical ; }
public boolean hasData ( String key ) { return data . containsKey ( key ) ; }
public Array [ ] getArrays ( ) { return arrays ; }
private ApkGenerationConfiguration . Builder getCommonSplitApkGenerationConfiguration ( AppBundle appBundle ) { BundleConfig bundleConfig = appBundle . getBundleConfig ( ) ; Version bundleToolVersion = Version . of ( bundleConfig . getBundletool ( ) . getVersion ( ) ) ; ApkGenerationConfiguration . Builder apkGenerationConfiguration = ApkGenerationConfiguration . builder ( ) . setOptimizationDimensions ( apkOptimizations . getSplitDimensions ( ) ) ; apkGenerationConfiguration . setEnableUncompressedNativeLibraries ( apkOptimizations . getUncompressNativeLibraries ( ) ) ; setEnableUncompressedDexOptimization ( appBundle , apkGenerationConfiguration ) ; boolean injectMinSdk = command . getInjectMinSdk ( ) || apkOptimizations . getInjectMinSdk ( ) ; apkGenerationConfiguration . setInjectMinSdk ( injectMinSdk ) ; apkGenerationConfiguration . setEnableSparseEncodingVariant ( injectMinSdk && ( command . getEnableSparseEncoding ( ) || apkOptimizations . getEnableSparseEncoding ( ) ) ) ; apkGenerationConfiguration . setInstallableOnExternalStorage ( appBundle . getBaseModule ( ) . getAndroidManifest ( ) . getInstallLocationValue ( ) . map ( installLocation -> installLocation . equals ( "auto" ) || installLocation . equals ( "preferExternal" ) ) . orElse ( false ) ) ; apkGenerationConfiguration . setMasterPinnedResourceIds ( bundleConfig . getMasterResources ( ) . getResourceIdsList ( ) . stream ( ) . map ( ResourceId :: create ) . collect ( toImmutableSet ( ) ) ) ; apkGenerationConfiguration . setMasterPinnedResourceNames ( ImmutableSet . copyOf ( bundleConfig . getMasterResources ( ) . getResourceNamesList ( ) ) ) ; apkGenerationConfiguration . setSuffixStrippings ( apkOptimizations . getSuffixStrippings ( ) ) ; apkGenerationConfiguration . setEnableBaseModuleMinSdkAsDefaultTargeting ( command . getEnableBaseModuleMinSdkAsDefaultTargeting ( ) ) ; command . getMinSdkForAdditionalVariantWithV3Rotation ( ) . ifPresent ( apkGenerationConfiguration :: setMinSdkForAdditionalVariantWithV3Rotation ) ; return apkGenerationConfiguration ; }
public void careplanEnd ( long time , String type , Code reason ) { if ( present . containsKey ( type ) ) { CarePlan careplan = ( CarePlan ) present . get ( type ) ; careplan . stop = time ; careplan . stopReason = reason ; present . remove ( type ) ; } }
static < T > Optional < Equivalence . Wrapper < T > > wrapOptionalInEquivalence ( Equivalence < T > equivalence , Optional < T > optional ) { return optional . map ( equivalence :: wrap ) ; }
public < X0 , X1 > Septet < A , B , C , D , E , X0 , X1 > addAt5 ( final X0 value0 , final X1 value1 ) { return new Septet < A , B , C , D , E , X0 , X1 > ( this . val0 , this . val1 , this . val2 , this . val3 , this . val4 , value0 , value1 ) ; }
static public String serialiseObject ( Object obj , Class < ? > objclass ) throws JAXBException { JAXBContext jaxbContext = getJAXBContext ( objclass ) ; Marshaller m = jaxbContext . createMarshaller ( ) ; StringWriter w = new StringWriter ( ) ; m . marshal ( obj , w ) ; String xmlString = w . toString ( ) ; return xmlString ; }
public short getRaw ( long i ) { return RAW . getShort ( base + checkIndex ( i , size ) * VALUE_BYTES ) ; }
public void sendExecuteFetchScroll ( Transport . Connection connection , final ShardFetchRequest request , SearchTask task , final SearchActionListener < FetchSearchResult > listener ) { sendExecuteFetch ( connection , FETCH_ID_SCROLL_ACTION_NAME , request , task , listener ) ; }
private static ZoneId extractZoneId ( byte [ ] bytes ) { int regionCode = ( bytes [ 11 ] & 0b1111111 ) << 6 ; regionCode += ( bytes [ 12 ] & 0b11111100 ) > > 2 ; String regionName = getRegion ( regionCode ) ; return ZoneId . of ( regionName ) ; }
public InstanceSegmentationTranslator build ( ) { validate ( ) ; ResizeShort resize = new ResizeShort ( shortEdge , maxEdge , Image . Interpolation . BILINEAR ) ; pipeline . insert ( 0 , null , resize ) ; return new InstanceSegmentationTranslator ( this ) ; }
public LuminanceSource rotateCounterClockwise45 ( ) { throw new UnsupportedOperationException ( "This luminance source does not support rotation by 45 degrees." ) ; }
protected @ IdRes int getSearchMenuId ( ) { return 0 ; }
public static void checkXposed ( Preference pref ) { if ( pref == null ) { return ; } checkBoxPreference = ( CheckBoxPreference ) pref ; Log . i ( Api . TAG , "Checking Xposed:" + G . isXposedEnabled ( ) + "" ) ; checkBoxPreference . setEnabled ( G . isXposedEnabled ( ) ) ; }
public String getRouteVersion ( ) { return getRouteVersion ( null ) ; }
public void destroy ( ) { setBlurAutoUpdate ( false ) ; blurAlgorithm . destroy ( ) ; initialized = false ; }
public float getBorderWidthDp ( ) { return pxToDp ( getBorderWidth ( ) ) ; }
public Criteria andBillTypeNotEqualTo ( String value ) { addCriterion ( "bill_type <>" , value , "billType" ) ; return ( Criteria ) this ; }
public void takeModules ( String capture ) throws IOException { final String SEP = "::" ; int o = 0 , i ; while ( o < capture . length ( ) && ( i = capture . indexOf ( SEP , o ) ) != - 1 ) { String module = capture . substring ( o , i ) ; offerSymbol ( module , o , false ) ; offer ( SEP ) ; o = i + 2 ; } if ( o < capture . length ( ) ) { String module = capture . substring ( o ) ; offerSymbol ( module , o , false ) ; } }
public String getPluginName ( ) { return "IdentityMap" ; }
protected URIBuilder setQueryNVP ( List < NameValuePair > nvp ) throws URISyntaxException { StringBuilder sb = new StringBuilder ( ) ; String path = base . getRawPath ( ) ; if ( path != null ) sb . append ( path ) ; sb . append ( '?' ) ; sb . append ( format ( nvp , isUrlEncodingEnabled , enc ) ) ; String frag = base . getRawFragment ( ) ; if ( frag != null ) sb . append ( '#' ) . append ( frag ) ; this . base = base . resolve ( sb . toString ( ) ) ; return this ; }
XpUpdateResult updateSkill ( Skill skill , long currentXp , int goalStartXp , int goalEndXp ) { XpStateSingle state = xpSkills . get ( skill ) ; if ( state == null || state . getStartXp ( ) == - 1 ) { assert currentXp >= 0 ; initializeSkill ( skill , currentXp ) ; return XpUpdateResult . INITIALIZED ; } else { long startXp = state . getStartXp ( ) ; int gainedXp = state . getTotalXpGained ( ) ; if ( startXp + gainedXp > currentXp ) { initializeSkill ( skill , currentXp ) ; return XpUpdateResult . INITIALIZED ; } else { if ( ! state . update ( currentXp ) ) { return XpUpdateResult . NO_CHANGE ; } state . updateGoals ( currentXp , goalStartXp , goalEndXp ) ; updateOrder ( skill ) ; return XpUpdateResult . UPDATED ; } } }
public int compareTo ( @ NonNull Result that ) { if ( this == that ) return 0 ; int result ; int minLength = Math . min ( this . codePoints . length , that . codePoints . length ) ; for ( int i = 0 ; i < minLength ; i += 1 ) { if ( ( result = Character . toLowerCase ( this . codePoints [ i ] ) - Character . toLowerCase ( that . codePoints [ i ] ) ) != 0 ) return result ; } if ( this . codePoints . length != that . codePoints . length ) return this . codePoints . length - that . codePoints . length ; return 0 ; }
public void onPackageLoaded ( ) { initHook ( FlashLightNotificationColor . INSTANCE , mPrefsMap . getBoolean ( "system_ui_control_center_opt_notification_element_background_color" ) ) ; }
public Boolean getFlag ( ) { return flag ; }
public Stream < String > tabComplete ( String label , IArgConsumer args ) throws CommandException { TabCompleteHelper helper = new TabCompleteHelper ( ) ; if ( args . hasExactlyOne ( ) ) { helper . append ( "reset" , "repack" , "supported" ) ; } return helper . filterPrefix ( args . getString ( ) ) . stream ( ) ; }
private Bitmap getVideoThumbToCache ( String path ) { return lruCache . get ( path ) ; }
public void read ( Json json , JsonValue jsonData ) { alphaValue = json . readValue ( "alpha" , ScaledNumericValue . class , jsonData ) ; colorValue = json . readValue ( "color" , GradientColorValue . class , jsonData ) ; }
public boolean awaitShutdown ( long timeout , @ Nonnull TimeUnit unit ) throws InterruptedException { timeout = unit . toMillis ( timeout ) ; long deadline = timeout == 0 ? Long . MAX_VALUE : System . currentTimeMillis ( ) + timeout ; MiscUtil . tryLock ( statusLock ) ; try { Status current = getStatus ( ) ; while ( current != Status . SHUTDOWN ) { if ( ! statusCondition . await ( deadline - System . currentTimeMillis ( ) , TimeUnit . MILLISECONDS ) ) { return false ; } current = getStatus ( ) ; } return true ; } finally { statusLock . unlock ( ) ; } }
public void setColorScheme ( ColorScheme colorScheme ) { weekAdapter . setColorScheme ( colorScheme ) ; calendarAdapter . colorScheme ( colorScheme ) ; }
protected Expression serializeForOptional ( Expression ordinal , Expression inputObject , Expression writer , String getMethod , TypeRef < ? > wrapType ) { Class < ? > primType = TypeUtils . unwrap ( wrapType . getRawType ( ) ) ; If value = new If ( new Expression . LogicalAnd ( true , new Expression . Not ( new Expression . IsNull ( inputObject ) ) , Invoke . inlineInvoke ( inputObject , "isPresent" , TypeUtils . PRIMITIVE_BOOLEAN_TYPE ) ) , new Invoke ( inputObject , getMethod , TypeRef . of ( primType ) ) , new Expression . Null ( wrapType ) , true , wrapType ) ; return setValueOrNull ( writer , ordinal , value , value ) ; }
public NDArray argMax ( ) { return getAlternativeArray ( ) . argMax ( ) ; }
void onDetachSegments ( final long correlationId , final long recordingId , final long newStartPosition ) { attemptToActivate ( ) ; if ( State . ACTIVE == state ) { conductor . detachSegments ( correlationId , recordingId , newStartPosition , this ) ; } }
public static void info ( @ Nullable Throwable throwable , @ Nullable String message , Object ... args ) { log ( LogLevel . INFO , throwable , message , args ) ; }
static List < KeyValueMarshaler > createRepeated ( Attributes attributes ) { if ( attributes . isEmpty ( ) ) { return new ArrayList < > ( ) ; } List < KeyValueMarshaler > marshalers = new ArrayList < > ( attributes . size ( ) ) ; attributes . forEach ( ( attributeKey , o ) -> marshalers . add ( create ( attributeKey , o ) ) ) ; return marshalers ; }
static void resetLoaded ( ) { loaded . set ( false ) ; }
public boolean isTupleType ( ) { return false ; }
public GenericDraweeHierarchyBuilder setProgressBarImageScaleType ( @ Nullable ScalingUtils . ScaleType progressBarImageScaleType ) { mProgressBarImageScaleType = progressBarImageScaleType ; return this ; }
public TypeInfo getType ( ) { return TypeInfo . TYPE_NULL ; }
public static MapAccessor of ( Map < Object , Object > map ) { if ( map == null ) { throw new IllegalArgumentException ( "map is null" ) ; } return new MapAccessor ( map ) ; }
private final Field < ? > groupConcatEmulation ( Context < ? > ctx ) { Field < ? > arg1 = arguments . get ( 0 ) ; if ( ! arg1 . getDataType ( ) . isBoolean ( ) && ! arg1 . getDataType ( ) . isNumeric ( ) && ! arg1 . getDataType ( ) . isJSON ( ) ) { switch ( ctx . family ( ) ) { case MARIADB : case MYSQL : arg1 = function ( N_JSON_QUOTE , getDataType ( ) , castIfNeeded ( arg1 , String . class ) ) ; break ; } } if ( onNull == NULL_ON_NULL ) { switch ( ctx . family ( ) ) { case MARIADB : case MYSQL : arg1 = DSL . coalesce ( arg1 , inline ( "null" ) ) ; break ; } } Field < ? > arg2 = arg1 ; return DSL . concat ( inline ( '[' ) , CustomField . of ( N_GROUP_CONCAT , VARCHAR , c1 -> { c1 . visit ( groupConcatEmulationWithoutArrayWrappers ( distinct , CustomField . of ( Names . N_FIELD , VARCHAR , c2 -> acceptArguments2 ( c2 , QueryPartListView . wrap ( arg2 ) ) ) , withinGroupOrderBy ) ) ; acceptFilterClause ( ctx ) ; acceptOverClause ( c1 ) ; } ) , inline ( ']' ) ) ; }
default Children setIncrBy ( R column , Number val ) { return setIncrBy ( true , column , val ) ; }
public Criteria andDepositIn ( List < BigDecimal > values ) { addCriterion ( "deposit in" , values , "deposit" ) ; return ( Criteria ) this ; }
public void observeOnMaybe ( Blackhole bh ) { observeOnMaybe . subscribeWith ( new PerfAsyncConsumer ( bh ) ) . await ( 1 ) ; }
public String getQualifiedName ( ) { return clazz . getCanonicalName ( ) ; }
public void visit ( AllTableColumns arg0 ) { for ( Column column : columns ) { underlyingTableInfo . columnMapping . put ( quoting . normalizeCase ( Quoting . staticUnquote ( column . name ) ) , quoting . normalizeCase ( Quoting . staticUnquote ( column . name ) ) ) ; underlyingTableInfo . origColumnName . put ( quoting . normalizeCase ( Quoting . staticUnquote ( column . name ) ) , Quoting . staticUnquote ( column . name ) ) ; } }
public PriceList getNextPriceList ( ) { return nextPriceList ; }
public void setNormalLandAngleEnd ( int normalLandAngleEnd ) { this . mNormalLandAngleEnd = normalLandAngleEnd ; }
public void close ( ) throws IoTDBConnectionException { if ( ! transport . isOpen ( ) ) { return ; } TSCloseSessionReq req = new TSCloseSessionReq ( sessionId ) ; try { client . closeSession ( req ) ; } catch ( TException e ) { throw new IoTDBConnectionException ( "Error occurs when closing session at server. Maybe server is down." , e ) ; } finally { if ( transport != null ) { transport . close ( ) ; } } }
public PendingIntent getBuyIntent ( String sku , boolean subscription ) throws RemoteException { if ( service == null ) return null ; Bundle bundle = service . getBuyIntent ( IAB_VERSION , context . getPackageName ( ) , sku , subscription ? "subs" : "inapp" , "netguard" ) ; Log . i ( TAG , "getBuyIntent sku=" + sku + " subscription=" + subscription ) ; Util . logBundle ( bundle ) ; int response = ( bundle == null ? - 1 : bundle . getInt ( "RESPONSE_CODE" , - 1 ) ) ; Log . i ( TAG , "Response=" + getResult ( response ) ) ; if ( response != 0 ) throw new IllegalArgumentException ( getResult ( response ) ) ; if ( ! bundle . containsKey ( "BUY_INTENT" ) ) throw new IllegalArgumentException ( "BUY_INTENT missing" ) ; return bundle . getParcelable ( "BUY_INTENT" ) ; }
public Date getModifyTime ( ) { return modifyTime ; }
public boolean isClick ( ) { return mClick ; }
public TableInfo getTable ( String fullName ) { LOGGER . debug ( "Getting table: {}" , fullName ) ; return TransactionManager . executeWithTransaction ( sessionFactory , session -> { String [ ] parts = fullName . split ( "\\." ) ; if ( parts . length != 3 ) { throw new BaseException ( ErrorCode . INVALID_ARGUMENT , "Invalid table name: " + fullName ) ; } String catalogName = parts [ 0 ] ; String schemaName = parts [ 1 ] ; String tableName = parts [ 2 ] ; TableInfoDAO tableInfoDAO = findTable ( session , catalogName , schemaName , tableName ) ; if ( tableInfoDAO == null ) { throw new BaseException ( ErrorCode . NOT_FOUND , "Table not found: " + fullName ) ; } TableInfo tableInfo = tableInfoDAO . toTableInfo ( true , catalogName , schemaName ) ; RepositoryUtils . attachProperties ( tableInfo , tableInfo . getTableId ( ) , Constants . TABLE , session ) ; return tableInfo ; } , "Failed to get table" , true ) ; }
private MetricsUtil . ReadableMetricsStruct readableMetrics ( ContentFile < ? > file , Types . NestedField readableMetricsField ) { StructType projectedMetricType = readableMetricsField . type ( ) . asStructType ( ) ; return MetricsUtil . readableMetricsStruct ( dataTableSchema , file , projectedMetricType ) ; }
public DateTimeFormatterBuilder appendDecimal ( DateTimeFieldType fieldType , int minDigits , int maxDigits ) { if ( fieldType == null ) { throw new IllegalArgumentException ( "Field type must not be null" ) ; } if ( maxDigits < minDigits ) { maxDigits = minDigits ; } if ( minDigits < 0 || maxDigits <= 0 ) { throw new IllegalArgumentException ( ) ; } if ( minDigits <= 1 ) { return append0 ( new UnpaddedNumber ( fieldType , maxDigits , false ) ) ; } else { return append0 ( new PaddedNumber ( fieldType , maxDigits , false , minDigits ) ) ; } }
public static Optional < ClientModelProperty > findProperty ( ClientModel model , String propertyName ) { final Stream < ClientModelProperty > allProperties = Stream . concat ( model . getProperties ( ) . stream ( ) , ClientModelUtil . getParentProperties ( model ) . stream ( ) ) ; return allProperties . filter ( p -> p . getSerializedName ( ) . equals ( propertyName ) ) . findFirst ( ) ; }
default < T > Mono < T > save ( Mono < ? extends T > entityPublisher , IndexCoordinates index ) { Assert . notNull ( entityPublisher , "EntityPublisher must not be null!" ) ; return entityPublisher . flatMap ( it -> save ( it , index ) ) ; }
public void addSingleSignOnService ( EndpointType endpt ) { this . singleSignOnService . add ( endpt ) ; }
public static < T extends HasMetadata > void visit ( Reconciliation reconciliation , T resource , Visitor visitor ) { ArrayList < String > path = new ArrayList < > ( ) ; try { visit ( reconciliation , path , resource , visitor ) ; } catch ( RuntimeException | ReflectiveOperationException | StackOverflowError e ) { LOGGER . errorCr ( reconciliation , "Error while visiting {}" , path , e ) ; if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else { throw new RuntimeException ( e ) ; } } }
public int getBottomAppBarContent ( ) { return R . layout . cat_bottomappbar_fragment ; }
public JDA setRequiredScopes ( @ Nonnull Collection < String > scopes ) { Checks . noneNull ( scopes , "Scopes" ) ; this . requiredScopes = String . join ( "+" , scopes ) ; if ( ! requiredScopes . contains ( "bot" ) ) { if ( requiredScopes . isEmpty ( ) ) { requiredScopes = "bot" ; } else { requiredScopes += "+bot" ; } } return this ; }
public void accept ( ParameterVisitor parameterVisitor ) { JavaAnnotationParameterVisitorAcceptor . accept ( getProperties ( ) , parameterVisitor ) ; }
protected final EnumSet < ? > _deserialize ( JsonParser p , DeserializationContext ctxt , EnumSet result ) throws JacksonException { try { JsonToken t ; while ( ( t = p . nextToken ( ) ) != JsonToken . END_ARRAY ) { Enum < ? > value ; if ( ( t == JsonToken . VALUE_NULL ) || ( value = _enumDeserializer . deserialize ( p , ctxt ) ) == null ) { value = ( Enum < ? > ) _nullProvider . getNullValue ( ctxt ) ; if ( value == null ) { if ( _skipNullValues ) { continue ; } throw InvalidNullException . from ( ctxt , null , _enumType ) ; } } result . add ( value ) ; } } catch ( Exception e ) { throw DatabindException . wrapWithPath ( ctxt , e , new JacksonException . Reference ( result , result . size ( ) ) ) ; } return result ; }
protected Set < ? > toSet ( String sValue ) { String [ ] tokens = StringUtils . split ( sValue ) ; if ( tokens == null || tokens . length <= 0 ) { return null ; } if ( tokens . length == 1 && isReference ( tokens [ 0 ] ) ) { Object reference = resolveReference ( tokens [ 0 ] ) ; if ( reference instanceof Set ) { return ( Set ) reference ; } } Set < String > setTokens = new LinkedHashSet < String > ( Arrays . asList ( tokens ) ) ; Set < Object > values = new LinkedHashSet < Object > ( setTokens . size ( ) ) ; for ( String token : setTokens ) { Object value = resolveValue ( token ) ; values . add ( value ) ; } return values ; }
public void skip ( int number ) { position += number ; }
public XmlPath using ( JAXBObjectMapperFactory factory ) { return new XmlPath ( this , getXmlPathConfig ( ) . jaxbObjectMapperFactory ( factory ) ) ; }
protected void analyzeVersionRange ( final QueryManager qm , final List < VulnerableSoftware > vsList , final Cpe targetCpe , final PackageURL targetPURL , final String targetVersion , final Component component , final VulnerabilityAnalysisLevel vulnerabilityAnalysisLevel ) { boolean ran = false ; if ( targetCpe != null ) { analyzeCpeVersionRange ( qm , vsList , targetCpe , targetVersion , component , vulnerabilityAnalysisLevel ) ; ran = true ; } if ( targetPURL != null ) { analyzePurlVersionRange ( qm , vsList , targetPURL , targetVersion , component , vulnerabilityAnalysisLevel ) ; ran = true ; } if ( ! ran ) { LOGGER . info ( "Neither CPE nor PURL available for component %s, skipping version range analysis" . formatted ( component . getUuid ( ) ) ) ; return ; } }
public DataModel getDataModel ( ) { return dataModel ; }
private void getDrawablePosition ( ) { Drawable drawable = getDrawable ( ) ; if ( drawable != null ) { getImageMatrix ( ) . getValues ( mMatrixValue ) ; mScaleX = mMatrixValue [ Matrix . MSCALE_X ] ; mScaleY = mMatrixValue [ Matrix . MSCALE_Y ] ; int origW = drawable . getIntrinsicWidth ( ) ; int origH = drawable . getIntrinsicHeight ( ) ; mActWidth = Math . round ( origW * mScaleX ) ; mActHeight = Math . round ( origH * mScaleY ) ; mActLeft = ( getWidth ( ) - mActWidth ) / 2 ; mActTop = ( getHeight ( ) - mActHeight ) / 2 ; } }
public String getSourceLanguage ( ) { return sourceLanguage ; }
private void restorePreviewUnfoldedNode ( ) { if ( previewUnfoldedNode != null && ! previewUnfoldedNode . isFolded ( ) ) { Controller controller = Controller . getCurrentController ( ) ; ModeController modeController = controller . getModeController ( ) ; MapController mapController = modeController . getMapController ( ) ; mapController . setFolded ( previewUnfoldedNode , true , controller . getSelection ( ) . getFilter ( ) ) ; previewUnfoldedNode = null ; } stopTimerForDelayedFolding ( ) ; }
public boolean matchesErrorCode ( int errorCode ) { return hresult != null && hresult . intValue ( ) == errorCode ; }
protected void updateTaskModel ( ChatCompletion chatCompletion , TaskModel simpleTask ) { Map < String , Object > paramReplacement = chatCompletion . getPromptVariables ( ) ; List < ChatMessage > messages = chatCompletion . getMessages ( ) ; if ( messages == null ) { messages = new ArrayList < > ( ) ; } for ( ChatMessage message : messages ) { String msgText = message . getMessage ( ) ; if ( msgText != null ) { msgText = StringTemplate . fString ( msgText , paramReplacement ) ; message . setMessage ( msgText ) ; } } simpleTask . getInputData ( ) . put ( "messages" , messages ) ; simpleTask . getInputData ( ) . put ( "tools" , chatCompletion . getTools ( ) ) ; }
public void setUserApiKeyService ( IUserApiKeyService userApiKeyService ) { JwtUtils . userApiKeyService = userApiKeyService ; }
public KafkaConsumer < byte [ ] , byte [ ] > getConsumer ( String clusterId ) throws InvalidClusterException { return getConsumer ( clusterId , new Properties ( ) ) ; }
private CharSequence generateAccessOrderListenerCall ( final FieldPrecedenceModel fieldPrecedenceModel , final String indent , final Token token , final String ... arguments ) { return generateAccessOrderListenerCall ( fieldPrecedenceModel , indent , accessOrderListenerMethodName ( token ) , arguments ) ; }
public ColumnEditor enumValues ( List < String > enumValues ) { this . enumValues = enumValues ; return this ; }
protected GPathResult method ( XmlSlurper slurper ) throws Exception { return slurper . parse ( source ) ; }
public void onFsViewerItemLongPressed ( File file , boolean doSelectMultiple ) { }
public boolean isReadOnlyForRedisClusterReplicas ( ) { return readOnlyForRedisClusterReplicas ; }
static boolean isPremium ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; String lt_user = prefs . getString ( "lt_user" , null ) ; String lt_key = prefs . getString ( "lt_key" , null ) ; return ( ! TextUtils . isEmpty ( lt_user ) && ! TextUtils . isEmpty ( lt_key ) ) ; }
public INDArray oneHot ( INDArray indices , int depth , int axis , double on , double off , DataType dataType ) { NDValidation . validateNumerical ( "oneHot" , "indices" , indices ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . shape . OneHot ( indices , depth , axis , on , off , dataType ) ) [ 0 ] ; }
public CatalogInfo toCatalogInfo ( ) { return new CatalogInfo ( ) . id ( getId ( ) . toString ( ) ) . name ( getName ( ) ) . comment ( comment ) . owner ( owner ) . createdAt ( createdAt . getTime ( ) ) . createdBy ( createdBy ) . updatedAt ( updatedAt != null ? updatedAt . getTime ( ) : null ) . updatedBy ( updatedBy ) . storageRoot ( storageRoot ) . storageLocation ( storageLocation ) ; }
public Element getLastChild ( ) { return relationLocator ( "lastElementChild" ) ; }
public void removeChangeListener ( ChangeListener listener ) { cs . removeChangeListener ( listener ) ; }
public void error ( Supplier < Throwable > throwableSupplier , Supplier < String > messageSupplier ) { }
public Result < JobDetail > getTaskDetail ( Job job ) { Result < ReassignJobDetail > detailResult = reassignJobService . getJobDetailsGroupByTopic ( job . getId ( ) ) ; if ( detailResult . failed ( ) ) { return Result . buildFromIgnoreData ( detailResult ) ; } return Result . buildSuc ( ReassignConverter . convert2JobDetail ( job , detailResult . getData ( ) ) ) ; }
public final boolean inCustomMode ( ) { return ( flags & FLAG_IN_CUSTOM_MODE ) != 0 ; }
protected String getDefaultWebLink ( ) { return DEFAULT_WEB_LINK ; }
public BaseActivity context ( ) { return context ; }
private void update ( MetadataUpdate . RemovePartitionSpecs unused ) { requireDefaultPartitionSpecNotChanged ( ) ; requireNoBranchesChanged ( ) ; }
public List < RowSet > getOutputRowSets ( ) { return null ; }
public StringBuilder visit ( JoinPipeOperator join , Void context ) { builder . append ( "|> " ) ; deparseJoin ( join . getJoin ( ) ) ; builder . append ( "\n" ) ; return builder ; }
protected void handleLanguagePackEvent ( @ Lang . EventType int event , int arg1 ) { }
public < T extends TypeDefinition > T getTypeOrNull ( String typeName , Class < T > ofType ) { TypeDefinition type = getTypeOrNull ( typeName ) ; if ( type != null ) { if ( type . getClass ( ) . equals ( ofType ) ) { return ( T ) type ; } } return null ; }
public void setScrimAnimationDuration ( @ IntRange ( from = 0 ) final long duration ) { scrimAnimationDuration = duration ; }
public void setLeaf ( ) { isLeaf = true ; }
public ConfigEntity getConfigByKey ( String configKey ) { LambdaQueryWrapper < ConfigEntity > queryWrapper = new LambdaQueryWrapper < > ( ) ; queryWrapper . eq ( ConfigEntity :: getConfigKey , configKey ) ; return configMapper . selectOne ( queryWrapper ) ; }
Map < String , Object > candidateToMap ( IceCandidate candidate ) { ConstraintsMap candidateParams = new ConstraintsMap ( ) ; candidateParams . putInt ( "sdpMLineIndex" , candidate . sdpMLineIndex ) ; candidateParams . putString ( "sdpMid" , candidate . sdpMid ) ; candidateParams . putString ( "candidate" , candidate . sdp ) ; return candidateParams . toMap ( ) ; }
public TcpDiscoverySharedFsIpFinder setPath ( String path ) { this . path = path ; return this ; }
public Hours toStandardHours ( ) { return Hours . hours ( getValue ( ) / DateTimeConstants . SECONDS_PER_HOUR ) ; }
protected long sizeOfBaseType ( ) { return SIZEOF ; }
public boolean isBinderAlive ( ) { throw new RuntimeException ( "STUB" ) ; }
public String getDeleteFlag ( ) { return deleteFlag ; }
public String getFrontDomain ( ) { SystemConfigDTO systemConfigDTO = ( ( SystemConfigService ) AopContext . currentProxy ( ) ) . getSystemConfig ( ) ; return systemConfigDTO . getFrontDomain ( ) ; }
public Criteria andReportMemberNameNotLike ( String value ) { addCriterion ( "report_member_name not like" , value , "reportMemberName" ) ; return ( Criteria ) this ; }
public void onDestroy ( ) { super . onDestroy ( ) ; tabsManager . unsetSavedTabsListener ( ) ; if ( binding != null ) { binding . pager . setAdapter ( null ) ; binding = null ; } }
public OptExpression rewrite ( OptExpression root , TaskContext taskContext ) { SessionVariable sv = taskContext . getOptimizerContext ( ) . getConnectContext ( ) . getSessionVariable ( ) ; if ( ! sv . isEnableLocalShuffleAgg ( ) || ! sv . isEnablePipelineEngine ( ) || ! GlobalStateMgr . getCurrentState ( ) . getNodeMgr ( ) . getClusterInfo ( ) . isSingleBackendAndComputeNode ( ) ) { return root ; } return root . getOp ( ) . accept ( VISITOR , root , null ) ; }
private String getString ( int id ) { return app . getString ( id ) ; }
public static boolean isAvailable ( ) { return android . os . Build . VERSION . SDK_INT >= android . os . Build . VERSION_CODES . M ; }
void addSaveButtonAction ( ActionListener action ) { this . saveButton . addActionListener ( action ) ; }
public long clusterSessionId ( ) { return clusterSessionId ; }
public void read ( org . apache . thrift . protocol . TProtocol prot , AppOutputAppendEvent struct ) throws org . apache . thrift . TException { org . apache . thrift . protocol . TTupleProtocol iprot = ( org . apache . thrift . protocol . TTupleProtocol ) prot ; java . util . BitSet incoming = iprot . readBitSet ( 5 ) ; if ( incoming . get ( 0 ) ) { struct . noteId = iprot . readString ( ) ; struct . setNoteIdIsSet ( true ) ; } if ( incoming . get ( 1 ) ) { struct . paragraphId = iprot . readString ( ) ; struct . setParagraphIdIsSet ( true ) ; } if ( incoming . get ( 2 ) ) { struct . appId = iprot . readString ( ) ; struct . setAppIdIsSet ( true ) ; } if ( incoming . get ( 3 ) ) { struct . index = iprot . readI32 ( ) ; struct . setIndexIsSet ( true ) ; } if ( incoming . get ( 4 ) ) { struct . data = iprot . readString ( ) ; struct . setDataIsSet ( true ) ; } }
private void captureTypes ( final List < Token > tokens , final int beginIndex , final int endIndex ) { for ( int i = beginIndex ; i <= endIndex ; i ++ ) { final Token token = tokens . get ( i ) ; final int typeBeginIndex = i ; switch ( token . signal ( ) ) { case BEGIN_COMPOSITE : i = captureType ( tokens , i , Signal . END_COMPOSITE , token . name ( ) , token . referencedName ( ) ) ; captureTypes ( tokens , typeBeginIndex + 1 , i - 1 ) ; break ; case BEGIN_ENUM : i = captureType ( tokens , i , Signal . END_ENUM , token . name ( ) , token . referencedName ( ) ) ; break ; case BEGIN_SET : i = captureType ( tokens , i , Signal . END_SET , token . name ( ) , token . referencedName ( ) ) ; break ; default : break ; } } }
private void initSinkTimeZone ( ) { final String timeZone = config . getSink ( ) . get ( "timezone" ) ; config . getSink ( ) . remove ( "timezone" ) ; if ( Asserts . isNotNullString ( timeZone ) ) { sinkTimeZone = ZoneId . of ( timeZone ) ; logger . info ( "Sink timezone is {}" , sinkTimeZone ) ; } }
private void setSettingView ( boolean tts ) { settingView . setContent ( tts ? ttsSettingBox : settingBox ) ; settingDrawer . setDefaultDrawerSize ( tts ? 150 : 320 ) ; }
public String getSQLQueryColumns ( String ... args ) { return "select column_name from public.table_columns where schema_name=? and table_name = ?" ; }
public String toApiTestFilename ( String name ) { return "test_" + toApiFilename ( name ) ; }
public void onResume ( ) { super . onResume ( ) ; if ( listViewAdapter != null ) { listViewAdapter . notifyDataSetChanged ( ) ; } }
public final EventHandlerGroup < T > handleEventsWith ( final EventHandler < ? super T > ... handlers ) { return createEventProcessors ( new Sequence [ 0 ] , handlers ) ; }
public void onCreate ( ) { super . onCreate ( ) ; addDisposable ( prefs ( ) . getBoolean ( R . string . settings_key_do_not_flip_quick_key_codes_functionality , R . bool . settings_default_do_not_flip_quick_keys_functionality ) . asObservable ( ) . subscribe ( value -> mDoNotFlipQuickTextKeyAndPopupFunctionality = value , GenericOnError . onError ( "settings_key_do_not_flip_quick_key_codes_functionality" ) ) ) ; addDisposable ( prefs ( ) . getString ( R . string . settings_key_emoticon_default_text , R . string . settings_default_empty ) . asObservable ( ) . subscribe ( value -> mOverrideQuickTextText = value , GenericOnError . onError ( "settings_key_emoticon_default_text" ) ) ) ; mDefaultSkinTonePrefTracker = new DefaultSkinTonePrefTracker ( prefs ( ) ) ; addDisposable ( mDefaultSkinTonePrefTracker ) ; mDefaultGenderPrefTracker = new DefaultGenderPrefTracker ( prefs ( ) ) ; addDisposable ( mDefaultGenderPrefTracker ) ; }
private static ImmutableSet < ZipPath > getDirectoriesWithFiles ( BundleModule module ) { return module . getEntries ( ) . stream ( ) . map ( entry -> entry . getPath ( ) . getParent ( ) ) . collect ( toImmutableSet ( ) ) ; }
public Circuit getCircuit ( ) { return circuit ; }
public void setBootstrapResolverForQuery ( boolean bootstrapResolverForQuery ) { this . bootstrapResolverForQuery = bootstrapResolverForQuery ; }
public < X0 , X1 > Septet < A , B , C , D , E , X0 , X1 > addAt5 ( final Pair < X0 , X1 > tuple ) { return addAt5 ( tuple . getValue0 ( ) , tuple . getValue1 ( ) ) ; }
public INDArray stridedSlice ( INDArray in , INDArray begin , INDArray end , INDArray strides ) { NDValidation . validateNumerical ( "stridedSlice" , "begin" , begin ) ; NDValidation . validateNumerical ( "stridedSlice" , "end" , end ) ; NDValidation . validateNumerical ( "stridedSlice" , "strides" , strides ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . shape . StridedSlice ( in , begin , end , strides , 0 , 0 , 0 , 0 , 0 ) ) [ 0 ] ; }
public ConnectionConfig closeIdleConnectionsAfterEachResponseAfter ( long idleTime , TimeUnit timeUnit ) { return new ConnectionConfig ( new CloseIdleConnectionConfig ( idleTime , timeUnit ) ) ; }
public static boolean willIgnoreOthersByKey ( String id , String key ) { return willIgnore ( id , i -> CollectionUtils . isNotEmpty ( i . getOthers ( ) ) && i . getOthers ( ) . getOrDefault ( key , false ) ) ; }
public boolean needAnimateChanges ( ) { ViewController < ? > c = ViewController . findAncestor ( ChatView . this ) ; return c == null || c . getParentOrSelf ( ) . getAttachState ( ) ; }
public void ifThrowStmt ( Consumer < ThrowStmt > action ) { action . accept ( this ) ; }
private void bindData ( List < ArrayList < WidgetItem > > recommendationTable ) { if ( recommendationTable . isEmpty ( ) ) { setVisibility ( GONE ) ; return ; } removeAllViews ( ) ; for ( int i = 0 ; i < recommendationTable . size ( ) ; i ++ ) { List < WidgetItem > widgetItems = recommendationTable . get ( i ) ; WidgetTableRow tableRow = new WidgetTableRow ( getContext ( ) ) ; tableRow . setupRow ( widgetItems . size ( ) , 0 ) ; tableRow . setGravity ( Gravity . TOP ) ; for ( WidgetItem widgetItem : widgetItems ) { WidgetCell widgetCell = addItemCell ( tableRow ) ; widgetCell . applyFromCellItem ( widgetItem ) ; widgetCell . showAppIconInWidgetTitle ( true ) ; widgetCell . showDescription ( false ) ; widgetCell . showDimensions ( false ) ; } addView ( tableRow ) ; } setVisibility ( VISIBLE ) ; }
public String getMessage ( ) { return msg ; }
public void visit ( Export export ) { StatementVisitor . super . visit ( export ) ; }
public String getClusterDomain ( ) { return clusterDomain ; }
public boolean shouldSkipField ( FieldAttributes f ) { return false ; }
private void stopScreenCapture ( ) { if ( mVirtualDisplay != null ) { mVirtualDisplay . release ( ) ; mVirtualDisplay = null ; } }
private void moveEdge ( DragPointType type , int xoff , int yoff ) { switch ( type ) { case TOP : movePoint ( mCropPoints [ P_LT ] , 0 , yoff ) ; movePoint ( mCropPoints [ P_RT ] , 0 , yoff ) ; break ; case RIGHT : movePoint ( mCropPoints [ P_RT ] , xoff , 0 ) ; movePoint ( mCropPoints [ P_RB ] , xoff , 0 ) ; break ; case BOTTOM : movePoint ( mCropPoints [ P_LB ] , 0 , yoff ) ; movePoint ( mCropPoints [ P_RB ] , 0 , yoff ) ; break ; case LEFT : movePoint ( mCropPoints [ P_LT ] , xoff , 0 ) ; movePoint ( mCropPoints [ P_LB ] , xoff , 0 ) ; break ; default : break ; } }
public ThreeStateValue invert ( ) { switch ( this ) { case zero : return one ; case one : return zero ; default : return dontCare ; } }
private void mockSystem2ForSingleCall ( long now ) { Mockito . reset ( mockedSystem2 ) ; when ( mockedSystem2 . now ( ) ) . thenReturn ( now ) . thenThrow ( new IllegalStateException ( "now should be called only once" ) ) ; }
public Criteria andCreatorIn ( List < Long > values ) { addCriterion ( "creator in" , values , "creator" ) ; return ( Criteria ) this ; }
private void saveDisconnectedRepositories ( ) { List < String > list = new LinkedList < String > ( ) ; synchronized ( allDisconnectedRepositories ) { for ( Map . Entry < String , Set < String > > e : allDisconnectedRepositories . entrySet ( ) ) { String vsKey = e . getKey ( ) ; for ( String f : e . getValue ( ) ) { list . add ( vsKey + SEP + f ) ; } } } Utils . put ( getPreferences ( ) , PREF_KEY , list ) ; }
public Object doAround ( ProceedingJoinPoint joinPoint ) { MethodSignature methodSignature = ( MethodSignature ) joinPoint . getSignature ( ) ; Method targetMethod = methodSignature . getMethod ( ) ; Lock lock = targetMethod . getAnnotation ( Lock . class ) ; String lockKey = KEY_PREFIX + buildLockKey ( lock . prefix ( ) , targetMethod , joinPoint . getArgs ( ) ) ; RLock rLock = redissonClient . getLock ( lockKey ) ; if ( lock . isWait ( ) ? rLock . tryLock ( lock . waitTime ( ) , TimeUnit . SECONDS ) : rLock . tryLock ( ) ) { try { return joinPoint . proceed ( ) ; } finally { rLock . unlock ( ) ; } } throw new BusinessException ( lock . failCode ( ) ) ; }
public @ Nullable ScalingUtils . ScaleType getRetryImageScaleType ( ) { return mRetryImageScaleType ; }
public int nextInt ( ) throws IOException { final BsonType type = delegate . getCurrentBsonType ( ) ; switch ( type ) { case INT32 : return delegate . readInt32 ( ) ; case INT64 : return ( int ) delegate . readInt64 ( ) ; case DOUBLE : return ( int ) delegate . readDouble ( ) ; case DECIMAL128 : return delegate . readDecimal128 ( ) . bigDecimalValue ( ) . intValueExact ( ) ; case DATE_TIME : return ( int ) delegate . readDateTime ( ) ; case TIMESTAMP : return ( int ) delegate . readTimestamp ( ) . getValue ( ) ; default : throw new IllegalStateException ( String . format ( "Expected numeric bson type (int) but got %s (as json:%s)" , type , toGsonToken ( type ) ) ) ; } }
default SlashCommandData addOption ( @ Nonnull OptionType type , @ Nonnull String name , @ Nonnull String description ) { return addOption ( type , name , description , false ) ; }
public double getDoubleProperty ( String name , double defaultValue ) { String property = getProperty ( name , null ) ; if ( property != null ) { try { return Double . parseDouble ( property ) ; } catch ( NumberFormatException e ) { } } return defaultValue ; }
public void addAsMetaZoneIntoTrie ( String mzID , TextTrieMap < NameInfo > trie ) { addNamesIntoTrie ( mzID , null , trie ) ; }
public Integer getUserId ( ) { return userId ; }
public Cardinality getCardinality ( ) { return cardinality ; }
public double calculateSolverTimeGradient ( SolverScope < Solution_ > solverScope ) { long solverTimeMillisSpent = solverScope . calculateTimeMillisSpentUpToNow ( ) ; return calculateTimeGradient ( solverTimeMillisSpent ) ; }
public JPanel getPanel ( ) { return panel ; }
public String toString ( ) { return "CheckNotActiveBrokerRequest{" + "checkTimeMillis=" + checkTimeMillis + '}' ; }
public void cleanup ( ) { for ( DRPCInvocationsClient c : clients . values ( ) ) { c . close ( ) ; } }
public void onActivityPermissionResult ( int code , boolean granted ) { }
public void flowFlatMapIterable1 ( Blackhole bh ) { flowFlatMapIterable1 . subscribe ( new PerfConsumer ( bh ) ) ; }
public static int getTitleTop2 ( int chatListMode ) { switch ( chatListMode ) { case Settings . CHAT_MODE_3LINE : case Settings . CHAT_MODE_3LINE_BIG : return Screen . dp ( 10f ) ; case Settings . CHAT_MODE_2LINE : default : return Screen . dp ( 12f ) ; } }
public TreeMap getTreeMap ( ) { return treeMap ; }
public String getCode ( ) { return this . code ; }
public void setUpdaterName ( String updaterName ) { this . updaterName = updaterName ; }
public Builder sslSocketFactory ( SSLSocketFactory sslSocketFactory ) { this . sslSocketFactory = sslSocketFactory ; return this ; }
public void setValue ( Object element , Object value ) throws Exception { Object subject = adapt ( element ) ; Number newValue = stringToLong . convert ( String . valueOf ( value ) ) ; if ( int . class . isAssignableFrom ( descriptor ( ) . getPropertyType ( ) ) || Integer . class . isAssignableFrom ( descriptor ( ) . getPropertyType ( ) ) ) newValue = Integer . valueOf ( newValue . intValue ( ) ) ; if ( validator != null && ! validator . test ( newValue ) ) throw new IllegalArgumentException ( MessageFormat . format ( Messages . MsgDialogInputRequired , descriptor ( ) . getDisplayName ( ) ) ) ; Number oldValue = ( Number ) descriptor ( ) . getReadMethod ( ) . invoke ( subject ) ; if ( ! newValue . equals ( oldValue ) ) { descriptor ( ) . getWriteMethod ( ) . invoke ( subject , newValue ) ; notify ( element , newValue , oldValue ) ; } }
public static NottableSchemaString notSchema ( String value ) { return new NottableSchemaString ( value , Boolean . TRUE ) ; }
public long getLiveBytes ( ) { return liveBytes . get ( ) ; }
public ShapeStroke . LineCapType getCapType ( ) { return capType ; }
public static CodePointCharStream fromChannel ( ReadableByteChannel channel , Charset charset , int bufferSize , CodingErrorAction decodingErrorAction , String sourceName , long inputSize ) throws IOException { try { ByteBuffer utf8BytesIn = ByteBuffer . allocate ( bufferSize ) ; CharBuffer utf16CodeUnitsOut = CharBuffer . allocate ( bufferSize ) ; if ( inputSize == - 1 ) { inputSize = bufferSize ; } else if ( inputSize > Integer . MAX_VALUE ) { throw new IOException ( String . format ( "inputSize %d larger than max %d" , inputSize , Integer . MAX_VALUE ) ) ; } CodePointBuffer . Builder codePointBufferBuilder = CodePointBuffer . builder ( ( int ) inputSize ) ; CharsetDecoder decoder = charset . newDecoder ( ) . onMalformedInput ( decodingErrorAction ) . onUnmappableCharacter ( decodingErrorAction ) ; boolean endOfInput = false ; while ( ! endOfInput ) { int bytesRead = channel . read ( utf8BytesIn ) ; endOfInput = ( bytesRead == - 1 ) ; utf8BytesIn . flip ( ) ; CoderResult result = decoder . decode ( utf8BytesIn , utf16CodeUnitsOut , endOfInput ) ; if ( result . isError ( ) && decodingErrorAction . equals ( CodingErrorAction . REPORT ) ) { result . throwException ( ) ; } utf16CodeUnitsOut . flip ( ) ; codePointBufferBuilder . append ( utf16CodeUnitsOut ) ; utf8BytesIn . compact ( ) ; utf16CodeUnitsOut . compact ( ) ; } CoderResult flushResult = decoder . flush ( utf16CodeUnitsOut ) ; if ( flushResult . isError ( ) && decodingErrorAction . equals ( CodingErrorAction . REPORT ) ) { flushResult . throwException ( ) ; } utf16CodeUnitsOut . flip ( ) ; codePointBufferBuilder . append ( utf16CodeUnitsOut ) ; CodePointBuffer codePointBuffer = codePointBufferBuilder . build ( ) ; return CodePointCharStream . fromBuffer ( codePointBuffer , sourceName ) ; } finally { channel . close ( ) ; } }
public void setUserVariable ( UserVariable userVariable ) { this . userVariable = userVariable ; }
public void write ( BufferedImage image , String filePath ) throws IOException { File file = new File ( filePath ) ; if ( file . exists ( ) ) { if ( ! file . delete ( ) ) { throw new IOException ( "File " + filePath + " exists already, and call to .delete() failed " + "unexpectedly" ) ; } } else { if ( ! file . createNewFile ( ) ) { throw new IOException ( "Unable to create file at path " + filePath + ", call to .createNewFile() " + "failed unexpectedly." ) ; } } try ( OutputStream fos = new BufferedOutputStream ( newOutputStream ( file . toPath ( ) ) ) ) { write ( image , fos ) ; } }
protected void doSkipBytes ( long length ) throws IOException { if ( length <= 0 ) { return ; } int remaining = limit - pos ; if ( length <= remaining ) { pos = ( int ) ( pos + length ) ; } else { limit = pos = 0 ; length -= remaining ; source . skipSourceBytes ( length ) ; } }
default double applyAsDouble ( T x , T y ) { return d ( x , y ) ; }
protected String getXMLElementName ( ) { return ELEMENT_EVENT_THROW ; }
public final T canonicalize ( T value ) { T canonical = canonicals . get ( value ) ; if ( canonical == null ) { value = toCanonical ( value ) ; T existing = canonicals . putIfAbsent ( value , value ) ; if ( existing == null ) { canonical = value ; } else { canonical = existing ; } } return canonical ; }
public boolean isClickHouse ( ) { return isClickHouse ( gainSQLDatabase ( ) ) ; }
public CameraOpenOptions optionalMicrophone ( boolean optionalMicrophone ) { this . optionalMicrophone = optionalMicrophone ; return this ; }
BigDecimal update ( BigDecimal src , BigDecimal dst ) { if ( src == null ) { return dst ; } if ( dst == null ) { return src ; } return src . add ( dst ) ; }
public boolean unregister ( IntGauge intGauge ) { return false ; }
public void setDataChangeLastModifiedBy ( String dataChangeLastModifiedBy ) { this . dataChangeLastModifiedBy = dataChangeLastModifiedBy ; }
public int getEndLineColor ( ) { return mEndLineColor ; }
protected void createSchemaTemplate ( TSCreateSchemaTemplateReq request ) throws IoTDBConnectionException , StatementExecutionException { final TSStatus status = callWithRetryAndReconnect ( ( ) -> { request . setSessionId ( sessionId ) ; return client . createSchemaTemplate ( request ) ; } ) . getResult ( ) ; RpcUtils . verifySuccess ( status ) ; }
public static void writeSymbolTable ( Writer out , Definitions defs ) throws IOException { if ( defs == null ) { return ; } Comparator < Tag > cmp = Comparator . comparing ( ( Tag tag ) -> tag . symbol ) . thenComparingInt ( tag -> tag . line ) ; Map < String , SortedSet < Tag > > symbols = new HashMap < > ( ) ; for ( Tag tag : defs . getTags ( ) ) { XrefStyle style = XrefStyle . getStyle ( tag . type ) ; if ( style != null && style . title != null ) { SortedSet < Tag > tags = symbols . computeIfAbsent ( style . name , k -> new TreeSet < > ( cmp ) ) ; tags . add ( tag ) ; } } out . append ( "<script type=\"text/javascript\">/* <![CDATA[ */\n" ) ; out . append ( "function get_sym_list(){return [" ) ; boolean first = true ; for ( XrefStyle style : XrefStyle . DEFINITION_STYLES ) { SortedSet < Tag > tags = symbols . get ( style . name ) ; if ( tags != null ) { if ( ! first ) { out . append ( ',' ) ; } out . append ( "[\"" ) ; out . append ( style . title ) ; out . append ( "\",\"" ) ; out . append ( style . ssClass ) ; out . append ( "\",[" ) ; boolean firstTag = true ; for ( Tag tag : tags ) { if ( ! firstTag ) { out . append ( ',' ) ; } out . append ( '[' ) ; out . append ( Util . jsStringLiteral ( tag . symbol ) ) ; out . append ( ',' ) ; out . append ( Integer . toString ( tag . line ) ) ; out . append ( ']' ) ; firstTag = false ; } out . append ( "]]" ) ; first = false ; } } out . append ( "];} /* ]]> */</script>" ) ; }
public void initData ( ) { super . initData ( ) ; }
public A removeFromDevices ( V1beta1AllocatedDeviceStatus ... items ) { if ( this . devices == null ) { return ( A ) this ; } for ( V1beta1AllocatedDeviceStatus item : items ) { V1beta1AllocatedDeviceStatusBuilder builder = new V1beta1AllocatedDeviceStatusBuilder ( item ) ; _visitables . get ( "devices" ) . remove ( builder ) ; this . devices . remove ( builder ) ; } return ( A ) this ; }
public NDArray diagonal ( int offset , int axis1 , int axis2 ) { return getAlternativeArray ( ) . diagonal ( offset , axis1 , axis2 ) ; }
private List < FeedItem > getCandidates ( ) { List < FeedItem > candidates = new ArrayList < > ( ) ; List < FeedItem > downloadedItems = DBReader . getEpisodes ( 0 , Integer . MAX_VALUE , new FeedItemFilter ( FeedItemFilter . DOWNLOADED ) , SortOrder . DATE_NEW_OLD ) ; for ( FeedItem item : downloadedItems ) { if ( item . hasMedia ( ) && item . getMedia ( ) . isDownloaded ( ) && ! item . isTagged ( FeedItem . TAG_QUEUE ) && ! item . isTagged ( FeedItem . TAG_FAVORITE ) ) { candidates . add ( item ) ; } } return candidates ; }
private static boolean [ ] convertToBits ( byte [ ] initialEntropy , byte checksum ) { int ent = initialEntropy . length * 8 ; int checksumLength = ent / 32 ; int totalLength = ent + checksumLength ; boolean [ ] bits = new boolean [ totalLength ] ; for ( int i = 0 ; i < initialEntropy . length ; i ++ ) { for ( int j = 0 ; j < 8 ; j ++ ) { byte b = initialEntropy [ i ] ; bits [ 8 * i + j ] = toBit ( b , j ) ; } } for ( int i = 0 ; i < checksumLength ; i ++ ) { bits [ ent + i ] = toBit ( checksum , i ) ; } return bits ; }
public INDArray identity ( INDArray input ) { return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . transforms . same . Identity ( input ) ) [ 0 ] ; }
public void onViewDetachedFromWindow ( @ NonNull View v ) { onDetachedToWindow ( ) ; }
public List < IllustsBean > getContent ( ) { if ( content == null ) { content = new DeduplicateArrayList < > ( ) ; } return content ; }
public void print ( LogParam logParam , AnchorInfo anchorInfo ) { print ( anchorInfo ) ; print ( logParam ) ; }
protected final boolean isTransformed ( ) { return transformFullyApplied ; }
public static Map < DecodeHintType , Object > createDecodeHint ( @ NonNull BarcodeFormat barcodeFormat ) { Map < DecodeHintType , Object > hints = new EnumMap < > ( DecodeHintType . class ) ; addDecodeHintTypes ( hints , Collections . singletonList ( barcodeFormat ) ) ; return hints ; }
public static void deleteLock ( ) { File lockFile = new File ( ResourcesUtil . baseDirectory ( ) , "config/.lock" ) ; lockFile . delete ( ) ; }
public void setDistinct ( boolean distinct ) { this . distinct = distinct ; }
SELF withTarget ( TARGET target ) { this . target = target ; return self ( ) ; }
public void visitBreakStatement ( final BreakStatement statement ) { pushContext ( statement ) ; super . visitBreakStatement ( statement ) ; popContext ( ) ; }
public void write ( Directory dir , SegmentInfo si , IOContext ioContext ) throws IOException { throw new UnsupportedOperationException ( "Old formats can't be used for writing" ) ; }
public void executeVoid ( Connection conn ) throws JobPersistenceException { for ( JobDetail job : triggersAndJobs . keySet ( ) ) { storeJob ( conn , job , replace ) ; for ( Trigger trigger : triggersAndJobs . get ( job ) ) { storeTrigger ( conn , ( OperableTrigger ) trigger , job , replace , Constants . STATE_WAITING , false , false ) ; } } }
private void updateFont ( ) { forEachPageView ( content -> { content . setStyle ( String . format ( FONT_STYLE_FORMAT , fontSizeSlider . getValue ( ) , fontSelector . getValue ( ) ) ) ; content . getTitle ( ) . setStyle ( String . format ( FONT_STYLE_FORMAT , fontSizeSlider . getValue ( ) + 12 , fontSelector . getValue ( ) ) ) ; } ) ; updateDisplayText ( ) ; }
public FieldVisitor visitField ( final int access , final String name , final String desc , final String signature , final Object value ) { myFieldDescMap . put ( name , desc ) ; myFieldAccessMap . put ( name , Integer . valueOf ( access ) ) ; return super . visitField ( access , name , desc , signature , value ) ; }
URI getUri ( ) ; String getRelativePath ( ) ; Resource resolve ( String path ) ; default String getPrefixedPath ( ) { return isClassPath ( ) ? CLASSPATH_COLON + getRelativePath ( ) : getRelativePath ( ) ; }
void setPasswordReminderTimestamp ( long timestamp ) { _prefs . edit ( ) . putLong ( "pref_password_reminder_counter" , timestamp ) . apply ( ) ; }
public void setGranularity ( long granularity ) { this . granularity = granularity ; }
private String getPrefix ( String namespace , boolean includeDefault , boolean generatePrefix ) throws IOException { for ( int i = mNamespaceCounts [ mDepth + 1 ] * 2 - 2 ; i >= 0 ; i -= 2 ) { if ( mNamespaceStack [ i + 1 ] . equals ( namespace ) && ( includeDefault || ! mNamespaceStack [ i ] . isEmpty ( ) ) ) { String candidate = mNamespaceStack [ i ] ; for ( int j = i + 2 ; j < mNamespaceCounts [ mDepth + 1 ] * 2 ; j ++ ) { if ( mNamespaceStack [ j ] . equals ( candidate ) ) { candidate = null ; break ; } } if ( candidate != null ) { return candidate ; } } } if ( ! generatePrefix ) { return null ; } String prefix ; if ( namespace . isEmpty ( ) ) { prefix = "" ; } else { do { prefix = "n" + ( mAutoNamespace ++ ) ; for ( int i = mNamespaceCounts [ mDepth + 1 ] * 2 - 2 ; i >= 0 ; i -= 2 ) { if ( prefix . equals ( mNamespaceStack [ i ] ) ) { prefix = null ; break ; } } } while ( prefix == null ) ; } boolean pending = mPending ; mPending = false ; setPrefix ( prefix , namespace ) ; mPending = pending ; return prefix ; }
protected HoodieReaderContext < ? > createReaderContext ( boolean needReloadMetaClient ) { HoodieTableMetaClient metaClient = table . getMetaClient ( ) ; Supplier < InternalSchemaManager > internalSchemaManagerSupplier = ( ) -> { if ( internalSchemaManager == null || needReloadMetaClient ) { internalSchemaManager = InternalSchemaManager . get ( metaClient . getStorageConf ( ) , metaClient ) ; } return internalSchemaManager ; } ; StorageConfiguration < ? > readerConf = writeClient . getEngineContext ( ) . getStorageConf ( ) ; return new FlinkRowDataReaderContext ( readerConf , internalSchemaManagerSupplier , Collections . emptyList ( ) , metaClient . getTableConfig ( ) , Option . empty ( ) ) ; }
public String getECLevel ( ) { return ecLevel ; }
public static int getDefaultAvatarCacheSize ( ) { return getAvatarSize ( Settings . instance ( ) . getChatListMode ( ) ) ; }
public void setLineOrientation ( int lineOrientation ) { this . mLineOrientation = lineOrientation ; }
public static Buffer malloc ( int capacity , MemoryStack stack ) { return new Buffer ( stack . nmalloc ( ALIGNOF , capacity * SIZEOF ) , capacity ) ; }
public void onDestroy ( ) { super . onDestroy ( ) ; getPermissionChannelImpl ( ) . onFragmentDestroy ( ) ; }
public boolean visible ( String name , Map < String , Object > parsedConfig ) { return base . visible ( unprefixed ( name ) , unprefixed ( parsedConfig ) ) ; }
protected RememberMeManager rememberMeManager ( ) { return super . rememberMeManager ( ) ; }
public static void fillBpmnTypes ( Map < Class < ? extends BaseElement > , Class < ? extends BaseBpmnJsonConverter > > convertersToJsonMap ) { convertersToJsonMap . put ( EventSubProcess . class , EventSubProcessJsonConverter . class ) ; }
public Class < ? > type ( Method i ) { return i . getReturnType ( ) ; }
public boolean isTimeRefIgnored ( ) { return timeRefIgnored ; }
public void addSubscribe ( SubscribeTask task ) { Duration duration = Duration . ofSeconds ( ( task . getDelayTime ( ) - System . currentTimeMillis ( ) ) / 1000 ) ; if ( duration . getSeconds ( ) < 0 ) { return ; } subscribes . put ( task . getKey ( ) , task ) ; String key = String . format ( "%s_%s_%s" , prefix , userSetting . getServerId ( ) , task . getKey ( ) ) ; redisTemplate . opsForValue ( ) . set ( key , task . getInfo ( ) , duration ) ; delayQueue . offer ( task ) ; }
public boolean hasStateForHolder ( EpoxyViewHolder holder ) { return get ( holder . getItemId ( ) ) != null ; }
public boolean isSymbolTableStatic ( ) { return false ; }
public static HttpURLConnection getHttpUrlConnection ( String url ) throws IOException { URL httpUrl = new URL ( url ) ; HttpURLConnection httpConnection = ( HttpURLConnection ) httpUrl . openConnection ( ) ; httpConnection . setRequestProperty ( "User-Agent" , "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36" ) ; return httpConnection ; }
public static PackageInfo getPackageInfoForPermission ( Context context ) { PackageInfo pi = null ; try { PackageManager pm = context . getPackageManager ( ) ; pi = pm . getPackageInfo ( context . getPackageName ( ) , PackageManager . GET_PERMISSIONS ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return pi ; }
public void setCurrentContact ( Contact contact ) { if ( metaContact == null ) { MetaContactListService mcs = ContactInfoActivator . getContactListService ( ) ; metaContact = mcs . findMetaContactByContact ( contact ) ; } }
public Element retry ( Integer count , Integer interval ) { driver . retry ( count , interval ) ; return this ; }
DeleteFile [ ] forEntry ( ManifestEntry < DataFile > entry ) { return forDataFile ( entry . dataSequenceNumber ( ) , entry . file ( ) ) ; }
public List < String > getIds ( ) { return ids ; }
public String toString ( ) { String s = "jakarta.ws.rs.WebApplicationException" ; String message = getLocalizedMessage ( ) ; return ( s + ( ": " + message ) ) ; }
public boolean equals ( Object o ) { if ( this == o ) return true ; if ( ! ( o instanceof ResourcePath ) ) return false ; ResourcePath that = ( ResourcePath ) o ; if ( ! Objects . equals ( rClass , that . rClass ) ) return false ; if ( ! Objects . equals ( resourceBase , that . resourceBase ) ) return false ; if ( ! Objects . equals ( assetsDir , that . assetsDir ) ) return false ; return Objects . equals ( internalRClass , that . internalRClass ) ; }
public static int roundColor ( int col , int max ) { return roundColor ( col , max , null ) ; }
public void setGraph ( JanusGraph graph ) { Preconditions . checkArgument ( graph != null && graph . isOpen ( ) , "Need to provide open graph" ) ; this . graph = ( StandardJanusGraph ) graph ; provided = true ; }
public ByteBuffer msg_control ( ) { return Msghdr . nmsg_control ( address ( ) ) ; }
private static int innerYearInterval ( int date1 , int date2 ) { int y1 , y2 ; if ( date1 < 0 ) { y1 = date1 / 384 + 1969 ; } else { y1 = date1 / 384 + 1970 ; } if ( date2 < 0 ) { y2 = date2 / 384 + 1969 ; } else { y2 = date2 / 384 + 1970 ; } return y2 - y1 ; }
public void anySetter ( JMethod setter , JDefinedClass clazz ) { setter . annotate ( JsonAnySetter . class ) ; }
public void setPassword ( String password ) { this . password = password ; }
default Future < Void > shutdown ( ) { return shutdown ( 30 , TimeUnit . SECONDS ) ; }
private int readField ( final ClassVisitor classVisitor , final Context context , final int fieldInfoOffset ) { char [ ] charBuffer = context . charBuffer ; int currentOffset = fieldInfoOffset ; int accessFlags = readUnsignedShort ( currentOffset ) ; String name = readUTF8 ( currentOffset + 2 , charBuffer ) ; String descriptor = readUTF8 ( currentOffset + 4 , charBuffer ) ; currentOffset += 6 ; Object constantValue = null ; String signature = null ; int runtimeVisibleAnnotationsOffset = 0 ; int runtimeInvisibleAnnotationsOffset = 0 ; int runtimeVisibleTypeAnnotationsOffset = 0 ; int runtimeInvisibleTypeAnnotationsOffset = 0 ; Attribute attributes = null ; int attributesCount = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; while ( attributesCount -- > 0 ) { String attributeName = readUTF8 ( currentOffset , charBuffer ) ; int attributeLength = readInt ( currentOffset + 2 ) ; currentOffset += 6 ; if ( Constants . CONSTANT_VALUE . equals ( attributeName ) ) { int constantvalueIndex = readUnsignedShort ( currentOffset ) ; constantValue = constantvalueIndex == 0 ? null : readConst ( constantvalueIndex , charBuffer ) ; } else if ( Constants . SIGNATURE . equals ( attributeName ) ) { signature = readUTF8 ( currentOffset , charBuffer ) ; } else if ( Constants . DEPRECATED . equals ( attributeName ) ) { accessFlags |= Opcodes . ACC_DEPRECATED ; } else if ( Constants . SYNTHETIC . equals ( attributeName ) ) { accessFlags |= Opcodes . ACC_SYNTHETIC ; } else if ( Constants . RUNTIME_VISIBLE_ANNOTATIONS . equals ( attributeName ) ) { runtimeVisibleAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS . equals ( attributeName ) ) { runtimeVisibleTypeAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS . equals ( attributeName ) ) { runtimeInvisibleAnnotationsOffset = currentOffset ; } else if ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS . equals ( attributeName ) ) { runtimeInvisibleTypeAnnotationsOffset = currentOffset ; } else { Attribute attribute = readAttribute ( context . attributePrototypes , attributeName , currentOffset , attributeLength , charBuffer , - 1 , null ) ; attribute . nextAttribute = attributes ; attributes = attribute ; } currentOffset += attributeLength ; } FieldVisitor fieldVisitor = classVisitor . visitField ( accessFlags , name , descriptor , signature , constantValue ) ; if ( fieldVisitor == null ) { return currentOffset ; } if ( runtimeVisibleAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeVisibleAnnotationsOffset ) ; int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( fieldVisitor . visitAnnotation ( annotationDescriptor , true ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeInvisibleAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeInvisibleAnnotationsOffset ) ; int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( fieldVisitor . visitAnnotation ( annotationDescriptor , false ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeVisibleTypeAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeVisibleTypeAnnotationsOffset ) ; int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { currentAnnotationOffset = readTypeAnnotationTarget ( context , currentAnnotationOffset ) ; String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( fieldVisitor . visitTypeAnnotation ( context . currentTypeAnnotationTarget , context . currentTypeAnnotationTargetPath , annotationDescriptor , true ) , currentAnnotationOffset , true , charBuffer ) ; } } if ( runtimeInvisibleTypeAnnotationsOffset != 0 ) { int numAnnotations = readUnsignedShort ( runtimeInvisibleTypeAnnotationsOffset ) ; int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2 ; while ( numAnnotations -- > 0 ) { currentAnnotationOffset = readTypeAnnotationTarget ( context , currentAnnotationOffset ) ; String annotationDescriptor = readUTF8 ( currentAnnotationOffset , charBuffer ) ; currentAnnotationOffset += 2 ; currentAnnotationOffset = readElementValues ( fieldVisitor . visitTypeAnnotation ( context . currentTypeAnnotationTarget , context . currentTypeAnnotationTargetPath , annotationDescriptor , false ) , currentAnnotationOffset , true , charBuffer ) ; } } while ( attributes != null ) { Attribute nextAttribute = attributes . nextAttribute ; attributes . nextAttribute = null ; fieldVisitor . visitAttribute ( attributes ) ; attributes = nextAttribute ; } fieldVisitor . visitEnd ( ) ; return currentOffset ; }
public void autoDetectClues ( Content content , boolean filter ) { byte [ ] data = content . getContent ( ) ; if ( minConfidence >= 0 && DETECTABLES . contains ( content . getContentType ( ) ) && data . length > MIN_LENGTH ) { CharsetMatch [ ] matches = null ; try { detector . enableInputFilter ( filter ) ; detector . setText ( data ) ; matches = detector . detectAll ( ) ; } catch ( Exception e ) { LOG . debug ( "Exception from ICU4J (ignoring): " , e ) ; } if ( matches != null ) { for ( CharsetMatch match : matches ) { addClue ( match . getName ( ) , "detect" , match . getConfidence ( ) ) ; } } } addClue ( parseCharacterEncoding ( content . getMetadata ( ) . get ( Response . CONTENT_TYPE ) ) , "header" ) ; }
protected void dropSchemaTemplate ( TSDropSchemaTemplateReq request ) throws IoTDBConnectionException , StatementExecutionException { final TSStatus status = callWithRetryAndReconnect ( ( ) -> { request . setSessionId ( sessionId ) ; return client . dropSchemaTemplate ( request ) ; } ) . getResult ( ) ; RpcUtils . verifySuccess ( status ) ; }
public < E extends GenericEvent > Once . Builder < E > listenOnce ( @ Nonnull Class < E > eventType ) { return new Once . Builder < > ( this , eventType ) ; }
public void mouseReleased ( java . awt . event . MouseEvent evt ) { subtitle_labelMouseReleased ( evt ) ; }
public Result httpDeleteByConfig ( String path , Map < String , String > headers , Map < String , String > paramValues , long readTimeoutMs ) { return null ; }
public static Collection < PluginConfigSpec < ? > > commonInputSettings ( Collection < PluginConfigSpec < ? > > settings ) { return combineSettings ( settings , commonInputSettings ( ) ) ; }
public boolean hasMatchingDevice ( Predicate < V1beta1AllocatedDeviceStatusBuilder > predicate ) { for ( V1beta1AllocatedDeviceStatusBuilder item : devices ) { if ( predicate . test ( item ) ) { return true ; } } return false ; }
protected void openIntentChooser ( ) throws ActivityNotFoundException { Activity activity = this . reactContext . getCurrentActivity ( ) ; if ( activity == null ) { TargetChosenReceiver . callbackReject ( "Something went wrong" ) ; return ; } Intent chooser ; IntentSender intentSender = null ; if ( TargetChosenReceiver . isSupported ( ) ) { intentSender = TargetChosenReceiver . getSharingSenderIntent ( this . reactContext ) ; chooser = Intent . createChooser ( this . getIntent ( ) , this . chooserTitle , intentSender ) ; } else { chooser = Intent . createChooser ( this . getIntent ( ) , this . chooserTitle ) ; } chooser . addFlags ( Intent . FLAG_ACTIVITY_NO_HISTORY ) ; if ( ShareIntent . hasValidKey ( "showAppsToView" , options ) && ShareIntent . hasValidKey ( "url" , options ) ) { Intent viewIntent = new Intent ( Intent . ACTION_VIEW ) ; viewIntent . setType ( this . fileShare . getType ( ) ) ; Intent [ ] viewIntents = this . getIntentsToViewFile ( viewIntent , this . fileShare . getURI ( ) ) ; chooser . putExtra ( Intent . EXTRA_INITIAL_INTENTS , viewIntents ) ; } if ( ShareIntent . hasValidKey ( "excludedActivityTypes" , options ) ) { if ( android . os . Build . VERSION . SDK_INT >= android . os . Build . VERSION_CODES . N ) { chooser . putExtra ( Intent . EXTRA_EXCLUDE_COMPONENTS , getExcludedComponentArray ( options . getArray ( "excludedActivityTypes" ) ) ) ; activity . startActivityForResult ( chooser , RNShareImpl . SHARE_REQUEST_CODE ) ; } else { activity . startActivityForResult ( excludeChooserIntent ( this . getIntent ( ) , options ) , RNShareImpl . SHARE_REQUEST_CODE ) ; } } else { activity . startActivityForResult ( chooser , RNShareImpl . SHARE_REQUEST_CODE ) ; } if ( intentSender == null ) { WritableMap reply = Arguments . createMap ( ) ; reply . putBoolean ( "success" , true ) ; reply . putString ( "message" , "OK" ) ; TargetChosenReceiver . callbackResolve ( reply ) ; } }
public static ConfigDetailInfo transferToConfigDetailInfo ( ConfigAllInfo configAllInfo ) { ConfigDetailInfo result = new ConfigDetailInfo ( ) ; BeanUtils . copyProperties ( configAllInfo , result ) ; result . setNamespaceId ( configAllInfo . getTenant ( ) ) ; result . setGroupName ( configAllInfo . getGroup ( ) ) ; return result ; }
public void setRectPosition ( int positionX , int positionY , int rectWidth , int rectHeight ) { mCircleCenterX = positionX ; mCircleCenterY = positionY ; mFocusWidth = rectWidth ; mFocusHeight = rectHeight ; mFocusShape = FocusShape . ROUNDED_RECTANGLE ; mHasFocus = true ; }
public static int analyzeTableQueryTimeout ( Map < String , String > properties ) throws AnalysisException { if ( properties == null || ! properties . containsKey ( PROPERTIES_TABLE_QUERY_TIMEOUT ) ) { return - 1 ; } String tableQueryTimeoutStr = properties . get ( PROPERTIES_TABLE_QUERY_TIMEOUT ) ; properties . remove ( PROPERTIES_TABLE_QUERY_TIMEOUT ) ; int tableQueryTimeout ; try { tableQueryTimeout = Integer . parseInt ( tableQueryTimeoutStr ) ; if ( tableQueryTimeout == - 1 ) { return - 1 ; } if ( tableQueryTimeout <= 0 ) { throw new AnalysisException ( "Property " + PROPERTIES_TABLE_QUERY_TIMEOUT + " must be greater than 0, or -1 to reset to default, got: " + tableQueryTimeoutStr ) ; } } catch ( NumberFormatException e ) { throw new AnalysisException ( "Property " + PROPERTIES_TABLE_QUERY_TIMEOUT + " must be a valid integer, got: " + tableQueryTimeoutStr ) ; } return tableQueryTimeout ; }
SELF withModifiers ( Set < JavaModifier > modifiers ) { this . modifiers = modifiers ; return self ( ) ; }
public static void loadOverlayConfig ( ) { try { OVERLAY = OverlayConfig . load ( ) ; LOGGER . debug ( "loaded overlay config: {}" , OVERLAY ) ; } catch ( Exception ex ) { LOGGER . warn ( "failed to load overlay config" , ex ) ; } }
public void startSearchTree ( VertexType vertex ) { searchTreeList . add ( createSearchTree ( vertex ) ) ; }
public static int colorWithAlpha ( int color , int alpha ) { return ( color & 0xffffff ) | ( ( alpha & 0xff ) << 24 ) ; }
public Seconds minus ( int seconds ) { return plus ( FieldUtils . safeNegate ( seconds ) ) ; }
private static @ Nullable RexNode calculateInnerSortFetch ( Sort sort , RexBuilder rexBuilder ) { if ( sort . fetch == null ) { return null ; } final BigDecimal outerFetch = RexLiteral . bigDecimalValue ( sort . fetch ) ; final BigDecimal outerOffset = sort . offset != null ? RexLiteral . bigDecimalValue ( sort . offset ) : BigDecimal . ZERO ; final BigDecimal totalFetch = outerOffset . add ( outerFetch ) ; return rexBuilder . makeExactLiteral ( totalFetch ) ; }
public boolean onPreDraw ( ) { videoView . getViewTreeObserver ( ) . removeOnPreDrawListener ( this ) ; return true ; }
public Iterator getIPAddresses ( ) throws DataUnavailable { if ( _ipAddresses . size ( ) > 0 ) { return _ipAddresses . iterator ( ) ; } else { throw new DataUnavailable ( ) ; } }
public void onPackageLoaded ( ) { initHook ( new DisableRootedCheck ( ) , mPrefsMap . getBoolean ( "guard_provider_disable_root_check" ) ) ; initHook ( new DisableUploadAppListNew ( ) , mPrefsMap . getBoolean ( "disable_upload_applist" ) ) ; }
public boolean isCellEditable ( int row , int column ) { return false ; }
static int roundColor ( int color , int [ ] colors , int max , String dist ) { return roundColor ( color , colors , max , getDistance ( dist ) ) ; }
public boolean containsProperty ( String key ) { return ( getProperty ( key ) != null ) ; }
private static ByteBuf writeSlice ( ByteBuf in , int len ) { checkArgument ( len <= in . writableBytes ( ) ) ; ByteBuf out = in . slice ( in . writerIndex ( ) , len ) ; in . writerIndex ( in . writerIndex ( ) + len ) ; return out . writerIndex ( 0 ) ; }
void requery ( ) { if ( mBindArgs != null ) { int len = mBindArgs . length ; try { if ( mObjectBindArgs != null ) { bindArguments ( mObjectBindArgs ) ; } else { for ( int i = 0 ; i < len ; i ++ ) { super . bindString ( i + 1 , mBindArgs [ i ] ) ; } } } catch ( SQLiteMisuseException e ) { StringBuilder errMsg = new StringBuilder ( "mSql " + mSql ) ; for ( int i = 0 ; i < len ; i ++ ) { errMsg . append ( " " ) ; errMsg . append ( mBindArgs [ i ] ) ; } errMsg . append ( " " ) ; IllegalStateException leakProgram = new IllegalStateException ( errMsg . toString ( ) , e ) ; throw leakProgram ; } } }
public void removed ( boolean removed ) { this . removed = removed ; }
public float getLayoutAlignmentY ( Container target ) { return ( delegate instanceof LayoutManager2 ) ? ( ( LayoutManager2 ) delegate ) . getLayoutAlignmentY ( target ) : 0.5f ; }
public void removePart ( Object value ) { if ( value == null ) { if ( parts . remove ( NULL ) ) { getProperties ( ) [ 1 ] . setValue ( parts ) ; } } else if ( parts . remove ( value ) ) { getProperties ( ) [ 1 ] . setValue ( parts ) ; } }
public void setBottomRightCutSizeDp ( float bottomRightCutSize ) { this . setBottomRightCutSize ( dpToPx ( bottomRightCutSize ) ) ; }
private void injectNamespaceRowMapper ( ) { RowMapperManager . registerRowMapper ( NamespaceRowMapperInjector . TENANT_INFO_ROW_MAPPER . getClass ( ) . getCanonicalName ( ) , NamespaceRowMapperInjector . TENANT_INFO_ROW_MAPPER ) ; }
private boolean trimParentElementFull ( UpgradeContext context , Element root , Element parentElement , Map < Path , Document > pomMap ) { boolean hasChanges = false ; String childGroupId = root . childText ( MavenPomElements . Elements . GROUP_ID ) ; String childVersion = root . childText ( MavenPomElements . Elements . VERSION ) ; hasChanges |= trimParentElementLimited ( context , root , parentElement ) ; if ( isParentInReactor ( parentElement , pomMap , context ) ) { if ( childGroupId == null ) { Element parentGroupIdElement = parentElement . child ( GROUP_ID ) . orElse ( null ) ; if ( parentGroupIdElement != null ) { DomUtils . removeElement ( parentGroupIdElement ) ; context . detail ( "Removed: parent groupId (child has no explicit groupId)" ) ; hasChanges = true ; } } if ( childVersion == null ) { Element parentVersionElement = parentElement . child ( VERSION ) . orElse ( null ) ; if ( parentVersionElement != null ) { DomUtils . removeElement ( parentVersionElement ) ; context . detail ( "Removed: parent version (child has no explicit version)" ) ; hasChanges = true ; } } if ( canInferParentArtifactId ( parentElement , pomMap ) ) { Element parentArtifactIdElement = parentElement . child ( ARTIFACT_ID ) . orElse ( null ) ; if ( parentArtifactIdElement != null ) { DomUtils . removeElement ( parentArtifactIdElement ) ; context . detail ( "Removed: parent artifactId (can be inferred from relativePath)" ) ; hasChanges = true ; } } } return hasChanges ; }
private String getTemplate ( DingtalkSettings setting , boolean isRecovery ) { return isRecovery ? setting . getRecoveryTextTemplate ( ) : setting . getTextTemplate ( ) ; }
public static DataType fromDbzColumn ( Column column , PostgresConnectorConfig dbzConfig , TypeRegistry typeRegistry ) { DataType dataType = convertFromColumn ( column , dbzConfig , typeRegistry ) ; if ( column . isOptional ( ) ) { return dataType ; } else { return dataType . notNull ( ) ; } }
public void setClientId ( String clientId ) { this . clientId = clientId ; }
protected boolean launchCustomHeaderTransformAnimator ( boolean open , int transformMode , Animator . AnimatorListener listener ) { return false ; }
public < T > void clear ( Class < T > clazz ) { clear ( getSharedPreferences ( getListPath ( clazz ) ) ) ; }
private StructType getDistinctValueSchema ( ) { if ( distinctValueSchema == null ) { List < StructField > fieldList = new ArrayList < > ( ) ; fieldList . add ( DataTypes . createStructField ( "dict_key" , DataTypes . StringType , false ) ) ; distinctValueSchema = DataTypes . createStructType ( fieldList ) ; } return distinctValueSchema ; }
public Properties clusterConfigs ( ) { return _clusterConfigs ; }
public boolean getUseDBLocks ( ) { return useDBLocks ; }
public int pointerParam ( ) { return param ( POINTER_SIZE ) ; }
public Iterator < MultiStepOperation < ? > > iterator ( ) { return state . values ( ) . iterator ( ) ; }
public void addColumn ( int index , ColumnDef definition ) { columns . add ( index , definition ) ; }
public boolean moveToLast ( ) { return doMoveToPosition ( results . length - 1 ) ; }
public static void addEdge ( List < List < Integer > > graph , int from , int to ) { graph . get ( from ) . add ( to ) ; graph . get ( to ) . add ( from ) ; }
private static String formatByteArray ( final byte [ ] filePiece , final int maxLength ) { final int length = filePiece . length ; final int displayLength = Math . min ( length , maxLength ) ; final StringBuilder sb = new StringBuilder ( ) ; sb . append ( "[" ) ; for ( int i = 0 ; i < displayLength ; i ++ ) { sb . append ( String . format ( "%02x" , filePiece [ i ] ) ) ; if ( i < displayLength - 1 ) { sb . append ( ", " ) ; } } if ( length > maxLength ) { sb . append ( "..." ) ; } sb . append ( "]" ) ; return sb . toString ( ) ; }
public CompletableFuture < Void > recordIssuance ( String processorItemId , PaymentProvider processor , ReceiptCredentialRequest request , Instant now ) { final AttributeValue key = dynamoDbKey ( processor , processorItemId ) ; final byte [ ] tag = generateIssuedReceiptTag ( request ) ; UpdateItemRequest updateItemRequest = UpdateItemRequest . builder ( ) . tableName ( table ) . key ( Map . of ( KEY_PROCESSOR_ITEM_ID , key ) ) . conditionExpression ( "attribute_not_exists(#key) OR contains(#tags, :tag) OR size(#tags) < :maxTags" ) . returnValues ( ReturnValue . NONE ) . updateExpression ( "SET #exp = if_not_exists(#exp, :exp) ADD #tags :singletonTag" ) . expressionAttributeNames ( Map . of ( "#key" , KEY_PROCESSOR_ITEM_ID , "#tags" , KEY_ISSUED_RECEIPT_TAG_SET , "#exp" , KEY_EXPIRATION ) ) . expressionAttributeValues ( Map . of ( ":tag" , b ( tag ) , ":singletonTag" , AttributeValue . fromBs ( List . of ( SdkBytes . fromByteArray ( tag ) ) ) , ":exp" , n ( now . plus ( expiration ) . getEpochSecond ( ) ) , ":maxTags" , n ( maxIssuedReceiptsPerPaymentId . get ( processor ) ) ) ) . build ( ) ; return dynamoDbAsyncClient . updateItem ( updateItemRequest ) . handle ( ( updateItemResponse , throwable ) -> { if ( throwable != null ) { Throwable rootCause = Throwables . getRootCause ( throwable ) ; if ( rootCause instanceof ConditionalCheckFailedException ) { throw new ClientErrorException ( Status . CONFLICT , rootCause ) ; } Throwables . throwIfUnchecked ( throwable ) ; throw new CompletionException ( throwable ) ; } return null ; } ) ; }
public < X0 , X1 , X2 , X3 > Ennead < A , X0 , X1 , X2 , X3 , B , C , D , E > addAt1 ( final X0 value0 , final X1 value1 , final X2 value2 , final X3 value3 ) { return new Ennead < A , X0 , X1 , X2 , X3 , B , C , D , E > ( this . val0 , value0 , value1 , value2 , value3 , this . val1 , this . val2 , this . val3 , this . val4 ) ; }
public String getDescription ( ) { return this . description ; }
public List < JavaType > getUpperBounds ( ) { return buildJavaTypes ( upperBoundCreationProcesses , owner , allTypeParametersInContext , importedClasses ) ; }
public void setCapacity ( @ jakarta . annotation . Nullable V1CapacityRequirements capacity ) { this . capacity = capacity ; }
public boolean isAsync ( ) { return EGraphSynchronization . ASYNC == getGraphSyncMode ( ) ; }
private static String readAsString ( Path path , Charset charset ) { try { return String . join ( System . lineSeparator ( ) , Files . readAllLines ( path . toAbsolutePath ( ) , charset ) ) ; } catch ( IOException ioe ) { throw new FlywayException ( "Unable to read " + path . toAbsolutePath ( ) + " from disk" , ioe ) ; } }
public Object getEmptyValue ( DeserializationContext ctxt ) throws JacksonException { ValueInstantiator vi = getValueInstantiator ( ) ; if ( vi == null || ! vi . canCreateUsingDefault ( ) ) { JavaType type = getValueType ( ) ; ctxt . reportBadDefinition ( type , String . format ( "Cannot create empty instance of %s, no default Creator" , type ) ) ; } return vi . createUsingDefault ( ctxt ) ; }
public void seekNextRecordBoundary ( ) throws IOException { readUntilMatchBegin ( ) ; }
public void onTouchEnd ( ) { scrollView . smoothScrollTo ( 0 , linearLayout . getMeasuredHeight ( ) ) ; }
public Builder withMetalakeId ( Long metalakeId ) { rolePO . metalakeId = metalakeId ; return this ; }
public SearchRequest term ( String field , String value ) { return query ( new Term ( field , value ) ) ; }
public void addAll ( java . util . Collection < PolygonOptions > opts ) { for ( PolygonOptions opt : opts ) { addPolygon ( opt ) ; } }
static native String nativeGetTablePrefix ( ) ; public static Class < ? extends RealmModel > getOriginalModelClass ( Class < ? extends RealmModel > clazz ) { if ( clazz . equals ( RealmModel . class ) || clazz . equals ( RealmObject . class ) ) { throw new IllegalArgumentException ( "RealmModel or RealmObject was passed as an argument. " + "Only subclasses of these can be used as arguments to methods that accept a Realm model class." ) ; } @ SuppressWarnings ( "unchecked" ) Class < ? extends RealmModel > superclass = ( Class < ? extends RealmModel > ) clazz . getSuperclass ( ) ; if ( ! superclass . equals ( Object . class ) && ! superclass . equals ( RealmObject . class ) ) { clazz = superclass ; } return clazz ; }
public boolean isEnd ( long t ) { return t >= _totalTime ; }
public void onOffsetChanged ( AppBarLayout layout , int verticalOffset ) { currentOffset = verticalOffset ; final int insetTop = lastInsets != null ? lastInsets . getSystemWindowInsetTop ( ) : 0 ; for ( int i = 0 , z = getChildCount ( ) ; i < z ; i ++ ) { final View child = getChildAt ( i ) ; final LayoutParams lp = ( LayoutParams ) child . getLayoutParams ( ) ; final ViewOffsetHelper offsetHelper = getViewOffsetHelper ( child ) ; switch ( lp . collapseMode ) { case LayoutParams . COLLAPSE_MODE_PIN : offsetHelper . setTopAndBottomOffset ( MathUtils . clamp ( - verticalOffset , 0 , getMaxOffsetForPinChild ( child ) ) ) ; break ; case LayoutParams . COLLAPSE_MODE_PARALLAX : offsetHelper . setTopAndBottomOffset ( Math . round ( - verticalOffset * lp . parallaxMult ) ) ; break ; default : break ; } } updateScrimVisibility ( ) ; if ( statusBarScrim != null && insetTop > 0 ) { postInvalidateOnAnimation ( ) ; } int height = getHeight ( ) ; final int expandRange = height - getMinimumHeight ( ) - insetTop ; final int scrimRange = height - getScrimVisibleHeightTrigger ( ) ; final int currentOffsetY = currentOffset + expandRange ; final float expansionFraction = Math . abs ( verticalOffset ) / ( float ) expandRange ; collapsingTitleHelper . setFadeModeStartFraction ( Math . min ( 1 , ( float ) scrimRange / ( float ) expandRange ) ) ; collapsingTitleHelper . setCurrentOffsetY ( currentOffsetY ) ; collapsingTitleHelper . setExpansionFraction ( expansionFraction ) ; collapsingSubtitleHelper . setFadeModeStartFraction ( Math . min ( 1 , ( float ) scrimRange / ( float ) expandRange ) ) ; collapsingSubtitleHelper . setCurrentOffsetY ( currentOffsetY ) ; collapsingSubtitleHelper . setExpansionFraction ( expansionFraction ) ; }
default SlashCommandData addOptions ( @ Nonnull Collection < ? extends OptionData > options ) { Checks . noneNull ( options , "Option" ) ; return addOptions ( options . toArray ( new OptionData [ 0 ] ) ) ; }
public String getScheme ( ) { return implementation . getScheme ( ) ; }
public void openMissingPermissionAlert ( @ StringRes int message ) { AlertDialog . Builder b = new AlertDialog . Builder ( context , Theme . dialogTheme ( ) ) ; b . setTitle ( Lang . getString ( R . string . AppName ) ) ; b . setMessage ( Lang . getString ( message ) ) ; b . setPositiveButton ( Lang . getOK ( ) , ( dialog , which ) -> dialog . dismiss ( ) ) ; b . setNegativeButton ( Lang . getString ( R . string . Settings ) , ( dialog , which ) -> Intents . openPermissionSettings ( ) ) ; showAlert ( b ) ; }
public void setReadCount ( String readCount ) { this . readCount = readCount ; }
public void push ( double value ) { append ( value ) ; }
public String toString ( ) { return "Histogram{" + "bins=" + Arrays . toString ( bins ) + ", count=" + count + ", breaks=" + Arrays . toString ( breaks ) + '}' ; }
public void processLine ( String line , OutputVisitor visitor ) { OutputVisitor . Context context = visitor . getContext ( ) ; Project prj = project ; if ( context != null && context . getCurrentProject ( ) != null ) { prj = context . getCurrentProject ( ) ; } OutputListener list = OutputUtils . matchStackTraceLine ( line , prj ) ; if ( list != null ) { visitor . setOutputListener ( list ) ; } }
public static int getInteger ( @ NonNull String resName ) { return Resources . getSystem ( ) . getInteger ( getResourceId ( INTEGER , resName ) ) ; }
public int getPlayState ( ) { return originalTrack . getPlayState ( ) ; }
public void clear ( ) { iFormatter = null ; iElementPairs . clear ( ) ; }
public void addPool ( String name , int threadCount ) { String queueName = getQueueName ( name ) ; if ( queues . get ( queueName ) != null ) { throw new IllegalStateException ( String . format ( "queue %s already present" , queueName ) ) ; } queues . put ( queueName , Executors . newFixedThreadPool ( threadCount , new OpenGrokThreadFactory ( queueName ) ) ) ; }
public RowData next ( ) { return toRowData ( objectIterator . next ( ) ) ; }
public void onResume ( ) { if ( ! Utils . isCAInstalled ( mCaCert ) ) { if ( ! mAddon . isConnected ( ) ) { if ( ! mAddon . connect ( 0 ) ) { new AlertDialog . Builder ( requireContext ( ) ) . setTitle ( R . string . error ) . setMessage ( R . string . mitm_addon_autostart_workaround ) . setNegativeButton ( R . string . no , ( dialogInterface , i ) -> { Toast . makeText ( requireContext ( ) , "addon connect failed" , Toast . LENGTH_LONG ) . show ( ) ; certFail ( ) ; } ) . setPositiveButton ( R . string . yes , ( d , whichButton ) -> { Context ctx = requireContext ( ) ; Intent launchIntent = ctx . getPackageManager ( ) . getLaunchIntentForPackage ( MitmAPI . PACKAGE_NAME ) ; if ( launchIntent != null ) Utils . startActivity ( ctx , launchIntent ) ; else { Toast . makeText ( requireContext ( ) , "addon connect failed" , Toast . LENGTH_LONG ) . show ( ) ; certFail ( ) ; } } ) . show ( ) ; } } } else certOk ( ) ; super . onResume ( ) ; }
public boolean transformerApplied ( ) { if ( originalMediator == null ) { return true ; } return originalMediator . transformerApplied ( ) ; }
public final void visit ( Node n ) { AllocNode an = ( AllocNode ) n ; AllocDotField adf = pag . makeAllocDotField ( an , src . getField ( ) ) ; returnValue = v . makeP2Set ( ) . addAll ( adf . getP2Set ( ) , null ) | returnValue ; }
public ColumnEditorImpl position ( int position ) { this . position = position ; return this ; }
public void sortColumnDown ( ) { viewModel . moveColumnDown ( ) ; }
public OperationsMap postProcessOperationsWithModels ( OperationsMap objs , List < ModelMap > allModels ) { super . postProcessOperationsWithModels ( objs , allModels ) ; OperationMap operations = objs . getOperations ( ) ; List < CodegenOperation > operationList = operations . getOperation ( ) ; Set < String > resultImports = new HashSet < > ( ) ; for ( CodegenOperation op : operationList ) { for ( CodegenParameter param : op . allParams ) { if ( ( ( op . isMultipart && param . isFormParam ) || param . isBodyParam ) && ( param . isBinary || param . isFile ) ) { param . dataType = param . dataType . replace ( "Uint8List" , "MultipartFile" ) ; param . baseType = param . baseType . replace ( "Uint8List" , "MultipartFile" ) ; op . imports . add ( "MultipartFile" ) ; if ( SERIALIZATION_LIBRARY_BUILT_VALUE . equals ( library ) ) { boolean skipFormModel = Boolean . parseBoolean ( GlobalSettings . getProperty ( CodegenConstants . SKIP_FORM_MODEL , "true" ) ) ; if ( param . isFormParam && param . isContainer && ! skipFormModel ) { addBuiltValueSerializerImport ( "Uint8List" ) ; } } } } if ( op . allParams . stream ( ) . noneMatch ( param -> param . dataType . equals ( "Uint8List" ) ) && op . responses . stream ( ) . filter ( response -> response . dataType != null ) . noneMatch ( response -> response . dataType . equals ( "Uint8List" ) ) ) { op . imports . remove ( "Uint8List" ) ; } if ( SERIALIZATION_LIBRARY_JSON_SERIALIZABLE . equals ( library ) ) { if ( op . isResponseFile ) { op . imports . add ( "Uint8List" ) ; op . returnType = "Uint8List" ; op . returnBaseType = "Uint8List" ; } } resultImports . addAll ( rewriteImports ( op . imports , false ) ) ; if ( SERIALIZATION_LIBRARY_BUILT_VALUE . equals ( library ) ) { for ( CodegenParameter param : op . allParams ) { if ( param . isContainer && ! ( param . isBinary || param . isFile ) ) { addBuiltValueSerializer ( new BuiltValueSerializer ( param . isArray , param . uniqueItems , param . isMap , param . items . isNullable , param . baseType ) ) ; } } } if ( SERIALIZATION_LIBRARY_BUILT_VALUE . equals ( library ) && ( op . getHasFormParams ( ) || op . getHasQueryParams ( ) || op . getHasPathParams ( ) ) ) { resultImports . add ( "package:" + pubName + "/" + sourceFolder + "/api_util.dart" ) ; } if ( op . returnContainer != null && ! ( op . isResponseBinary || op . isResponseFile ) ) { addBuiltValueSerializer ( new BuiltValueSerializer ( Objects . equals ( "array" , op . returnContainer ) || Objects . equals ( "set" , op . returnContainer ) , op . uniqueItems , Objects . equals ( "map" , op . returnContainer ) , false , op . returnBaseType ) ) ; } } objs . put ( "imports" , resultImports . stream ( ) . sorted ( ) . collect ( Collectors . toList ( ) ) ) ; return objs ; }
private HoodieSchema getMessageSchema ( Descriptors . Descriptor descriptor , CopyOnWriteMap < Descriptors . Descriptor , Integer > recursionDepths , String path ) { Integer currentRecursionCount = recursionDepths . getOrDefault ( descriptor , 0 ) ; if ( currentRecursionCount >= maxRecursionDepth ) { return RECURSION_OVERFLOW_SCHEMA ; } recursionDepths . put ( descriptor , ++ currentRecursionCount ) ; List < HoodieSchemaField > fields = new ArrayList < > ( descriptor . getFields ( ) . size ( ) ) ; for ( Descriptors . FieldDescriptor fieldDescriptor : descriptor . getFields ( ) ) { HoodieSchema fieldSchema = getFieldSchema ( fieldDescriptor , new CopyOnWriteMap < > ( recursionDepths ) , path ) ; fields . add ( HoodieSchemaField . of ( fieldDescriptor . getName ( ) , fieldSchema , null , getDefault ( fieldSchema , fieldDescriptor ) ) ) ; } return HoodieSchema . createRecord ( descriptor . getName ( ) , path , null , fields ) ; }
public void afterTextChanged ( Editable s ) { int length = s . length ( ) ; int end = length ; while ( end > 0 && Character . isWhitespace ( s . charAt ( end - 1 ) ) ) { end -- ; } if ( end > 0 && end < length ) { end ++ ; } int start = 0 ; while ( start < end && Character . isWhitespace ( s . charAt ( start ) ) ) { start ++ ; } if ( start > 0 || end < length ) { s . replace ( 0 , length , s . subSequence ( start , end ) ) ; } else { String text = s . toString ( ) . trim ( ) ; if ( ! text . equals ( oldText ) || ( executeCallbackOnEmpty && text . isEmpty ( ) ) ) { textChangedCallback . execute ( text ) ; } } }
public int getHeight ( ) { return height ; }
public String getValueHint ( ) { return valueHint ; }
public String getCreateStatement ( String schema , String tableName ) { return String . format ( createTableSql , schema , tableName ) ; }
protected void writeAdditionalAttributes ( BaseElement element , BpmnModel model , XMLStreamWriter xtw ) throws Exception { }
public static void combine ( @ AggregationState QuantileDigestAndPercentileState state , QuantileDigestAndPercentileState otherState ) { QuantileDigest input = otherState . getDigest ( ) ; QuantileDigest previous = state . getDigest ( ) ; if ( previous == null ) { state . setDigest ( input ) ; state . addMemoryUsage ( input . estimatedInMemorySizeInBytes ( ) ) ; } else { state . addMemoryUsage ( - previous . estimatedInMemorySizeInBytes ( ) ) ; previous . merge ( input ) ; state . addMemoryUsage ( previous . estimatedInMemorySizeInBytes ( ) ) ; } state . setPercentile ( otherState . getPercentile ( ) ) ; }
public long memoryAddress ( int offset ) { return memoryAddress + idx ( offset ) ; }
void count_by_status_and_entity_uuid ( ) { insertPending ( newCeQueueDto ( TASK_UUID_1 ) . setEntityUuid ( ENTITY_UUID_1 ) . setStatus ( IN_PROGRESS ) . setTaskType ( CeTaskTypes . REPORT ) . setCreatedAt ( 100_000L ) ) ; insertPending ( newCeQueueDto ( TASK_UUID_2 ) . setEntityUuid ( ENTITY_UUID_2 ) . setStatus ( IN_PROGRESS ) . setTaskType ( CeTaskTypes . REPORT ) . setCreatedAt ( 100_000L ) ) ; insertPending ( newCeQueueDto ( TASK_UUID_3 ) . setEntityUuid ( ENTITY_UUID_1 ) . setStatus ( PENDING ) . setTaskType ( CeTaskTypes . REPORT ) . setCreatedAt ( 100_000L ) ) ; assertThat ( underTest . countByStatusAndEntityUuid ( db . getSession ( ) , IN_PROGRESS , ENTITY_UUID_1 ) ) . isOne ( ) ; assertThat ( underTest . countByStatus ( db . getSession ( ) , IN_PROGRESS ) ) . isEqualTo ( 2 ) ; }
public Path getAssetsDir ( ) { return assetsDir ; }
public PeriodParser toParser ( ) { if ( iNotParser ) { return null ; } return toFormatter ( ) . getParser ( ) ; }
private MaxwellDiagnosticResult . Check exceptionResult ( Throwable e ) { Map < String , String > info = new HashMap < > ( ) ; info . put ( "error" , e . getCause ( ) . toString ( ) ) ; return new MaxwellDiagnosticResult . Check ( this , false , info ) ; }
private static void failIfPhysiologyEnabled ( String arg ) { if ( Boolean . valueOf ( Config . get ( "physiology.generators.enabled" , "false" ) ) ) { String errString = String . format ( "The %s command line switch %s - %s" , arg , "cannot be used when physiology generators are enabled" , "set configuration option physiology.generators.enabled=false to use" ) ; throw new IllegalArgumentException ( errString ) ; } }
public Long getValue ( ) { try { CpuCore . Stat stat = ( ( CpuCore ) core ) . getCpuStat ( ) ; return stat . nrThrottled ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public Criteria andReportMemberNameBetween ( String value1 , String value2 ) { addCriterion ( "report_member_name between" , value1 , value2 , "reportMemberName" ) ; return ( Criteria ) this ; }
public InstrumentedMemoryCache < CacheKey , PooledByteBuffer > getEncodedMemoryCache ( ) { if ( mEncodedMemoryCache == null ) { MemoryCache < CacheKey , PooledByteBuffer > backingCache = mConfig . getEncodedMemoryCacheOverride ( ) != null ? mConfig . getEncodedMemoryCacheOverride ( ) : getEncodedCountingMemoryCache ( ) ; mEncodedMemoryCache = EncodedMemoryCacheFactory . get ( backingCache , mConfig . getImageCacheStatsTracker ( ) ) ; } return mEncodedMemoryCache ; }
public boolean canEqual ( Object obj ) { return obj instanceof TimeIntervalTypeInfo ; }
public void removeTarget ( @ NonNull Target target ) { ViewController < ? > controller = target . getTargetParent ( this ) ; if ( controller != null && ! controller . getAttachState ( ) ) { pendingTargets . remove ( target ) ; } else { if ( targets . remove ( target ) ) { } } }
default R visitIcebergMeta ( IcebergMeta icebergMeta , C context ) { return visitTableValuedFunction ( icebergMeta , context ) ; }
public void addParams ( CommandArguments args ) { args . addObjects ( params ) ; }
public static byte [ ] getRowkey ( Record record , ObHTableInfo obHTableInfo ) { byte [ ] rowkeyBuffer = { } ; for ( Triple < Integer , String , ColumnType > rowKeyElement : obHTableInfo . getRowKeyElementList ( ) ) { Integer index = rowKeyElement . getLeft ( ) ; ColumnType columnType = rowKeyElement . getRight ( ) ; if ( index == - 1 ) { String value = rowKeyElement . getMiddle ( ) ; rowkeyBuffer = Bytes . add ( rowkeyBuffer , getValueByte ( columnType , value , obHTableInfo . getEncoding ( ) ) ) ; } else { if ( index >= record . getColumnNumber ( ) ) { throw DataXException . asDataXException ( Hbase094xWriterErrorCode . CONSTRUCT_ROWKEY_ERROR , MESSAGE_SOURCE . message ( "normaltask.3" , record . getColumnNumber ( ) , index ) ) ; } byte [ ] value = getColumnByte ( columnType , record . getColumn ( index ) , obHTableInfo ) ; rowkeyBuffer = Bytes . add ( rowkeyBuffer , value ) ; } } return rowkeyBuffer ; }
public final TypeAdapter < T > nullSafe ( ) { if ( ! ( this instanceof TypeAdapter . NullSafeTypeAdapter ) ) { return new NullSafeTypeAdapter ( ) ; } return this ; }
protected MediaStreamTrack getTransceiversTrack ( String trackId ) { if ( this . configuration . sdpSemantics != PeerConnection . SdpSemantics . UNIFIED_PLAN ) { return null ; } MediaStreamTrack track = null ; List < RtpTransceiver > transceivers = peerConnection . getTransceivers ( ) ; for ( RtpTransceiver transceiver : transceivers ) { RtpReceiver receiver = transceiver . getReceiver ( ) ; if ( receiver != null ) { if ( receiver . track ( ) != null && receiver . track ( ) . id ( ) . equals ( trackId ) ) { track = receiver . track ( ) ; break ; } } } return track ; }
public static void setLevel ( int level ) { if ( level < LogLevel . ALL || level > LogLevel . OFF ) { throw new IllegalArgumentException ( "Invalid log level: " + level ) ; } nativeSetLogLevel ( level ) ; }
public Criteria andCreateTimeIn ( List < Long > values ) { addCriterion ( "create_time in" , values , "createTime" ) ; return ( Criteria ) this ; }
public AnalyzerFactory forFactory ( ) { return getTrueMenMatcher ( ) . forFactory ( ) ; }
private Boolean checkIsFollowCase ( String caseId , String userId ) { FunctionalCaseFollowerExample example = new FunctionalCaseFollowerExample ( ) ; example . createCriteria ( ) . andCaseIdEqualTo ( caseId ) . andUserIdEqualTo ( userId ) ; return functionalCaseFollowerMapper . countByExample ( example ) > 0 ; }
public void shareSingle ( ReadableMap options , Promise promise ) { TargetChosenReceiver . registerCallbacks ( promise ) ; if ( ShareIntent . hasValidKey ( "social" , options ) ) { try { ShareIntent shareClass = SHARES . getShareClass ( options . getString ( "social" ) , RCTContext ) ; if ( shareClass != null && shareClass instanceof ShareIntent ) { shareClass . open ( options ) ; } else { throw new ActivityNotFoundException ( "Invalid share activity" ) ; } } catch ( ActivityNotFoundException ex ) { Log . e ( NAME , ex . getMessage ( ) ) ; ex . printStackTrace ( System . out ) ; TargetChosenReceiver . callbackReject ( ex . getMessage ( ) ) ; } catch ( Exception e ) { Log . e ( NAME , e . getMessage ( ) ) ; e . printStackTrace ( System . out ) ; TargetChosenReceiver . callbackReject ( e . getMessage ( ) ) ; } } else { TargetChosenReceiver . callbackReject ( "key 'social' missing in options" ) ; } }
public char [ ] getTextCharacters ( int [ ] holderForStartAndLength ) { String text = getText ( ) ; if ( text == null ) { return null ; } holderForStartAndLength [ 0 ] = 0 ; holderForStartAndLength [ 1 ] = text . length ( ) ; char [ ] chars = new char [ text . length ( ) ] ; text . getChars ( 0 , text . length ( ) , chars , 0 ) ; return chars ; }
public boolean isAutoFullWithSize ( ) { return mAutoFullWithSize ; }
public Class < ? > getAnswerMessage ( ) { return null ; }
public HttpObjectCallbackDTO setResponseCallback ( Boolean responseCallback ) { this . responseCallback = responseCallback ; return this ; }
public Object get ( int position ) { return mItems . valueAt ( position ) ; }
public NDArray atan2 ( NDArray other ) { return getAlternativeArray ( ) . atan2 ( other ) ; }
public State getState ( ) { return state ; }
public void updateLiveDiskSpaceUsed ( long adjustment ) { cfstore . metric . liveDiskSpaceUsed . inc ( adjustment ) ; cfstore . metric . totalDiskSpaceUsed . inc ( adjustment ) ; }
public EntityPersister getEntityDescriptor ( ) { return entityDescriptor ; }
public void addDays ( int days ) { super . addField ( DurationFieldType . days ( ) , days ) ; }
public void didRemoveException ( long dialog_id ) { removeException ( topic . id ) ; AndroidUtilities . runOnUIThread ( ( ) -> { exceptionsTopics . remove ( topic . id ) ; updateRows ( ) ; } , 300 ) ; }
public static Map < String , String > parseUserMessage ( String xmlContent ) { return parseXmlToMap ( xmlContent , "ToUserName" , "Encrypt" ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } StopExternalService that = ( StopExternalService ) o ; return Objects . equals ( serviceName , that . serviceName ) ; }
public void hotkeyPressed ( HotkeyEvent e ) { if ( Commons . hasOption ( RUN ) ) { Runner . abortAll ( ) ; RunTime . terminate ( 254 , "AbortKey was pressed: aborting all running scripts" ) ; } }
private BlobOperationsDefinition determineOperation ( final Exchange exchange ) { return configurationProxy . getOperation ( exchange ) ; }
public static int compute ( ) { startStatus = endStatus = 0 ; for ( int j = 0 ; j < m ; j ++ ) { startStatus = set ( startStatus , j , start [ j ] ) ; endStatus = set ( endStatus , j , end [ j ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { for ( int s = 0 ; s < maxs ; s ++ ) { dp [ i ] [ j ] [ s ] = - 1 ; } } } return f ( 1 , 0 , startStatus ) ; }
public static String formatResourceLink ( Object ... formatArgs ) { String username = ( String ) formatArgs [ 0 ] ; String tweetId = ( String ) formatArgs [ 1 ] ; return String . format ( LINK_FORMAT , getShareDomain ( ) , username , tweetId ) ; }
public JsonSchemaProvider getJsonSchemaProvider ( String clusterId ) throws InvalidClusterException { if ( ! this . clusterExists ( clusterId ) ) { throw new InvalidClusterException ( INVALID_CLUSTER + clusterId + "'" ) ; } JsonSchemaProvider jsonSchemaProvider = new JsonSchemaProvider ( ) ; jsonSchemaProvider . configure ( Collections . singletonMap ( SCHEMA_VERSION_FETCHER , new CachedSchemaRegistryClient ( this . getRegistryRestClient ( clusterId ) , 1000 ) ) ) ; return jsonSchemaProvider ; }
public static boolean isWsl ( ) throws IOException { if ( WINDOWS ) { return false ; } final File f = new File ( "/proc/version" ) ; if ( ! f . exists ( ) ) { return false ; } final String output = FileUtils . readFileToString ( f , StandardCharsets . UTF_8 . name ( ) ) ; return ( output != null ) && System . getProperty ( "os.name" ) . startsWith ( "Linux" ) && output . toLowerCase ( ) . contains ( "microsoft" ) ; }
public void setRequiresGradient ( boolean requiresGrad ) { throw new UnsupportedOperationException ( UNSUPPORTED_MSG ) ; }
public void injectParser ( CustomParser parser ) { ReflectUtil . setFieldValue ( getPlanner ( ) , "parser" , new ParserWrapper ( parser ) ) ; }
public void printTo ( StringBuffer buf , ReadablePeriod period , Locale locale ) { long valueLong = getFieldValue ( period ) ; if ( valueLong == Long . MAX_VALUE ) { return ; } int value = ( int ) valueLong ; if ( iFieldType >= SECONDS_MILLIS ) { value = ( int ) ( valueLong / DateTimeConstants . MILLIS_PER_SECOND ) ; } if ( iPrefix != null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits <= 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; } else { FormatUtils . appendPaddedInteger ( buf , value , minDigits ) ; } if ( iFieldType >= SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType == SECONDS_MILLIS || dp > 0 ) { if ( valueLong < 0 && valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , '-' ) ; } buf . append ( '.' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; } } if ( iSuffix != null ) { iSuffix . printTo ( buf , value ) ; } }
private void createScreenStream ( ) { VideoTrack track = createScreenTrack ( ) ; if ( track == null ) { displayMediaPromise . reject ( new RuntimeException ( "ScreenTrack is null." ) ) ; } else { createStream ( new MediaStreamTrack [ ] { track } , ( streamId , tracksInfo ) -> { WritableMap data = Arguments . createMap ( ) ; data . putString ( "streamId" , streamId ) ; if ( tracksInfo . size ( ) == 0 ) { displayMediaPromise . reject ( new RuntimeException ( "No ScreenTrackInfo found." ) ) ; } else { data . putMap ( "track" , tracksInfo . get ( 0 ) ) ; displayMediaPromise . resolve ( data ) ; } } ) ; } mediaProjectionPermissionResultData = null ; displayMediaPromise = null ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { uuid = readUUID ( in ) ; endpoint = new RaftEndpointImpl ( uuid ) ; String host = in . readUTF ( ) ; int port = in . readInt ( ) ; try { address = new Address ( host , port ) ; } catch ( UnknownHostException ex ) { address = Address . createUnresolvedAddress ( host , port ) ; } try { autoStepDownWhenLeader = in . readBoolean ( ) ; } catch ( EOFException ignore ) { autoStepDownWhenLeader = false ; } }
public void print ( final String message ) { lwjglLogger . info ( message ) ; }
void clear ( String key ) { LinkedList < WindowManagerProxy > queue = sQueueMap . get ( key ) ; if ( queue != null ) { queue . clear ( ) ; } sQueueMap . remove ( key ) ; PopupLog . d ( TAG , queue , sQueueMap ) ; }
public void write ( ByteBuf buf , byte b ) { buf . writeByte ( b ) ; }
public static ServerInterceptor instance ( ) { return new TransmitStatusRuntimeExceptionInterceptor ( ) ; }
public RFuture < Long > sizeInMemoryAsync ( ) { List < Object > keys = Arrays . < Object > asList ( getRawName ( ) , semaphoreName ) ; return super . sizeInMemoryAsync ( keys ) ; }
public InProgressSequences with ( MultiStepOperation . SequenceKey key , MultiStepOperation < ? > sequence ) { if ( contains ( key ) ) { throw new Transformation . RejectedTransformationException ( String . format ( "Can not add a new in-progress sequence for %s, " + "since there's already one associated with it: %s" , key , get ( key ) ) ) ; } ImmutableMap . Builder < MultiStepOperation . SequenceKey , MultiStepOperation < ? > > builder = ImmutableMap . builder ( ) ; builder . put ( key , sequence ) ; for ( Map . Entry < MultiStepOperation . SequenceKey , MultiStepOperation < ? > > e : state . entrySet ( ) ) { if ( e . getKey ( ) . equals ( key ) ) continue ; builder . put ( e . getKey ( ) , e . getValue ( ) ) ; } return new InProgressSequences ( lastModified , builder . build ( ) ) ; }
public final boolean pop ( int prefix , int uri ) { if ( m_dataLength == 0 ) { return false ; } int offset = m_dataLength - 1 ; int count = m_data [ offset ] ; for ( int i = 0 , o = offset - 2 ; i != count ; ++ i , o -= 2 ) { if ( m_data [ o ] != prefix || m_data [ o + 1 ] != uri ) { continue ; } count -= 1 ; if ( i == 0 ) { m_data [ o ] = count ; o -= ( 1 + count * 2 ) ; m_data [ o ] = count ; } else { m_data [ offset ] = count ; offset -= ( 1 + 2 + count * 2 ) ; m_data [ offset ] = count ; System . arraycopy ( m_data , o + 2 , m_data , o , m_dataLength - o ) ; } m_dataLength -= 2 ; m_count -= 1 ; return true ; } return false ; }
public boolean onOutSideTouch ( MotionEvent event , boolean touchInBackground , boolean isPressed ) { if ( mHelper . isOutSideDismiss ( ) && event . getAction ( ) == MotionEvent . ACTION_UP && isPressed ) { dismiss ( ) ; return true ; } return false ; }
default void onExit ( int code , Status status ) { }
public ExpandCollapseAnimationHelper addEndAnchoredViews ( @ NonNull Collection < View > views ) { endAnchoredViews . addAll ( views ) ; return this ; }
public void onConfigurationChanged ( @ NonNull Configuration newConfig ) { super . onConfigurationChanged ( newConfig ) ; toggle . onConfigurationChanged ( newConfig ) ; }
public AbstractDataSourceProperties getValidDataSourceProperties ( ) { List < String > invalidFields = getValidField ( ) ; if ( invalidFields . size ( ) == 1 ) { try { this . getClass ( ) . getDeclaredField ( invalidFields . get ( 0 ) ) . setAccessible ( true ) ; return ( AbstractDataSourceProperties ) this . getClass ( ) . getDeclaredField ( invalidFields . get ( 0 ) ) . get ( this ) ; } catch ( IllegalAccessException e ) { } catch ( NoSuchFieldException e ) { } } return null ; }
public void setBeanFactory ( BeanFactory beanFactory ) { this . beanFactory = beanFactory ; }
public List < ModelRela > getModelRelaList ( @ RequestParam ( "domainId" ) Long domainId ) { return modelRelaService . getModelRelaList ( domainId ) ; }
public int getCurrX ( ) { return mScroller . getCurrX ( ) ; }
public int getPort ( ) { return this . serverSocket . getLocalPort ( ) ; }
public void initializeGraph ( Configuration config ) { if ( ! provided ) { this . graph = ( StandardJanusGraph ) JanusGraphFactory . open ( ( BasicConfiguration ) config ) ; } }
public static boolean isFragmentUnavailable ( @ Nullable Fragment fragment ) { return fragment == null || ! fragment . isAdded ( ) || fragment . isRemoving ( ) ; }
public void drawPlanRegion ( BuildPlan plan , Eachable < BuildPlan > list ) { drawer . drawPlan ( this , plan , list ) ; }
public List < JavaType > getGenericParameterTypes ( JavaCodeUnit codeUnit ) { return build ( genericParameterTypes , codeUnit ) ; }
public String getJdbcType ( ) { return this . jdbcType ; }
public < S > Void visit ( ExtractExpression eexpr , S context ) { if ( eexpr . getExpression ( ) != null ) { eexpr . getExpression ( ) . accept ( this , context ) ; } return null ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; UnquotedString other = ( UnquotedString ) obj ; return Objects . equals ( string , other . string ) ; }
public Load load ( ) { return _load ; }
public boolean isIconVisible ( ) { return _prefs . getBoolean ( "pref_show_icons" , true ) ; }
public boolean isDeleted ( ) { return isDeleted ; }
public boolean requiresAuthorization ( ) { return this . port . getPrefs ( ) . get ( "auth_upload" ) . contentEquals ( "yes" ) ; }
public void setTarget ( String target ) { this . target = target ; }
protected void deleteStorageGroups ( List < String > storageGroups ) throws IoTDBConnectionException , StatementExecutionException { final TSStatus status = callWithRetryAndReconnect ( ( ) -> client . deleteStorageGroups ( sessionId , storageGroups ) ) . getResult ( ) ; RpcUtils . verifySuccess ( status ) ; }
public < S > Void visit ( Insert insert , S context ) { visit ( insert . getTable ( ) , context ) ; if ( insert . getWithItemsList ( ) != null ) { for ( WithItem < ? > withItem : insert . getWithItemsList ( ) ) { withItem . accept ( ( SelectVisitor < ? > ) this , context ) ; } } if ( insert . getSelect ( ) != null ) { visit ( insert . getSelect ( ) , context ) ; } return null ; }
private static String arch ( ) { String arch = OS_ARCH . value ( ) . toLowerCase ( Locale . US ) ; if ( arch . equals ( "x86_64" ) || arch . equals ( "amd64" ) ) { return "x86_64" ; } return arch ; }
public String toString ( ) { return identifier ; }
public void setDateParam ( String date , Map < String , Object > params ) { params . put ( StaticKeys . SEARCH_START_TIME , date + " 00:00:00" ) ; params . put ( StaticKeys . SEARCH_END_TIME , date + " 23:59:59" ) ; }
public boolean isEmpty ( ) { return queue . isEmpty ( ) ; }
public static void publish ( @ NonNull Object message ) { sSubject . onNext ( message ) ; }
public void deleteDeviceProfilesByTenantId ( TenantId tenantId ) { log . trace ( "Executing deleteDeviceProfilesByTenantId, tenantId [{}]" , tenantId ) ; validateId ( tenantId , id -> INCORRECT_TENANT_ID + id ) ; tenantDeviceProfilesRemover . removeEntities ( tenantId , tenantId ) ; }
public R < Boolean > save ( @ RequestBody OptLogDTO data ) { baseOperationLogService . save ( BeanPlusUtil . toBean ( data , BaseOperationLogSaveVO . class ) ) ; return R . success ( true ) ; }
public VolumeClaimTemplatesNested < A > editFirstVolumeClaimTemplate ( ) { if ( volumeClaimTemplates . size ( ) == 0 ) { throw new RuntimeException ( String . format ( "Can't edit first %s. The list is empty." , "volumeClaimTemplates" ) ) ; } return this . setNewVolumeClaimTemplateLike ( 0 , this . buildVolumeClaimTemplate ( 0 ) ) ; }
public DecodeConfig setSupportLuminanceInvertMultiDecode ( boolean supportLuminanceInvertMultiDecode ) { isSupportLuminanceInvertMultiDecode = supportLuminanceInvertMultiDecode ; return this ; }
private int computeMaxKeyCountPerPage ( ) { final DynamicGridKeyboard tempKeyboard = new DynamicGridKeyboard ( mPrefs , mLayoutSet . getKeyboard ( KeyboardId . ELEMENT_EMOJI_RECENTS ) , 0 , 0 , ResourceUtils . getKeyboardWidth ( mContext , Settings . getValues ( ) ) ) ; return MAX_LINE_COUNT_PER_PAGE * tempKeyboard . getOccupiedColumnCount ( ) ; }
public void setTargetAlias ( String targetAlias ) { this . targetAlias = targetAlias ; }
public void ensureValid ( String name , Object o ) { if ( o == null ) { throw new ConfigException ( name , null , "Value must be non-null" ) ; } Number n = ( Number ) o ; if ( _min != null && n . doubleValue ( ) < _min . doubleValue ( ) ) { throw new ConfigException ( name , o , "Value must be at least " + _min ) ; } if ( _max != null && n . doubleValue ( ) > _max . doubleValue ( ) ) { throw new ConfigException ( name , o , "Value must be no more than " + _max ) ; } }
static boolean modifyDictionary ( Context context , String word , String dictionary , boolean add ) throws IOException , JSONException { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; String lt_user = prefs . getString ( "lt_user" , null ) ; String lt_key = prefs . getString ( "lt_key" , null ) ; String lt_uri = prefs . getString ( "lt_uri" , LT_URI_PLUS ) ; if ( TextUtils . isEmpty ( lt_user ) || TextUtils . isEmpty ( lt_key ) ) return false ; Uri . Builder builder = new Uri . Builder ( ) . appendQueryParameter ( "word" , word ) . appendQueryParameter ( "username" , lt_user ) . appendQueryParameter ( "apiKey" , lt_key ) ; if ( dictionary != null ) builder . appendQueryParameter ( "dict" , dictionary ) ; Uri uri = Uri . parse ( lt_uri ) . buildUpon ( ) . appendPath ( add ? "words/add" : "words/delete" ) . build ( ) ; String request = builder . build ( ) . toString ( ) . substring ( 1 ) ; Log . i ( "LT uri=" + uri + " request=" + request ) ; URL url = new URL ( uri . toString ( ) ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; connection . setRequestMethod ( "POST" ) ; connection . setDoOutput ( true ) ; connection . setReadTimeout ( LT_TIMEOUT * 1000 ) ; connection . setConnectTimeout ( LT_TIMEOUT * 1000 ) ; ConnectionHelper . setUserAgent ( context , connection ) ; connection . setRequestProperty ( "Accept" , "application/json" ) ; connection . setRequestProperty ( "Content-Length" , Integer . toString ( request . length ( ) ) ) ; connection . setRequestProperty ( "Content-Type" , "application/x-www-form-urlencoded" ) ; connection . connect ( ) ; try { connection . getOutputStream ( ) . write ( request . getBytes ( ) ) ; checkStatus ( connection ) ; String response = Helper . readStream ( connection . getInputStream ( ) ) ; Log . i ( "LT response=" + response ) ; JSONObject jroot = new JSONObject ( response ) ; return jroot . getBoolean ( add ? "added" : "deleted" ) ; } finally { connection . disconnect ( ) ; } }
public void execute ( ) { log . info ( "Starting migration: {}" , getKey ( ) ) ; int batchSize = 1000 ; int processedCount = 0 ; int offset = 0 ; while ( true ) { List < BookEntity > bookBatch = bookRepository . findBooksForMigrationBatch ( offset , batchSize ) ; if ( bookBatch . isEmpty ( ) ) break ; for ( BookEntity book : bookBatch ) { if ( book . getBookCoverHash ( ) == null ) { book . setBookCoverHash ( BookCoverUtils . generateCoverHash ( ) ) ; } } bookRepository . saveAll ( bookBatch ) ; processedCount += bookBatch . size ( ) ; offset += batchSize ; log . info ( "Migration progress: {} books processed" , processedCount ) ; if ( bookBatch . size ( ) < batchSize ) break ; } log . info ( "Completed migration '{}'. Total books processed: {}" , getKey ( ) , processedCount ) ; }
public void setSizes ( int width , int height , int rotation , CropState cropState ) { this . sourceWidth = width ; this . sourceCropState = cropState ; this . sourceHeight = height ; this . sourceRotation = rotation ; }
public void draw ( @ NonNull Canvas canvas , CharSequence text , int start , int end , float x , int top , int y , int bottom , @ NonNull Paint paint ) { }
public void stop ( ) { interval . unsubscribeOn ( scheduler ) ; try { if ( nc != null ) { nc . close ( ) ; } } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; LOG . error ( "Failed to close Nats connection" , e ) ; } running . set ( false ) ; }
private void SaveEchoCancelDelay ( String delayText ) { try { Integer intValue ; intValue = Integer . valueOf ( delayText ) ; echoCancelDelay = intValue ; Log . i ( TAG , "Input echo cancel delay :" + echoCancelDelay ) ; } catch ( NumberFormatException e ) { Log . i ( TAG , "Input  echo cancel delay convert exception" ) ; e . printStackTrace ( ) ; } }
public static boolean isArrayKey ( String key ) { return key != null && key . endsWith ( KEY_ARRAY ) ; }
public static String [ ] smartPathSplit ( final String pathStr , final char separatorChar , final ScanSpec scanSpec ) { if ( pathStr == null || pathStr . isEmpty ( ) ) { return new String [ 0 ] ; } if ( separatorChar != ':' ) { final List < String > partsFiltered = new ArrayList < > ( ) ; for ( final String part : pathStr . split ( String . valueOf ( separatorChar ) ) ) { final String partFiltered = part . trim ( ) ; if ( ! partFiltered . isEmpty ( ) ) { partsFiltered . add ( partFiltered ) ; } } return partsFiltered . toArray ( new String [ 0 ] ) ; } else { final Set < Integer > splitPoints = new HashSet < > ( ) ; for ( int i = - 1 ; ; ) { boolean foundNonPathSeparator = false ; for ( int j = 0 ; j < UNIX_NON_PATH_SEPARATORS . length ; j ++ ) { final int startIdx = i - UNIX_NON_PATH_SEPARATOR_COLON_POSITIONS [ j ] ; if ( pathStr . regionMatches ( true , startIdx , UNIX_NON_PATH_SEPARATORS [ j ] , 0 , UNIX_NON_PATH_SEPARATORS [ j ] . length ( ) ) && ( startIdx == 0 || pathStr . charAt ( startIdx - 1 ) == ':' ) ) { foundNonPathSeparator = true ; break ; } } if ( ! foundNonPathSeparator && scanSpec != null && scanSpec . allowedURLSchemes != null && ! scanSpec . allowedURLSchemes . isEmpty ( ) ) { for ( final String scheme : scanSpec . allowedURLSchemes ) { if ( ! scheme . equals ( "http" ) && ! scheme . equals ( "https" ) && ! scheme . equals ( "jar" ) && ! scheme . equals ( "file" ) ) { final int schemeLen = scheme . length ( ) ; final int startIdx = i - schemeLen ; if ( pathStr . regionMatches ( true , startIdx , scheme , 0 , schemeLen ) && ( startIdx == 0 || pathStr . charAt ( startIdx - 1 ) == ':' ) ) { foundNonPathSeparator = true ; break ; } } } } if ( ! foundNonPathSeparator ) { splitPoints . add ( i ) ; } i = pathStr . indexOf ( ':' , i + 1 ) ; if ( i < 0 ) { splitPoints . add ( pathStr . length ( ) ) ; break ; } } final List < Integer > splitPointsSorted = new ArrayList < > ( splitPoints ) ; CollectionUtils . sortIfNotEmpty ( splitPointsSorted ) ; final List < String > parts = new ArrayList < > ( ) ; for ( int i = 1 ; i < splitPointsSorted . size ( ) ; i ++ ) { final int idx0 = splitPointsSorted . get ( i - 1 ) ; final int idx1 = splitPointsSorted . get ( i ) ; String part = pathStr . substring ( idx0 + 1 , idx1 ) . trim ( ) ; part = DOUBLE_BACKSHLASH_WITH_COLON . matcher ( part ) . replaceAll ( ":" ) ; if ( ! part . isEmpty ( ) ) { parts . add ( part ) ; } } return parts . toArray ( new String [ 0 ] ) ; } }
private void updateLockAtMostUntil ( String transactionId , BaseDocument existingDocument , Instant lockAtMostUntil ) { setDocumentAttributes ( existingDocument , lockAtMostUntil ) ; arangoCollection . updateDocument ( existingDocument . getKey ( ) , existingDocument , new DocumentUpdateOptions ( ) . streamTransactionId ( transactionId ) ) ; }
public void obsFlatMapIterable1 ( Blackhole bh ) { obsFlatMapIterable1 . subscribe ( new PerfConsumer ( bh ) ) ; }
private void serializeRowBody ( Row row , int flags , SerializationHelper helper , DataOutputPlus out ) throws IOException { boolean isStatic = row . isStatic ( ) ; SerializationHeader header = helper . header ; Columns headerColumns = header . columns ( isStatic ) ; LivenessInfo pkLiveness = row . primaryKeyLivenessInfo ( ) ; Row . Deletion deletion = row . deletion ( ) ; if ( hasTimestamp ( flags ) ) header . writeTimestamp ( pkLiveness . timestamp ( ) , out ) ; if ( hasTTL ( flags ) ) { header . writeTTL ( pkLiveness . ttl ( ) , out ) ; header . writeLocalDeletionTime ( pkLiveness . localExpirationTime ( ) , out ) ; } if ( hasDeletion ( flags ) ) header . writeDeletionTime ( deletion . time ( ) , out ) ; if ( ( flags & HAS_ALL_COLUMNS ) == 0 ) Columns . serializer . serializeSubset ( row . columns ( ) , headerColumns , out ) ; SearchIterator < ColumnMetadata , ColumnMetadata > si = helper . header . columnsMayChanged ( ) ? helper . iterator ( isStatic ) : null ; helper . flags = flags ; helper . pkLiveness = pkLiveness ; helper . out = out ; helper . si = si ; try { row . apply ( UnfilteredSerializer :: serializeColumnData , helper ) ; } catch ( WrappedException e ) { if ( e . getCause ( ) instanceof IOException ) throw ( IOException ) e . getCause ( ) ; throw e ; } }
private void syncGroupsAndSshKeys ( User user , boolean forNewUser ) { var groupNames = authenticated . getGroupNames ( ) ; if ( forNewUser && groupNames == null ) groupNames = new HashSet < String > ( ) ; if ( groupNames != null ) { if ( getProvider ( ) . getDefaultGroup ( ) != null ) groupNames . add ( getProvider ( ) . getDefaultGroup ( ) . getName ( ) ) ; if ( settingService . getSecuritySetting ( ) . getDefaultGroupName ( ) != null ) groupNames . add ( settingService . getSecuritySetting ( ) . getDefaultGroupName ( ) ) ; membershipService . syncMemberships ( user , groupNames ) ; } if ( authenticated . getSshKeys ( ) != null ) sshKeyService . syncSshKeys ( user , authenticated . getSshKeys ( ) ) ; }
public static void print ( ) { log . info ( BANNER ) ; String version = PowerJobWorkerVersion . getVersion ( ) ; version = ( version != null ) ? " (v" + version + ")" : "" ; log . info ( ":: PowerJob Worker :: {}" , version ) ; }
public static Module combine ( Iterable < ? extends Module > modules ) { return new CombinedModule ( modules ) ; }
public List < UserInfo > findUsersByMobile ( String mobile ) { if ( StringUtils . isBlank ( mobile ) ) { return new ArrayList < > ( ) ; } LambdaQueryWrapper < UserInfo > wrapper = new LambdaQueryWrapper < > ( ) ; wrapper . eq ( UserInfo :: getMobile , mobile ) ; return userInfoMapper . selectList ( wrapper ) ; }
public void setNeedAlert ( boolean needAlert ) { this . needAlert = needAlert ; }
static ImmutableWriteResult unknown ( ) { return WriteResults . UNKNOWN ; }
public boolean isClickPort ( ) { return mClickPort ; }
public String getForbiddenUrl ( ) { return getForbiddenUrl ( null , null ) ; }
public void printTo ( Writer out , ReadablePeriod period , Locale locale ) throws IOException { PeriodPrinter [ ] printers = iPrinters ; int len = printers . length ; for ( int i = 0 ; i < len ; i ++ ) { printers [ i ] . printTo ( out , period , locale ) ; } }
public List < SignerInfo > getV2SchemeSigners ( ) { return mV2SchemeSigners ; }
public void setMarkerPaddingRight ( int markerPaddingRight ) { mMarkerPaddingRight = markerPaddingRight ; initTimeline ( ) ; }
public Class < ? > getSupportedType ( ) { return ReadableDuration . class ; }
public Criteria andLinkApplyIn ( List < String > values ) { addCriterion ( "link_apply in" , values , "linkApply" ) ; return ( Criteria ) this ; }
public void onNTRenderFrame ( int width , int height , long timestamp ) { if ( y_buffer_ == null ) return ; if ( u_buffer_ == null ) return ; if ( v_buffer_ == null ) return ; y_buffer_ . rewind ( ) ; u_buffer_ . rewind ( ) ; v_buffer_ . rewind ( ) ; Log . i ( TAG , "I420ExternalRender::onNTRenderFrame w=" + width + " h=" + height + " timestamp=" + timestamp ) ; }
public StringBuilder visit ( AsPipeOperator as , Void context ) { builder . append ( "|> " ) . append ( as . getAlias ( ) ) ; builder . append ( "\n" ) ; return builder ; }
private void setProgressBar ( boolean status , String message , int progress ) { progressBar . setIndeterminate ( status && progress <= 0 ) ; progressBar . setString ( message ) ; progressBar . setStringPainted ( true ) ; progressBar . setMaximum ( 100 ) ; if ( progress > 0 ) { progressBar . setValue ( progress ) ; } else if ( ! status ) { progressBar . setValue ( progressBar . getMaximum ( ) ) ; } }
public Criteria andNameGreaterThan ( String value ) { addCriterion ( "name >" , value , "name" ) ; return ( Criteria ) this ; }
public List < Writable > next ( ) { if ( uris == null ) throw new IllegalStateException ( "URIs are null. Not initialized?" ) ; if ( ! hasNext ( ) ) throw new NoSuchElementException ( "No next element" ) ; URI uri = uris [ cursor ++ ] ; invokeListeners ( uri ) ; String fileAsString ; try ( InputStream s = streamCreatorFn . apply ( uri ) ) { fileAsString = IOUtils . toString ( s , charset ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error reading URI file" , e ) ; } return readValues ( uri , fileAsString ) ; }
private void replaceAll ( ) { if ( findField . getText ( ) . length ( ) == 0 ) { return ; } if ( searchAllFilesBox . isSelected ( ) ) { editor . selectTab ( 0 ) ; } editor . getCurrentTab ( ) . setSelection ( 0 , 0 ) ; boolean foundAtLeastOne = false ; while ( true ) { if ( find ( false , false , searchAllFilesBox . isSelected ( ) , - 1 ) ) { foundAtLeastOne = true ; editor . getCurrentTab ( ) . setSelectedText ( replaceField . getText ( ) ) ; } else { break ; } } if ( ! foundAtLeastOne ) { Toolkit . getDefaultToolkit ( ) . beep ( ) ; } }
public void serialize ( ColumnDef def , JsonGenerator jgen , SerializerProvider provider ) throws IOException , JsonProcessingException { jgen . writeStartObject ( ) ; jgen . writeStringField ( "type" , def . getType ( ) ) ; jgen . writeStringField ( "name" , def . getName ( ) ) ; if ( def instanceof StringColumnDef ) { jgen . writeStringField ( "charset" , ( ( StringColumnDef ) def ) . getCharset ( ) ) ; } else if ( def instanceof IntColumnDef ) { jgen . writeBooleanField ( "signed" , ( ( IntColumnDef ) def ) . isSigned ( ) ) ; } else if ( def instanceof BigIntColumnDef ) { jgen . writeBooleanField ( "signed" , ( ( BigIntColumnDef ) def ) . isSigned ( ) ) ; } else if ( def instanceof EnumeratedColumnDef ) { jgen . writeArrayFieldStart ( "enum-values" ) ; for ( String s : ( ( EnumeratedColumnDef ) def ) . getEnumValues ( ) ) jgen . writeString ( s ) ; jgen . writeEndArray ( ) ; } else if ( def instanceof ColumnDefWithLength ) { Long columnLength = ( ( ColumnDefWithLength ) def ) . getColumnLength ( ) ; if ( columnLength != null ) jgen . writeNumberField ( "column-length" , columnLength ) ; } jgen . writeEndObject ( ) ; }
public ReadableProductOptionEntity convert ( ProductOption source , MerchantStore store , Language language ) { ReadableProductOptionEntity destination = new ReadableProductOptionEntity ( ) ; return merge ( source , destination , store , language ) ; }
private Map < String , String > buildStateAbbrevTable ( ) { Map < String , String > states = new HashMap < String , String > ( ) ; states . put ( "Alabama" , "AL" ) ; states . put ( "Alaska" , "AK" ) ; states . put ( "Alberta" , "AB" ) ; states . put ( "American Samoa" , "AS" ) ; states . put ( "Arizona" , "AZ" ) ; states . put ( "Arkansas" , "AR" ) ; states . put ( "Armed Forces (AE)" , "AE" ) ; states . put ( "Armed Forces Americas" , "AA" ) ; states . put ( "Armed Forces Pacific" , "AP" ) ; states . put ( "British Columbia" , "BC" ) ; states . put ( "California" , "CA" ) ; states . put ( "Colorado" , "CO" ) ; states . put ( "Connecticut" , "CT" ) ; states . put ( "Delaware" , "DE" ) ; states . put ( "District of Columbia" , "DC" ) ; states . put ( "Florida" , "FL" ) ; states . put ( "Georgia" , "GA" ) ; states . put ( "Guam" , "GU" ) ; states . put ( "Hawaii" , "HI" ) ; states . put ( "Idaho" , "ID" ) ; states . put ( "Illinois" , "IL" ) ; states . put ( "Indiana" , "IN" ) ; states . put ( "Iowa" , "IA" ) ; states . put ( "Kansas" , "KS" ) ; states . put ( "Kentucky" , "KY" ) ; states . put ( "Louisiana" , "LA" ) ; states . put ( "Maine" , "ME" ) ; states . put ( "Manitoba" , "MB" ) ; states . put ( "Maryland" , "MD" ) ; states . put ( "Massachusetts" , "MA" ) ; states . put ( "Michigan" , "MI" ) ; states . put ( "Minnesota" , "MN" ) ; states . put ( "Mississippi" , "MS" ) ; states . put ( "Missouri" , "MO" ) ; states . put ( "Montana" , "MT" ) ; states . put ( "Nebraska" , "NE" ) ; states . put ( "Nevada" , "NV" ) ; states . put ( "New Brunswick" , "NB" ) ; states . put ( "New Hampshire" , "NH" ) ; states . put ( "New Jersey" , "NJ" ) ; states . put ( "New Mexico" , "NM" ) ; states . put ( "New York" , "NY" ) ; states . put ( "Newfoundland" , "NF" ) ; states . put ( "North Carolina" , "NC" ) ; states . put ( "North Dakota" , "ND" ) ; states . put ( "Northwest Territories" , "NT" ) ; states . put ( "Nova Scotia" , "NS" ) ; states . put ( "Nunavut" , "NU" ) ; states . put ( "Ohio" , "OH" ) ; states . put ( "Oklahoma" , "OK" ) ; states . put ( "Ontario" , "ON" ) ; states . put ( "Oregon" , "OR" ) ; states . put ( "Pennsylvania" , "PA" ) ; states . put ( "Prince Edward Island" , "PE" ) ; states . put ( "Puerto Rico" , "PR" ) ; states . put ( "Quebec" , "QC" ) ; states . put ( "Rhode Island" , "RI" ) ; states . put ( "Saskatchewan" , "SK" ) ; states . put ( "South Carolina" , "SC" ) ; states . put ( "South Dakota" , "SD" ) ; states . put ( "Tennessee" , "TN" ) ; states . put ( "Texas" , "TX" ) ; states . put ( "Utah" , "UT" ) ; states . put ( "Vermont" , "VT" ) ; states . put ( "Virgin Islands" , "VI" ) ; states . put ( "Virginia" , "VA" ) ; states . put ( "Washington" , "WA" ) ; states . put ( "West Virginia" , "WV" ) ; states . put ( "Wisconsin" , "WI" ) ; states . put ( "Wyoming" , "WY" ) ; states . put ( "Yukon Territory" , "YT" ) ; return states ; }
protected UnitTest parseUnitTest ( final XmlElement unitTestElement ) { final String name = unitTestElement . getAttribute ( NAME_ATTRIBUTE ) ; final String className = unitTestElement . getFirst ( TEST_METHOD_ELEMENT ) . map ( testMethod -> testMethod . getAttribute ( CLASS_NAME_ATTRIBUTE ) ) . orElse ( null ) ; final String description = unitTestElement . getFirst ( DESCRIPTION_ELEMENT ) . map ( XmlElement :: getValue ) . orElse ( null ) ; final String executionId = unitTestElement . getFirst ( EXECUTION_ELEMENT ) . map ( execution -> execution . getAttribute ( ID_ATTRIBUTE ) ) . orElse ( null ) ; final Map < String , String > properties = parseProperties ( unitTestElement ) ; return new UnitTest ( name , className , executionId , description , properties ) ; }
protected float getAngleSpeedDirection ( ) { RotationDirection rotationDirection = RotationDirection . values ( ) [ movementDirection . getValue ( ) ] ; return ( rotationDirection == RotationDirection . CLOCKWISE ? 1 : - 1 ) ; }
public void valueChanged ( TreeSelectionEvent e ) { JTree selectedTree = ( JTree ) e . getSource ( ) ; TreePath path = selectedTree . getSelectionPath ( ) ; if ( path != null ) { TreeNodeWrapper treeNode = ( TreeNodeWrapper ) path . getLastPathComponent ( ) ; viewer . setTree ( ( Tree ) treeNode . getUserObject ( ) ) ; } }
public final int getArgumentCount ( ) { if ( null == this . arguments ) { return 0 ; } else { return this . arguments . length ; } }
public static Builder builder ( ) { return new Builder ( ) ; }
public Criteria andDiscountMoneyLessThan ( BigDecimal value ) { addCriterion ( "discount_money <" , value , "discountMoney" ) ; return ( Criteria ) this ; }
public double getScale ( ) { return scale ; }
final protected int getArrowDeltaX ( ) { return arrowDeltaX ; }
public static SecretKey deriveKey ( Params params ) { try { if ( params . getAlgorithm ( ) . equals ( "PBKDF2withHmacSHA512" ) ) { PKCS5S2ParametersGenerator gen = new PKCS5S2ParametersGenerator ( new SHA512Digest ( ) ) ; gen . init ( CryptoUtils . toBytes ( params . getPassword ( ) ) , params . getSalt ( ) , params . getIterations ( ) ) ; byte [ ] key = ( ( KeyParameter ) gen . generateDerivedParameters ( params . getKeySize ( ) ) ) . getKey ( ) ; return new SecretKeySpec ( key , "AES" ) ; } SecretKeyFactory factory = SecretKeyFactory . getInstance ( params . getAlgorithm ( ) ) ; KeySpec spec = new PBEKeySpec ( params . getPassword ( ) , params . getSalt ( ) , params . getIterations ( ) , params . getKeySize ( ) ) ; SecretKey key = factory . generateSecret ( spec ) ; return new SecretKeySpec ( key . getEncoded ( ) , "AES" ) ; } catch ( NoSuchAlgorithmException | InvalidKeySpecException e ) { throw new RuntimeException ( e ) ; } }
public static OperationResult runCommandExtension ( final Configuration configuration , final String command , final List < String > flags ) { return configuration . getPluginRegister ( ) . getInstancesOf ( CommandExtension . class ) . stream ( ) . filter ( commandExtension -> commandExtension . handlesCommand ( command ) ) . findFirst ( ) . map ( commandExtension -> commandExtension . handle ( configuration , flags ) ) . orElseThrow ( ( ) -> new FlywayException ( "No command extension found to handle command: " + command ) ) ; }
public void append ( byte [ ] utf8 , int start , int len ) { setCapacity ( length + len , true ) ; System . arraycopy ( utf8 , start , bytes , length , len ) ; length += len ; }
public final T next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "next() on empty iterator" ) ; } return getNext ( ) ; }
public void setX ( int x ) { this . x = x ; }
public void onNestedScroll ( View target , int dxConsumed , int dyConsumed , int dxUnconsumed , int dyUnconsumed ) { scrollTo ( getScrollX ( ) , getScrollY ( ) + dyUnconsumed ) ; }
public void setValue ( @ PluralsRes int pluralRes , int quantity , @ Nullable Object [ ] formatArgs ) { if ( pluralRes != 0 ) { this . pluralRes = pluralRes ; this . quantity = quantity ; this . formatArgs = formatArgs ; string = null ; stringRes = 0 ; } else { handleInvalidStringRes ( ) ; } }
public void setIsSelected ( boolean isSelected , boolean animated ) { this . isSelected . setValue ( isSelected , animated ) ; }
abstract Optional < Boolean > getExported ( ) ; abstract Optional < IntentFilter > getIntentFilter ( ) ; public static Builder builder ( ) { return new AutoValue_Receiver . Builder ( ) ; }
public void insert ( int index , double [ ] values ) { if ( index < 0 ) { throw new IllegalArgumentException ( "insert() index cannot be negative: it was " + index ) ; } if ( index >= data . length ) { throw new IllegalArgumentException ( "insert() index " + index + " is past the end of this list" ) ; } double [ ] temp = new double [ count + values . length ] ; System . arraycopy ( data , 0 , temp , 0 , Math . min ( count , index ) ) ; System . arraycopy ( values , 0 , temp , index , values . length ) ; System . arraycopy ( data , index , temp , index + values . length , count - index ) ; count = count + values . length ; data = temp ; }
public static < T > Supplier < T > defaultInstanceGetter ( Class < T > clazz ) { return new DefaultInstanceGetter < > ( clazz ) ; }
public boolean isDefault ( ) { return typeMirror == null || "picocli.CommandLine.NoVersionProvider" . equals ( getTypeElement ( ) . getQualifiedName ( ) . toString ( ) ) ; }
public ContentLayout getContentWrap ( ) { return contentWrap ; }
private boolean containsGroup ( final Set < Group > userGroups , final AccessPolicy policy ) { if ( userGroups . isEmpty ( ) || policy . getGroups ( ) . isEmpty ( ) ) { return false ; } for ( Group userGroup : userGroups ) { if ( policy . getGroups ( ) . contains ( userGroup . getIdentifier ( ) ) ) { return true ; } } return false ; }
protected TypeScopeReference associatedTypeFromResolvedModule ( BindingsMap . ResolvedModule module ) { return TypeScopeReference . moduleAssociatedType ( module . qualifiedName ( ) ) ; }
public void setSplitPos ( org . openxmlformats . schemas . drawingml . x2006 . chart . CTDouble splitPos ) { generatedSetterHelperImpl ( splitPos , PROPERTY_QNAME [ 6 ] , 0 , org . apache . xmlbeans . impl . values . XmlObjectBase . KIND_SETTERHELPER_SINGLETON ) ; }
private Object getProperty ( Object object , String propertyPath ) { try { return beanUtilsBean . getPropertyUtils ( ) . getProperty ( object , propertyPath ) ; } catch ( Exception e ) { throw new ConfigurationException ( "Unable to access property '" + propertyPath + "'" , e ) ; } }
public void notifyDropped ( DurationSpec . IntSecondsBound ttl ) { notify ( new TableDroppedNotification ( cfstore , ttl ) ) ; }
public void onImeTopChanged ( int imeTop ) { BubbleBarExpandedView bbev = getExpandedView ( ) ; if ( bbev == null ) { Log . w ( TAG , "Bubble bar expanded view was null when IME top changed" ) ; return ; } bbev . onImeTopChanged ( imeTop ) ; }
public void write ( MemoryBuffer buffer , final URI uri ) { fory . writeString ( buffer , uri . toString ( ) ) ; }
public Object execute ( Connection conn ) throws JobPersistenceException { return removeTrigger ( conn , triggerKey ) ? Boolean . TRUE : Boolean . FALSE ; }
public Criteria andUrlNotEqualTo ( String value ) { addCriterion ( "url <>" , value , "url" ) ; return ( Criteria ) this ; }
public void setPosition ( double lng , double lat , double alt ) { mLocHandler . removeMessages ( HANDLER_MSG_ID ) ; mCurLng = lng ; mCurLat = lat ; mCurAlt = alt ; mLocHandler . sendEmptyMessage ( HANDLER_MSG_ID ) ; mJoyStick . setCurrentPosition ( mCurLng , mCurLat , mCurAlt ) ; }
static String getSeedSource ( ) { return seedSource ; }
public static Date getNextMonthStartDay ( ) { return DateUtil . beginOfMonth ( DateUtil . nextMonth ( ) ) ; }
public void serialize ( Object value , JsonGenerator gen , SerializationContext provider ) throws JacksonException { if ( radix < Character . MIN_RADIX || radix > Character . MAX_RADIX ) { String errorMsg = String . format ( "To use a custom radix for string serialization, use radix within [%d, %d]" , Character . MIN_RADIX , Character . MAX_RADIX ) ; provider . reportBadDefinition ( handledType ( ) , errorMsg ) ; } String text = "" ; if ( value instanceof BigInteger ) { BigInteger bigIntegerValue = ( BigInteger ) value ; text = bigIntegerValue . toString ( radix ) ; } else if ( value instanceof Byte || value instanceof Short || value instanceof Integer || value instanceof Long ) { long longValue = ( ( Number ) value ) . longValue ( ) ; text = Long . toString ( longValue , radix ) ; } else { provider . reportBadDefinition ( handledType ( ) , "Trying to serialize a non-whole number with NumberToStringWithRadixSerializer" ) ; } gen . writeString ( text ) ; }
private boolean isValidLiteralValue ( Value < ? > value , GraphQLList type , GraphQLSchema schema , GraphQLContext graphQLContext , Locale locale ) { GraphQLType wrappedType = type . getWrappedType ( ) ; if ( value instanceof ArrayValue ) { List < Value > values = ( ( ArrayValue ) value ) . getValues ( ) ; for ( int i = 0 ; i < values . size ( ) ; i ++ ) { if ( ! isValidLiteralValue ( values . get ( i ) , wrappedType , schema , graphQLContext , locale ) ) { handleFieldNotValidError ( values . get ( i ) , wrappedType , i ) ; return false ; } } return true ; } else { return isValidLiteralValue ( value , wrappedType , schema , graphQLContext , locale ) ; } }
public String getModular ( ) { return CacheKeyModular . SYSTEM ; }
public Criteria andRemarkLessThan ( String value ) { addCriterion ( "remark <" , value , "remark" ) ; return ( Criteria ) this ; }
public List < WebRTCViewerInfo > getWebRTCViewerList ( int offset , int size , String sortBy , String orderBy , String search ) { long startTime = System . nanoTime ( ) ; List < WebRTCViewerInfo > viewerList = new ArrayList < > ( ) ; synchronized ( broadcastLock ) { Query < WebRTCViewerInfo > query = datastore . find ( WebRTCViewerInfo . class ) ; if ( size > MAX_ITEM_IN_ONE_LIST ) { size = MAX_ITEM_IN_ONE_LIST ; } FindOptions findOptions = new FindOptions ( ) . skip ( offset ) . limit ( size ) ; if ( sortBy != null && orderBy != null && ! sortBy . isEmpty ( ) && ! orderBy . isEmpty ( ) ) { findOptions . sort ( orderBy . equals ( "desc" ) ? Sort . descending ( sortBy ) : Sort . ascending ( sortBy ) ) ; } if ( search != null && ! search . isEmpty ( ) ) { logger . info ( "Server side search is called for WebRTCViewerInfo = {}" , search ) ; query . filter ( Filters . regex ( VIEWER_ID ) . caseInsensitive ( ) . pattern ( ".*" + search + ".*" ) ) ; } viewerList = query . iterator ( findOptions ) . toList ( ) ; } recordQueryDuration ( startTime , "getWebRTCViewerList" ) ; return viewerList ; }
public < S > Void visit ( Division division , S context ) { visitBinaryExpression ( division ) ; return null ; }
public String get ( byte byID ) { return get ( ( long ) byID ) ; }
public float getBackgroundStrokeWidth ( ) { return mBackground . getStrokeWidth ( ) ; }
protected void onSizeChanged ( int w , int h , int oldw , int oldh ) { super . onSizeChanged ( w , h , oldw , oldh ) ; blurController . updateBlurViewSize ( ) ; }
public boolean isBlurAsync ( ) { return mBlurAsync ; }
public String getGlobalRouteRegion ( ) { RuleEntity ruleEntity = pluginAdapter . getRule ( ) ; if ( ruleEntity != null ) { StrategyEntity strategyEntity = ruleEntity . getStrategyEntity ( ) ; if ( strategyEntity != null ) { return strategyEntity . getRegionValue ( ) ; } } return null ; }
public void updateEmail ( final RequestContext context ) { context . renderJSON ( StatusCodes . ERR ) ; final Request request = context . getRequest ( ) ; final JSONObject requestJSONObject = context . requestJSON ( ) ; final String captcha = requestJSONObject . optString ( CaptchaProcessor . CAPTCHA ) ; final JSONObject currentUser = Sessions . getUser ( ) ; final String userId = currentUser . optString ( Keys . OBJECT_ID ) ; try { final JSONObject verifycode = verifycodeQueryService . getVerifycodeByUserId ( Verifycode . TYPE_C_EMAIL , Verifycode . BIZ_TYPE_C_BIND_EMAIL , userId ) ; if ( null == verifycode ) { final String msg = langPropsService . get ( "updateFailLabel" ) + " - " + langPropsService . get ( "captchaErrorLabel" ) ; context . renderMsg ( msg ) ; context . renderJSONValue ( Keys . CODE , 2 ) ; return ; } if ( ! StringUtils . equals ( verifycode . optString ( Verifycode . CODE ) , captcha ) ) { final String msg = langPropsService . get ( "updateFailLabel" ) + " - " + langPropsService . get ( "captchaErrorLabel" ) ; context . renderMsg ( msg ) ; context . renderJSONValue ( Keys . CODE , 2 ) ; return ; } final JSONObject user = userQueryService . getUser ( userId ) ; final String email = verifycode . optString ( Verifycode . RECEIVER ) ; user . put ( User . USER_EMAIL , email ) ; userMgmtService . updateUserEmail ( userId , user ) ; verifycodeMgmtService . removeByCode ( captcha ) ; context . renderJSON ( StatusCodes . SUCC ) ; } catch ( final ServiceException e ) { context . renderMsg ( e . getMessage ( ) ) ; } }
public Criteria andAccountIdListLessThan ( String value ) { addCriterion ( "account_id_list <" , value , "accountIdList" ) ; return ( Criteria ) this ; }
private void updatePreviewItems ( boolean animate ) { mPreviewItemManager . updatePreviewItems ( animate ) ; mCurrentPreviewItems . clear ( ) ; mCurrentPreviewItems . addAll ( getPreviewItemsOnPage ( 0 ) ) ; }
public Long convert ( Object obj ) { return unit . convert ( ( Long ) obj , source ) ; }
public INDArray unsortedSegmentProd ( INDArray data , INDArray segmentIds , int numSegments ) { NDValidation . validateNumerical ( "unsortedSegmentProd" , "data" , data ) ; NDValidation . validateNumerical ( "unsortedSegmentProd" , "segmentIds" , segmentIds ) ; return Nd4j . exec ( new org . nd4j . linalg . api . ops . impl . transforms . segment . UnsortedSegmentProd ( data , segmentIds , numSegments ) ) [ 0 ] ; }
public int getAttributeValueType ( int index ) { int offset = getAttributeOffset ( index ) ; return m_attributes [ offset + ATTRIBUTE_IX_VALUE_TYPE ] ; }
public boolean execute ( LocalDataArea lda ) { if ( ! lda . stackHasMinSize ( 2 ) ) { return false ; } String objectName = lda . popAsString ( ) ; int numArgs = ( int ) ( double ) lda . popAsNumber ( ) ; if ( ! lda . stackHasMinSize ( numArgs ) ) { return false ; } List < Object > args = new ArrayList < > ( ) ; for ( int i = 0 ; i < numArgs ; i ++ ) { args . add ( lda . pop ( ) ) ; } ActionScriptObject obj = new ActionScriptObject ( ) ; lda . push ( obj ) ; return true ; }
public int count ( @ Nullable Object element ) { int index = elementSet . indexOf ( element ) ; return ( index >= 0 ) ? getCount ( index ) : 0 ; }
private static String fromMotionEvent ( MotionEvent motionEvent ) { return actionToString ( motionEvent . getAction ( ) ) ; }
public void onNTFrameSizeChanged ( int width , int height ) { width_ = width ; height_ = height ; row_bytes_ = width_ * 4 ; Log . i ( TAG , "RGBAExternalRender::onNTFrameSizeChanged width_:" + width_ + " height_:" + height_ ) ; rgba_buffer_ = ByteBuffer . allocateDirect ( row_bytes_ * height_ ) ; }
public F getFirst ( ) { return mFirst ; }
public void stop ( ) { if ( ! started ) { throw new IllegalStateException ( getClass ( ) . getSimpleName ( ) + " not started." ) ; } for ( Service < T > s : services ) { if ( log . isLoggable ( Level . FINE ) ) { log . log ( Level . FINE , "Stopping service:{0}" , s ) ; } s . stop ( ) ; } started = false ; }
public void printTo ( Writer out , ReadablePeriod period , Locale locale ) throws IOException { long valueLong = getFieldValue ( period ) ; if ( valueLong == Long . MAX_VALUE ) { return ; } int value = ( int ) valueLong ; if ( iFieldType >= SECONDS_MILLIS ) { value = ( int ) ( valueLong / DateTimeConstants . MILLIS_PER_SECOND ) ; } if ( iPrefix != null ) { iPrefix . printTo ( out , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits <= 1 ) { FormatUtils . writeUnpaddedInteger ( out , value ) ; } else { FormatUtils . writePaddedInteger ( out , value , minDigits ) ; } if ( iFieldType >= SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType == SECONDS_MILLIS || dp > 0 ) { out . write ( '.' ) ; FormatUtils . writePaddedInteger ( out , dp , 3 ) ; } } if ( iSuffix != null ) { iSuffix . printTo ( out , value ) ; } }
BinaryDecoder configure ( InputStream in , int bufferSize ) { configureSource ( bufferSize , new InputStreamByteSource ( in ) ) ; return this ; }
public void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { if ( api < Opcodes . ASM5 ) { if ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) { throw new IllegalArgumentException ( "INVOKESPECIAL/STATIC on interfaces requires ASM5" ) ; } visitMethodInsn ( opcode , owner , name , descriptor ) ; return ; } if ( mv != null ) { mv . visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; } }
public byte [ ] onChallenge ( final byte [ ] encodedChallenge ) { throw new ArchiveException ( "Replication does not support challenge/response authentication" ) ; }
public boolean isEating ( ) { return this . getHandle ( ) . isEating ( ) ; }
public void setWithApiResponseDoc ( boolean withApiDoc ) { this . withApiResponseDoc = withApiDoc ; }
public Builder enableShowWhenAppBackground ( boolean enableShowWhenAppBackground ) { this . popupInfo . enableShowWhenAppBackground = enableShowWhenAppBackground ; return this ; }
public Criteria andCreateUserLike ( String value ) { addCriterion ( "create_user like" , value , "createUser" ) ; return ( Criteria ) this ; }
public void setVeryHidden ( boolean sheetVeryHidden ) { this . sheetVeryHidden = sheetVeryHidden ; }
public < T > Http3Settings set ( HttpSetting < T > setting , T value ) { return ( Http3Settings ) super . set ( setting , value ) ; }
public String toString ( ) { return displayName ; }
int batchSize ( ) ; @ WithDefault ( "true" ) boolean keepStarredEntries ( ) ; default Instant statusesInstantThreshold ( ) { return statusesMaxAge ( ) . toMillis ( ) > 0 ? Instant . now ( ) . minus ( statusesMaxAge ( ) ) : null ; }
public GenericSecretSource getClientSecret ( ) { return clientSecret ; }
public AnimatableGradientColorValue getGradientColor ( ) { return gradientColor ; }
private static File getPreferencesFile ( ) { String home = System . getProperty ( "user.home" ) ; return new File ( home , "junit.properties" ) ; }
public JSONObject getByTitle ( final String domainTitle ) { try { final JSONObject ret = domainRepository . getByTitle ( domainTitle ) ; if ( null == ret ) { return null ; } if ( Domain . DOMAIN_STATUS_C_VALID != ret . optInt ( Domain . DOMAIN_STATUS ) ) { return null ; } String description = ret . optString ( Domain . DOMAIN_DESCRIPTION ) ; String descriptionText = ret . optString ( Domain . DOMAIN_TITLE ) ; if ( StringUtils . isNotBlank ( description ) ) { description = Markdowns . toHTML ( description ) ; ret . put ( Domain . DOMAIN_DESCRIPTION , description ) ; descriptionText = Jsoup . parse ( description ) . text ( ) ; } if ( StringUtils . isBlank ( ret . optString ( Domain . DOMAIN_SEO_TITLE ) ) ) { ret . put ( Domain . DOMAIN_SEO_TITLE , domainTitle ) ; } if ( StringUtils . isBlank ( ret . optString ( Domain . DOMAIN_SEO_DESC ) ) ) { ret . put ( Domain . DOMAIN_SEO_DESC , descriptionText ) ; } if ( StringUtils . isBlank ( ret . optString ( Domain . DOMAIN_SEO_KEYWORDS ) ) ) { ret . put ( Domain . DOMAIN_SEO_KEYWORDS , domainTitle ) ; } return ret ; } catch ( final RepositoryException e ) { LOGGER . log ( Level . ERROR , "Gets domain [title=" + domainTitle + "] failed" , e ) ; return null ; } }
public Object getPrintData ( ) throws IOException { return printData ; }
public void handleEvent ( Event event ) { var fileDialog = new FileDialog ( resultTable . getShell ( ) , SWT . OPEN ) ; List < String > extensions2 = new ArrayList < > ( ) ; List < String > descriptions = new ArrayList < > ( ) ; var labelBuffer = new StringBuffer ( Labels . getLabel ( "title.load" ) ) ; addFileExtensions ( extensions2 , descriptions , labelBuffer ) ; List < String > extensions = new ArrayList < > ( ) ; extensions . add ( extensions2 . get ( 0 ) ) ; fileDialog . setText ( labelBuffer . toString ( ) ) ; fileDialog . setFilterExtensions ( extensions . toArray ( new String [ extensions . size ( ) ] ) ) ; fileDialog . setFilterNames ( descriptions . toArray ( new String [ descriptions . size ( ) ] ) ) ; var fileName = fileDialog . open ( ) ; if ( fileName == null ) return ; loadResultsFrom ( fileName ) ; }
public long getPacketsSent ( ) { return this . packetsSent ; }
private void insertCast ( String funcText , List < T > children ) throws SemanticException { if ( funcText . equals ( "substring" ) || funcText . equals ( "concat" ) ) { if ( children . size ( ) > 0 && ! isStringType ( exprFactory . getTypeInfo ( children . get ( 0 ) ) ) ) { T newColumn = createConversionCast ( children . get ( 0 ) , TypeInfoFactory . stringTypeInfo ) ; children . set ( 0 , newColumn ) ; } } if ( funcText . equalsIgnoreCase ( "and" ) || funcText . equalsIgnoreCase ( "or" ) || funcText . equalsIgnoreCase ( "not" ) || funcText . equalsIgnoreCase ( "!" ) ) { for ( int i = 0 ; i < children . size ( ) ; i ++ ) { T child = children . get ( i ) ; TypeInfo typeInfo = exprFactory . getTypeInfo ( child ) ; if ( ! TypeInfoFactory . booleanTypeInfo . accept ( typeInfo ) ) { if ( typeInfo . getCategory ( ) == ObjectInspector . Category . PRIMITIVE ) { children . set ( i , createConversionCast ( child , TypeInfoFactory . booleanTypeInfo ) ) ; } else { child = exprFactory . createFuncCallExpr ( TypeInfoFactory . booleanTypeInfo , exprFactory . getFunctionInfo ( "isnotnull" ) , "isnotnull" , Arrays . asList ( child ) ) ; children . set ( i , child ) ; } } } } }
public String getFirstPortal ( ) { return this . portals . get ( 0 ) ; }
public int getDisplayId ( ) { return mDisplayId ; }
public HazelcastCommand getCommand ( ) { return command ; }
public long skip ( long n ) throws IOException { int lim = ba . getLim ( ) ; int pos = ba . getPos ( ) ; int remaining = lim - pos ; if ( remaining > n ) { pos = ( int ) ( pos + n ) ; ba . setPos ( pos ) ; return n ; } else { pos = lim ; ba . setPos ( pos ) ; long isSkipCount = trySkipBytes ( n - remaining ) ; return isSkipCount + remaining ; } }
public String readUTF8 ( final int offset , final char [ ] charBuffer ) { int constantPoolEntryIndex = readUnsignedShort ( offset ) ; if ( offset == 0 || constantPoolEntryIndex == 0 ) { return null ; } return readUTF ( constantPoolEntryIndex , charBuffer ) ; }
public String getNamespaceURI ( String prefix ) { return doc . lookupNamespaceURI ( prefix ) ; }
public Collection < AbstractFile > visit ( VolumeSystem vs ) { return getAllFromChildren ( vs ) ; }
void addChars ( int numChars ) { totalChars += numChars ; }
public int getInt32 ( int offset ) { return data . getInt ( offset ) ; }
public static VideoThumbLoader getInstance ( ) { if ( instance == null ) { synchronized ( VideoThumbLoader . class ) { if ( instance == null ) { instance = new VideoThumbLoader ( ) ; } } } return instance ; }
public boolean isXml ( ) { switch ( this ) { case XML : case RDFXML : return true ; default : return false ; } }
public static String analyzeRefreshMode ( Map < String , String > properties ) { String refreshMode = null ; if ( properties != null && properties . containsKey ( PROPERTIES_MV_REFRESH_MODE ) ) { refreshMode = properties . get ( PROPERTIES_MV_REFRESH_MODE ) ; try { MaterializedView . RefreshMode . valueOf ( refreshMode . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( "Invalid refresh_mode: " + refreshMode + ". Only " + EnumUtils . getEnumList ( MaterializedView . RefreshMode . class ) . stream ( ) . map ( MaterializedView . RefreshMode :: name ) . collect ( Collectors . joining ( ", " ) ) + " are supported." ) ; } properties . remove ( PROPERTIES_MV_REFRESH_MODE ) ; } return refreshMode ; }
public void printTo ( Appendable appendable , ReadablePartial partial , Locale locale ) throws IOException { int year = getTwoDigitYear ( partial ) ; if ( year < 0 ) { appendable . append ( '' ) ; appendable . append ( '' ) ; } else { FormatUtils . appendPaddedInteger ( appendable , year , 2 ) ; } }
public void windowDeactivated ( WindowEvent e ) { activeChanged ( false ) ; updateNativeTitleBarHeightAndHitTestSpots ( ) ; repaintBorder ( ) ; }
public static CodeUnitAccessTargetBuilder < JavaConstructor , ConstructorReferenceTarget > newConstructorReferenceTargetBuilder ( ) { return new CodeUnitAccessTargetBuilder < > ( DomainObjectCreationContext :: createConstructorReferenceTarget ) . withName ( CONSTRUCTOR_NAME ) ; }
private void addSetProperty ( JDefinedClass jclass , JBlock callSite , String propertyName , JType propertyType , JVar valueVar , JsonNode node ) { JMethod propertySetter = jclass . getMethod ( getSetterName ( propertyName , node ) , new JType [ ] { propertyType } ) ; JConditional isInstance = callSite . _if ( valueVar . _instanceof ( propertyType . boxify ( ) . erasure ( ) ) ) ; isInstance . _then ( ) . invoke ( propertySetter ) . arg ( cast ( propertyType . boxify ( ) , valueVar ) ) ; isInstance . _else ( ) . _throw ( illegalArgumentInvocation ( jclass , propertyName , propertyType , valueVar ) ) ; }
private T interpretNodeAsConstant ( PrimitiveTypeInfo targetType , T constChild , boolean isEqual ) throws SemanticException { if ( exprFactory . isConstantExpr ( constChild ) ) { Object constVal = exprFactory . getConstantValue ( constChild ) ; if ( constVal == null ) { return exprFactory . createConstantExpr ( targetType , null ) ; } PrimitiveTypeInfo sourceType = ( PrimitiveTypeInfo ) exprFactory . getTypeInfo ( constChild ) ; Object newConst = exprFactory . interpretConstantAsPrimitive ( targetType , constVal , sourceType , isEqual ) ; if ( newConst == null ) { return null ; } if ( newConst == constVal ) { return constChild ; } else { return exprFactory . createConstantExpr ( exprFactory . adjustConstantType ( targetType , newConst ) , newConst ) ; } } return constChild ; }
public < S > StringBuilder visit ( TableStatement tableStatement , S context ) { new TableStatementDeParser ( expressionVisitor , builder ) . deParse ( tableStatement ) ; return builder ; }
public BannerOptions getBannerOptions ( ) { if ( mBannerOptions == null ) { mBannerOptions = new BannerOptions ( ) ; } return mBannerOptions ; }
public final ThemeListenerEntry addOrUpdateThemeTextColorListener ( Object view , @ ColorId int colorId ) { ThemeListenerEntry entry = getThemeListeners ( ) . findThemeListenerByTarget ( view , ThemeListenerEntry . MODE_TEXT_COLOR ) ; if ( entry != null ) { entry . setTargetColorId ( colorId ) ; return entry ; } return addThemeTextColorListener ( view , colorId ) ; }
public SmartForest < T > get ( char c ) { return getBranch ( c ) ; }
public void addCleanup ( Runnable cleanup ) { cleanups . add ( cleanup ) ; }
public Number reg_read ( int regId ) throws BackendException { try { switch ( regId ) { case ArmConst . UC_ARM_REG_R0 : case ArmConst . UC_ARM_REG_R1 : case ArmConst . UC_ARM_REG_R2 : case ArmConst . UC_ARM_REG_R3 : case ArmConst . UC_ARM_REG_R4 : case ArmConst . UC_ARM_REG_R5 : case ArmConst . UC_ARM_REG_R6 : case ArmConst . UC_ARM_REG_R7 : case ArmConst . UC_ARM_REG_R8 : case ArmConst . UC_ARM_REG_R9 : case ArmConst . UC_ARM_REG_R10 : case ArmConst . UC_ARM_REG_R11 : case ArmConst . UC_ARM_REG_R12 : return dynarmic . reg_read32 ( regId - ArmConst . UC_ARM_REG_R0 ) ; case ArmConst . UC_ARM_REG_SP : return dynarmic . reg_read32 ( 13 ) ; case ArmConst . UC_ARM_REG_LR : return dynarmic . reg_read32 ( 14 ) ; case ArmConst . UC_ARM_REG_PC : return dynarmic . reg_read32 ( 15 ) ; case ArmConst . UC_ARM_REG_CPSR : return dynarmic . reg_read_cpsr ( ) ; default : throw new DynarmicException ( "regId=" + regId ) ; } } catch ( DynarmicException e ) { throw new BackendException ( e ) ; } }
public void onPing ( String clientId ) { if ( ! clientContexts . containsKey ( clientId ) ) { clientContexts . putIfAbsent ( clientId , new ClientResourceContext ( clientId ) ) ; } ClientResourceContext clientContext = clientContexts . get ( clientId ) ; clientContext . updateLastPingTime ( ) ; }
public SnowflakeCacheView < ScheduledEvent > getScheduledEventCache ( ) { return CacheView . allSnowflakes ( ( ) -> guildCache . stream ( ) . map ( Guild :: getScheduledEventCache ) ) ; }
private boolean _isOKFinishedInQueue ( ) { return _transference_finished_queue . stream ( ) . anyMatch ( ( t ) -> ( ! t . isStatusError ( ) && ! t . isCanceled ( ) ) ) ; }
boolean isLeftToRight ( ) { return getComponent ( ) . getComponentOrientation ( ) . isLeftToRight ( ) ; }
private static int listIndex ( final String key , final int size ) { return listIndex ( Integer . parseInt ( key ) , size ) ; }
private JMethod getInternalGetMethod ( JDefinedClass jclass ) { return jclass . getMethod ( DEFINED_GETTER_NAME , new JType [ ] { jclass . owner ( ) . ref ( String . class ) , jclass . owner ( ) . ref ( Object . class ) } ) ; }
private float getAmplitudeFractionFromLevel ( int level ) { return level >= baseSpec . waveAmplitudeRampProgressMin * MAX_DRAWABLE_LEVEL && level <= baseSpec . waveAmplitudeRampProgressMax * MAX_DRAWABLE_LEVEL ? 1f : 0f ; }
public ResultMessage < Feedback > getFeedback ( @ PathVariable String id ) { return ResultUtil . data ( this . feedbackService . getById ( id ) ) ; }
private static List < FileSystemProvider > loadInstalledProviders ( ) { List < FileSystemProvider > list = new ArrayList < FileSystemProvider > ( ) ; ServiceLoader < FileSystemProvider > sl = ServiceLoader . load ( FileSystemProvider . class , ClassLoader . getSystemClassLoader ( ) ) ; for ( FileSystemProvider provider : sl ) { String scheme = provider . getScheme ( ) ; if ( ! scheme . equalsIgnoreCase ( "file" ) ) { boolean found = false ; for ( FileSystemProvider p : list ) { if ( p . getScheme ( ) . equalsIgnoreCase ( scheme ) ) { found = true ; break ; } } if ( ! found ) { list . add ( provider ) ; } } } return list ; }
public Throwable getThrown ( ) { return event . getThrown ( ) ; }
private boolean recursiveIsDependencyPredicate ( List < String > dependencyNames , Model model ) { if ( model instanceof NamedComponentModel ) { NamedComponentModel namedComponentModel = ( NamedComponentModel ) model ; String modelName = namedComponentModel . getName ( ) ; if ( dependencyNames . contains ( modelName ) ) { return true ; } } for ( Model submodel : model . getSubModels ( ) ) { boolean result = recursiveIsDependencyPredicate ( dependencyNames , submodel ) ; if ( result ) return true ; } return false ; }
void setImageBytes ( byte [ ] bytes ) { beforeInit ( ) ; ImageIcon icon = new ImageIcon ( bytes ) ; image . setIcon ( icon ) ; afterInit ( ) ; }
public static String getNewUrlIfPermanentRedirect ( String downloadUrl ) { try { Request httpReq = new Request . Builder ( ) . url ( downloadUrl ) . head ( ) . build ( ) ; Response response = AntennapodHttpClient . getHttpClient ( ) . newCall ( httpReq ) . execute ( ) ; return RedirectChecker . getNewUrlIfPermanentRedirect ( response ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return null ; }
public Icon getIcon ( ) { return ImageUtilities . loadImageIcon ( "DataLaboratoryPlugin/merge.svg" , false ) ; }
public static boolean equals ( final CharSequence s1 , final CharSequence s2 ) { if ( s1 == s2 ) return true ; int length ; if ( s1 != null && s2 != null && ( length = s1 . length ( ) ) == s2 . length ( ) ) { if ( s1 instanceof String && s2 instanceof String ) { return s1 . equals ( s2 ) ; } else { for ( int i = 0 ; i < length ; i ++ ) { if ( s1 . charAt ( i ) != s2 . charAt ( i ) ) return false ; } return true ; } } return false ; }
public R < List < Long > > saveRoleEmployee ( @ RequestBody RoleEmployeeSaveVO roleEmployeeSaveVO ) { return success ( superService . saveRoleEmployee ( roleEmployeeSaveVO ) ) ; }
JavaMethodBuilder withAnnotationDefaultValue ( Function < JavaMethod , Optional < Object > > createAnnotationDefaultValue ) { this . createAnnotationDefaultValue = createAnnotationDefaultValue ; return this ; }
public < T extends Parcelable > T getParcelable ( @ Nullable String key ) { unparcel ( ) ; Object o = mMap . get ( key ) ; if ( o == null ) { return null ; } try { return ( T ) o ; } catch ( ClassCastException e ) { typeWarning ( key , o , "Parcelable" , e ) ; return null ; } }
public Cursor getForwarding ( ) { lock . readLock ( ) . lock ( ) ; try { SQLiteDatabase db = this . getReadableDatabase ( ) ; String query = "SELECT ID AS _id, *" ; query += " FROM forward" ; query += " ORDER BY dport" ; return db . rawQuery ( query , new String [ ] { } ) ; } finally { lock . readLock ( ) . unlock ( ) ; } }
public Disposable schedule ( @ NonNull Runnable action ) { if ( disposed ) { return EmptyDisposable . INSTANCE ; } return poolWorker . scheduleActual ( action , 0 , TimeUnit . MILLISECONDS , serial ) ; }
public List < String > getOwners ( ) { return owners ; }
default boolean removeSubcommandByName ( @ Nonnull String name ) { return removeSubcommands ( subcommand -> subcommand . getName ( ) . equals ( name ) ) ; }
private void adjustMapPosition ( int y ) { MapActivity mapActivity = getMapActivity ( ) ; if ( menu == null || menu . isSelectFromMap ( ) || mapActivity == null ) { return ; } RoutingHelper rh = app . getRoutingHelper ( ) ; if ( rh . isRoutePlanningMode ( ) ) { mapActivity . getMapView ( ) ; QuadRect r = menu . getRouteRect ( mapActivity ) ; RotatedTileBox tb = mapActivity . getMapView ( ) . getRotatedTileBox ( ) ; int tileBoxWidthPx = 0 ; int tileBoxHeightPx = 0 ; if ( ! isPortrait ( ) ) { tileBoxWidthPx = tb . getPixWidth ( ) - getWidth ( ) ; } else { int fHeight = getViewHeight ( ) - y - AndroidUtils . getStatusBarHeight ( app ) ; tileBoxHeightPx = tb . getPixHeight ( ) - fHeight ; } if ( r . left != 0 && r . right != 0 ) { mapActivity . getMapView ( ) . fitRectToMap ( r . left , r . right , r . top , r . bottom , tileBoxWidthPx , tileBoxHeightPx , 0 ) ; } } }
public long total ( ) { return this . value . getTotal ( ) ; }
public ApplicationItem getLastSelectedPackage ( ) { Iterator < ApplicationItem > it = mSelectedPackageApplicationItemMap . values ( ) . iterator ( ) ; ApplicationItem lastItem = null ; while ( it . hasNext ( ) ) { lastItem = it . next ( ) ; } return lastItem ; }
public int size ( ) { return mArray . size ( ) ; }
public String toString ( ) { return "TableMutationBuilder( " + mutationType + " - '" + mutatingTable . getTableName ( ) + "')" ; }
public List < InnerEnum > getInnerEnums ( ) { return innerEnums ; }
public static PentahoDiPlugin . PurRepositoryPluginApiRevision purRepositoryPluginApiRevision ( Client client ) { return purRepositoryPluginApiRevision ( client , BASE_URI ) ; }
protected void storeMap ( Map < String , String > map ) { map . put ( "device_info" , deviceInfo ) ; map . put ( "transaction_id" , transactionId ) ; map . put ( "out_trade_no" , outTradeNo ) ; map . put ( "out_refund_no" , outRefundNo ) ; map . put ( "total_fee" , totalFee . toString ( ) ) ; map . put ( "refund_fee" , refundFee . toString ( ) ) ; map . put ( "refund_fee_type" , refundFeeType ) ; map . put ( "op_user_id" , opUserId ) ; map . put ( "refund_account" , refundAccount ) ; map . put ( "refund_desc" , refundDesc ) ; map . put ( "notify_url" , notifyUrl ) ; }
public static QuickQuerySteps . FromStep quickQuery ( ) { return new QuickQueryBuilder ( ) ; }
public boolean areItemsTheSame ( @ NonNull Message message , @ NonNull Message t1 ) { return message . getId ( ) . equals ( t1 . getId ( ) ) ; }
public static BasicAuthConfig load ( String configName ) { if ( CONFIG_NAME . equals ( configName ) ) { Map < String , Object > mappedConfig = Config . getInstance ( ) . getJsonMapConfig ( configName ) ; if ( instance != null && instance . getMappedConfig ( ) == mappedConfig ) { return instance ; } synchronized ( BasicAuthConfig . class ) { mappedConfig = Config . getInstance ( ) . getJsonMapConfig ( configName ) ; if ( instance != null && instance . getMappedConfig ( ) == mappedConfig ) { return instance ; } instance = new BasicAuthConfig ( configName ) ; List < String > masks = new ArrayList < > ( ) ; masks . add ( "password" ) ; ModuleRegistry . registerModule ( configName , BasicAuthConfig . class . getName ( ) , Config . getNoneDecryptedInstance ( ) . getJsonMapConfigNoCache ( configName ) , masks ) ; return instance ; } } return new BasicAuthConfig ( configName ) ; }
public static CharStream fromFileName ( String fileName ) throws IOException { return fromPath ( Paths . get ( fileName ) , StandardCharsets . UTF_8 ) ; }
public boolean [ ] getAsBooleanArray ( String key ) { return isCompatibleCast ( key , boolean [ ] . class ) ? ( boolean [ ] ) mValues . get ( key ) : null ; }
public EurekaClient eurekaClient ( ApplicationInfoManager manager , EurekaClientConfig config , TransportClientFactories < ? > transportClientFactories ) { return new CloudEurekaClient ( manager , config , transportClientFactories , this . optionalArgs , this . context ) ; }
public void deinstall ( MissionInit missionInit ) { EntityPlayerSP player = Minecraft . getMinecraft ( ) . player ; if ( player != null ) { player . movementInput = this . originalMovement ; } MinecraftForge . EVENT_BUS . unregister ( this ) ; }
void generate ( InputStream model , InputStream javadoc , OutputStream output ) throws IOException { ResolvedModel resolvedModel = JacksonMappers . yamlObjectReader ( ) . readValue ( model , ResolvedModel . class ) ; JavadocElements javadocElements = JacksonMappers . yamlObjectReader ( ) . readValue ( javadoc , JavadocElements . class ) ; for ( ConfigRoot configRoot : resolvedModel . getConfigRoots ( ) ) { for ( AbstractConfigItem item : configRoot . getItems ( ) ) { handleAbstractConfigItem ( item , javadocElements ) ; } } IOUtils . write ( String . join ( "\n" , lines ) , output , StandardCharsets . UTF_8 ) ; }
public CBuilder add ( Object value ) { throw new UnsupportedOperationException ( ) ; }
public void onSetting ( StageDecorator view , IconButton settingButton ) { showOperationView ( ) ; }
static boolean isEnabled ( Context context ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; return prefs . getBoolean ( "lt_enabled" , false ) ; }
protected WidgetsBundleExportData newExportData ( ) { return new WidgetsBundleExportData ( ) ; }
private void prepareForAnimateIn ( BubbleBarExpandedView bbev ) { ProtoLog . d ( WM_SHELL_BUBBLES_NOISY , "BBAnimationHelper.prepareForAnimateIn()" ) ; bbev . setAnimating ( true ) ; updateExpandedView ( bbev ) ; bbev . setSurfaceZOrderedOnTop ( true ) ; bbev . setTaskViewAlpha ( 0f ) ; bbev . setContentVisibility ( false ) ; bbev . setVisibility ( VISIBLE ) ; }
private void init ( ) { if ( this . securityContext != null ) { return ; } this . securityContext = this . supplier . get ( ) ; this . missingContext = ( this . securityContext == null ) ; if ( this . missingContext ) { this . securityContext = this . strategy . createEmptyContext ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( LogMessage . format ( "Created %s" , this . securityContext ) ) ; } } }
public void scanBlueOceanCredentials ( ) { if ( SCANNING_INTERVAL < 1 ) { LOGGER . info ( "BlueOceanCredentialsMonitor scanning is deactivated" ) ; return ; } Timer . get ( ) . scheduleAtFixedRate ( this :: scanInstance , 0 , SCANNING_INTERVAL , TimeUnit . MINUTES ) ; }
public String get ( short byID ) { return get ( ( long ) byID ) ; }
public int estimateParsedLength ( ) { return iMaxParsedDigits ; }
public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { injectedClassMap . put ( clazz . getName ( ) , internalClassName ( ConfigurationLogger . class . getName ( ) ) ) ; injectedClassMap . put ( clazz . getName ( ) , internalClassName ( ConfigurationLogger . MethodSignature . class . getName ( ) ) ) ; }
public Response updateClusterCompactionConfig ( ClusterCompactionConfig updatePayload , @ Context HttpServletRequest req ) { final AuditInfo auditInfo = AuthorizationUtils . buildAuditInfo ( req ) ; return ServletResourceUtils . buildUpdateResponse ( ( ) -> configManager . updateClusterCompactionConfig ( updatePayload , auditInfo ) ) ; }
public Criteria andDefaultNumberLike ( String value ) { addCriterion ( "default_number like" , value , "defaultNumber" ) ; return ( Criteria ) this ; }
void makeLeader ( TopicPartition tp , AggregatedMetricValues leadershipLoadDelta ) { Replica replica = replica ( tp ) ; removeSortedReplicas ( replica ) ; replica . makeLeader ( leadershipLoadDelta ) ; _leadershipLoadForNwResources . addLoad ( replica . load ( ) ) ; _load . addLoad ( leadershipLoadDelta ) ; _leaderReplicas . add ( replica ) ; addSortedReplicas ( replica ) ; }
public String getCommentBlock ( String prefix ) { prefix = prefix + " " ; StringBuilder ret = new StringBuilder ( ) ; if ( getComment ( ) . length ( ) > 0 ) { StringTokenizer st = new StringTokenizer ( getComment ( ) , "\n" ) ; while ( st . hasMoreTokens ( ) ) { ret . append ( prefix ) . append ( st . nextToken ( ) ) . append ( "\n" ) ; } } return ret . toString ( ) ; }
public void insufficientStorage ( String message , String description , HealthStateType type ) { httpCode = 507 ; this . message = message ; serverHealthStateOperationResult . error ( message , description , type ) ; }
public static SslContext openSslContext ( String trustFile , String clientCertFile , String clientKeyFile ) { SslContext ssl ; try { File trustManagerFile = FileUtils . getFile ( trustFile ) ; File keyCertChainFile = FileUtils . getFile ( clientCertFile ) ; File KeyFile = FileUtils . getFile ( clientKeyFile ) ; ApplicationProtocolConfig alpn = new ApplicationProtocolConfig ( ApplicationProtocolConfig . Protocol . ALPN , ApplicationProtocolConfig . SelectorFailureBehavior . NO_ADVERTISE , ApplicationProtocolConfig . SelectedListenerFailureBehavior . ACCEPT , ApplicationProtocolNames . HTTP_2 ) ; ssl = SslContextBuilder . forClient ( ) . applicationProtocolConfig ( alpn ) . sslProvider ( SslProvider . OPENSSL ) . trustManager ( trustManagerFile ) . keyManager ( keyCertChainFile , KeyFile ) . build ( ) ; } catch ( Exception e ) { throw new HugeException ( "Failed to open ssl context" , e ) ; } return ssl ; }
public String getVersionNumber ( ) { if ( available > 0 ) { return String . format ( "%d.%d.%d" , major , minor , sub ) ; } return "" ; }
void accept ( int row , int column , char [ ] chars , int off , int len ) ; default void afterRow ( int row ) { }
public void onAnimationUpdate ( ValueAnimator animation ) { mAnimateValue = ( int ) animation . getAnimatedValue ( ) ; invalidate ( ) ; }
public void setMessageSource ( MessageSource messageSource ) { Assert . notNull ( messageSource , "messageSource cannot be null" ) ; this . messages = new MessageSourceAccessor ( messageSource ) ; }
public String stringify ( long nanos ) { return toTimeString ( nanos , NANOSECONDS ) ; }
public void setPlaceholderPrefix ( String placeholderPrefix ) { this . placeholderPrefix = placeholderPrefix ; }
public static void printSystemLoad ( ) { log . info ( getSystemLoad ( ) ) ; }
public List < LocalPlaylistFragment > getLocalPlaylistFragments ( ) { return localPlaylistFragments ; }
public void setZkAddr ( String zkAddr ) { this . zkAddr = zkAddr ; }
protected boolean insert ( T e ) { int n = size ; if ( n >= heap . length ) { grow ( n + 1 ) ; } siftUp ( n , e ) ; size = n + 1 ; return true ; }
SELF self ( ) { return ( SELF ) this ; }
public static < T > T [ ] array ( Class < T > type , Generator < T > gen , int size ) { T [ ] a = ( T [ ] ) java . lang . reflect . Array . newInstance ( type , size ) ; return new CollectionData < T > ( gen , size ) . toArray ( a ) ; }
private @ CheckForNull ExportedPipelineFunction getStepMetadata ( Descriptor < ? > d ) { String symbol = symbolForObject ( d ) ; if ( symbol != null ) { ExportedPipelineFunction f = new ExportedPipelineFunction ( new DescribableModel < > ( d . clazz ) , symbol ) ; for ( ExportedDescribableParameterDecorator decorator : ExtensionList . lookup ( ExportedDescribableParameterDecorator . class ) ) { decorator . decorate ( f , f . getParameters ( ) ) ; } return f ; } else { return null ; } }
public Criteria andPayTypeLessThan ( String value ) { addCriterion ( "pay_type <" , value , "payType" ) ; return ( Criteria ) this ; }
public WaitingNested < A > editOrNewWaitingLike ( V1ContainerStateWaiting item ) { return this . withNewWaitingLike ( Optional . ofNullable ( this . buildWaiting ( ) ) . orElse ( item ) ) ; }
protected boolean isDirty ( ) { return startupMetadata . isDirty ( ) ; }
public List < ViewManager > createViewManagers ( ReactApplicationContext reactContext ) { return Arrays . < ViewManager > asList ( new RTCVideoViewManager ( ) ) ; }
static int indexOfNextPair ( int collectionSize ) { return ( collectionSize / 2 ) + 1 ; }
protected void processPolyglotJavaImport ( String visibleName , String javaClassName ) { }
public String authorHash ( ) { final String a = record . get ( "ahash" ) ; return a ; }
private static void sortEntries ( List < VaultEntry > entries , SortCategory sortCategory ) { if ( sortCategory != null ) { Comparator < VaultEntry > comparator = sortCategory . getComparator ( ) ; if ( comparator != null ) { Collections . sort ( entries , comparator ) ; } } Comparator < VaultEntry > favoriteComparator = new FavoriteComparator ( ) ; Collections . sort ( entries , favoriteComparator ) ; }
private int param ( int bytes , int alignment ) { int param = ( offset + ( alignment - 1 ) ) & - alignment ; ensureCapacity ( offset = param + bytes ) ; return param ; }
public Object process ( Node nd , Stack < Node > stack , NodeProcessorCtx procCtx , Object ... nodeOutputs ) throws SemanticException { TypeCheckCtx ctx = ( TypeCheckCtx ) procCtx ; if ( ctx . getError ( ) != null ) { return null ; } ASTNode expr = ( ASTNode ) nd ; ASTNode sqNode = ( ASTNode ) expr . getParent ( ) . getChild ( 1 ) ; if ( ! ctx . getallowSubQueryExpr ( ) ) { throw new CalciteSubquerySemanticException ( SemanticAnalyzer . generateErrorMessage ( sqNode , ErrorMsg . UNSUPPORTED_SUBQUERY_EXPRESSION . getMsg ( "Currently SubQuery expressions are only allowed as " + "Where and Having Clause predicates" ) ) ) ; } T desc = processGByExpr ( nd , procCtx ) ; if ( desc != null ) { return desc ; } assert ( expr . getChildren ( ) . size ( ) == 3 || expr . getChildren ( ) . size ( ) == 2 ) ; assert ( expr . getChild ( 0 ) . getType ( ) == HiveParser . TOK_SUBQUERY_OP ) ; ASTNode subqueryOp = ( ASTNode ) expr . getChild ( 0 ) ; SubqueryType subqueryType = null ; if ( ( subqueryOp . getChildCount ( ) > 0 ) && ( subqueryOp . getChild ( 0 ) . getType ( ) == HiveParser . KW_IN || subqueryOp . getChild ( 0 ) . getType ( ) == HiveParser . TOK_SUBQUERY_OP_NOTIN ) ) { subqueryType = SubqueryType . IN ; } else if ( ( subqueryOp . getChildCount ( ) > 0 ) && ( subqueryOp . getChild ( 0 ) . getType ( ) == HiveParser . KW_EXISTS || subqueryOp . getChild ( 0 ) . getType ( ) == HiveParser . TOK_SUBQUERY_OP_NOTEXISTS ) ) { subqueryType = SubqueryType . EXISTS ; } else if ( ( subqueryOp . getChildCount ( ) > 0 ) && ( subqueryOp . getChild ( 0 ) . getType ( ) == HiveParser . KW_SOME ) ) { subqueryType = SubqueryType . SOME ; } else if ( ( subqueryOp . getChildCount ( ) > 0 ) && ( subqueryOp . getChild ( 0 ) . getType ( ) == HiveParser . KW_ALL ) ) { subqueryType = SubqueryType . ALL ; } else if ( subqueryOp . getChildCount ( ) == 0 ) { subqueryType = SubqueryType . SCALAR ; } T res = exprFactory . createSubqueryExpr ( ctx , expr , subqueryType , nodeOutputs ) ; if ( res == null ) { ctx . setError ( ASTErrorUtils . getMsg ( ErrorMsg . UNSUPPORTED_SUBQUERY_EXPRESSION . getMsg ( ) , sqNode , "Currently only IN & EXISTS SubQuery expressions are allowed" ) , sqNode ) ; } return res ; }
public Criteria andSortGreaterThan ( Integer value ) { addCriterion ( "sort >" , value , "sort" ) ; return ( Criteria ) this ; }
public String getNamespaceUri ( int pos ) throws XmlPullParserException { int uri = m_namespaces . getUri ( pos ) ; return m_strings . getString ( uri ) ; }
public boolean accept ( File dir , String filename ) { Matcher matcher = fileNamePattern . matcher ( filename ) ; return matcher . matches ( ) && Integer . valueOf ( matcher . group ( 2 ) ) < BuildConfig . VERSION_CODE ; }
public Object update ( @ RequestBody LitemallIssue issue ) { Object error = validate ( issue ) ; if ( error != null ) { return error ; } if ( issueService . updateById ( issue ) == 0 ) { return ResponseUtil . updatedDataFailed ( ) ; } return ResponseUtil . ok ( issue ) ; }
public void popupMessage ( PopupMessageNotificationAction action , String title , String message , byte [ ] icon , Object tag ) { SystrayService systray = NotificationActivator . getSystray ( ) ; if ( systray == null ) return ; if ( StringUtils . isNotEmpty ( message ) ) { PopupMessage popupMsg = new PopupMessage ( title , message , icon , tag ) ; popupMsg . setTimeout ( action . getTimeout ( ) ) ; popupMsg . setGroup ( action . getGroupName ( ) ) ; systray . showPopupMessage ( popupMsg ) ; } else if ( message == null ) { logger . error ( "Message is null!" ) ; } }
private Group parseGroup ( final Element element ) { final Group . Builder builder = new Group . Builder ( ) . identifier ( element . getAttribute ( IDENTIFIER_ATTR ) ) . name ( element . getAttribute ( NAME_ATTR ) ) ; NodeList groupUsers = element . getElementsByTagName ( GROUP_USER_ELEMENT ) ; for ( int i = 0 ; i < groupUsers . getLength ( ) ; i ++ ) { Element groupUserNode = ( Element ) groupUsers . item ( i ) ; builder . addUser ( groupUserNode . getAttribute ( IDENTIFIER_ATTR ) ) ; } return builder . build ( ) ; }
public String getTargetTable ( ) { return targetTable ; }
public int getDatabase ( ) { return database ; }
protected void onCreate ( @ Nullable Bundle bundle ) { getWindow ( ) . requestFeature ( Window . FEATURE_ACTIVITY_TRANSITIONS ) ; findViewById ( android . R . id . content ) . setTransitionName ( "shared_element_end_root" ) ; setEnterSharedElementCallback ( new MaterialContainerTransformSharedElementCallback ( ) ) ; getWindow ( ) . setSharedElementEnterTransition ( buildContainerTransform ( true ) ) ; getWindow ( ) . setSharedElementReturnTransition ( buildContainerTransform ( false ) ) ; super . onCreate ( bundle ) ; }
public NDArray max ( int [ ] axes , boolean keepDims ) { return getAlternativeArray ( ) . max ( axes , keepDims ) ; }
public ConsumerMethodModel getMethodModel ( String method , String [ ] argsType ) { Optional < ConsumerMethodModel > consumerMethodModel = methodModels . entrySet ( ) . stream ( ) . filter ( entry -> entry . getKey ( ) . getName ( ) . equals ( method ) ) . map ( Map . Entry :: getValue ) . filter ( methodModel -> Arrays . equals ( argsType , methodModel . getParameterTypes ( ) ) ) . findFirst ( ) ; return consumerMethodModel . orElse ( null ) ; }
public Iterator < CartItem > getCartItems ( ) { return itemList . iterator ( ) ; }
public int hashCode ( ) { int result = concurrencyLevel ; result = 31 * result + initialCapacity ; result = 31 * result + ( maximumSize != null ? maximumSize . hashCode ( ) : 0 ) ; result = 31 * result + ( expireAfterAccess != null ? expireAfterAccess . hashCode ( ) : 0 ) ; result = 31 * result + ( expireAfterWrite != null ? expireAfterWrite . hashCode ( ) : 0 ) ; return result ; }
public void withAspectRatio ( float x , float y ) { mOptionBundle . putFloat ( EXTRA_ASPECT_RATIO_X , x ) ; mOptionBundle . putFloat ( EXTRA_ASPECT_RATIO_Y , y ) ; }
private final void doNext ( ) throws IOException { if ( m_strings == null ) { ChunkUtil . readCheckType ( m_reader , CHUNK_AXML_FILE ) ; m_reader . skipInt ( ) ; m_strings = StringBlock . read ( m_reader ) ; m_namespaces . increaseDepth ( ) ; m_operational = true ; } if ( m_event == END_DOCUMENT ) { return ; } int event = m_event ; resetEventInfo ( ) ; while ( true ) { if ( m_decreaseDepth ) { m_decreaseDepth = false ; m_namespaces . decreaseDepth ( ) ; } if ( event == END_TAG && m_namespaces . getDepth ( ) == 1 && m_namespaces . getCurrentCount ( ) == 0 ) { m_event = END_DOCUMENT ; break ; } int chunkType ; if ( event == START_DOCUMENT ) { chunkType = CHUNK_XML_START_TAG ; } else { chunkType = m_reader . readInt ( ) ; } if ( chunkType == CHUNK_RESOURCEIDS ) { int chunkSize = m_reader . readInt ( ) ; if ( chunkSize < 8 || ( chunkSize % 4 ) != 0 ) { throw new IOException ( "Invalid resource ids size (" + chunkSize + ")." ) ; } m_resourceIDs = m_reader . readIntArray ( chunkSize / 4 - 2 ) ; continue ; } if ( chunkType < CHUNK_XML_FIRST || chunkType > CHUNK_XML_LAST ) { throw new IOException ( "Invalid chunk type (" + chunkType + ")." ) ; } if ( chunkType == CHUNK_XML_START_TAG && event == - 1 ) { m_event = START_DOCUMENT ; break ; } m_reader . skipInt ( ) ; int lineNumber = m_reader . readInt ( ) ; m_reader . skipInt ( ) ; if ( chunkType == CHUNK_XML_START_NAMESPACE || chunkType == CHUNK_XML_END_NAMESPACE ) { if ( chunkType == CHUNK_XML_START_NAMESPACE ) { int prefix = m_reader . readInt ( ) ; int uri = m_reader . readInt ( ) ; m_namespaces . push ( prefix , uri ) ; } else { m_reader . skipInt ( ) ; m_reader . skipInt ( ) ; m_namespaces . pop ( ) ; } continue ; } m_lineNumber = lineNumber ; if ( chunkType == CHUNK_XML_START_TAG ) { m_namespaceUri = m_reader . readInt ( ) ; m_name = m_reader . readInt ( ) ; m_reader . skipInt ( ) ; int attributeCount = m_reader . readInt ( ) ; m_idAttribute = ( attributeCount > > > 16 ) - 1 ; attributeCount &= 0xFFFF ; m_classAttribute = m_reader . readInt ( ) ; m_styleAttribute = ( m_classAttribute > > > 16 ) - 1 ; m_classAttribute = ( m_classAttribute & 0xFFFF ) - 1 ; m_attributes = m_reader . readIntArray ( attributeCount * ATTRIBUTE_LENGHT ) ; for ( int i = ATTRIBUTE_IX_VALUE_TYPE ; i < m_attributes . length ; ) { m_attributes [ i ] = ( m_attributes [ i ] > > > 24 ) ; i += ATTRIBUTE_LENGHT ; } m_namespaces . increaseDepth ( ) ; m_event = START_TAG ; break ; } if ( chunkType == CHUNK_XML_END_TAG ) { m_namespaceUri = m_reader . readInt ( ) ; m_name = m_reader . readInt ( ) ; m_event = END_TAG ; m_decreaseDepth = true ; break ; } if ( chunkType == CHUNK_XML_TEXT ) { m_name = m_reader . readInt ( ) ; m_reader . skipInt ( ) ; m_reader . skipInt ( ) ; m_event = TEXT ; break ; } } }
public GlideBuilder setDefaultRequestOptions ( @ NonNull RequestOptionsFactory factory ) { this . defaultRequestOptionsFactory = Preconditions . checkNotNull ( factory ) ; return this ; }
public PersistentVolumeClaimRetentionPolicyNested < A > withNewPersistentVolumeClaimRetentionPolicy ( ) { return new PersistentVolumeClaimRetentionPolicyNested ( null ) ; }
public static ConfigBasicInfo transferToConfigBasicInfo ( ConfigInfo configInfo ) { ConfigBasicInfo result = new ConfigBasicInfo ( ) ; BeanUtils . copyProperties ( configInfo , result ) ; result . setNamespaceId ( configInfo . getTenant ( ) ) ; result . setGroupName ( configInfo . getGroup ( ) ) ; return result ; }
public RestAction < List < RoleConnectionMetadata > > updateRoleConnectionMetadata ( @ Nonnull Collection < ? extends RoleConnectionMetadata > records ) { Checks . noneNull ( records , "Records" ) ; Checks . check ( records . size ( ) <= RoleConnectionMetadata . MAX_RECORDS , "An application can have a maximum of %d metadata records" , RoleConnectionMetadata . MAX_RECORDS ) ; Route . CompiledRoute route = Route . Applications . UPDATE_ROLE_CONNECTION_METADATA . compile ( getSelfUser ( ) . getApplicationId ( ) ) ; DataArray array = DataArray . fromCollection ( records ) ; RequestBody body = RequestBody . create ( array . toJson ( ) , Requester . MEDIA_TYPE_JSON ) ; return new RestActionImpl < > ( this , route , body , ( response , request ) -> response . getArray ( ) . stream ( DataArray :: getObject ) . map ( RoleConnectionMetadata :: fromData ) . collect ( Helpers . toUnmodifiableList ( ) ) ) ; }
public Map < Id , BaseProperty < ? > > getProperties ( ) { Map < Id , BaseProperty < ? > > props = new HashMap < > ( ) ; for ( IntObjectPair < BaseProperty < ? > > e : this . properties . keyValuesView ( ) ) { props . put ( IdGenerator . of ( e . getOne ( ) ) , e . getTwo ( ) ) ; } return props ; }
private String toAbsolute ( String location ) { if ( location == null ) { return location ; } boolean leadingSlash = location . startsWith ( "/" ) ; if ( leadingSlash || ! hasScheme ( location ) ) { return RedirectBuilder . redirect ( exchange , location , false ) ; } else { return location ; } }
public static PublicKey string2PublicKey ( String pubStr ) throws Exception { byte [ ] keyBytes = base642Byte ( pubStr ) ; X509EncodedKeySpec keySpec = new X509EncodedKeySpec ( keyBytes ) ; KeyFactory keyFactory = KeyFactory . getInstance ( "RSA" ) ; PublicKey publicKey = keyFactory . generatePublic ( keySpec ) ; return publicKey ; }
public CacheView < AudioManager > getAudioManagerCache ( ) { return audioManagers ; }
private WatchStats unwatch ( String path , Watcher watcher , Map < String , WatchStats > paths , Set < Watcher > watchers ) { WatchStats stats = paths . remove ( path ) ; if ( stats == null ) { return WatchStats . NONE ; } if ( paths . isEmpty ( ) ) { watch2Paths . remove ( watcher ) ; } watchers . remove ( watcher ) ; if ( watchers . isEmpty ( ) ) { watchTable . remove ( path ) ; } return stats ; }
public boolean isBackup ( ) { return backup ; }
private String udiDate ( long time ) { SimpleDateFormat format = new SimpleDateFormat ( "YYMMdd" ) ; return format . format ( new Date ( time ) ) ; }
public BaseModel < String > template ( @ PathVariable String env ) { return BaseModel . getInstance ( TemplateConfigLoader . loadCanalConfig ( ) ) ; }
public final void runOnUiThreadOptional ( Runnable runnable ) { runOnUiThreadOptional ( runnable , null , 0 ) ; }
public void setCount ( @ jakarta . annotation . Nullable Long count ) { this . count = count ; }
public void setMainClass ( String mainClass ) { this . mainClass = mainClass ; }
public String getEncode ( ) { return null ; }
public Number getAsNumber ( ) { throw new UnsupportedOperationException ( getClass ( ) . getSimpleName ( ) ) ; }
public String getPortName ( ) { return portName ; }
public void setPasswordReminderFrequency ( PassReminderFreq freq ) { _prefs . edit ( ) . putInt ( "pref_password_reminder_freq" , freq . ordinal ( ) ) . apply ( ) ; }
public static Typeface create ( String familyName , @ Style int style ) { return create ( getSystemDefaultTypeface ( familyName ) , style ) ; }
public String nextName ( ) throws IOException { return delegate . readName ( ) ; }
private static void resetOptionsFromConfig ( Generator . GeneratorOptions options , Exporter . ExporterRuntimeOptions exportOptions ) { options . population = Config . getAsInteger ( "generate.default_population" , 1 ) ; options . threadPoolSize = Config . getAsInteger ( "generate.thread_pool_size" , - 1 ) ; exportOptions . yearsOfHistory = Config . getAsInteger ( "exporter.years_of_history" , 10 ) ; exportOptions . terminologyService = ! Config . get ( "generate.terminology_service_url" , "" ) . isEmpty ( ) ; }
public Long getGeneration ( ) { return this . generation ; }
protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
protected void updateThumbPosition ( ScrollPositionState scrollPosState , int rowCount ) { int availableScrollHeight ; int availableScrollBarHeight ; int scrolledPastHeight ; if ( getAdapter ( ) instanceof MeasurableAdapter ) { availableScrollHeight = getAvailableScrollHeight ( calculateAdapterHeight ( ) , 0 ) ; scrolledPastHeight = calculateScrollDistanceToPosition ( scrollPosState . rowIndex ) ; } else { availableScrollHeight = getAvailableScrollHeight ( rowCount * scrollPosState . rowHeight , 0 ) ; scrolledPastHeight = scrollPosState . rowIndex * scrollPosState . rowHeight ; } availableScrollBarHeight = getAvailableScrollBarHeight ( ) ; if ( availableScrollHeight <= 0 ) { mScrollbar . setThumbPosition ( - 1 , - 1 ) ; return ; } int scrollY = Math . min ( availableScrollHeight , getPaddingTop ( ) + scrolledPastHeight - scrollPosState . rowTopOffset ) ; int scrollBarY = ( int ) ( ( ( float ) scrollY / availableScrollHeight ) * availableScrollBarHeight ) ; int scrollBarX ; if ( Utils . isRtl ( getResources ( ) ) ) { scrollBarX = 0 ; } else { scrollBarX = getWidth ( ) - mScrollbar . getWidth ( ) ; } mScrollbar . setThumbPosition ( scrollBarX , scrollBarY ) ; }
public void reset ( ) { mRowsCount = 0 ; }
public void setAttributes ( List < ProductAttribute > attributes ) { this . attributes = attributes ; }
