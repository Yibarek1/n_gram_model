private void hideWelcomeScreen ( ) { if ( isWelcomeScreen ) { if ( currentView == VIEW_EASY ) { showContentPanelCard ( EASY_PANEL ) ; } else { showContentPanelCard ( SPLIT_PANE1 ) ; } isWelcomeScreen = false ; } }
public int getLongDuration ( ) { return mLongDuration ; }
public boolean isOpen ( ) { return mNativeHandle != 0 ; }
public void init ( ) { ServletConfig config = getServletConfig ( ) ; Enumeration < ? > en = config . getInitParameterNames ( ) ; ArrayList < String > list = new ArrayList < > ( ) ; while ( en . hasMoreElements ( ) ) { String name = en . nextElement ( ) . toString ( ) ; String value = config . getInitParameter ( name ) ; if ( ! name . startsWith ( "-" ) ) { name = "-" + name ; } list . add ( name ) ; if ( value . length ( ) > 0 ) { list . add ( value ) ; } } String [ ] args = list . toArray ( new String [ 0 ] ) ; server = new WebServer ( ) ; server . setAllowChunked ( false ) ; server . init ( args ) ; }
public void setAddress ( String address ) { this . address = address ; }
public void setExplorerMode ( @ ExplorerMode int explorerMode ) { this . explorerMode = explorerMode ; }
public TreeWidgetData getData ( final List < LaunchResults > launches ) { final Tree < TestResult > data = BehaviorsPlugin . getData ( launches ) ; final List < TreeWidgetItem > items = data . getChildren ( ) . stream ( ) . filter ( TestResultTreeGroup . class :: isInstance ) . map ( TestResultTreeGroup . class :: cast ) . map ( WidgetAggregator :: toWidgetItem ) . sorted ( Comparator . comparing ( TreeWidgetItem :: getStatistic , comparator ( ) ) . reversed ( ) ) . limit ( 10 ) . collect ( Collectors . toList ( ) ) ; return new TreeWidgetData ( ) . setItems ( items ) . setTotal ( data . getChildren ( ) . size ( ) ) ; }
private static void generateAccessOrderException ( final StringBuilder sb , final String indent , final String action , final FieldPrecedenceModel fieldPrecedenceModel , final FieldPrecedenceModel . CodecInteraction interaction ) { sb . append ( indent ) . append ( "throw AccessOrderError(" ) . append ( "std::string(\"Illegal field access order. \") +\n" ) . append ( indent ) . append ( INDENT ) . append ( "\"Cannot " ) . append ( action ) . append ( " \\\"" ) . append ( interaction . groupQualifiedName ( ) ) . append ( "\\\" in state: \" + codecStateName(codecState()) +\n" ) . append ( indent ) . append ( INDENT ) . append ( "\". Expected one of these transitions: [\" + codecStateTransitions(codecState()) +\n" ) . append ( indent ) . append ( INDENT ) . append ( "\"]. Please see the diagram in the docs of the enum " ) . append ( fieldPrecedenceModel . generatedRepresentationClassName ( ) ) . append ( ".\");\n" ) ; }
protected DecideResult innerDecide ( CrawlURI uri ) { if ( uri . getContentLength ( ) < getContentLengthThreshold ( ) ) { return DecideResult . ACCEPT ; } return DecideResult . REJECT ; }
public void onTableRename ( Table newTable , String oldTableName ) { if ( newTable == null ) { return ; } if ( this . tableName != null && this . tableName . equals ( oldTableName ) ) { if ( newTable instanceof OlapTable ) { this . tableId = newTable . getId ( ) ; } this . tableName = newTable . getName ( ) ; } }
private ByteBuffer readFrameAndUnwrap ( ) throws IOException { ByteBuffer frame = readFrame ( ) ; if ( ! dataIsWrapped ) return frame ; ByteBuffer unwrapped = ByteBuffer . wrap ( sasl . unwrap ( frame . array ( ) ) ) ; LOG . debug ( "unwrapped data of length: {}" , unwrapped . remaining ( ) ) ; return unwrapped ; }
public void channelUnregistered ( ChannelHandlerContext ctx ) throws Exception { Connection connection = ctx . channel ( ) . attr ( CONNECTION ) . get ( ) ; if ( connection != null ) { connection . close ( ) ; } super . channelUnregistered ( ctx ) ; }
public Set < MediaType > getSupportedTypes ( ParseContext context ) { return SUPPORTED_TYPES ; }
private void updateChatUnreadReactionCount ( TdApi . UpdateChatUnreadReactionCount update ) { final boolean availabilityChanged ; final TdApi . Chat chat ; final TdlibChatList [ ] chatLists ; synchronized ( dataLock ) { chat = chats . get ( update . chatId ) ; if ( TdlibUtils . assertChat ( update . chatId , chat , update ) ) { return ; } availabilityChanged = ( chat . unreadReactionCount > 0 ) != ( update . unreadReactionCount > 0 ) ; chat . unreadReactionCount = update . unreadReactionCount ; chatLists = chatListsImpl ( chat . positions ) ; } listeners . updateChatUnreadReactionCount ( update , availabilityChanged , chat , chatLists ) ; }
public void setDeleteInvalidSessions ( boolean deleteInvalidSessions ) { this . deleteInvalidSessions = deleteInvalidSessions ; }
public boolean canLoadSegmentOnDemand ( DataSegment dataSegment ) { return config . isVirtualStorage ( ) ; }
@ Override public String toString ( ) { switch ( this ) { case UINTEGER : return "INTEGER UNSIGNED" ; case UBIGINT : return "BIGINT UNSIGNED" ; case UTINYINT : return "TINYINT UNSIGNED" ; case USMALLINT : return "SMALLINT UNSIGNED" ; default : return this . name ( ) ; } }
public static Class < ? > getSuperGenericType ( Class < ? > clazz ) { return getSuperGenericType ( clazz , 0 ) ; }
protected String toSourceFilePath ( String name , String extension ) { return "src" + File . separator + toModuleName ( name ) + "." + extension ; }
public Animator toShow ( ) { return toShow ( null ) ; }
public static String prettyPrint ( String xml ) { try { return prettyPrint ( read ( xml ) ) ; } catch ( Exception e ) { return throwUnchecked ( e , String . class ) ; } }
private void initLevelFile ( List < CompressDataFileInfo > fileList ) { if ( this . levelFileMap == null ) { this . levelFileMap = new HashMap < > ( ) ; } for ( CompressDataFileInfo fileInfo : fileList ) { if ( fileInfo . getFilePath ( ) . contains ( COMPACT_DIR ) ) { int index = fileInfo . getFilePath ( ) . indexOf ( COMPACT_DIR ) ; String levelPath = fileInfo . getFilePath ( ) . substring ( index , index + COMPACT_DIR . length ( ) + 1 ) ; this . levelFileMap . computeIfAbsent ( levelPath , COMPACT_FILE -> new ArrayList < > ( ) ) . add ( fileInfo ) ; } else { this . levelFileMap . computeIfAbsent ( INCREMENTAL_FILE , INCREMENTAL_FILE -> new ArrayList < > ( ) ) . add ( fileInfo ) ; } } LOG . info ( "Task {}, Initialized level file for table {}, files {}, levelFileMap {}" , taskId , tablePath , fileList , levelFileMap ) ; }
public void writeTo ( com . google . protobuf . CodedOutputStream output ) throws java . io . IOException { if ( ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) ) { com . google . protobuf . GeneratedMessageV3 . writeString ( output , 1 , ip_ ) ; } if ( ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) ) { com . google . protobuf . GeneratedMessageV3 . writeString ( output , 2 , hostname_ ) ; } for ( int i = 0 ; i < ports_ . size ( ) ; i ++ ) { output . writeMessage ( 4 , ports_ . get ( i ) ) ; } unknownFields . writeTo ( output ) ; }
public SingleResult < String > login ( HttpServletResponse response , @ RequestBody User user ) { UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken ( user . getUsername ( ) , user . getPassword ( ) ) ; try { Authentication authentication = authenticationManager . authenticate ( authenticationToken ) ; SecurityContextHolder . getContext ( ) . setAuthentication ( authentication ) ; String token = jwtTokenUtils . createToken ( authentication ) ; String authHeader = WebSecurityConfig . TOKEN_PREFIX + token ; response . addHeader ( WebSecurityConfig . AUTHORIZATION_HEADER , authHeader ) ; return SingleResult . success ( authHeader ) ; } catch ( BadCredentialsException authentication ) { return SingleResult . failure ( Code . LOGIN_FAILED ) ; } }
private List < Type > getTypeParameters ( TypeMirror mirror , boolean isImplementationType ) { if ( mirror . getKind ( ) != TypeKind . DECLARED ) { return java . util . Collections . emptyList ( ) ; } DeclaredType declaredType = ( DeclaredType ) mirror ; List < Type > typeParameters = new ArrayList < > ( declaredType . getTypeArguments ( ) . size ( ) ) ; for ( TypeMirror typeParameter : declaredType . getTypeArguments ( ) ) { if ( isImplementationType ) { typeParameters . add ( getType ( typeParameter ) . getTypeBound ( ) ) ; } else { typeParameters . add ( getType ( typeParameter ) ) ; } } return typeParameters ; }
public BlurViewFacade setFrameClearDrawable ( @ Nullable Drawable frameClearDrawable ) { this . frameClearDrawable = frameClearDrawable ; return this ; }
protected void putPrefix ( ) { this . checkOnEachPublicOperation ( ) ; if ( ! ( this . innerUpdateLock . isHeldByCurrentThread ( ) ) ) this . innerUpdateLock . lock ( ) ; if ( ( this . nestedContextsLockedOnSameSegment ( ) ) && ( ( this . rootContextLockedOnThisSegment ( ) . latestSameThreadSegmentModCount ( ) ) != ( this . contextModCount ( ) ) ) ) { if ( ( this . hashLookupPosInit ( ) ) && ( this . searchStateAbsent ( ) ) ) this . closeHashLookupPos ( ) ; } }
public String getName ( ) { return "erlang-server-deprecated" ; }
public String getColumnClassName ( int column ) throws SQLException { String columnTypeName = getColumnTypeName ( column ) ; return DriverUtils . getJavaClassName ( columnTypeName ) ; }
public KernelTransaction . Revertable overrideWith ( SecurityContext context ) { return ktx . overrideWith ( context ) ; }
public TbQueueProducer < TbProtoQueueMsg < ToEdqsMsg > > createEdqsEventsProducer ( ) { return TbKafkaProducerTemplate . < TbProtoQueueMsg < ToEdqsMsg > > builder ( ) . clientId ( "edqs-events-producer-" + serviceInfoProvider . getServiceId ( ) ) . defaultTopic ( topicService . buildTopicName ( edqsConfig . getEventsTopic ( ) ) ) . settings ( kafkaSettings ) . admin ( edqsEventsAdmin ) . build ( ) ; }
public @ Nullable VoIPLogs . Pair findCallLogInformation ( long chatId , long messageId ) { synchronized ( dataLock ) { List < CallLog > list = callLogs != null ? callLogs . get ( chatId ) : null ; if ( list != null ) { for ( CallLog callLog : list ) { if ( callLog . chatId == chatId && callLog . guessedMessageId == messageId ) { return callLog . files ; } } } } return null ; }
public void bindDtpProperties ( Map < ? , Object > properties , DtpProperties dtpProperties ) { beforeBind ( properties , dtpProperties ) ; try { Class . forName ( "org.springframework.boot.context.properties.bind.Binder" ) ; doBindIn2X ( properties , dtpProperties ) ; } catch ( ClassNotFoundException e ) { doBindIn1X ( properties , dtpProperties ) ; } afterBind ( properties , dtpProperties ) ; }
private void runStartupChecks ( ) { checkDeviceToken ( ) ; animatedTgxEmoji . load ( this ) ; if ( Settings . instance ( ) . getNewSetting ( Settings . SETTING_FLAG_EXPLICIT_DICE ) && ! isDebugInstance ( ) ) { animatedDiceExplicit . load ( this ) ; } }
public final boolean $ifExists ( ) { return ifExists ; }
public void onOpened ( ) { digestNotification ( ) ; }
public void cleanup ( ) { try { if ( inbuf != null ) { inbuf . close ( ) ; inbuf = null ; } } catch ( Exception e ) { FileLog . e ( e ) ; } try { if ( in != null ) { in . close ( ) ; in = null ; } } catch ( Exception e ) { FileLog . e ( e ) ; } try { if ( outbuf != null ) { outbuf . close ( ) ; outbuf = null ; } } catch ( Exception e ) { FileLog . e ( e ) ; } try { if ( out != null ) { out . close ( ) ; out = null ; } } catch ( Exception e ) { FileLog . e ( e ) ; } }
public static io . kubernetes . client . proto . V1Networking . NetworkPolicyIngressRule parseDelimitedFrom ( java . io . InputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( '\n' ) ; for ( List < String > row : rows ) { sb . append ( '|' ) . append ( '\t' ) ; for ( String s : row ) { sb . append ( s ) . append ( '\t' ) . append ( '|' ) ; } sb . append ( '\n' ) ; } return sb . toString ( ) ; }
public String getPosition ( ) { return position ; }
private static boolean canAccess ( Method m , Object target ) { if ( CAN_ACCESS_PRED != null ) { try { return ( boolean ) CAN_ACCESS_PRED . invoke ( m , target ) ; } catch ( Throwable t ) { throw Util . sneakyThrow ( t ) ; } } else { return true ; } }
public static < T > List < T > loadFactories ( Class < T > clazz , ClassLoader classLoader ) { if ( classLoader != null ) { return loadFactories ( ServiceLoader . load ( clazz , classLoader ) ) ; } classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; List < T > list = loadFactories ( ServiceLoader . load ( clazz , classLoader ) ) ; if ( list . isEmpty ( ) && classLoader != ServiceHelper . class . getClassLoader ( ) ) { list = loadFactories ( ServiceLoader . load ( clazz , ServiceHelper . class . getClassLoader ( ) ) ) ; } return list ; }
public void setTranslationY ( float translationY ) { super . setTranslationY ( translationY ) ; if ( fullscreenButtons != null ) { fullscreenButtons . setTranslationY ( dp ( 24 ) + translationY ) ; } if ( bulletinContainer != null ) { bulletinContainer . setTranslationY ( lerp ( ActionBar . getCurrentActionBarHeight ( ) - dp ( 24 ) , insets . top + dp ( 24 + 8 + 30 + 8 ) , fullscreenProgress ) + swipeContainer . getTranslationY ( ) ) ; } }
public AutoModRuleData addExemptChannels ( @ Nonnull Collection < ? extends GuildChannel > channels ) { Checks . noneNull ( channels , "Channels" ) ; Checks . check ( channels . size ( ) + exemptChannels . size ( ) <= AutoModRule . MAX_EXEMPT_CHANNELS , "Cannot add more than %d channels" , AutoModRule . MAX_EXEMPT_CHANNELS ) ; for ( GuildChannel channel : channels ) { exemptChannels . add ( channel . getId ( ) ) ; } return this ; }
public Builder setStatus ( io . kubernetes . client . proto . V1Networking . ServiceCIDRStatus value ) { if ( statusBuilder_ == null ) { if ( value == null ) { throw new NullPointerException ( ) ; } status_ = value ; onChanged ( ) ; } else { statusBuilder_ . setMessage ( value ) ; } bitField0_ |= 0x00000004 ; return this ; }
private void moveCard ( int fromIndex , int toIndex ) { if ( fromIndex < toIndex ) { for ( int i = 0 ; i < toIndex - fromIndex ; i ++ ) cardsView . swap ( fromIndex + i , fromIndex + i + 1 ) ; } else { for ( int i = 0 ; i < fromIndex - toIndex ; i ++ ) cardsView . swap ( fromIndex - i , fromIndex - i - 1 ) ; } }
public void setBrokerAddrTable ( Map < String , BrokerData > brokerAddrTable ) { this . brokerAddrTable = brokerAddrTable ; }
public static boolean floatArrayNotEquals ( float [ ] a , float [ ] b ) { return ! Arrays . equals ( a , b ) ; }
static < L , R > Either < L , R > cond ( boolean test , @ NonNull R right , @ NonNull L left ) { Objects . requireNonNull ( right , "right is null" ) ; Objects . requireNonNull ( left , "left is null" ) ; return cond ( test , ( ) -> right , ( ) -> left ) ; }
public void onPause ( ) { super . onPause ( ) ; detachListeners ( ) ; }
protected void convertArchLayer ( ArrayList < Image > layerList , Group layerGroup , float newBaseScale ) { ArrayList < Image > oldImages = new ArrayList < > ( layerList ) ; layerList . clear ( ) ; for ( int i = 0 ; i < oldImages . size ( ) ; i ++ ) { Image oldArch = oldImages . get ( i ) ; Image newArch = convertImage ( oldArch , newBaseScale ) ; layerList . add ( newArch ) ; layerGroup . add ( newArch ) ; while ( newArch . x + newArch . width ( ) < width && ( i == oldImages . size ( ) - 1 || oldImages . get ( i + 1 ) . y != oldArch . y ) ) { Image extraArch = new Image ( Assets . Splashes . Title . ARCHS ) ; extraArch . frame ( getArchFrame ( ) ) ; extraArch . scale . set ( newBaseScale ) ; extraArch . x = newArch . x + newArch . width ( ) ; extraArch . x -= 9 * newArch . scale . x ; extraArch . y = newArch . y ; layerList . add ( extraArch ) ; layerGroup . add ( extraArch ) ; newArch = extraArch ; } } }
public boolean match ( Object executor ) { return Objects . equals ( MATCH_CLASS_NAME , executor . getClass ( ) . getSimpleName ( ) ) ; }
public void setTot6 ( double tot6 ) { this . tot6 = tot6 ; }
public Object invoke ( Object reader , Object eq , Object opts , Object pendingForms ) { if ( ! RT . booleanCast ( RT . READEVAL . deref ( ) ) ) { throw Util . runtimeException ( "EvalReader not allowed when *read-eval* is false." ) ; } PushbackReader r = ( PushbackReader ) reader ; Object o = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; if ( o instanceof Symbol ) { return RT . classForName ( o . toString ( ) ) ; } else if ( o instanceof IPersistentList ) { Symbol fs = ( Symbol ) RT . first ( o ) ; if ( fs . equals ( THE_VAR ) ) { Symbol vs = ( Symbol ) RT . second ( o ) ; return RT . var ( vs . ns , vs . name ) ; } if ( fs . name . endsWith ( "." ) ) { Object [ ] args = RT . toArray ( RT . next ( o ) ) ; return Reflector . invokeConstructor ( RT . classForName ( fs . name . substring ( 0 , fs . name . length ( ) - 1 ) ) , args ) ; } if ( Compiler . namesStaticMember ( fs ) ) { Object [ ] args = RT . toArray ( RT . next ( o ) ) ; return Reflector . invokeStaticMethod ( fs . ns , fs . name , args ) ; } Object v = Compiler . maybeResolveIn ( Compiler . currentNS ( ) , fs ) ; if ( v instanceof Var ) { return ( ( IFn ) v ) . applyTo ( RT . next ( o ) ) ; } throw Util . runtimeException ( "Can't resolve " + fs ) ; } else throw new IllegalArgumentException ( "Unsupported #= form" ) ; }
default CustomCursor selectedCursor ( ) { return CustomCursor . RS3_GOLD ; }
public @ Nullable String getPassword ( ) { return password ; }
public static ClientMessage encodeMigrationEvent ( com . hazelcast . partition . MigrationState migrationState , int type ) { ClientMessage clientMessage = ClientMessage . createForEncode ( ) ; ClientMessage . Frame initialFrame = new ClientMessage . Frame ( new byte [ EVENT_MIGRATION_INITIAL_FRAME_SIZE ] , UNFRAGMENTED_MESSAGE ) ; initialFrame . flags |= ClientMessage . IS_EVENT_FLAG ; encodeInt ( initialFrame . content , TYPE_FIELD_OFFSET , EVENT_MIGRATION_MESSAGE_TYPE ) ; encodeInt ( initialFrame . content , PARTITION_ID_FIELD_OFFSET , - 1 ) ; encodeInt ( initialFrame . content , EVENT_MIGRATION_TYPE_FIELD_OFFSET , type ) ; clientMessage . add ( initialFrame ) ; MigrationStateCodec . encode ( clientMessage , migrationState ) ; return clientMessage ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } CompositePartitionKey that = ( CompositePartitionKey ) o ; if ( proxyPort != that . proxyPort ) { return false ; } if ( ! Objects . equals ( targetHostBaseUrl , that . targetHostBaseUrl ) ) { return false ; } if ( ! Objects . equals ( virtualHost , that . virtualHost ) ) { return false ; } if ( ! Objects . equals ( proxyHost , that . proxyHost ) ) { return false ; } return proxyType == that . proxyType ; }
public CredentialInfo addCredential ( CreateCredentialRequest createCredentialRequest ) { ValidationUtils . validateSqlObjectName ( createCredentialRequest . getName ( ) ) ; String callerId = IdentityUtils . findPrincipalEmailAddress ( ) ; CredentialDAO dao = CredentialDAO . from ( createCredentialRequest , callerId ) ; return TransactionManager . executeWithTransaction ( sessionFactory , session -> { if ( getCredentialDAO ( session , createCredentialRequest . getName ( ) ) != null ) { throw new BaseException ( ErrorCode . ALREADY_EXISTS , "Storage credential already exists: " + createCredentialRequest . getName ( ) ) ; } session . persist ( dao ) ; LOGGER . info ( "Added storage credential: {}" , dao . getName ( ) ) ; return dao . toCredentialInfo ( getAwsS3MasterRoleArn ( ) ) ; } , "Failed to add storage credential" , false ) ; }
public void gcClipboard ( ) { for ( int i = orderedClipboard . size ( ) - 1 ; i >= 0 ; i -- ) { WeakReference < TreeItem > ref = orderedClipboard . get ( i ) ; TreeItem item = ref . get ( ) ; if ( item != null ) { if ( item . getOpenable ( ) == null ) { orderedClipboard . remove ( i ) ; clipboard . remove ( item ) ; } } } resourcesClipboardPanel . update ( ) ; tagListClipboardPanel . update ( ) ; }
public static void replaceWithSchema ( Class source , Schema target ) { modelToSchemaMap . put ( source , target ) ; }
public void setPasswordRequireUnbreached ( Boolean passwordRequireUnbreached ) { this . passwordRequireUnbreached = passwordRequireUnbreached ; }
@ Override public long reads ( ) { return 0 ; }
public void closeMapEntryStagesReadFoundEntryDependants ( ) { this . closeKeySearch ( ) ; }
public Iterator getAttributeNames ( ) { return new AttributeNameIterator ( this ) ; }
void resetInternal ( ) { super . resetInternal ( ) ; to ( Direction . RIGHT ) ; }
public static < T > Message < T > forgeIdentityForTests ( Message < T > msg , InetAddressAndPort addr ) { return new Message < > ( new Header ( msg . header . id , msg . header . epoch , msg . header . verb , addr , msg . header . createdAtNanos , msg . header . expiresAtNanos , msg . header . flags , msg . header . params ) , msg . payload ) ; }
public static Throwable getCause ( final Throwable throwable ) { return getCause ( throwable , null ) ; }
public static io . kubernetes . client . proto . V1Networking . IngressClassParametersReference parseFrom ( byte [ ] data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public String toHexString ( ) { return Hex . toHexString ( data ) ; }
public VectorField build ( ) { if ( fieldName == null || algorithm == null || attributes == null || attributes . isEmpty ( ) ) { throw new IllegalArgumentException ( "All required VectorField parameters are not set." ) ; } return new VectorField ( fieldName , algorithm , attributes ) ; }
public CharSequence getSlowModeRestrictionText ( long chatId ) { return getSlowModeRestrictionText ( chatId , null ) ; }
public void findResource ( RunnableData < TdApi . Message > onDone , String query , long afterDateMs ) { withChat ( chatId -> { if ( chatId == 0 ) { onDone . runWithData ( null ) ; return ; } tdlib . incrementJobReferenceCount ( ) ; tdlib . openChat ( chatId , null , ( ) -> { tdlib . send ( new TdApi . SearchChatMessages ( chatId , null , query , null , 0 , 0 , 1 , new TdApi . SearchMessagesFilterDocument ( ) ) , ( messages , error ) -> { if ( messages != null ) { if ( messages . messages . length > 0 && TimeUnit . SECONDS . toMillis ( messages . messages [ 0 ] . date ) > afterDateMs ) { onDone . runWithData ( messages . messages [ 0 ] ) ; } else { onDone . runWithData ( null ) ; } } else { Log . e ( "Unable to fetch resource in @%s: %s" , channelUsername , TD . toErrorString ( error ) ) ; onDone . runWithData ( null ) ; } tdlib . closeChat ( chatId , null , false ) ; tdlib . decrementJobReferenceCount ( ) ; } ) ; } ) ; } ) ; }
public SiteBody icon32Delete ( Boolean icon32Delete ) { this . icon32Delete = icon32Delete ; return this ; }
@ Override public void enterMessageField ( Protobuf2Parser . MessageFieldContext ctx ) { }
protected Counter newResponseCounterFor ( final MethodDescriptor < ? , ? > method ) { return this . counterCustomizer . apply ( prepareCounterFor ( method , METRIC_NAME_CLIENT_RESPONSES_RECEIVED , "The total number of responses received" ) ) . register ( this . registry ) ; }
public QueryRendererBuilder visitFromQuery ( HqlParser . FromQueryContext ctx ) { QueryRendererBuilder builder = QueryRenderer . builder ( ) ; if ( ! isSubquery ( ctx ) && ctx . selectClause ( ) == null ) { QueryRendererBuilder countBuilder = QueryRenderer . builder ( ) ; countBuilder . append ( TOKEN_SELECT_COUNT ) ; if ( countProjection != null ) { countBuilder . append ( QueryTokens . token ( countProjection ) ) ; } else { if ( primaryFromAlias == null ) { countBuilder . append ( TOKEN_DOUBLE_UNDERSCORE ) ; } else { countBuilder . append ( QueryTokens . token ( primaryFromAlias ) ) ; } } countBuilder . append ( TOKEN_CLOSE_PAREN ) ; builder . appendExpression ( countBuilder ) ; } if ( ctx . fromClause ( ) != null ) { builder . appendExpression ( visit ( ctx . fromClause ( ) ) ) ; if ( primaryFromAlias == null ) { builder . append ( TOKEN_AS ) ; builder . append ( TOKEN_DOUBLE_UNDERSCORE ) ; } } if ( ctx . whereClause ( ) != null ) { builder . appendExpression ( visit ( ctx . whereClause ( ) ) ) ; } if ( ctx . groupByClause ( ) != null ) { builder . appendExpression ( visit ( ctx . groupByClause ( ) ) ) ; } if ( ctx . havingClause ( ) != null ) { builder . appendExpression ( visit ( ctx . havingClause ( ) ) ) ; } if ( ctx . selectClause ( ) != null ) { builder . appendExpression ( visit ( ctx . selectClause ( ) ) ) ; } return builder ; }
public String getColumnName ( int i ) { return columnNames [ i ] ; }
public static SharedLibrary loadNative ( Class < ? > context , String module , String name , boolean bundledWithLWJGL ) { return loadNative ( context , module , name , bundledWithLWJGL , true ) ; }
public int deleteById ( String [ ] id ) throws Exception { return systemInfoMapper . deleteById ( id ) ; }
IndexedSeq < T > dropRight ( int n ) ; @ Override IndexedSeq < T > dropRightUntil ( @ NonNull Predicate < ? super T > predicate ) ; @ Override IndexedSeq < T > dropRightWhile ( @ NonNull Predicate < ? super T > predicate ) ; @ Override default boolean endsWith ( @ NonNull Seq < ? extends T > that ) { Objects . requireNonNull ( that , "that is null" ) ; if ( that instanceof IndexedSeq ) { int i = length ( ) - 1 ; int j = that . length ( ) - 1 ; if ( j > i ) { return false ; } else { while ( j >= 0 ) { if ( ! Objects . equals ( this . get ( i ) , that . get ( j ) ) ) { return false ; } i -- ; j -- ; } return true ; } } else { return Seq . super . endsWith ( that ) ; } }
@ Override public @ Nullable String toDruidExpression ( RexNode rexNode , RelDataType rowType , DruidQuery query ) { final RexCall call = ( RexCall ) rexNode ; final RexNode arg = call . getOperands ( ) . get ( 0 ) ; final String druidExpression = DruidExpressions . toDruidExpression ( arg , rowType , query ) ; if ( druidExpression == null ) { return null ; } else if ( call . getOperands ( ) . size ( ) == 1 ) { return DruidQuery . format ( "ceil(%s)" , druidExpression ) ; } else if ( call . getOperands ( ) . size ( ) == 2 ) { final RexLiteral flag = ( RexLiteral ) call . getOperands ( ) . get ( 1 ) ; final TimeUnitRange timeUnit = requireNonNull ( ( TimeUnitRange ) flag . getValue ( ) ) ; final Granularity . Type type = DruidDateTimeUtils . toDruidGranularity ( timeUnit ) ; if ( type == null ) { return null ; } String isoPeriodFormat = DruidDateTimeUtils . toISOPeriodFormat ( type ) ; if ( isoPeriodFormat == null ) { return null ; } final TimeZone tz ; if ( arg . getType ( ) . getSqlTypeName ( ) == SqlTypeName . TIMESTAMP_WITH_LOCAL_TIME_ZONE ) { tz = TimeZone . getTimeZone ( query . getConnectionConfig ( ) . timeZone ( ) ) ; } else { tz = DateTimeUtils . UTC_ZONE ; } return DruidExpressions . applyTimestampCeil ( druidExpression , isoPeriodFormat , "" , tz ) ; } else { return null ; } }
public boolean canCopyPublicMessageLinks ( long chatId ) { if ( chatId == 0 ) { return false ; } long supergroupId = ChatId . toSupergroupId ( chatId ) ; if ( supergroupId == 0 ) { return false ; } TdApi . Usernames usernames = cache ( ) . supergroupUsernames ( supergroupId ) ; return Td . hasUsername ( usernames ) ; }
public CruiseControlApiUsers getApiUsers ( ) { return apiUsers ; }
private void adjustRight ( RectF rect , float right , RectF bounds , int viewWidth , float snapMargin , float aspectRatio , boolean topMoves , boolean bottomMoves ) { float newRight = right ; if ( newRight > viewWidth ) { newRight = viewWidth + ( newRight - viewWidth ) / 1.05f ; mTouchOffset . x -= ( newRight - viewWidth ) / 1.1f ; } if ( newRight > bounds . right ) { mTouchOffset . x -= ( newRight - bounds . right ) / 2f ; } if ( bounds . right - newRight < snapMargin ) { newRight = bounds . right ; } if ( newRight - rect . left < mMinCropWidth ) { newRight = rect . left + mMinCropWidth ; } if ( newRight - rect . left > mMaxCropWidth ) { newRight = rect . left + mMaxCropWidth ; } if ( bounds . right - newRight < snapMargin ) { newRight = bounds . right ; } if ( aspectRatio > 0 ) { float newHeight = ( newRight - rect . left ) / aspectRatio ; if ( newHeight < mMinCropHeight ) { newRight = Math . min ( bounds . right , rect . left + mMinCropHeight * aspectRatio ) ; newHeight = ( newRight - rect . left ) / aspectRatio ; } if ( newHeight > mMaxCropHeight ) { newRight = Math . min ( bounds . right , rect . left + mMaxCropHeight * aspectRatio ) ; newHeight = ( newRight - rect . left ) / aspectRatio ; } if ( topMoves && bottomMoves ) { newRight = Math . min ( newRight , Math . min ( bounds . right , rect . left + bounds . height ( ) * aspectRatio ) ) ; } else { if ( topMoves && rect . bottom - newHeight < bounds . top ) { newRight = Math . min ( bounds . right , rect . left + ( rect . bottom - bounds . top ) * aspectRatio ) ; newHeight = ( newRight - rect . left ) / aspectRatio ; } if ( bottomMoves && rect . top + newHeight > bounds . bottom ) { newRight = Math . min ( newRight , Math . min ( bounds . right , rect . left + ( bounds . bottom - rect . top ) * aspectRatio ) ) ; } } } rect . right = newRight ; }
public static boolean isRun ( ) { return gPrefs . getBoolean ( RUN_NOTIFICATION , true ) ; }
public boolean isCancelled ( ) { return mDialog . isCancelled ( ) ; }
public boolean requestChildRectangleOnScreen ( @ NonNull RecyclerView parent , @ NonNull View child , @ NonNull Rect rect , boolean immediate ) { return requestChildRectangleOnScreen ( parent , child , rect , immediate , false ) ; }
public Type getChangeType ( ) { return type ; }
public void onActivityPaused ( Activity activity ) { if ( mFocusActivity != activity ) { return ; } mFocusActivity = null ; }
public int getState ( ) { return state ; }
public Detail getNet ( ) { return net ; }
public void setGlobalFreeze ( final boolean globalFreeze ) { this . globalFreeze = globalFreeze ; }
public boolean fetchBrokerMetricSamples ( long startMs , long endMs , long timeoutMs , SampleStore sampleStore ) { LOG . info ( "Kicking off broker metric sampling for time range [{}, {}], duration {} ms with timeout {} ms." , startMs , endMs , endMs - startMs , timeoutMs ) ; Set < TopicPartition > partitionAssignment = _partitionAssignor . assignPartitions ( _metadataClient . cluster ( ) ) ; MetricFetcher trainingFetcher = new TrainingFetcher ( _metricSampler , _metadataClient . cluster ( ) , sampleStore , partitionAssignment , startMs , endMs , _metricDef , _trainingSamplesFetcherTimer , _trainingSamplesFetcherFailureRate ) ; return fetchSamples ( trainingFetcher , timeoutMs ) ; }
public static String parseCode ( @ NonNull Bitmap bitmap , @ Nullable Map < DecodeHintType , Object > hints ) { Result result = parseCodeResult ( bitmap , hints ) ; if ( result != null ) { return result . getText ( ) ; } return null ; }
public boolean canDeleteCharacters ( ) { return mExpectedSelStart > 0 ; }
protected Icon toGray ( Icon icon ) { if ( icon instanceof ImageIcon ) { Image grayImage = GrayFilter . createDisabledImage ( ( ( ImageIcon ) icon ) . getImage ( ) ) ; return new ImageIcon ( grayImage ) ; } return icon ; }
public static void setDictionaryPageSize ( Job job , int pageSize ) { getConfiguration ( job ) . setInt ( DICTIONARY_PAGE_SIZE , pageSize ) ; }
public String toString ( ) { return name . toString ( ) ; }
public Criteria andIdIsNotNull ( ) { addCriterion ( "id is not null" ) ; return ( Criteria ) this ; }
public AudioAttributes getAudioAttributes ( ) { return sink . getAudioAttributes ( ) ; }
public void updateClob ( String columnLabel , Reader reader ) throws SQLException { throw new SQLFeatureNotSupportedException ( ) ; }
public static io . kubernetes . client . proto . V1Networking . NetworkPolicySpec parseFrom ( java . io . InputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input ) ; }
public void loadData ( @ NonNull String data , @ Nullable String mimeType , @ Nullable String encoding ) { checkThread ( ) ; mProvider . loadData ( data , mimeType , encoding ) ; }
public static io . kubernetes . client . proto . V1Networking . ServiceCIDR parseFrom ( byte [ ] data , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data , extensionRegistry ) ; }
public static String buildFullRequestUrl ( String scheme , String serverName , int serverPort , String requestURI , @ Nullable String queryString ) { scheme = scheme . toLowerCase ( Locale . ENGLISH ) ; StringBuilder url = new StringBuilder ( ) ; url . append ( scheme ) . append ( "://" ) . append ( serverName ) ; if ( "http" . equals ( scheme ) ) { if ( serverPort != 80 ) { url . append ( ":" ) . append ( serverPort ) ; } } else if ( "https" . equals ( scheme ) ) { if ( serverPort != 443 ) { url . append ( ":" ) . append ( serverPort ) ; } } url . append ( requestURI ) ; if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
public void setMarkerColor ( int color ) { mMarker . setColorFilter ( color , PorterDuff . Mode . SRC_ATOP ) ; initTimeline ( ) ; }
public void serialize ( JsonBodyDTO jsonBodyDTO , JsonGenerator jgen , SerializerProvider provider ) throws IOException { boolean notNonDefault = jsonBodyDTO . getNot ( ) != null && jsonBodyDTO . getNot ( ) ; boolean optionalNonDefault = jsonBodyDTO . getOptional ( ) != null && jsonBodyDTO . getOptional ( ) ; boolean contentTypeNonDefault = jsonBodyDTO . getContentType ( ) != null && ! jsonBodyDTO . getContentType ( ) . equals ( JsonBody . DEFAULT_JSON_CONTENT_TYPE . toString ( ) ) ; boolean matchTypeNonDefault = jsonBodyDTO . getMatchType ( ) != JsonBody . DEFAULT_MATCH_TYPE ; if ( serialiseDefaultValues || notNonDefault || optionalNonDefault || contentTypeNonDefault || matchTypeNonDefault ) { jgen . writeStartObject ( ) ; if ( notNonDefault ) { jgen . writeBooleanField ( "not" , jsonBodyDTO . getNot ( ) ) ; } if ( optionalNonDefault ) { jgen . writeBooleanField ( "optional" , jsonBodyDTO . getOptional ( ) ) ; } if ( contentTypeNonDefault ) { jgen . writeStringField ( "contentType" , jsonBodyDTO . getContentType ( ) ) ; } jgen . writeStringField ( "type" , jsonBodyDTO . getType ( ) . name ( ) ) ; try { jgen . writeObjectField ( "json" , OBJECT_MAPPER . readTree ( jsonBodyDTO . getJson ( ) ) ) ; } catch ( Throwable throwable ) { new MockServerLogger ( ) . logEvent ( new LogEntry ( ) . setType ( EXCEPTION ) . setMessageFormat ( "exception:{} while deserialising JsonBodyDTO with json:{}" ) . setArguments ( throwable . getMessage ( ) , jsonBodyDTO . getJson ( ) ) . setThrowable ( throwable ) ) ; } if ( jsonBodyDTO . getRawBytes ( ) != null ) { jgen . writeObjectField ( "rawBytes" , jsonBodyDTO . getRawBytes ( ) ) ; } if ( matchTypeNonDefault ) { jgen . writeStringField ( "matchType" , jsonBodyDTO . getMatchType ( ) . name ( ) ) ; } jgen . writeEndObject ( ) ; } else { jgen . writeObject ( OBJECT_MAPPER . readTree ( jsonBodyDTO . getJson ( ) ) ) ; } }
public void menuAboutToShow ( IMenuManager manager ) { manager . appendToGroup ( DashboardView . INFO_MENU_GROUP_NAME , new LabelOnly ( getLabel ( ) ) ) ; MenuManager subMenu = new MenuManager ( Messages . LabelClientFilter ) ; manager . add ( subMenu ) ; menu . menuAboutToShow ( subMenu ) ; }
AlignmentPattern find ( ) throws NotFoundException { int startX = this . startX ; int height = this . height ; int maxJ = startX + width ; int middleI = startY + ( height / 2 ) ; int [ ] stateCount = new int [ 3 ] ; for ( int iGen = 0 ; iGen < height ; iGen ++ ) { int i = middleI + ( ( iGen & 0x01 ) == 0 ? ( iGen + 1 ) / 2 : - ( ( iGen + 1 ) / 2 ) ) ; stateCount [ 0 ] = 0 ; stateCount [ 1 ] = 0 ; stateCount [ 2 ] = 0 ; int j = startX ; while ( j < maxJ && ! image . get ( j , i ) ) { j ++ ; } int currentState = 0 ; while ( j < maxJ ) { if ( image . get ( j , i ) ) { if ( currentState == 1 ) { stateCount [ 1 ] ++ ; } else { if ( currentState == 2 ) { if ( foundPatternCross ( stateCount ) ) { AlignmentPattern confirmed = handlePossibleCenter ( stateCount , i , j ) ; if ( confirmed != null ) { return confirmed ; } } stateCount [ 0 ] = stateCount [ 2 ] ; stateCount [ 1 ] = 1 ; stateCount [ 2 ] = 0 ; currentState = 1 ; } else { stateCount [ ++ currentState ] ++ ; } } } else { if ( currentState == 1 ) { currentState ++ ; } stateCount [ currentState ] ++ ; } j ++ ; } if ( foundPatternCross ( stateCount ) ) { AlignmentPattern confirmed = handlePossibleCenter ( stateCount , i , maxJ ) ; if ( confirmed != null ) { return confirmed ; } } } if ( ! possibleCenters . isEmpty ( ) ) { return possibleCenters . get ( 0 ) ; } throw NotFoundException . getNotFoundInstance ( ) ; }
public static PartitionGetResult partitionGetWithCount ( PSContext psContext , PartitionGetParam partParam ) { PartGetNeighborWithCountParam param = ( PartGetNeighborWithCountParam ) partParam ; KeyValuePart keyValuePart = param . getIndicesPart ( ) ; long [ ] nodeIds = ( ( ILongKeyIntValuePartOp ) keyValuePart ) . getKeys ( ) ; int [ ] count = ( ( ILongKeyIntValuePartOp ) keyValuePart ) . getValues ( ) ; long [ ] [ ] neighbors = new long [ nodeIds . length ] [ ] ; Random r = new Random ( ) ; ServerLongAnyRow row = GraphMatrixUtils . getPSLongKeyRow ( psContext , param ) ; for ( int i = 0 ; i < nodeIds . length ; i ++ ) { long nodeId = nodeIds [ i ] ; DynamicSimpleNeighborElement element = ( DynamicSimpleNeighborElement ) ( row . get ( nodeId ) ) ; if ( element == null || count [ i ] <= 0 ) { neighbors [ i ] = null ; } else { neighbors [ i ] = new long [ count [ i ] ] ; for ( int j = 0 ; j < count [ i ] ; j ++ ) { neighbors [ i ] [ j ] = element . sample ( r , nodeId ) ; } } } return new PartGetNeighborWithCountResult ( nodeIds , neighbors ) ; }
private String methodNameOf ( final JCMethodInvocation methodCall ) { if ( methodCall . meth instanceof JCIdent ) { return ( ( JCIdent ) methodCall . meth ) . name . toString ( ) ; } else { return ( ( JCFieldAccess ) methodCall . meth ) . name . toString ( ) ; } }
public void setAccessKeyId ( String accessKeyId ) { this . accessKeyId = accessKeyId ; }
public boolean attachTo ( Char target ) { if ( super . attachTo ( target ) ) { if ( Dungeon . level != null ) { target . viewDistance = Math . max ( Dungeon . level . viewDistance , DISTANCE ) ; Dungeon . observe ( ) ; } return true ; } else { return false ; } }
public synchronized void propagateLocalIndexStatus ( String keyspace , String index , Index . Status status ) { try { Map < String , Index . Status > statusMap = peerIndexStatus . computeIfAbsent ( FBUtilities . getBroadcastAddressAndPort ( ) , k -> new HashMap < > ( ) ) ; String keyspaceIndex = identifier ( keyspace , index ) ; if ( status == Index . Status . DROPPED ) statusMap . remove ( keyspaceIndex ) ; else statusMap . put ( keyspaceIndex , status ) ; if ( Gossiper . instance . isEnabled ( ) ) { CassandraVersion minVersion = ClusterMetadata . current ( ) . directory . clusterMinVersion . cassandraVersion ; String newSerializedStatusMap = shouldWriteLegacyStatusFormat ( minVersion ) ? JsonUtils . writeAsJsonString ( statusMap ) : toSerializedFormat ( statusMap ) ; statusPropagationExecutor . submit ( ( ) -> { VersionedValue value = StorageService . instance . valueFactory . indexStatus ( newSerializedStatusMap ) ; Gossiper . instance . addLocalApplicationState ( ApplicationState . INDEX_STATUS , value ) ; } ) ; } } catch ( Exception e ) { logger . warn ( "Unable to propagate index status: {}" , e . getMessage ( ) ) ; } }
public Optional < Map < String , ContainerBuilder > > createNumberVariableAggregation ( final VariableAggregationContextES context ) { if ( context . getVariableRangeMinMaxStats ( ) . isEmpty ( ) ) { return Optional . empty ( ) ; } final Optional < Double > min = getBaselineForNumberVariableAggregation ( context ) ; if ( min . isEmpty ( ) ) { return Optional . empty ( ) ; } final double intervalSize = getIntervalSize ( context , min . get ( ) ) ; final double max = context . getMaxVariableValue ( ) ; final String digitFormat = VariableType . DOUBLE . equals ( context . getVariableType ( ) ) ? "0.00" : "0" ; final Aggregation . Builder . ContainerBuilder histogramAggregation = generateHistogramWithField ( VARIABLE_HISTOGRAM_AGGREGATION , intervalSize , min . get ( ) , max , context . getNestedVariableValueFieldLabel ( ) , digitFormat , context . getSubAggregations ( ) ) ; return Optional . of ( Map . of ( VARIABLE_HISTOGRAM_AGGREGATION , histogramAggregation ) ) ; }
protected XMPPPacketReader initialValue ( ) { final XMPPPacketReader parser = new XMPPPacketReader ( ) ; parser . setXPPFactory ( factory ) ; return parser ; }
protected void channelRead0 ( ChannelHandlerContext ctx , AddressedEnvelope < ByteBuf , InetSocketAddress > envelope ) throws Exception { final ByteBuf msg = envelope . content ( ) ; final byte [ ] bytes = new byte [ msg . readableBytes ( ) ] ; msg . readBytes ( bytes ) ; final RawMessage raw = new RawMessage ( bytes , envelope . sender ( ) ) ; input . processRawMessage ( raw ) ; }
@ Override public void enterReservedWord ( Protobuf2Parser . ReservedWordContext ctx ) { }
public void addDigest ( byte [ ] x509CertificateDigestBytes , String algorithmURI ) { this . add ( new XMLX509Digest ( getDocument ( ) , x509CertificateDigestBytes , algorithmURI ) ) ; }
SortedMap < K , V > reject ( @ NonNull Predicate < ? super Tuple2 < K , V > > predicate ) ; @ Override SortedMap < K , V > filter ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override SortedMap < K , V > reject ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override SortedMap < K , V > filterKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override SortedMap < K , V > rejectKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override SortedMap < K , V > filterValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override SortedMap < K , V > rejectValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeAll ( @ NonNull BiPredicate < ? super K , ? super V > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeKeys ( @ NonNull Predicate < ? super K > predicate ) ; @ Override @ Deprecated SortedMap < K , V > removeValues ( @ NonNull Predicate < ? super V > predicate ) ; @ Override < K2 , V2 > SortedMap < K2 , V2 > flatMap ( @ NonNull BiFunction < ? super K , ? super V , ? extends Iterable < Tuple2 < K2 , V2 > > > mapper ) ; @ Override < C > Map < C , ? extends SortedMap < K , V > > groupBy ( @ NonNull Function < ? super Tuple2 < K , V > , ? extends C > classifier ) ; @ Override Iterator < ? extends SortedMap < K , V > > grouped ( int size ) ; @ Override SortedMap < K , V > init ( ) ; @ Override Option < ? extends SortedMap < K , V > > initOption ( ) ; @ Override default boolean isOrdered ( ) { return true ; }
public void setFeatureDrawableResource ( int featureId , int resId ) { mDialog . setFeatureDrawableResource ( featureId , resId ) ; }
public boolean onTouchEvent ( MotionEvent event ) { ( ( ViewGroup ) fragmentView ) . requestDisallowInterceptTouchEvent ( true ) ; return super . onTouchEvent ( event ) ; }
public CompletableFuture < Void > asyncRemoveWorkflow ( String workflowId ) { return CompletableFuture . runAsync ( ( ) -> removeWorkflow ( workflowId ) , executorService ) ; }
public int getPeerEurekaStatusRefreshTimeIntervalMs ( ) { return peerEurekaStatusRefreshTimeIntervalMs ; }
public V1ClusterRoleBinding addSubjectsItem ( RbacV1Subject subjectsItem ) { if ( this . subjects == null ) { this . subjects = new ArrayList < > ( ) ; } this . subjects . add ( subjectsItem ) ; return this ; }
public void handle ( long now ) { if ( ! dirty . get ( ) ) { return ; } updateVisibilities ( scroll , vbox ) ; dirty . set ( false ) ; }
public ValueLob copyLob ( ValueLob old , int tableId ) { throw new UnsupportedOperationException ( ) ; }
private Quaternion interpolateRotation ( float keyFrameTime ) { assert keyFrameTime >= 0f && keyFrameTime <= duration ; float prev = 0f ; float next = duration ; for ( float key : rotations . keySet ( ) ) { if ( key <= keyFrameTime && key > prev ) { prev = key ; } if ( key >= keyFrameTime && key < next ) { next = key ; } } assert prev <= next ; Quaternion prevRotation = rotations . get ( prev ) ; Quaternion result = new Quaternion ( ) ; if ( prev == next || ! rotations . containsKey ( next ) ) { result . set ( prevRotation ) ; } else { float fraction = ( keyFrameTime - prev ) / ( next - prev ) ; assert fraction >= 0f && fraction <= 1f ; Quaternion nextRotation = rotations . get ( next ) ; result . slerp ( prevRotation , nextRotation , fraction ) ; } return result ; }
private void updateTaskStatusAndReason ( String id , Integer status , String reason ) { updateTaskStatus ( id , status ) ; taskService . setVariableLocal ( id , BpmnVariableConstants . TASK_VARIABLE_REASON , reason ) ; }
private void setPaymentMethod ( TLRPC . TL_paymentFormMethod method ) { paymentFormMethod = method ; }
protected final ChannelFuture writePing ( ChannelHandlerContext ctx ) { lastPingPayload = random . nextLong ( ) ; final ChannelFuture future = frameWriter . writePing ( ctx , false , lastPingPayload , ctx . newPromise ( ) ) ; ctx . flush ( ) ; listener ( ) . pingWrite ( lastPingPayload ) ; return future ; }
public void setPreviewLabelTextSize ( int previewLabelTextSize ) { mPreviewLabelTextSize = previewLabelTextSize ; }
protected void runBlock ( ) { super . runBlock ( ) ; conditionEditor . okButtonActionPerformed ( null ) ; }
public boolean isImagePattern ( ) { return imagePattern ; }
public long getValueCount ( ) { return entry . termsDictEntry . termsDictSize ; }
public ComplexItemEntity setTitle ( String title ) { this . title = title ; return this ; }
public static io . kubernetes . client . proto . V1Networking . IngressClass parseFrom ( com . google . protobuf . ByteString data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public < T > void printResults ( T entity ) { output ( entity ) ; }
public NDList getRowFeatures ( NDManager manager , long index , List < Feature > selected ) { DynamicBuffer bb = new DynamicBuffer ( ) ; for ( Feature feature : selected ) { String name = feature . getName ( ) ; String value = getCell ( index , name ) ; feature . getFeaturizer ( ) . featurize ( bb , value ) ; } FloatBuffer buf = bb . getBuffer ( ) ; return new NDList ( manager . create ( buf , new Shape ( bb . getLength ( ) ) ) ) ; }
public short readShort ( ) { return dataInput . readShort ( ) ; }
public void acceptComment ( final RequestContext context ) { context . renderJSON ( StatusCodes . ERR ) ; final JSONObject requestJSONObject = context . requestJSON ( ) ; final JSONObject currentUser = Sessions . getUser ( ) ; final String userId = currentUser . optString ( Keys . OBJECT_ID ) ; final String commentId = requestJSONObject . optString ( Comment . COMMENT_T_ID ) ; try { final JSONObject comment = commentQueryService . getComment ( commentId ) ; if ( null == comment ) { context . renderMsg ( "Not found comment to accept" ) ; return ; } final String commentAuthorId = comment . optString ( Comment . COMMENT_AUTHOR_ID ) ; if ( StringUtils . equals ( userId , commentAuthorId ) ) { context . renderMsg ( langPropsService . get ( "thankSelfLabel" ) ) ; return ; } final String articleId = comment . optString ( Comment . COMMENT_ON_ARTICLE_ID ) ; final JSONObject article = articleQueryService . getArticle ( articleId ) ; if ( ! StringUtils . equals ( userId , article . optString ( Article . ARTICLE_AUTHOR_ID ) ) ) { context . renderMsg ( langPropsService . get ( "sc403Label" ) ) ; return ; } commentMgmtService . acceptComment ( commentId ) ; context . renderJSON ( StatusCodes . SUCC ) ; } catch ( final ServiceException e ) { context . renderMsg ( e . getMessage ( ) ) ; } }
public boolean containsMethod ( SootMethod sm ) { return ( edge != null && edge . tgt ( ) == sm ) || ( next != null && next . containsMethod ( sm ) ) ; }
public void startOffset ( long startOffset ) { this . startOffset = startOffset ; }
public void setShipZip ( String shipZip ) { this . shipZip = shipZip ; }
public static void setPageRowCountLimit ( JobContext jobContext , int rowCount ) { setPageRowCountLimit ( getConfiguration ( jobContext ) , rowCount ) ; }
public void onAnimationUpdate ( @ NonNull ValueAnimator animation ) { fullscreenTransitionProgress = ( float ) animation . getAnimatedValue ( ) ; fullscreenProgress = fullscreen ? fullscreenTransitionProgress : 1.0f - fullscreenTransitionProgress ; actionBar . setAlpha ( 1.0f - fullscreenProgress ) ; actionBar . setTranslationY ( - ActionBar . getCurrentActionBarHeight ( ) * fullscreenProgress ) ; swipeContainer . setTranslationY ( lerp ( fromTranslationY , toTranslationY , fullscreenTransitionProgress ) ) ; swipeContainer . setTranslationX ( lerp ( fromTranslationX , toTranslationX , fullscreenTransitionProgress ) ) ; botButtons . setTranslationX ( lerp ( fromButtonsTranslationX , 0 , fullscreenTransitionProgress ) ) ; fullscreenButtons . setAlpha ( fullscreenProgress ) ; windowView . invalidate ( ) ; webViewContainer . setViewPortHeightOffset ( swipeContainer . getTranslationY ( ) - toTranslationY ) ; webViewContainer . invalidateViewPortHeight ( false , false ) ; updateDownloadBulletinArrow ( ) ; }
default int updateByPrimaryKey ( CrawlBatchTask record ) { return update ( c -> c . set ( sourceId ) . equalTo ( record :: getSourceId ) . set ( crawlCountSuccess ) . equalTo ( record :: getCrawlCountSuccess ) . set ( crawlCountTarget ) . equalTo ( record :: getCrawlCountTarget ) . set ( taskStatus ) . equalTo ( record :: getTaskStatus ) . set ( startTime ) . equalTo ( record :: getStartTime ) . set ( endTime ) . equalTo ( record :: getEndTime ) . where ( id , isEqualTo ( record :: getId ) ) ) ; }
public Object invoke ( Object reader , Object quote , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; Object o = read ( r , true , null , true , opts , ensurePending ( pendingForms ) ) ; return RT . list ( THE_VAR , o ) ; }
public void execute ( Fragment fragment , Writer writer ) throws IOException { String input = fragment . execute ( ) ; int inputLength = input . length ( ) ; StringBuilder builder = new StringBuilder ( ) ; if ( inputLength > maxLength ) { builder . append ( String . format ( Locale . ROOT , SPLIT_INIT , inputLength ) ) ; int currentPosition = 0 ; int currentStringLength = 0 ; char currentLastChar = '\\' ; while ( currentPosition + maxLength < input . length ( ) ) { currentStringLength = maxLength ; currentLastChar = input . charAt ( currentPosition + currentStringLength - 1 ) ; if ( currentLastChar == '\\' ) { -- currentStringLength ; } builder . append ( String . format ( Locale . ROOT , SPLIT_PART , input . substring ( currentPosition , currentPosition + currentStringLength ) ) ) ; currentPosition += currentStringLength ; } if ( currentPosition < input . length ( ) ) { builder . append ( String . format ( Locale . ROOT , SPLIT_PART , input . substring ( currentPosition ) ) ) ; } builder . append ( SPLIT_SUFFIX ) ; } else { builder . append ( String . format ( Locale . ROOT , "\"%s\"" , input ) ) ; } writer . write ( builder . toString ( ) ) ; }
void readIntoArray ( JsonReader reader , int index , Object [ ] target ) throws IOException , JsonParseException { Object fieldValue = typeAdapter . read ( reader ) ; if ( fieldValue == null && isPrimitive ) { throw new JsonParseException ( "null is not allowed as value for record component '" + fieldName + "' of primitive type; at path " + reader . getPath ( ) ) ; } target [ index ] = fieldValue ; }
public boolean getHighlightGraphNodes ( ) { return highlightGraphNodesCheckBox . isSelected ( ) ; }
public boolean isSearchable ( int col ) { return true ; }
public static io . kubernetes . client . proto . V1Networking . IngressServiceBackend parseFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
public void changedUpdate ( DocumentEvent e ) { updateCLIArea ( ) ; }
public final AlterSequenceImpl < T > renameTo ( Sequence < ? > renameTo ) { this . renameTo = renameTo ; return this ; }
public Builder withNamespaceAware ( boolean namespaceAware ) { this . namespaceAware = namespaceAware ; return this ; }
public boolean isHeadersInEvent ( ) { return headersInEvent ; }
public void run ( ) { TreePath selectionPath = getLeadSelectionPath ( ) ; int oldSelectionIndex = getLeadSelectionRow ( ) ; children . sort ( nodeComparator ) ; fireNodesChanged ( ) ; treeModel . getParentTree ( ) . setSelectionPath ( selectionPath ) ; refreshSelection ( oldSelectionIndex , getLeadSelectionRow ( ) ) ; }
public boolean isChecked ( ) { return checked ; }
public Builder addItems ( io . kubernetes . client . proto . V1Networking . IngressClass value ) { if ( itemsBuilder_ == null ) { if ( value == null ) { throw new NullPointerException ( ) ; } ensureItemsIsMutable ( ) ; items_ . add ( value ) ; onChanged ( ) ; } else { itemsBuilder_ . addMessage ( value ) ; } return this ; }
public final PipelineIndicator . FlowObservation collectWorkerUtilizationFlowObservation ( ) { return this . collectFlowObservation ( WORKER_UTILIZATION_KEY . asJavaString ( ) :: equals ) ; }
public Object call ( Properties bindings , Object [ ] args ) { if ( args . length == 2 && args [ 0 ] instanceof Number && args [ 1 ] instanceof Number ) { return Math . max ( ( ( Number ) args [ 0 ] ) . doubleValue ( ) , ( ( Number ) args [ 1 ] ) . doubleValue ( ) ) ; } return new EvalError ( EvalErrorMessage . expects_two_numbers ( ControlFunctionRegistry . getFunctionName ( this ) ) ) ; }
public ParquetReaderConfig setVectorizedDecodingEnabled ( boolean vectorizedDecodingEnabled ) { options = ParquetReaderOptions . builder ( options ) . withVectorizedDecodingEnabled ( vectorizedDecodingEnabled ) . build ( ) ; return this ; }
public boolean isContactChat ( TdApi . Chat chat ) { if ( chat != null ) { TdApi . User user = chatUser ( chat ) ; return TD . isContact ( user ) && ! isSelfUserId ( user . id ) ; } return false ; }
public static Version maintainPreservingPatches ( GameRepository repository , Version version ) { if ( ! version . isResolvedPreservingPatches ( ) ) throw new IllegalArgumentException ( "MaintainTask requires independent game version" ) ; Version newVersion = maintain ( repository , version . resolve ( repository ) ) ; return newVersion . setPatches ( version . getPatches ( ) ) . markAsUnresolved ( ) ; }
public Component getCustomEditor ( ) { return null ; }
protected Builder newBuilderForType ( com . google . protobuf . GeneratedMessageV3 . BuilderParent parent ) { Builder builder = new Builder ( parent ) ; return builder ; }
public boolean isLeftJoin ( ) { return "<" . equals ( getJoinType ( ) ) ; }
public boolean isFinished ( ) { return BitwiseUtils . hasFlag ( flags , FLAG_COMPLETED | FLAG_FAILED ) ; }
static void setSnackbarLines ( Snackbar snackbar , int lines ) { View sv = snackbar . getView ( ) ; if ( sv == null ) return ; TextView tv = sv . findViewById ( com . google . android . material . R . id . snackbar_text ) ; if ( tv == null ) return ; tv . setMaxLines ( lines ) ; }
public Size apply ( MethodVisitor methodVisitor , Implementation . Context implementationContext ) { methodVisitor . visitInsn ( opcode ) ; return SIZE ; }
public void add ( XMLX509IssuerSerial xmlX509IssuerSerial ) { appendSelf ( xmlX509IssuerSerial ) ; addReturnToSelf ( ) ; }
public static io . kubernetes . client . proto . V1Networking . IngressRuleValue parseFrom ( com . google . protobuf . ByteString data , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data , extensionRegistry ) ; }
public String toString ( ) { return "AnonymousOrNonStaticLocalClassAdapter" ; }
public float getFontDescentDescriptor ( ) { return font . getFontDescriptor ( DocumentFont . DESCENT , fontSize ) ; }
public java . util . List < io . kubernetes . client . proto . V1Networking . IngressRule . Builder > getRulesBuilderList ( ) { return getRulesFieldBuilder ( ) . getBuilderList ( ) ; }
public boolean usedInit ( ) { return used ; }
public String getRegion ( ) { return config . getOrDefault ( GRAVITINO_CLOUD_REGION_CODE . key , GRAVITINO_CLOUD_REGION_CODE . defaultValue ) ; }
public static void checkAnyActionOnWarehouse ( ConnectContext context , String name ) throws AccessDeniedException { Warehouse warehouse = GlobalStateMgr . getCurrentState ( ) . getWarehouseMgr ( ) . getWarehouse ( name ) ; if ( warehouse . getId ( ) != WarehouseManager . DEFAULT_WAREHOUSE_ID ) { getInstance ( ) . getAccessControlOrDefault ( InternalCatalog . DEFAULT_INTERNAL_CATALOG_NAME ) . checkAnyActionOnWarehouse ( context , name ) ; } }
public void extractToHDFS ( String dir , String project ) throws IOException { FavoriteRuleManager manager = FavoriteRuleManager . getInstance ( project ) ; FileSystem fs = HadoopUtil . getWorkingFileSystem ( ) ; String filePathStr = StringUtils . appendIfMissing ( dir , "/" ) + project + ZIP_SUFFIX ; try ( FSDataOutputStream fos = fs . create ( new Path ( filePathStr ) ) ; ZipOutputStream zos = new ZipOutputStream ( fos ) ; BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( zos , Charset . defaultCharset ( ) ) ) ) { for ( FavoriteRule line : manager . getAll ( ) ) { zos . putNextEntry ( new ZipEntry ( line . getId ( ) + ".json" ) ) ; bw . write ( JsonUtil . writeValueAsString ( line ) ) ; bw . flush ( ) ; } } }
public File getSegmentFiles ( final DataSegment segment ) { final SegmentCacheEntry cacheEntry = new SegmentCacheEntry ( segment ) ; final ReferenceCountingLock lock = lock ( segment ) ; synchronized ( lock ) { try { for ( StorageLocation location : locations ) { final SegmentCacheEntry entry = location . getCacheEntry ( cacheEntry . id ) ; if ( entry != null ) { return entry . storageDir ; } } } finally { unlock ( segment , lock ) ; } } return null ; }
public static Date parseDate ( String src , String pattern ) throws ParseException { return getSdFormat ( pattern ) . parse ( src ) ; }
private void updateSupergroup ( TdApi . UpdateSupergroup update ) { TdApi . Chat chat ; synchronized ( dataLock ) { long chatId = ChatId . fromSupergroupId ( update . supergroup . id ) ; chat = chats . get ( chatId ) ; if ( chat != null ) { boolean prevIsChannel = ( ( TdApi . ChatTypeSupergroup ) chat . type ) . isChannel ; boolean nowIsChannel = update . supergroup . isChannel ; if ( prevIsChannel != nowIsChannel ) { ( ( TdApi . ChatTypeSupergroup ) chat . type ) . isChannel = nowIsChannel ; long supergroupId = ( ( TdApi . ChatTypeSupergroup ) chat . type ) . supergroupId ; if ( nowIsChannel ) { channels . add ( supergroupId ) ; } else { channels . remove ( supergroupId ) ; } } } } cache . onUpdateSupergroup ( update , chat ) ; }
public String getType ( @ NonNull Uri uri ) { return null ; }
public void addColumn ( String colName , String colType ) { cols . add ( new Column ( colName , colType ) ) ; }
public int chatAccessState ( long chatId ) { return chatId != 0 ? chatAccessState ( chat ( chatId ) ) : CHAT_ACCESS_FAIL ; }
public void onBindViewHolder ( @ NonNull ReleaseAdapter . ViewHolder holder , int position ) { if ( holder . getItemViewType ( ) == 1 ) { holder . progress . setVisibility ( View . GONE ) ; holder . title . setVisibility ( View . VISIBLE ) ; holder . itemView . setOnClickListener ( v -> { if ( holder . progress . getVisibility ( ) == View . GONE ) { holder . title . setVisibility ( View . GONE ) ; holder . progress . show ( ) ; RepoLoader . getInstance ( ) . loadRemoteReleases ( module . getName ( ) ) ; } } ) ; } else { Release release = items . get ( position ) ; holder . title . setText ( release . getName ( ) ) ; var instant = Instant . parse ( release . getPublishedAt ( ) ) ; var formatter = DateTimeFormatter . ofLocalizedDateTime ( FormatStyle . SHORT ) . withLocale ( App . getLocale ( ) ) . withZone ( ZoneId . systemDefault ( ) ) ; holder . publishedTime . setText ( String . format ( getString ( R . string . module_repo_published_time ) , formatter . format ( instant ) ) ) ; renderGithubMarkdown ( holder . description , release . getDescriptionHTML ( ) ) ; holder . openInBrowser . setOnClickListener ( v -> NavUtil . startURL ( requireActivity ( ) , release . getUrl ( ) ) ) ; List < ReleaseAsset > assets = release . getReleaseAssets ( ) ; if ( assets != null && ! assets . isEmpty ( ) ) { holder . viewAssets . setOnClickListener ( v -> DownloadDialog . create ( requireActivity ( ) , getParentFragmentManager ( ) , assets ) ) ; } else { holder . viewAssets . setVisibility ( View . GONE ) ; } } }
public ResEntry getEntry ( int typeId , int entryId ) throws UndefinedResObjectException { return getEntry ( typeId , entryId , ResConfig . DEFAULT ) ; }
public static long allocateMemory ( long size ) { return UNSAFE . allocateMemory ( size ) ; }
public Flux < Variable > createVariable ( NotifyAction config ) { return Flux . empty ( ) ; }
public void setStartJoins ( List < Join > startJoins ) { this . startJoins = startJoins ; }
public void setCourier ( String courier ) { this . courier = courier ; }
public DataTableScan newScan ( ) { DataTableBatchScan scan = new DataTableBatchScan ( tableSchema , schemaManager ( ) , coreOptions ( ) , newSnapshotReader ( ) , catalogEnvironment . tableQueryAuth ( coreOptions ( ) ) ) ; if ( coreOptions ( ) . dataEvolutionEnabled ( ) ) { return new DataEvolutionBatchScan ( this , scan ) ; } return scan ; }
public Builder setSpec ( io . kubernetes . client . proto . V1Networking . IngressClassSpec value ) { if ( specBuilder_ == null ) { if ( value == null ) { throw new NullPointerException ( ) ; } spec_ = value ; onChanged ( ) ; } else { specBuilder_ . setMessage ( value ) ; } bitField0_ |= 0x00000002 ; return this ; }
protected AWSCredentialProviderList getParentAuthChain ( ) { return parentAuthChain ; }
public AuthenticatorConfigModel addAuthenticatorConfig ( AuthenticatorConfigModel model ) { getDelegateForUpdate ( ) ; return updated . addAuthenticatorConfig ( model ) ; }
public void setTopLeftRadius ( float topLeftRadius ) { this . topLeftRadius = topLeftRadius ; requiresShapeUpdate ( ) ; }
public void setMaxThreadsForPeerReplication ( int maxThreadsForPeerReplication ) { this . maxThreadsForPeerReplication = maxThreadsForPeerReplication ; }
static void cleanup ( ) { String searchPattern = "sqlite-" + getVersion ( ) ; try ( Stream < Path > dirList = Files . list ( getTempDir ( ) . toPath ( ) ) ) { dirList . filter ( path -> ! path . getFileName ( ) . toString ( ) . endsWith ( LOCK_EXT ) && path . getFileName ( ) . toString ( ) . startsWith ( searchPattern ) ) . forEach ( nativeLib -> { Path lckFile = Paths . get ( nativeLib + LOCK_EXT ) ; if ( Files . notExists ( lckFile ) ) { try { Files . delete ( nativeLib ) ; } catch ( Exception e ) { logger . error ( ( ) -> "Failed to delete old native lib" , e ) ; } } } ) ; } catch ( IOException e ) { logger . error ( ( ) -> "Failed to open directory" , e ) ; } }
private String currentGroupPath ( ) { final StringBuilder sb = new StringBuilder ( ) ; groupPath . forEach ( ( token ) -> { sb . append ( token . name ( ) ) . append ( '.' ) ; } ) ; return sb . toString ( ) ; }
public final String getSymbol ( ) { return " == " ; }
public void render ( StringBuilder sbuf , ILoggingEvent event ) { IThrowableProxy tp = event . getThrowableProxy ( ) ; sbuf . append ( "<tr><td class=\"Exception\" colspan=\"6\">" ) ; while ( tp != null ) { render ( sbuf , tp ) ; tp = tp . getCause ( ) ; } sbuf . append ( "</td></tr>" ) ; }
public void handlerPlugin ( final PluginData pluginData ) { MqttServerConfiguration configuration = GsonUtils . getInstance ( ) . fromJson ( pluginData . getConfig ( ) , MqttServerConfiguration . class ) ; configuration . afterPropertiesSet ( ) ; if ( pluginData . getEnabled ( ) ) { server . init ( ) ; server . start ( ) ; } else { if ( isPortUsing ( configuration . getPort ( ) ) ) { server . shutdown ( ) ; } } }
public boolean updateSize ( int newsize ) { if ( newsize != this . durationHigh . length ) { int [ ] oldDurationHigh = Arrays . copyOf ( durationHigh , durationHigh . length ) ; int [ ] oldDurationLow = Arrays . copyOf ( durationLow , durationLow . length ) ; durationHigh = new int [ newsize ] ; durationLow = new int [ newsize ] ; clearValues ( ) ; int lowerlength = Math . min ( oldDurationHigh . length , newsize ) ; for ( byte i = 0 ; i < lowerlength ; i ++ ) { durationHigh [ i ] = oldDurationHigh [ i ] ; durationLow [ i ] = oldDurationLow [ i ] ; } saveData ( ) ; return true ; } return false ; }
public OExecutionStream internalStart ( OCommandContext ctx ) throws OTimeoutException { if ( prev == null || ! prev . isPresent ( ) ) { throw new OCommandExecutionException ( "Cannot expand without a target" ) ; } OExecutionStream resultSet = getPrev ( ) . get ( ) . start ( ctx ) ; return resultSet . flatMap ( this :: fetchNextResults ) ; }
private List < MarkerType > postProcessCallout ( String result , LayoutTokenization layoutTokenization ) { if ( layoutTokenization == null ) return null ; List < LayoutToken > tokenizations = layoutTokenization . getTokenization ( ) ; TaggingTokenClusteror clusteror = new TaggingTokenClusteror ( FULLTEXT , result , tokenizations ) ; String tokenLabel = null ; List < TaggingTokenCluster > clusters = clusteror . cluster ( ) ; MarkerType majorityReferenceMarkerType = MarkerType . UNKNOWN ; MarkerType majorityFigureMarkerType = MarkerType . UNKNOWN ; MarkerType majorityTableMarkerType = MarkerType . UNKNOWN ; MarkerType majorityEquationarkerType = MarkerType . UNKNOWN ; Map < MarkerType , Integer > referenceMarkerTypeCounts = new HashMap < > ( ) ; Map < MarkerType , Integer > figureMarkerTypeCounts = new HashMap < > ( ) ; Map < MarkerType , Integer > tableMarkerTypeCounts = new HashMap < > ( ) ; Map < MarkerType , Integer > equationMarkerTypeCounts = new HashMap < > ( ) ; List < String > referenceMarkerSeen = new ArrayList < > ( ) ; List < String > figureMarkerSeen = new ArrayList < > ( ) ; List < String > tableMarkerSeen = new ArrayList < > ( ) ; List < String > equationMarkerSeen = new ArrayList < > ( ) ; for ( TaggingTokenCluster cluster : clusters ) { if ( cluster == null ) { continue ; } TaggingLabel clusterLabel = cluster . getTaggingLabel ( ) ; if ( TEIFormatter . MARKER_LABELS . contains ( clusterLabel ) ) { List < LayoutToken > refTokens = cluster . concatTokens ( ) ; refTokens = LayoutTokensUtil . dehyphenize ( refTokens ) ; String refText = LayoutTokensUtil . toText ( refTokens ) ; refText = refText . replace ( "\n" , "" ) ; refText = refText . replace ( " " , "" ) ; if ( refText . trim ( ) . length ( ) == 0 ) continue ; if ( clusterLabel . equals ( TaggingLabels . CITATION_MARKER ) ) { if ( referenceMarkerSeen . contains ( refText ) ) { continue ; } MarkerType localMarkerType = CalloutAnalyzer . getCalloutType ( refTokens ) ; if ( referenceMarkerTypeCounts . get ( localMarkerType ) == null ) referenceMarkerTypeCounts . put ( localMarkerType , 1 ) ; else referenceMarkerTypeCounts . put ( localMarkerType , referenceMarkerTypeCounts . get ( localMarkerType ) + 1 ) ; if ( ! referenceMarkerSeen . contains ( refText ) ) referenceMarkerSeen . add ( refText ) ; } else if ( clusterLabel . equals ( TaggingLabels . FIGURE_MARKER ) ) { if ( figureMarkerSeen . contains ( refText ) ) { continue ; } MarkerType localMarkerType = CalloutAnalyzer . getCalloutType ( refTokens ) ; if ( figureMarkerTypeCounts . get ( localMarkerType ) == null ) figureMarkerTypeCounts . put ( localMarkerType , 1 ) ; else figureMarkerTypeCounts . put ( localMarkerType , figureMarkerTypeCounts . get ( localMarkerType ) + 1 ) ; if ( ! figureMarkerSeen . contains ( refText ) ) figureMarkerSeen . add ( refText ) ; } else if ( clusterLabel . equals ( TaggingLabels . TABLE_MARKER ) ) { if ( tableMarkerSeen . contains ( refText ) ) { continue ; } MarkerType localMarkerType = CalloutAnalyzer . getCalloutType ( refTokens ) ; if ( tableMarkerTypeCounts . get ( localMarkerType ) == null ) tableMarkerTypeCounts . put ( localMarkerType , 1 ) ; else tableMarkerTypeCounts . put ( localMarkerType , tableMarkerTypeCounts . get ( localMarkerType ) + 1 ) ; if ( ! tableMarkerSeen . contains ( refText ) ) tableMarkerSeen . add ( refText ) ; } else if ( clusterLabel . equals ( TaggingLabels . EQUATION_MARKER ) ) { if ( equationMarkerSeen . contains ( refText ) ) { continue ; } MarkerType localMarkerType = CalloutAnalyzer . getCalloutType ( refTokens ) ; if ( equationMarkerTypeCounts . get ( localMarkerType ) == null ) equationMarkerTypeCounts . put ( localMarkerType , 1 ) ; else equationMarkerTypeCounts . put ( localMarkerType , equationMarkerTypeCounts . get ( localMarkerType ) + 1 ) ; if ( ! equationMarkerSeen . contains ( refText ) ) equationMarkerSeen . add ( refText ) ; } } } majorityReferenceMarkerType = getBestType ( referenceMarkerTypeCounts ) ; majorityFigureMarkerType = getBestType ( figureMarkerTypeCounts ) ; majorityTableMarkerType = getBestType ( tableMarkerTypeCounts ) ; majorityEquationarkerType = getBestType ( equationMarkerTypeCounts ) ; return Arrays . asList ( majorityReferenceMarkerType , majorityFigureMarkerType , majorityTableMarkerType , majorityEquationarkerType ) ; }
public RuleConditionDTOBuilder paramValue ( final String paramValue ) { this . paramValue = paramValue ; return this ; }
public static Intent createIntent ( Context context , String [ ] names , ArrayList < Integer > idList ) { return new Intent ( context , BottomMenuWindow . class ) . putExtra ( INTENT_ITEMS , names ) . putExtra ( INTENT_ITEM_IDS , idList ) ; }
private void setupCanvasMatrix ( Canvas canvas , Size targetSize , Size scaledSize ) { float scaleFactorH = ( float ) targetSize . height / scaledSize . height ; float scaleFactorW = ( float ) targetSize . width / scaledSize . width ; float scaledLeftPosition = - getLeft ( ) / scaleFactorW ; float scaledTopPosition = - getTop ( ) / scaleFactorH ; canvas . translate ( scaledLeftPosition , scaledTopPosition ) ; canvas . scale ( 1 / scaleFactorW , 1 / scaleFactorH ) ; }
public ConditionsNested < A > addNewConditionLike ( V1Condition item ) { return new ConditionsNested ( - 1 , item ) ; }
TranslationConfig fromX ( float fromX , boolean percentage ) { this . isPercentageFromX = percentage ; this . fromX = fromX ; return this ; }
public Fragment createFragment ( int position ) { Bundle bundle = new Bundle ( ) ; bundle . putInt ( "position" , position ) ; Fragment f ; if ( position == 0 ) { f = new ReadmeFragment ( ) ; } else if ( position == 1 ) { f = new RecyclerviewFragment ( ) ; } else { f = new RecyclerviewFragment ( ) ; } f . setArguments ( bundle ) ; return f ; }
private void initializePqFlowMetrics ( final ThreadContext context , final RubySymbol [ ] flowNamespace , final UptimeMetric uptime ) { final Metric < Number > uptimeInPreciseSeconds = uptime . withUnitsPrecise ( SECONDS ) ; final IRubyObject queueContext = getSetting ( context , QueueFactoryExt . QUEUE_TYPE_CONTEXT_NAME ) ; if ( ! queueContext . isNil ( ) && queueContext . asJavaString ( ) . equals ( QueueFactoryExt . PERSISTED_TYPE ) ) { final RubySymbol [ ] queueNamespace = buildNamespace ( QUEUE_KEY ) ; final RubySymbol [ ] queueCapacityNamespace = buildNamespace ( QUEUE_KEY , CAPACITY_KEY ) ; final Supplier < NumberGauge > eventsGaugeMetricSupplier = ( ) -> initOrGetNumberGaugeMetric ( context , queueNamespace , EVENTS_KEY ) . orElse ( null ) ; final FlowMetric growthEventsFlow = createFlowMetric ( QUEUE_PERSISTED_GROWTH_EVENTS_KEY , eventsGaugeMetricSupplier , ( ) -> uptimeInPreciseSeconds ) ; this . scopedFlowMetrics . register ( ScopedFlowMetrics . Scope . WORKER , growthEventsFlow ) ; storeMetric ( context , flowNamespace , growthEventsFlow ) ; final Supplier < NumberGauge > queueSizeInBytesMetricSupplier = ( ) -> initOrGetNumberGaugeMetric ( context , queueCapacityNamespace , QUEUE_SIZE_IN_BYTES_KEY ) . orElse ( null ) ; final FlowMetric growthBytesFlow = createFlowMetric ( QUEUE_PERSISTED_GROWTH_BYTES_KEY , queueSizeInBytesMetricSupplier , ( ) -> uptimeInPreciseSeconds ) ; this . scopedFlowMetrics . register ( ScopedFlowMetrics . Scope . WORKER , growthBytesFlow ) ; storeMetric ( context , flowNamespace , growthBytesFlow ) ; } }
public void setValues ( FlowElement otherElement ) { super . setValues ( otherElement ) ; setName ( otherElement . getName ( ) ) ; setDocumentation ( otherElement . getDocumentation ( ) ) ; executionListeners = new ArrayList < ActivitiListener > ( ) ; if ( otherElement . getExecutionListeners ( ) != null && ! otherElement . getExecutionListeners ( ) . isEmpty ( ) ) { for ( ActivitiListener listener : otherElement . getExecutionListeners ( ) ) { executionListeners . add ( listener . clone ( ) ) ; } } }
public void onResponse ( int page , List < T > list , Exception e ) { if ( ( list == null || list . isEmpty ( ) ) && e != null ) { onLoadFailed ( page , e ) ; } else { onLoadSucceed ( page , list ) ; } }
public static void glClearTexImage ( @ NativeType ( "GLuint" ) int texture , @ NativeType ( "GLint" ) int level , @ NativeType ( "GLenum" ) int format , @ NativeType ( "GLenum" ) int type , @ Nullable @ NativeType ( "void const *" ) FloatBuffer data ) { nglClearTexImage ( texture , level , format , type , memAddressSafe ( data ) ) ; }
public Currency getCurrency ( ) { if ( Strings . emptyToNull ( currency ) == null ) { return null ; } else { return Currency . valueOf ( currency ) ; } }
private void updateWidthForNudge ( ) { if ( ! Flags . nudgePill ( ) ) { return ; } float width = mWidthForNudgePill . value ; ViewGroup . MarginLayoutParams nudgePillLayoutParams = ( ViewGroup . MarginLayoutParams ) mNudgeIcon . getLayoutParams ( ) ; nudgePillLayoutParams . width = ( int ) width ; mNudgeIcon . setLayoutParams ( nudgePillLayoutParams ) ; }
private static int computeMessageRootBlockLength ( final List < Field > fields ) { int blockLength = 0 ; for ( final Field field : fields ) { if ( field . groupFields ( ) != null ) { return blockLength ; } else if ( field . type ( ) != null ) { final int fieldLength = field . type ( ) . encodedLength ( ) ; if ( Token . VARIABLE_LENGTH == fieldLength ) { return blockLength ; } if ( field . presence ( ) == Presence . CONSTANT ) { blockLength = field . computedOffset ( ) ; } else { blockLength = field . computedOffset ( ) + fieldLength ; } } } return blockLength ; }
public Function getGeneratorFunction ( ) { return generatorFunction ; }
public Object browseLogsDirectory ( @ PathVariable ( "path" ) Optional < String > path , ModelMap model , HttpServletRequest request , @ RequestHeader ( value = HttpHeaders . ACCEPT , required = false ) String acceptHeader ) { logger . info ( "Requested directory listing of logs {}/logs/{}" , ROOT_CONTEXT , path . orElse ( "" ) ) ; try { Path logsBaseDir = Paths . get ( propertiesBooter . getLogsDirectory ( ) ) ; Path requestedLogPath = Paths . get ( logsBaseDir . toString ( ) , path . orElse ( "" ) ) ; logger . info ( "Requested directory listing of path: [{}] resolved to [{}]" , path , requestedLogPath ) ; if ( ! Files . exists ( requestedLogPath ) ) { return getNotFoundResponseEntity ( "Requested path does not exist!" , acceptHeader ) ; } if ( ! Files . isDirectory ( requestedLogPath ) ) { return getBadRequestResponseEntity ( "Requested path is not a directory!" , acceptHeader ) ; } DirectoryListing directoryListing = directoryListingService . fromPath ( logsBaseDir , requestedLogPath ) ; directoryListing . setFiles ( directoryListing . getFiles ( ) . stream ( ) . filter ( file -> file . getName ( ) . endsWith ( ".log" ) && ! file . getName ( ) . startsWith ( "gc-" ) ) . collect ( Collectors . toList ( ) ) ) ; if ( acceptHeader != null && acceptHeader . contains ( MediaType . APPLICATION_JSON_VALUE ) ) { return ResponseEntity . ok ( objectMapper . writer ( ) . writeValueAsString ( directoryListing ) ) ; } String currentUrl = StringUtils . chomp ( request . getRequestURI ( ) , "/" ) ; String downloadUrl = currentUrl . replaceFirst ( "/browse" , "/download" ) ; boolean showBack = path . isPresent ( ) && ! StringUtils . isBlank ( path . get ( ) ) ; model . addAttribute ( "showBack" , showBack ) ; model . addAttribute ( "currentUrl" , currentUrl ) ; model . addAttribute ( "downloadBaseUrl" , downloadUrl ) ; model . addAttribute ( "directories" , directoryListing . getDirectories ( ) ) ; model . addAttribute ( "files" , directoryListing . getFiles ( ) ) ; return new ModelAndView ( "directoryListing" , model ) ; } catch ( Exception e ) { String message = "Attempt to browse logs failed. Check server logs for more information." ; return getExceptionResponseEntity ( HttpStatus . INTERNAL_SERVER_ERROR , message , e , acceptHeader ) ; } }
private void updateApparitions ( AnalyzedTokenReadings aTr ) { if ( matchPostagRegexp ( aTr , NOM ) || matchPostagRegexp ( aTr , ADJECTIU ) ) { initializeApparitions ( ) ; return ; } adverbAppeared |= matchPostagRegexp ( aTr , ADVERBI ) ; conjunctionAppeared |= matchPostagRegexp ( aTr , CONJUNCIO ) ; punctuationAppeared |= ( matchPostagRegexp ( aTr , PUNTUACIO ) || aTr . getToken ( ) . equals ( "," ) ) ; }
String push ( String phaseName ) { this . add ( phaseName ) ; return phaseName ; }
void closeSegment ( ) { if ( ! ( this . segmentInit ( ) ) ) return ; this . closeSegmentDependants ( ) ; entrySpaceOffset = 0 ; }
public static void addLink ( @ Nonnull OperationContext opContext , String linkUrl , String linkLabel , Urn resourceUrn , Urn actor , @ Nullable LinkSettingsInput settingsInput , EntityService < ? > entityService ) { InstitutionalMemory institutionalMemoryAspect = ( InstitutionalMemory ) EntityUtils . getAspectFromEntity ( opContext , resourceUrn . toString ( ) , Constants . INSTITUTIONAL_MEMORY_ASPECT_NAME , entityService , new InstitutionalMemory ( ) ) ; addLink ( institutionalMemoryAspect , linkUrl , linkLabel , actor , settingsInput ) ; persistAspect ( opContext , resourceUrn , Constants . INSTITUTIONAL_MEMORY_ASPECT_NAME , institutionalMemoryAspect , actor , entityService ) ; }
private com . google . protobuf . RepeatedFieldBuilderV3 < io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngress , io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngress . Builder , io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngressOrBuilder > getIngressFieldBuilder ( ) { if ( ingressBuilder_ == null ) { ingressBuilder_ = new com . google . protobuf . RepeatedFieldBuilderV3 < io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngress , io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngress . Builder , io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngressOrBuilder > ( ingress_ , ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) , getParentForChildren ( ) , isClean ( ) ) ; ingress_ = null ; } return ingressBuilder_ ; }
public SiteBody welcomeScreen ( String welcomeScreen ) { this . welcomeScreen = welcomeScreen ; return this ; }
public ArtifactCoordinates getArtifactCoordinates ( GenericCoordinatesEntity entity ) { DebianCoordinates debianArtifactCoordinates = null ; if ( ! entity . getCoordinates ( ) . isEmpty ( ) ) { debianArtifactCoordinates = new DebianCoordinates ( ) ; } else { String component = entity . getCoordinates ( ) . get ( DebianConstant . COMPONENT ) ; String name = entity . getCoordinates ( ) . get ( DebianConstant . NAME ) ; String extension = entity . getCoordinates ( ) . get ( DebianConstant . EXTENSION ) ; debianArtifactCoordinates = new DebianCoordinates ( component , name , extension ) ; } debianArtifactCoordinates . setUuid ( entity . getUuid ( ) ) ; debianArtifactCoordinates . setNativeId ( entity . getNativeId ( ) ) ; debianArtifactCoordinates . setHierarchyParent ( entity ) ; debianArtifactCoordinates . setVersion ( entity . getVersion ( ) ) ; entity . setHierarchyChild ( debianArtifactCoordinates ) ; return debianArtifactCoordinates ; }
public OServerExecutionPlan createExecutionPlan ( OServerCommandContext ctx , boolean enableProfiling ) { return new OSingleOpServerExecutionPlan ( this ) ; }
public void onUpgrade ( SQLiteDatabase sqLiteDatabase , int oldVersion , int newVersion ) { String sql = "DROP TABLE IF EXISTS " + TABLE_NAME ; sqLiteDatabase . execSQL ( sql ) ; onCreate ( sqLiteDatabase ) ; }
public void onFinish ( PipelineSnapshot snapshot , BuildResult result ) { ApplicationBuildPipeline buildPipeline = ApplicationBuildPipeline . fromPipeSnapshot ( snapshot ) . setAppId ( app . getId ( ) ) . setBuildResult ( result ) ; saveEntity ( buildPipeline ) ; if ( result . pass ( ) ) { if ( app . isRunning ( ) ) { app . setRelease ( ReleaseStateEnum . NEED_RESTART . get ( ) ) ; } else { app . setOptionState ( OptionStateEnum . NONE . getValue ( ) ) ; app . setRelease ( ReleaseStateEnum . DONE . get ( ) ) ; if ( app . isFlinkSql ( ) ) { applicationManageService . toEffective ( app ) ; } else { if ( app . isStreamParkType ( ) ) { FlinkApplicationConfig config = applicationConfigService . getLatest ( app . getId ( ) ) ; if ( config != null ) { config . setToApplication ( app ) ; applicationConfigService . toEffective ( app . getId ( ) , app . getConfigId ( ) ) ; } } } } if ( ! app . isNeedRollback ( ) ) { if ( app . isFlinkSql ( ) && newFlinkSql != null ) { backUpService . backup ( app , newFlinkSql ) ; } else { backUpService . backup ( app , null ) ; } } applicationLog . setSuccess ( true ) ; app . setBuild ( false ) ; } else { Message message = new Message ( ServiceHelper . getUserId ( ) , app . getId ( ) , app . getJobName ( ) . concat ( " release failed" ) , ExceptionUtils . stringifyException ( snapshot . error ( ) . exception ( ) ) , NoticeTypeEnum . EXCEPTION ) ; messageService . push ( message ) ; app . setRelease ( ReleaseStateEnum . FAILED . get ( ) ) ; app . setOptionState ( OptionStateEnum . NONE . getValue ( ) ) ; app . setBuild ( true ) ; applicationLog . setException ( ExceptionUtils . stringifyException ( snapshot . error ( ) . exception ( ) ) ) ; applicationLog . setSuccess ( false ) ; } applicationManageService . updateRelease ( app ) ; applicationLogService . save ( applicationLog ) ; if ( flinkAppHttpWatcher . isWatchingApp ( app . getId ( ) ) ) { flinkAppHttpWatcher . init ( ) ; } }
public void goBack ( ) { checkThread ( ) ; mProvider . goBack ( ) ; }
public String getTargetGroupName ( ) { return this . targetGroupName ; }
public static boolean showAllApps ( ) { return gPrefs . getBoolean ( SHOW_ALL_APPS , false ) ; }
public io . kubernetes . client . proto . Meta . Condition . Builder addConditionsBuilder ( ) { return getConditionsFieldBuilder ( ) . addBuilder ( io . kubernetes . client . proto . Meta . Condition . getDefaultInstance ( ) ) ; }
public ValueDeserializer < Object > getContentDeserializer ( ) { return _valueDeserializer ; }
private static void recurse ( List < Map > list , StepResult stepResult , int depth ) { if ( stepResult . getCallResults ( ) != null ) { for ( FeatureResult fr : stepResult . getCallResults ( ) ) { Step call = new Step ( stepResult . getStep ( ) . getFeature ( ) , - 1 ) ; call . setLine ( stepResult . getStep ( ) . getLine ( ) ) ; call . setPrefix ( StringUtils . repeat ( '>' , depth ) ) ; call . setText ( fr . getCallNameForReport ( ) ) ; StepResult callResult = new StepResult ( call , Result . passed ( stepResult . getResult ( ) . getStartTime ( ) , 0 ) ) ; callResult . setHidden ( stepResult . isHidden ( ) ) ; list . add ( callResult . toCucumberJson ( ) ) ; for ( StepResult sr : fr . getAllScenarioStepResultsNotHidden ( ) ) { Map < String , Object > map = sr . toCucumberJson ( ) ; String temp = ( String ) map . get ( "keyword" ) ; map . put ( "keyword" , StringUtils . repeat ( '>' , depth + 1 ) + ' ' + temp ) ; list . add ( map ) ; recurse ( list , sr , depth + 1 ) ; } } } }
private TbCoapDtlsSessionInfo getCoapDtlsSessionInfo ( EndpointContext endpointContext ) { InetSocketAddress peerAddress = endpointContext . getPeerAddress ( ) ; String certPemStr = getCertPem ( endpointContext ) ; TbCoapDtlsSessionKey tbCoapDtlsSessionKey = StringUtils . isNotBlank ( certPemStr ) ? new TbCoapDtlsSessionKey ( peerAddress , certPemStr ) : null ; TbCoapDtlsSessionInfo tbCoapDtlsSessionInfo ; if ( tbCoapDtlsSessionKey != null ) { tbCoapDtlsSessionInfo = dtlsSessionsMap . computeIfPresent ( tbCoapDtlsSessionKey , ( dtlsSessionIdStr , dtlsSessionInfo ) -> { dtlsSessionInfo . setLastActivityTime ( System . currentTimeMillis ( ) ) ; return dtlsSessionInfo ; } ) ; } else { tbCoapDtlsSessionInfo = null ; } return tbCoapDtlsSessionInfo ; }
public boolean contains ( long [ ] hashes ) { for ( int i = 0 ; i < hashes . length ; i ++ ) { int block = ( int ) ( hashes [ i ] > > DIV64_SHIFT ) ; long MASK = 1L << ( hashes [ i ] & MOD64_MASK ) ; if ( ( bitsets [ i ] [ block ] & MASK ) != MASK ) return false ; } return true ; }
public String getMDCAdapterClassStr ( ) { return Log4jMDCAdapter . class . getName ( ) ; }
static void put ( final AnnotationWriter [ ] panns , final int off , final ByteVector out ) { int size = 1 + 2 * ( panns . length - off ) ; for ( int i = off ; i < panns . length ; ++ i ) { size += panns [ i ] == null ? 0 : panns [ i ] . getSize ( ) ; } out . putInt ( size ) . putByte ( panns . length - off ) ; for ( int i = off ; i < panns . length ; ++ i ) { AnnotationWriter aw = panns [ i ] ; AnnotationWriter last = null ; int n = 0 ; while ( aw != null ) { ++ n ; aw . visitEnd ( ) ; aw . prev = last ; last = aw ; aw = aw . next ; } out . putShort ( n ) ; aw = last ; while ( aw != null ) { out . putByteArray ( aw . bv . data , 0 , aw . bv . length ) ; aw = aw . prev ; } } }
public Builder addAllPorts ( java . lang . Iterable < ? extends io . kubernetes . client . proto . V1Networking . NetworkPolicyPort > values ) { if ( portsBuilder_ == null ) { ensurePortsIsMutable ( ) ; com . google . protobuf . AbstractMessageLite . Builder . addAll ( values , ports_ ) ; onChanged ( ) ; } else { portsBuilder_ . addAllMessages ( values ) ; } return this ; }
public void set ( long integer ) { if ( ! hasKey ) { key = ( K ) Long . valueOf ( integer ) ; hasKey = true ; return ; } V value = ( V ) Long . valueOf ( integer ) ; output . put ( key , value ) ; key = null ; hasKey = false ; }
public Optional < KeyStoreProperties > getTrustStoreProperties ( ) { return Optional . ofNullable ( trustStoreProperties ) ; }
public static void renderTextRun ( XWPFRun run , TextRenderData data ) { XWPFRun textRun = run ; if ( data instanceof HyperlinkTextRenderData ) { textRun = createHyperlink ( run , ( ( HyperlinkTextRenderData ) data ) . getUrl ( ) ) ; } StyleUtils . styleRun ( textRun , data . getStyle ( ) ) ; String text = Optional . ofNullable ( data . getText ( ) ) . orElse ( "" ) ; String [ ] fragment = text . split ( REGEX_LINE_CHARACTOR , - 1 ) ; if ( fragment . length > 0 ) { textRun . setText ( fragment [ 0 ] , 0 ) ; boolean lineAtTable = fragment . length > 1 && ! ( data instanceof HyperlinkTextRenderData ) && TableTools . isInsideTable ( run ) ; for ( int i = 1 ; i < fragment . length ; i ++ ) { if ( lineAtTable ) { textRun . addBreak ( BreakType . TEXT_WRAPPING ) ; } else { textRun . addCarriageReturn ( ) ; } textRun . setText ( fragment [ i ] ) ; } } if ( data instanceof BookmarkTextRenderData ) { createBookmark ( textRun , ( ( BookmarkTextRenderData ) data ) . getBookmark ( ) ) ; } }
public ScaleConfig scale ( float from , float to ) { scaleFromX = scaleFromY = from ; scaleToX = scaleToY = to ; changeFrom = changeTo = true ; return this ; }
private Map < String , String > getCollisionMapByKey ( ModelInterpretationContext mic , MapKey mapKey ) { Map < String , String > map = ( Map < String , String > ) mic . getObjectMap ( ) . get ( mapKey . name ( ) ) ; if ( map == null ) { map = new HashMap < > ( ) ; mic . getObjectMap ( ) . put ( mapKey . name ( ) , map ) ; } return map ; }
public void rejectedExecution ( Runnable r , ThreadPoolExecutor executor ) { r . run ( ) ; logger . warn ( ">>>>>>>>>>> xxl-job, callback too fast, match threadpool rejected handler(run now)." ) ; }
public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } V1ClusterRoleBinding v1ClusterRoleBinding = ( V1ClusterRoleBinding ) o ; return Objects . equals ( this . apiVersion , v1ClusterRoleBinding . apiVersion ) && Objects . equals ( this . kind , v1ClusterRoleBinding . kind ) && Objects . equals ( this . metadata , v1ClusterRoleBinding . metadata ) && Objects . equals ( this . roleRef , v1ClusterRoleBinding . roleRef ) && Objects . equals ( this . subjects , v1ClusterRoleBinding . subjects ) ; }
public void perspective ( float fovy , float aspect , float zNear , float zFar ) { showMissingWarning ( "perspective" ) ; }
public Activity getOwnerActivity ( ) { return mDialog . getOwnerActivity ( ) ; }
Object [ ] createAccumulator ( ) { return constructorArgsDefaults . clone ( ) ; }
static boolean isIpAddress ( String address ) { return zipkin2 . Endpoint . newBuilder ( ) . parseIp ( address ) ; }
public ExcelWriter writeCol ( Map < ? , ? extends Iterable < ? > > colMap , boolean isWriteKeyAsHead ) { return writeCol ( colMap , 0 , isWriteKeyAsHead ) ; }
public Object get ( String providerKey ) { return actual . get ( providerKey ) ; }
private void match ( int ttype , String token ) throws IOException , SyntaxException { if ( ( currentToken . ttype == ttype ) && ( currentToken . sval . compareTo ( token ) == 0 ) ) { logln ( "matched type: " + ttype + " and token = " + currentToken . sval ) ; nextToken ( ) ; } else { throw new SyntaxException ( st . lineno ( ) ) ; } }
public Builder genAiClient ( Client genAiClient ) { this . genAiClient = genAiClient ; return this ; }
public void notifyCheckpointComplete ( long checkpointId ) throws Exception { }
static SfString parseSfString ( Reader input ) throws IOException { StringBuilder result = new StringBuilder ( ) ; while ( true ) { int c = input . read ( ) ; if ( c == '\\' ) { requireNotChar ( input , - 1 ) ; c = input . read ( ) ; if ( c != '\\' && c != '\"' ) { throw new IllegalArgumentException ( sm . getString ( "sf.string.invalidEscape" , String . format ( "\\u%04X" , Integer . valueOf ( c ) ) ) ) ; } } else { if ( c == '\"' ) { break ; } if ( c < 32 || c > 126 ) { throw new IllegalArgumentException ( sm . getString ( "sf.string.invalidCharacter" , String . format ( "\\u%04X" , Integer . valueOf ( c ) ) ) ) ; } } result . append ( ( char ) c ) ; } return new SfString ( result . toString ( ) ) ; }
public void updateByte ( int col , byte x ) throws SQLException { throw unsupported ( ) ; }
public Schema < byte [ ] > newAutoProduceSchema ( Schema < ? > schema ) { return new AutoProduceBytesSchema ( schema ) ; }
public KafkaItemWriterBuilder < K , V > timeout ( long timeout ) { this . timeout = timeout ; return this ; }
public void setToolbarTitle ( @ Nullable String text ) { mOptionBundle . putString ( EXTRA_UCROP_TITLE_TEXT_TOOLBAR , text ) ; }
private void saveOtherColors ( SharedPreferences . Editor editor ) { Settings . instance ( ) . setEmojiOtherColors ( otherColors , editor ) ; }
public long getCheckinTimestamp ( ) { return checkinTimestamp ; }
public long getReplicationLag ( ) { return this . replicationLag ; }
public boolean mightContain ( long e ) { return bloomFilter . mightContain ( e ) ; }
private void onUpdateActiveNotifications ( TdApi . UpdateActiveNotifications update ) { TDLib . Tag . notifications ( 0 , accountId , "Received updateActiveNotifications, ignore: %b" , ignoreNotificationUpdates ) ; if ( ignoreNotificationUpdates && update . groups . length > 0 ) { update = new TdApi . UpdateActiveNotifications ( new TdApi . NotificationGroup [ 0 ] ) ; receivedActiveNotificationsIgnored = true ; } else { receivedActiveNotificationsIgnored = false ; } receivedActiveNotificationsTime = SystemClock . uptimeMillis ( ) ; notificationManager . onUpdateActiveNotifications ( update , this :: dispatchNotificationsInitialized ) ; }
public static boolean getEnableDictionary ( Configuration configuration ) { return configuration . getBoolean ( ENABLE_DICTIONARY , ParquetProperties . DEFAULT_IS_DICTIONARY_ENABLED ) ; }
public SiteBody maxPriorPasswords ( Integer maxPriorPasswords ) { this . maxPriorPasswords = maxPriorPasswords ; return this ; }
Tuple2 < ? extends IndexedSeq < T > , ? extends IndexedSeq < T > > span ( @ NonNull Predicate < ? super T > predicate ) ; @ Override default boolean startsWith ( @ NonNull Iterable < ? extends T > that , int offset ) { Objects . requireNonNull ( that , "that is null" ) ; if ( offset < 0 ) { return false ; } if ( that instanceof IndexedSeq ) { IndexedSeq < ? extends T > thatIndexedSeq = ( IndexedSeq < ? extends T > ) that ; int i = offset ; int j = 0 ; int thisLen = length ( ) ; int thatLen = thatIndexedSeq . length ( ) ; while ( i < thisLen && j < thatLen && Objects . equals ( this . get ( i ) , thatIndexedSeq . get ( j ) ) ) { i ++ ; j ++ ; } return j == thatLen ; } else { int i = offset ; int thisLen = length ( ) ; java . util . Iterator < ? extends T > thatElems = that . iterator ( ) ; while ( i < thisLen && thatElems . hasNext ( ) ) { if ( ! Objects . equals ( this . get ( i ) , thatElems . next ( ) ) ) { return false ; } i ++ ; } return ! thatElems . hasNext ( ) ; } }
public BooleanIndexer get ( long [ ] indices , boolean [ ] b ) { return get ( indices , b , 0 , b . length ) ; }
public List < Throwable > validateMethodsForDefaultRunner ( ) { validateNoArgConstructor ( ) ; validateStaticMethods ( ) ; validateInstanceMethods ( ) ; return errors ; }
public boolean isError ( ) { return "error" . equals ( status ) ; }
private static boolean dateByMonth ( DateTimeFormatterBuilder bld , Collection < DateTimeFieldType > fields , boolean extended , boolean strictISO ) { boolean reducedPrec = false ; if ( fields . remove ( DateTimeFieldType . year ( ) ) ) { bld . append ( Constants . ye ) ; if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendMonthOfYear ( 2 ) ; appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( 2 ) ; } else { bld . appendLiteral ( '-' ) ; bld . appendMonthOfYear ( 2 ) ; reducedPrec = true ; } } else { if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { checkNotStrictISO ( fields , strictISO ) ; bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendDayOfMonth ( 2 ) ; } else { reducedPrec = true ; } } } else if ( fields . remove ( DateTimeFieldType . monthOfYear ( ) ) ) { bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendMonthOfYear ( 2 ) ; if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { appendSeparator ( bld , extended ) ; bld . appendDayOfMonth ( 2 ) ; } else { reducedPrec = true ; } } else if ( fields . remove ( DateTimeFieldType . dayOfMonth ( ) ) ) { bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendLiteral ( '-' ) ; bld . appendDayOfMonth ( 2 ) ; } return reducedPrec ; }
public void onAnimationEnd ( Animator animation ) { super . onAnimationEnd ( animation ) ; isAnimating = false ; isWeekView = true ; showWeek ( ) ; if ( mDelegate == null || mDelegate . mViewChangeListener == null ) { return ; } mDelegate . mViewChangeListener . onViewChange ( false ) ; }
public static Statistics getStatsBasedOnType ( PrimitiveTypeName type ) { switch ( type ) { case INT32 : return new IntStatistics ( ) ; case INT64 : return new LongStatistics ( ) ; case FLOAT : return new FloatStatistics ( ) ; case DOUBLE : return new DoubleStatistics ( ) ; case BOOLEAN : return new BooleanStatistics ( ) ; case BINARY : return new BinaryStatistics ( ) ; case INT96 : return new BinaryStatistics ( ) ; case FIXED_LEN_BYTE_ARRAY : return new BinaryStatistics ( ) ; default : throw new UnknownColumnTypeException ( type ) ; } }
private void setupGestureListeners ( ) { mGestureDetector = new GestureDetector ( getContext ( ) , new GestureListener ( ) , null , true ) ; mScaleDetector = new ScaleGestureDetector ( getContext ( ) , new ScaleListener ( ) ) ; mRotateDetector = new RotationGestureDetector ( new RotateListener ( ) ) ; }
private void parseHeader ( ) { byte [ ] frameData = headerScratchBytes . getData ( ) ; if ( format == null ) { format = DtsUtil . parseDtsFormat ( frameData , formatId , language , null ) ; output . format ( format ) ; } sampleSize = DtsUtil . getDtsFrameSize ( frameData ) ; sampleDurationUs = ( int ) ( C . MICROS_PER_SECOND * DtsUtil . parseDtsAudioSampleCount ( frameData ) / format . sampleRate ) ; }
public void updateNull ( String col ) throws SQLException { throw unsupported ( ) ; }
boolean isConnected ( ) ; @ Deprecated ( forRemoval = true , since = "4.4.0" ) int read ( BufferData buffer ) ; void write ( BufferData buffer ) ; default boolean protocolNegotiated ( ) { return false ; }
public int getDatabasePort ( ) { return databasePort ; }
public static int sp2px ( int sp ) { return ( int ) TypedValue . applyDimension ( TypedValue . COMPLEX_UNIT_SP , sp , getDisplayMetrics ( ) ) ; }
public NetherWarts clone ( ) { return ( NetherWarts ) super . clone ( ) ; }
public void getReward ( MissionInit missionInit , MultidimensionalReward reward ) { super . getReward ( missionInit , reward ) ; }
public void addBoolean ( boolean value ) { for ( ValueInspector valueInspector : valueInspectors ) { valueInspector . update ( value ) ; } delegate . addBoolean ( value ) ; }
public boolean canRead ( FsPath dest , String user ) throws IOException { return false ; }
public static void glBindVertexBuffers ( @ NativeType ( "GLuint" ) int first , @ Nullable @ NativeType ( "GLuint const *" ) int [ ] buffers , @ Nullable @ NativeType ( "GLintptr const *" ) PointerBuffer offsets , @ Nullable @ NativeType ( "GLsizei const *" ) int [ ] strides ) { long __functionAddress = GL . getICD ( ) . glBindVertexBuffers ; if ( CHECKS ) { check ( __functionAddress ) ; checkSafe ( offsets , lengthSafe ( buffers ) ) ; checkSafe ( strides , lengthSafe ( buffers ) ) ; } callPPPV ( first , lengthSafe ( buffers ) , buffers , memAddressSafe ( offsets ) , strides , __functionAddress ) ; }
public AbstractSQLConfig < T , M , L > setTag ( String tag ) { this . tag = tag ; return this ; }
protected Counter newRequestCounterFor ( final MethodDescriptor < ? , ? > method ) { return this . counterCustomizer . apply ( prepareCounterFor ( method , METRIC_NAME_CLIENT_REQUESTS_SENT , "The total number of requests sent" ) ) . register ( this . registry ) ; }
public void withMaxResultSize ( @ IntRange ( from = MIN_SIZE ) int width , @ IntRange ( from = MIN_SIZE ) int height ) { mOptionBundle . putInt ( EXTRA_MAX_SIZE_X , width ) ; mOptionBundle . putInt ( EXTRA_MAX_SIZE_Y , height ) ; }
public String getOriginKey ( ) { return originKey ; }
public static io . kubernetes . client . proto . V1Networking . NetworkPolicyPort parseFrom ( java . nio . ByteBuffer data , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data , extensionRegistry ) ; }
public io . kubernetes . client . proto . V1Networking . NetworkPolicyIngressRule . Builder getIngressBuilder ( int index ) { return getIngressFieldBuilder ( ) . getBuilder ( index ) ; }
private void ensureMutable ( ) { if ( ! _mutable ) { throw new IllegalStateException ( "Cannot change this operation progress because it is immutable." ) ; } }
private static List < BarcodeFormat > getDefaultFormats ( ) { List < BarcodeFormat > list = new ArrayList < > ( ) ; list . add ( BarcodeFormat . QR_CODE ) ; list . add ( BarcodeFormat . UPC_A ) ; list . add ( BarcodeFormat . EAN_13 ) ; list . add ( BarcodeFormat . CODE_128 ) ; return list ; }
public static io . kubernetes . client . proto . V1Networking . IngressLoadBalancerStatus parseFrom ( byte [ ] data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public String getDisplayName ( ) { return PipelineNodeUtil . getDisplayName ( node . getNode ( ) ) ; }
public String getGoodsSn ( ) { return goodsSn ; }
public static MultiUri . Builder create ( ) { return new Builder ( ) ; }
public List < Node > selectNodes ( String text ) { try { Document doc = parse ( text ) ; return selectNodes ( doc ) ; } catch ( Exception e ) { logger . error ( "select text error! " + xpathStr , e ) ; } return null ; }
public int version ( ) { return version ; }
public void setPointFillColor ( int pointFillColor ) { this . mPointFillColor = pointFillColor ; }
static boolean isCharging ( Context context ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . M ) return false ; try { BatteryManager bm = Helper . getSystemService ( context , BatteryManager . class ) ; if ( bm == null ) return false ; return bm . isCharging ( ) ; } catch ( Throwable ex ) { Log . e ( ex ) ; return false ; } }
public boolean doesResourceExist ( final String resourcePath ) throws IOException { Request request = new Request ( HttpMethod . HEAD , resourcePath ) ; Response response = elasticSearchAdminClient . performRequest ( request ) ; return response . getStatusLine ( ) . getStatusCode ( ) == HttpStatus . SC_OK ; }
private void write ( ByteBuffer response ) throws IOException { LOG . debug ( "writing: {}" , response . remaining ( ) ) ; ( ( Buffer ) writeHeader ) . clear ( ) ; ( ( Buffer ) writeHeader . putInt ( response . remaining ( ) ) ) . flip ( ) ; writeFully ( writeHeader , response ) ; }
public void printResults ( String results ) { BaseOutputFormat . output ( results , System . out ) ; }
public int newNameType ( final String name , final String descriptor ) { return symbolTable . addConstantNameAndType ( name , descriptor ) ; }
public void start ( ) { backendThread . start ( ) ; started = true ; }
public JCheckBox getInnerClassCheckBox ( ) { return innerClassCheckBox ; }
private NodeModifier prependToLeaf ( java . util . Iterator < ? extends T > iterator ) { return ( array , index ) -> { final Object copy = type . copy ( array , BRANCHING_FACTOR ) ; while ( iterator . hasNext ( ) && index >= 0 ) { type . setAt ( copy , index -- , iterator . next ( ) ) ; } return copy ; } ; }
public void testButton ( ) throws FindFailed { Debug . on ( 3 ) ; Visual vis = guide . text ( "text" ) ; String img = "idea" ; vis . setTarget ( img ) ; vis . setLayout ( Visual . Layout . RIGHT ) ; vis . setTextColor ( Color . red ) ; }
static void viewFAQ ( Context context , int question ) { viewFAQ ( context , question , true ) ; }
public static boolean isAllowMobileFeedRefresh ( ) { return isAllowMobileFor ( "feed_refresh" ) ; }
public void export ( ) { onFinish . run ( ) ; }
public protobuf . PaymentMethod toProtoMessage ( ) { return protobuf . PaymentMethod . newBuilder ( ) . setId ( id ) . setMaxTradePeriod ( maxTradePeriod ) . setMaxTradeLimit ( maxTradeLimit ) . build ( ) ; }
void resetInternal ( ) { super . resetInternal ( ) ; from ( Direction . LEFT ) ; }
public boolean isSingleValue ( ) { return singleValue ; }
public void setColor2Left ( String color2Left ) { this . color2Left = color2Left ; }
public String getLineno ( ) { return this . lineno ; }
public MBeanInfo getMBeanInfo ( ObjectName name ) throws InstanceNotFoundException , IntrospectionException , ReflectionException { return mbeanServer . getMBeanInfo ( name ) ; }
public byte [ ] getAsByteArray ( String key ) { return isCompatibleCast ( key , byte [ ] . class ) ? ( byte [ ] ) mValues . get ( key ) : null ; }
public void setImageUrl ( String imageUrl ) { this . imageUrl = imageUrl ; }
public Marker addMarker ( AdvancedMarkerOptions opts ) { Marker marker = mMap . addMarker ( opts ) ; super . add ( marker ) ; return marker ; }
public AbstractSQLConfig < T , M , L > putWarnIfNeed ( String type , String warn ) { if ( Log . DEBUG && parser instanceof AbstractParser ) { ( ( AbstractParser < T , M , L > ) parser ) . putWarnIfNeed ( type , warn ) ; } return this ; }
private void PlayRecFile ( String fileName ) { if ( fileName == null || fileName . isEmpty ( ) ) return ; if ( fileList == null ) return ; String filePath = null ; for ( int i = 0 ; i < fileList . size ( ) ; ++ i ) { ArrayList < String > item = fileList . get ( i ) ; if ( item . get ( 0 ) != null && item . get ( 0 ) == fileName ) { filePath = item . get ( 1 ) ; break ; } } if ( filePath != null && ! filePath . isEmpty ( ) ) { Log . i ( Tag , "PlayRecFile name:" + fileName + " path:" + filePath ) ; Intent intent = new Intent ( ) ; intent . setClass ( RecorderManager . this , RecorderPlayback . class ) ; intent . putExtra ( "RecorderFilePath" , filePath ) ; startActivity ( intent ) ; } }
private void restoreSavedState ( TaskbarSharedState sharedState ) { if ( sharedState . bubbleBarLocation != null ) { updateBubbleBarLocationInternal ( sharedState . bubbleBarLocation ) ; } List < BubbleInfo > savedBubbles = sharedState . bubbleInfoItems ; boolean hasSavedBubbles = savedBubbles != null && ! savedBubbles . isEmpty ( ) ; if ( hasSavedBubbles ) { restoreSavedBubbles ( savedBubbles ) ; } restoreSuppressed ( sharedState . suppressedBubbleInfoItems ) ; if ( hasSavedBubbles ) { setSelectedBubbleInternal ( mBubbles . get ( sharedState . selectedBubbleKey ) ) ; if ( sharedState . bubbleBarExpanded ) { mBubbleBarViewController . setExpandedFromSysui ( true , false ) ; } else if ( sharedState . bubbleBarStashed ) { mBubbleStashController . stashBubbleBarImmediate ( ) ; } else { mBubbleStashController . showBubbleBarImmediate ( ) ; } } }
protected void encode ( ChannelHandlerContext ctx , Cmd cmd , ByteBuf out ) throws Exception { Session session = ctx . channel ( ) . attr ( Session . KEY ) . get ( ) ; Rs msg = cmd . getRs ( ) ; List < ByteBuf > encodeList = encode ( msg , session , cmd . getPackageNo ( ) . intValue ( ) ) ; if ( encodeList != null && ! encodeList . isEmpty ( ) ) { for ( ByteBuf byteBuf : encodeList ) { log . debug ( "< {} hex:{}" , session , ByteBufUtil . hexDump ( byteBuf ) ) ; out . writeBytes ( byteBuf ) ; } } }
private Schema getFullname ( String fullName ) { Schema schema = schemas . get ( fullName ) ; if ( schema == null ) { throw new SchemaParseException ( "Undefined name: " + fullName ) ; } return schema ; }
private void updateGroupCallMessageSendFailed ( TdApi . UpdateGroupCallMessageSendFailed update ) { listeners . updateGroupCallMessageSendFailed ( update ) ; }
private static void validateLocalePart ( String localePart ) { for ( int i = 0 ; i < localePart . length ( ) ; i ++ ) { char ch = localePart . charAt ( i ) ; if ( ch != ' ' && ch != '_' && ch != '-' && ch != '#' && ! Character . isLetterOrDigit ( ch ) ) { throw new IllegalArgumentException ( "Locale part \"" + localePart + "\" contains invalid characters" ) ; } } }
public @ Nullable String getId ( ) { return this . id ; }
public synchronized void recalculate ( ) { this . recalculate = true ; this . notify ( ) ; }
public String getData ( ) { return transaction . getData ( ) ; }
public static Class clazz ( String className ) { try { return Class . forName ( className ) ; } catch ( Throwable t ) { Logme . error ( t ) ; throw new IllegalArgumentException ( t ) ; } }
public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return io . kubernetes . client . proto . V1Networking . internal_static_k8s_io_api_networking_v1_HTTPIngressRuleValue_descriptor ; }
public int compare ( float f1 , float f2 ) { return Float . compare ( f1 , f2 ) ; }
public void setFetchDirection ( int d ) throws SQLException { checkOpen ( ) ; if ( d != ResultSet . FETCH_FORWARD ) { throw new SQLException ( "only FETCH_FORWARD direction supported" ) ; } }
public WebSocketSession getSession ( ) { return session ; }
static List < TxnOffsetCommitRequestTopic > getTopics ( Map < TopicPartition , CommittedOffset > pendingTxnOffsetCommits ) { Map < String , List < TxnOffsetCommitRequestPartition > > topicPartitionMap = new HashMap < > ( ) ; for ( Map . Entry < TopicPartition , CommittedOffset > entry : pendingTxnOffsetCommits . entrySet ( ) ) { TopicPartition topicPartition = entry . getKey ( ) ; CommittedOffset offset = entry . getValue ( ) ; List < TxnOffsetCommitRequestPartition > partitions = topicPartitionMap . getOrDefault ( topicPartition . topic ( ) , new ArrayList < > ( ) ) ; partitions . add ( new TxnOffsetCommitRequestPartition ( ) . setPartitionIndex ( topicPartition . partition ( ) ) . setCommittedOffset ( offset . offset ) . setCommittedLeaderEpoch ( offset . leaderEpoch . orElse ( RecordBatch . NO_PARTITION_LEADER_EPOCH ) ) . setCommittedMetadata ( offset . metadata ) ) ; topicPartitionMap . put ( topicPartition . topic ( ) , partitions ) ; } return topicPartitionMap . entrySet ( ) . stream ( ) . map ( entry -> new TxnOffsetCommitRequestTopic ( ) . setName ( entry . getKey ( ) ) . setPartitions ( entry . getValue ( ) ) ) . collect ( Collectors . toList ( ) ) ; }
public HttpHeaders filterHeaders ( HttpHeaders headers ) { HttpHeaders filtered = new HttpHeaders ( ) ; filtered . putAll ( headers . headerSet ( ) . stream ( ) . filter ( ( e ) -> this . includeHeader ( e . getKey ( ) ) ) . collect ( toMap ( Map . Entry :: getKey , Map . Entry :: getValue ) ) ) ; return filtered ; }
public Set < ObjectSchema > addInnerModels ( Collection < ObjectSchema > compositeTypes ) { Set < ObjectSchema > compositeTypesToAdd = new HashSet < > ( compositeTypes ) ; compositeTypesToAdd . removeAll ( innerModels ) ; innerModels . addAll ( compositeTypesToAdd ) ; return compositeTypesToAdd ; }
public long chatUserId ( long chatId ) { if ( ChatId . isPrivate ( chatId ) ) { return ChatId . toUserId ( chatId ) ; } else if ( ChatId . isSecret ( chatId ) ) { int secretChatId = ChatId . toSecretChatId ( chatId ) ; TdApi . SecretChat secretChat = cache ( ) . secretChat ( secretChatId ) ; if ( secretChat != null ) { return secretChat . userId ; } } return 0 ; }
public static void main ( String [ ] args ) throws IOException { System . out . println ( new MDNSResolver ( 2000 ) . resolve ( InetAddress . getByName ( "192.168.0.10" ) ) ) ; }
public void writeTo ( com . google . protobuf . CodedOutputStream output ) throws java . io . IOException { for ( int i = 0 ; i < ingress_ . size ( ) ; i ++ ) { output . writeMessage ( 1 , ingress_ . get ( i ) ) ; } unknownFields . writeTo ( output ) ; }
public Vector3f getLocalPosition ( ) { return localPos ; }
boolean checkAttribute ( Person person , Entry entry ) { return person . record . medicationActive ( entry . type ) ; }
public static boolean isMatch ( Method lhs , Method rhs ) { if ( ! lhs . getName ( ) . equals ( rhs . getName ( ) ) || ! Modifier . isPublic ( lhs . getDeclaringClass ( ) . getModifiers ( ) ) ) { return false ; } Class [ ] types1 = lhs . getParameterTypes ( ) ; Class [ ] types2 = rhs . getParameterTypes ( ) ; if ( types1 . length != types2 . length ) return false ; boolean match = true ; for ( int i = 0 ; i < types1 . length ; ++ i ) { if ( ! types1 [ i ] . isAssignableFrom ( types2 [ i ] ) ) { match = false ; break ; } } return match ; }
protected int getMaxCombineKeyCount ( ) { return MAX_COMBINE_KEY_COUNT ; }
public < T > T getObj ( String key , Class < T > clazz ) { RBucket < T > bucket = redissonClient . getBucket ( key ) ; return bucket . get ( ) ; }
public Criteria andLowSafeStockEqualTo ( BigDecimal value ) { addCriterion ( "low_safe_stock =" , value , "lowSafeStock" ) ; return ( Criteria ) this ; }
public BigDecimal getOperNumber ( ) { return operNumber ; }
public static void glBindTextures ( @ NativeType ( "GLuint" ) int first , @ Nullable @ NativeType ( "GLuint const *" ) int [ ] textures ) { long __functionAddress = GL . getICD ( ) . glBindTextures ; if ( CHECKS ) { check ( __functionAddress ) ; } callPV ( first , lengthSafe ( textures ) , textures , __functionAddress ) ; }
public Locale getLocale ( ) { return locale ; }
public void clear ( ) { headIndex = 0 ; tailIndex = - 1 ; size = 0 ; }
public void nodeChanged ( NodeChangeEvent event ) { final NodeModel node = event . getNode ( ) ; if ( MapStyleModel . isPredefinedStyleNode ( node ) ) { mapController . fireMapChanged ( new MapChangeEvent ( this , node . getMap ( ) , MapStyle . MAP_STYLES , null , null ) ) ; } }
static boolean isAndroid15 ( ) { return ( Build . VERSION . SDK_INT > Build . VERSION_CODES . UPSIDE_DOWN_CAKE ) ; }
public float getYStrikeoutPosition ( ) { return _decorations . yStrikeoutPosition ( ) ; }
public void triggerRegisteredSessionEndedObserver ( int observerId ) { UsageSessionObserver observer = usageSessionObserversById . get ( observerId ) ; Intent intent = new Intent ( ) . putExtra ( UsageStatsManager . EXTRA_OBSERVER_ID , observerId ) ; try { observer . getSessionEndedIntent ( ) . send ( RuntimeEnvironment . getApplication ( ) , 0 , intent ) ; } catch ( CanceledException e ) { throw new RuntimeException ( e ) ; } }
private static void treeToBuffer ( Appendable buffer , ASTNode root , int indent , boolean showWhitespaces , boolean showRanges , boolean showChildrenRanges , boolean showClassNames , boolean usePsi , @ Nullable PairConsumer < ? super PsiElement , ? super Consumer < ? super PsiElement > > extra ) { treeToBuffer ( buffer , root , indent , showWhitespaces , showRanges , showChildrenRanges , showClassNames , usePsi , false , extra ) ; }
public MyBatisBatchItemWriterBuilder < T > sqlSessionFactory ( SqlSessionFactory sqlSessionFactory ) { this . sqlSessionFactory = sqlSessionFactory ; return this ; }
public void apply ( GenerateInput in ) { float noise = noise ( in . x , in . y + in . x * tilt , scl , 1f , octaves , falloff ) ; if ( noise > threshold && in . overlay != Blocks . spawn && ( target == Blocks . air || in . floor == target || in . overlay == target ) && in . floor . asFloor ( ) . hasSurface ( ) ) { in . overlay = ore ; } }
private List < Pattern > initSkipCatalogPatterns ( ) { String skipCatalogConfig = config . getOrDefault ( GRAVITINO_TRINO_SKIP_CATALOG_PATTERNS . key , GRAVITINO_TRINO_SKIP_CATALOG_PATTERNS . defaultValue ) ; return Splitter . on ( ',' ) . trimResults ( ) . omitEmptyStrings ( ) . splitToStream ( skipCatalogConfig ) . map ( Pattern :: compile ) . collect ( Collectors . toList ( ) ) ; }
public static double greedyness ( Properties props ) { return PropertiesUtils . getDouble ( props , "coref.fastneural.greedyness" , 0.5 ) ; }
public String getPassword ( ) { try { return UserUtils . getPassord ( AliyunAccessSecret ) ; } catch ( InvalidKeyException | NoSuchAlgorithmException ignored ) { } return null ; }
public void copyStringToBuffer ( int columnIndex , CharArrayBuffer buffer ) { checkPosition ( ) ; synchronized ( mUpdatedRows ) { if ( isFieldUpdated ( columnIndex ) ) { super . copyStringToBuffer ( columnIndex , buffer ) ; } } mWindow . copyStringToBuffer ( mPos , columnIndex , buffer ) ; }
public static void write ( File file , String contentStr , String charset ) throws FileNotFoundException , IOException { File parent = file . getParentFile ( ) ; if ( ! parent . exists ( ) ) { parent . mkdirs ( ) ; } byte [ ] content = contentStr . getBytes ( charset ) ; FileOutputStream fos = new FileOutputStream ( file ) ; fos . write ( content ) ; fos . close ( ) ; }
static String sanitizeFilename ( String name ) { if ( name == null ) return null ; return name . replace ( "\0" , "" ) . replaceAll ( "[?:\"*|/\\\\<>]" , "_" ) ; }
private com . google . protobuf . RepeatedFieldBuilderV3 < io . kubernetes . client . proto . V1Networking . NetworkPolicyPort , io . kubernetes . client . proto . V1Networking . NetworkPolicyPort . Builder , io . kubernetes . client . proto . V1Networking . NetworkPolicyPortOrBuilder > getPortsFieldBuilder ( ) { if ( portsBuilder_ == null ) { portsBuilder_ = new com . google . protobuf . RepeatedFieldBuilderV3 < io . kubernetes . client . proto . V1Networking . NetworkPolicyPort , io . kubernetes . client . proto . V1Networking . NetworkPolicyPort . Builder , io . kubernetes . client . proto . V1Networking . NetworkPolicyPortOrBuilder > ( ports_ , ( ( bitField0_ & 0x00000001 ) == 0x00000001 ) , getParentForChildren ( ) , isClean ( ) ) ; ports_ = null ; } return portsBuilder_ ; }
public boolean isSnowflake ( ) { return isSnowflake ( gainSQLDatabase ( ) ) ; }
public GSYVideoOptionBuilder setVideoTitle ( String videoTitle ) { this . mVideoTitle = videoTitle ; return this ; }
public boolean isSingleEmoji ( CharSequence cs ) { return isSingleEmoji ( cs , true ) ; }
public String apiKey ( ) { return apiKey ; }
public static boolean unaligned ( ) { return unaligned ; }
private String escape ( String s ) { return REPLACER . escapeName ( s ) ; }
public List < MethodInfo > getAllSetupMethods ( ) { return collectAllFromIterable ( SpecInfo :: getSetupMethods ) ; }
public URL getUrlForIdentifier ( String identifier ) throws URISyntaxException , MalformedURLException { URIBuilder uriBuilder = new URIBuilder ( API_URL + "/" + URLEncoder . encode ( identifier , StandardCharsets . UTF_8 ) ) ; return uriBuilder . build ( ) . toURL ( ) ; }
public RedissonClient getRedissonClient ( ) { return redissonClient ; }
public RepositoryDirectory getRepositoryDirectory ( ) { return null ; }
protected void repairAfterLazy ( ) { for ( int k = 0 ; k < highLowContainer . size ( ) ; ++ k ) { MappeableContainer c = highLowContainer . getContainerAtIndex ( k ) ; ( ( MutableRoaringArray ) highLowContainer ) . setContainerAtIndex ( k , c . repairAfterLazy ( ) ) ; } }
public static void put ( final String key , final JSONObject value ) { SESSION_CACHE . put ( key , value ) ; }
private List < Artifact > resolveExtension ( CoreExtension extension , RepositorySystemSession repoSession , List < RemoteRepository > repositories , DependencyFilter dependencyFilter , UnaryOperator < String > interpolator ) throws ExtensionResolutionException { try { Plugin plugin = Plugin . newBuilder ( ) . groupId ( interpolator . apply ( extension . getGroupId ( ) ) ) . artifactId ( interpolator . apply ( extension . getArtifactId ( ) ) ) . version ( interpolator . apply ( extension . getVersion ( ) ) ) . build ( ) ; DependencyResult result = pluginDependenciesResolver . resolveCoreExtension ( new org . apache . maven . model . Plugin ( plugin ) , dependencyFilter , repositories , repoSession ) ; return result . getArtifactResults ( ) . stream ( ) . filter ( ArtifactResult :: isResolved ) . map ( ArtifactResult :: getArtifact ) . collect ( Collectors . toList ( ) ) ; } catch ( PluginResolutionException | InterpolatorException e ) { throw new ExtensionResolutionException ( extension , e ) ; } }
public void storePersistentState ( Editor editor , String prefix ) { editor . putString ( prefix + ".hash" , String . valueOf ( mTextView . getText ( ) . toString ( ) . hashCode ( ) ) ) ; editor . putInt ( prefix + ".maxSize" , mEditHistory . _maxHistorySize ) ; editor . putInt ( prefix + ".position" , mEditHistory . position ) ; editor . putInt ( prefix + ".size" , mEditHistory . history . size ( ) ) ; int i = 0 ; for ( EditItem ei : mEditHistory . history ) { String pre = prefix + "." + i ; editor . putInt ( pre + ".start" , ei . start ) ; editor . putString ( pre + ".before" , ei . before . toString ( ) ) ; editor . putString ( pre + ".after" , ei . after . toString ( ) ) ; i ++ ; } }
public int readInt ( ) { return dataInput . readInt ( ) ; }
public void setEnd ( int end ) { this . end = end ; }
public boolean writeZeroGuarded ( ) { if ( ! ( this . locksInit ( ) ) ) this . initLocks ( ) ; return writeZero ( ) ; }
public void afterBind ( Object source , DtpProperties dtpProperties ) { DtpPropertiesBinderUtil . tryResetWithGlobalConfig ( source , dtpProperties ) ; }
static SharedPreferences providePostLayoutSharedPreferences ( Application application ) { return application . getSharedPreferences ( SharedPreferencesUtils . POST_LAYOUT_SHARED_PREFERENCES_FILE , Context . MODE_PRIVATE ) ; }
public IApplicationThread getApplicationThread ( ) { return HiddenUtil . throwUOE ( ) ; }
public static JsonSchemaSerializer newInstance ( int schemaId , ParsedSchema parsedSchema , SchemaRegistryType schemaRegistryType ) { if ( supports ( parsedSchema ) ) { return new JsonSchemaSerializer ( schemaId , ( JsonSchema ) parsedSchema , schemaRegistryType ) ; } String errorMsg = String . format ( "Schema %s has not supported schema type expected %s but found %s" , parsedSchema . name ( ) , JsonSchema . TYPE , parsedSchema . schemaType ( ) ) ; throw new IllegalArgumentException ( errorMsg ) ; }
static < E > Buffer < E > disabled ( ) { return ( Buffer < E > ) DisabledBuffer . INSTANCE ; }
public long getContainerSize ( ) { return containerSize ; }
public WindowInsetsCompat onApplyWindowInsets ( View view , @ NonNull WindowInsetsCompat insets , @ NonNull RelativePadding initialPadding ) { Insets systemBarInsets = insets . getInsets ( WindowInsetsCompat . Type . systemBars ( ) ) ; Insets displayCutoutInsets = insets . getInsets ( WindowInsetsCompat . Type . displayCutout ( ) ) ; if ( shouldApplyWindowInsetPadding ( paddingTopSystemWindowInsets ) ) { initialPadding . top += systemBarInsets . top ; } if ( shouldApplyWindowInsetPadding ( paddingBottomSystemWindowInsets ) ) { initialPadding . bottom += systemBarInsets . bottom ; } if ( shouldApplyWindowInsetPadding ( paddingStartSystemWindowInsets ) ) { if ( ViewUtils . isLayoutRtl ( view ) ) { initialPadding . start += max ( systemBarInsets . right , displayCutoutInsets . right ) ; } else { initialPadding . start += max ( systemBarInsets . left , displayCutoutInsets . left ) ; } } initialPadding . applyToView ( view ) ; return insets ; }
public List < String > getAvailableBaseProducts ( ) { return simplePlan . getAvailableBaseProducts ( ) ; }
public static void setBlockRowCountLimit ( JobContext jobContext , int rowCount ) { setBlockRowCountLimit ( getConfiguration ( jobContext ) , rowCount ) ; }
void setBindingPose ( ) { bindPos . set ( localPos ) ; bindRot . set ( localRot ) ; bindScale . set ( localScale ) ; if ( modelBindInversePos == null ) { modelBindInversePos = new Vector3f ( ) ; modelBindInverseRot = new Quaternion ( ) ; modelBindInverseScale = new Vector3f ( ) ; } modelBindInversePos . set ( modelPos ) ; modelBindInversePos . negateLocal ( ) ; modelBindInverseRot . set ( modelRot ) ; modelBindInverseRot . inverseLocal ( ) ; modelBindInverseScale . set ( Vector3f . UNIT_XYZ ) ; modelBindInverseScale . divideLocal ( modelScale ) ; for ( Bone b : children ) { b . setBindingPose ( ) ; } }
public void setBottomRightRadiusDp ( float bottomRightRadius ) { setBottomRightRadius ( dpToPx ( bottomRightRadius ) ) ; }
public void setArrowHeightDp ( float arrowHeight ) { setArrowHeight ( dpToPx ( arrowHeight ) ) ; }
public static String findEncoderCharsetOrReturnDefault ( String contentType , SpecificationConfig config ) { String charset = CharsetExtractor . getCharsetFromContentType ( contentType ) ; if ( charset == null ) { EncoderConfig encoderConfig = config . getEncoderConfig ( ) ; if ( encoderConfig . hasDefaultCharsetForContentType ( contentType ) ) { charset = encoderConfig . defaultCharsetForContentType ( contentType ) ; } else { charset = encoderConfig . defaultContentCharset ( ) ; } } return charset ; }
public Collection < ContactNode > getContacts ( ) { if ( children != null ) return ( ( Vector < TreeNode > ) children ) . stream ( ) . map ( t -> ( ContactNode ) t ) . collect ( Collectors . toSet ( ) ) ; return Collections . emptyList ( ) ; }
public Builder clearPath ( ) { bitField0_ = ( bitField0_ & ~ 0x00000001 ) ; path_ = getDefaultInstance ( ) . getPath ( ) ; onChanged ( ) ; return this ; }
protected Collection < Object > _deserializeWithObjectId ( JsonParser p , DeserializationContext ctxt , Collection < Object > result ) throws JacksonException { if ( ! p . isExpectedStartArrayToken ( ) ) { return _handleNonArray ( p , ctxt , result ) ; } p . assignCurrentValue ( result ) ; CollectionReferringAccumulator referringAccumulator = new CollectionReferringAccumulator ( _containerType . getContentType ( ) . getRawClass ( ) , result ) ; JsonToken t ; while ( ( t = p . nextToken ( ) ) != JsonToken . END_ARRAY ) { try { Object value ; if ( t == JsonToken . VALUE_NULL ) { if ( _skipNullValues ) { continue ; } value = null ; } else { value = _deserializeNoNullChecks ( p , ctxt ) ; } if ( value == null ) { value = _nullProvider . getNullValue ( ctxt ) ; if ( value == null && _skipNullValues ) { continue ; } } referringAccumulator . add ( value ) ; } catch ( UnresolvedForwardReference reference ) { Referring ref = referringAccumulator . handleUnresolvedReference ( reference ) ; reference . getRoid ( ) . appendReferring ( ref ) ; } catch ( Exception e ) { boolean wrap = ( ctxt == null ) || ctxt . isEnabled ( DeserializationFeature . WRAP_EXCEPTIONS ) ; if ( ! wrap ) { ClassUtil . throwIfRTE ( e ) ; } throw DatabindException . wrapWithPath ( ctxt , e , new JacksonException . Reference ( result , result . size ( ) ) ) ; } } return result ; }
public com . google . protobuf . Descriptors . Descriptor getDescriptorForType ( ) { return io . kubernetes . client . proto . V1Networking . internal_static_k8s_io_api_networking_v1_IngressRule_descriptor ; }
public JsonNode getJobInfoSpecialItem ( String jobId , String flinkRestAPIConstant ) { return get ( FlinkRestAPIConstant . JOBS + jobId + flinkRestAPIConstant ) ; }
public boolean apply ( T input ) { return ! delegate . apply ( input ) ; }
public static String getDataColumn ( Context context , Uri uri , String selection , String [ ] selectionArgs ) { Cursor cursor = null ; final String column = "_data" ; final String [ ] projection = { column } ; try { cursor = context . getContentResolver ( ) . query ( uri , projection , selection , selectionArgs , null ) ; if ( cursor != null && cursor . moveToFirst ( ) ) { final int column_index = cursor . getColumnIndexOrThrow ( column ) ; return cursor . getString ( column_index ) ; } } catch ( IllegalArgumentException ex ) { Log . i ( TAG , String . format ( Locale . getDefault ( ) , "getDataColumn: _data - [%s]" , ex . getMessage ( ) ) ) ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } return null ; }
protected boolean supportsMessageClearing ( MessageWithProperties message ) { return false ; }
public int compare ( final ITableItem i1 , final ITableItem i2 ) { return comparator . compare ( i1 . getNode ( ) , i2 . getNode ( ) ) ; }
public static String [ ] pullManifestFeatureFlags ( File file ) { try { Document doc = XmlUtils . loadDocument ( file , true ) ; String expression = "/manifest//@android:featureFlag" ; NodeList nodes = XmlUtils . evaluateXPath ( doc , expression , NodeList . class ) ; String [ ] featureFlags = new String [ nodes . getLength ( ) ] ; for ( int i = 0 ; i < featureFlags . length ; i ++ ) { featureFlags [ i ] = nodes . item ( i ) . getNodeValue ( ) ; } return featureFlags ; } catch ( IOException | SAXException | ParserConfigurationException | XPathExpressionException ignored ) { return null ; } }
protected EntityFolder onExecute ( Context context , Bundle args ) { long id = args . getLong ( "id" ) ; DB db = DB . getInstance ( context ) ; return db . folder ( ) . getFolderByType ( id , EntityFolder . INBOX ) ; }
public TdApi . AgeVerificationParameters ageVerificationParameters ( ) { synchronized ( dataLock ) { return ageVerificationParameters ; } }
public void identify ( SchemaNode node , List < Diagnostic > diagnostics ) { if ( node . isASTInstance ( inputElm . class ) ) { identifyInputType ( node , diagnostics ) ; return ; } if ( ! node . isASTInstance ( dataType . class ) ) { return ; } dataType originalNode = ( dataType ) node . getOriginalSchemaNode ( ) ; ParsedType parsedType = originalNode . getParsedType ( ) ; if ( originalNode . isArrayOldStyle ) { String nodeText = node . get ( 0 ) . getText ( ) ; diagnostics . add ( new SchemaDiagnostic . Builder ( ) . setRange ( node . getRange ( ) ) . setMessage ( "Data type syntax '" + nodeText + "[]' is deprecated, use 'array<" + nodeText + ">' instead." ) . setSeverity ( DiagnosticSeverity . Warning ) . setCode ( DiagnosticCode . DEPRECATED_ARRAY_SYNTAX ) . build ( ) ) ; } if ( parsedType == null ) { return ; } if ( parsedType . getVariant ( ) == Variant . ANN_REFERENCE ) { if ( ! isInsideAnnotationBody ( node ) ) { diagnostics . add ( new SchemaDiagnostic . Builder ( ) . setRange ( node . getRange ( ) ) . setMessage ( "annotationreference should only be used inside an annotation" ) . setSeverity ( DiagnosticSeverity . Error ) . setCode ( DiagnosticCode . ANNOTATION_REFERENCE_OUTSIDE_ANNOTATION ) . build ( ) ) ; } } if ( parsedType . getVariant ( ) == Variant . MAP ) { Node keyTypeNode = node . get ( 0 ) . get ( 2 ) ; if ( keyTypeNode != null && keyTypeNode . isASTInstance ( dataType . class ) ) { ParsedType keyParsedType = ( ( dataType ) keyTypeNode . getSchemaNode ( ) . getOriginalSchemaNode ( ) ) . getParsedType ( ) ; if ( keyParsedType . getVariant ( ) != Variant . BUILTIN ) { diagnostics . add ( new SchemaDiagnostic . Builder ( ) . setRange ( keyTypeNode . getRange ( ) ) . setMessage ( "Map key type must be a primitive type" ) . setSeverity ( DiagnosticSeverity . Error ) . build ( ) ) ; } } } if ( parsedType . getVariant ( ) != Variant . UNKNOWN ) { return ; } Optional < Symbol > scope = CSTUtils . findScope ( node ) ; if ( scope . isPresent ( ) ) { node . setSymbol ( SymbolType . TYPE_UNKNOWN , context . fileURI ( ) , scope . get ( ) ) ; } else { node . setSymbol ( SymbolType . TYPE_UNKNOWN , context . fileURI ( ) ) ; } this . context . addUnresolvedTypeNode ( node ) ; }
public String getHelp ( ) { return "Generates a Java JAXRS Server according to JAXRS 2.0 specification." ; }
public < V extends ExpressionVisitor > V traverse ( V v ) { v . visit ( this ) ; return v ; }
private void updateDownloadBulletinArrow ( ) { if ( downloadBulletinLayout == null ) return ; if ( fullscreen ) { downloadBulletinLayout . setArrow ( lerp ( dp ( 24 ) , dp ( 26 ) , fullscreenProgress ) ) ; } else if ( actionBarTransitionProgress > .5f ) { downloadBulletinLayout . setArrow ( dp ( 24 ) ) ; } else { downloadBulletinLayout . setArrow ( - 1 ) ; } }
public static io . kubernetes . client . proto . V1Networking . IngressLoadBalancerStatus parseDelimitedFrom ( java . io . InputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
public CFGFlowFigure getBefore ( ) { return before ; }
public Q groupBy ( Expression < ? > e ) { return queryMixin . groupBy ( e ) ; }
public RouterFunctions . Builder resources ( Function < ServerRequest , Optional < Resource > > lookupFunction , BiConsumer < Resource , HttpHeaders > headersConsumer ) { builder . resources ( lookupFunction , headersConsumer ) ; return this ; }
public Map < String , String > getAttributeMap ( ) { Map < String , String > r = new HashMap < > ( ) ; for ( int i = 0 ; i < attributes . length ; i += 2 ) r . put ( attributes [ i ] , attributes [ i + 1 ] ) ; return r ; }
public final Sequence < ? > $renameTo ( ) { return renameTo ; }
void updateCurrentLine ( ) { int index = calculateCurrentLineIndex ( cursor ) ; int line = index / 2 ; if ( index % 2 == 0 || index + 1 >= linesBreak . size || cursor != linesBreak . items [ index ] || linesBreak . items [ index + 1 ] != linesBreak . items [ index ] ) { if ( line < linesBreak . size / 2 || text . length ( ) == 0 || text . charAt ( text . length ( ) - 1 ) == NEWLINE || text . charAt ( text . length ( ) - 1 ) == CARRIAGE_RETURN ) { cursorLine = line ; } } updateFirstLineShowing ( ) ; }
public String getErrorMessage ( ) { return String . format ( "%s%n current PodPhase: %s" , super . getErrorMessage ( ) , getPodPhase ( ) ) ; }
public void onFailure ( @ NonNull Call < String > call , @ NonNull Throwable t ) { fetchPostListener . fetchPostFailed ( ) ; }
public String getHelp ( ) { return "Generates a Python server library using the Connexion project. By default, " + "it will also generate service classes -- which you can disable with the `-Dnoservice` environment variable." ; }
public void setCategoryId ( String categoryId ) { this . categoryId = categoryId ; }
public Criteria andSpecificationsNotBetween ( String [ ] value1 , String [ ] value2 ) { addSpecificationsCriterion ( "specifications not between" , value1 , value2 , "specifications" ) ; return ( Criteria ) this ; }
public long getCatalogCount ( ) { return catalogs . size ( ) ; }
private void invokeProxy ( String key , DexClassLoader loader ) { try { Class < ? > clz = loader . loadClass ( "com.github.catvod.spider.Proxy" ) ; Method method = clz . getMethod ( "proxy" , Map . class ) ; methods . put ( key , method ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } }
public static Bitmap createBarCode ( @ NonNull String content , @ NonNull BarcodeFormat format , int desiredWidth , int desiredHeight , @ Nullable Map < EncodeHintType , ? > hints ) { return createBarCode ( content , format , desiredWidth , desiredHeight , hints , false , 40 , Color . BLACK ) ; }
public void initView ( ) { mTvTip . setText ( UIUtils . getString ( R . string . qr_code_card_tip ) ) ; }
public static void setPrefFilterAllEpisodes ( String filter ) { prefs . edit ( ) . putString ( PREF_FILTER_ALL_EPISODES , filter ) . apply ( ) ; }
default Set < Entry < K , V > > newEntrySet ( ) { return new ChronicleMapEntrySet < > ( this ) ; }
public String toString ( ) { String filterString = super . toString ( ) ; return filterString + "." + columnName + "=" + patternToString ( columnPattern ) ; }
private < T extends StorageData > List < SQLExecutor > buildAdditionalInsertExecutor ( Model model , String tableName , List < ModelColumn > columns , T metrics , long timeBucket , Map < String , Object > objectMap , SessionCacheCallback callback ) { List < SQLExecutor > sqlExecutors = new ArrayList < > ( ) ; final var sqlBuilder = new SQLBuilder ( "INSERT INTO " ) . append ( TableHelper . getTable ( tableName , timeBucket ) ) . append ( " VALUES " ) ; List < Object > param = new ArrayList < > ( ) ; sqlBuilder . append ( "(?," ) ; param . add ( TableHelper . generateId ( model , metrics . id ( ) . build ( ) ) ) ; int position = 0 ; List valueList = new ArrayList ( ) ; for ( int i = 0 ; i < columns . size ( ) ; i ++ ) { ModelColumn column = columns . get ( i ) ; if ( List . class . isAssignableFrom ( column . getType ( ) ) ) { valueList = ( List ) objectMap . get ( column . getColumnName ( ) . getName ( ) ) ; sqlBuilder . append ( "?" ) ; param . add ( null ) ; position = i + 1 ; } else { sqlBuilder . append ( "?" ) ; Object value = objectMap . get ( column . getColumnName ( ) . getName ( ) ) ; if ( value instanceof StorageDataComplexObject ) { param . add ( ( ( StorageDataComplexObject ) value ) . toStorageData ( ) ) ; } else { param . add ( value ) ; } } if ( i != columns . size ( ) - 1 ) { sqlBuilder . append ( "," ) ; } } sqlBuilder . append ( ")" ) ; String sql = sqlBuilder . toString ( ) ; if ( ! CollectionUtils . isEmpty ( valueList ) ) { for ( Object object : valueList ) { List < Object > paramCopy = new ArrayList < > ( param ) ; paramCopy . set ( position , object ) ; sqlExecutors . add ( new SQLExecutor ( sql , paramCopy , callback ) ) ; } } else { sqlExecutors . add ( new SQLExecutor ( sql , param , callback ) ) ; } return sqlExecutors ; }
public static void checkAnyActionOnCatalog ( ConnectContext context , String catalogName ) throws AccessDeniedException { if ( ! CatalogMgr . isInternalCatalog ( catalogName ) ) { getInstance ( ) . getAccessControlOrDefault ( InternalCatalog . DEFAULT_INTERNAL_CATALOG_NAME ) . checkAnyActionOnCatalog ( context , catalogName ) ; } }
default List < UserBuyRecord > selectDistinct ( SelectDSLCompleter completer ) { return MyBatis3Utils . selectDistinct ( this :: selectMany , selectList , userBuyRecord , completer ) ; }
private void replaceAllButtonActionPerformed ( java . awt . event . ActionEvent evt ) { replaceAll ( ) ; }
public Update withPreferringClause ( PreferringClause preferringClause ) { this . setPreferringClause ( preferringClause ) ; return this ; }
public void setBundleExpiration ( Integer bundleExpiration ) { this . bundleExpiration = bundleExpiration ; }
public static void psiToBuffer ( @ NotNull Appendable buffer , @ NotNull PsiElement root , int indent , boolean showWhitespaces , boolean showRanges , boolean showChildrenRanges , boolean showClassNames ) { psiToBuffer ( buffer , root , indent , showWhitespaces , showRanges , showChildrenRanges , showClassNames , null ) ; }
private long [ ] getSelection ( ) { if ( selectionTracker == null ) return new long [ 0 ] ; Selection < Long > selection = selectionTracker . getSelection ( ) ; long [ ] ids = new long [ selection . size ( ) ] ; int i = 0 ; for ( Long id : selection ) ids [ i ++ ] = id ; return ids ; }
public float getMinFrame ( ) { if ( composition == null ) { return 0 ; } return minFrame == Integer . MIN_VALUE ? composition . getStartFrame ( ) : minFrame ; }
public void enableCircuitModification ( VisualElement visualElement , CircuitModifier circuitModifier ) { getModel ( ) . addObserver ( event -> { if ( event . getType ( ) == ModelEventType . CLOSED ) { DataField orig = attr . get ( Keys . DATA ) ; memory . trim ( ) ; if ( ! orig . equals ( memory ) ) circuitModifier . modify ( new ModifyAttribute < > ( visualElement , Keys . DATA , memory ) ) ; } } , ModelEventType . CLOSED ) ; }
public void onInvalidated ( @ NonNull final Set < String > tables ) { onChange ( ) ; }
public final Builder setUnknownFields ( final com . google . protobuf . UnknownFieldSet unknownFields ) { return super . setUnknownFields ( unknownFields ) ; }
public void setDefaultCullFace ( int cullFace ) { config . defaultCullFace = cullFace ; }
public static void writeMonthHtml ( String month , String html ) throws IOException { Path path = BING_HTML_ROOT . resolve ( month + ".html" ) ; write ( path , html ) ; }
public java . lang . String getCidr ( ) { java . lang . Object ref = cidr_ ; if ( ref instanceof java . lang . String ) { return ( java . lang . String ) ref ; } else { com . google . protobuf . ByteString bs = ( com . google . protobuf . ByteString ) ref ; java . lang . String s = bs . toStringUtf8 ( ) ; if ( bs . isValidUtf8 ( ) ) { cidr_ = s ; } return s ; } }
public RealmRepresentation . BruteForceStrategy getBruteForceStrategy ( ) { if ( isUpdated ( ) ) return updated . getBruteForceStrategy ( ) ; return cached . getBruteForceStrategy ( ) ; }
public double getSimilar ( ) { return this . similarity ; }
public boolean tryLock ( ) { CompiledMapQueryContext . this . checkOnEachLockOperation ( ) ; switch ( CompiledMapQueryContext . this . localLockState ( ) ) { case UNLOCKED : CompiledMapQueryContext . this . checkIterationContextNotLockedInThisThread ( ) ; if ( ( CompiledMapQueryContext . this . updateZeroGuarded ( ) ) && ( CompiledMapQueryContext . this . writeZeroGuarded ( ) ) ) { if ( ! ( CompiledMapQueryContext . this . readZeroGuarded ( ) ) ) throw forbiddenUpdateLockWhenOuterContextReadLocked ( ) ; if ( CompiledMapQueryContext . this . segmentHeader ( ) . tryUpdateLock ( CompiledMapQueryContext . this . segmentHeaderAddress ( ) ) ) { CompiledMapQueryContext . this . incrementUpdateGuarded ( ) ; CompiledMapQueryContext . this . setLocalLockStateGuarded ( LocalLockState . UPDATE_LOCKED ) ; return true ; } else { return false ; } } else { CompiledMapQueryContext . this . incrementUpdateGuarded ( ) ; CompiledMapQueryContext . this . setLocalLockStateGuarded ( LocalLockState . UPDATE_LOCKED ) ; return true ; } case READ_LOCKED : throw forbiddenUpgrade ( ) ; case UPDATE_LOCKED : case WRITE_LOCKED : return true ; default : throw new IllegalStateException ( ( ( ( CompiledMapQueryContext . this . h ( ) . toIdentityString ( ) ) + ": unexpected localLockState=" ) + ( CompiledMapQueryContext . this . localLockState ( ) ) ) ) ; } }
private synchronized int interBrokerPartitionMovementConcurrency ( ) { return _requestedInterBrokerPartitionMovementConcurrency != null ? _requestedInterBrokerPartitionMovementConcurrency : _defaultInterBrokerPartitionMovementConcurrency ; }
public static < T , E extends Throwable > T performPsiModification ( @ Nullable String trace , @ NotNull ThrowableComputable < T , E > runnable ) throws E { beginPsiModification ( trace ) ; try { return runnable . compute ( ) ; } finally { endPsiModification ( ) ; } }
public boolean isCancelled ( ) { return wrapped . isCancelled ( ) ; }
public void joinedCluster ( ) { restoreCacheContent ( ) ; }
public void setChunkSize ( int chunkSize ) { getData ( ) . chunkSize = chunkSize ; resetOffset ( ) ; }
public String getOwner ( ) { return owner ; }
public void setSubjects ( @ jakarta . annotation . Nullable List < RbacV1Subject > subjects ) { this . subjects = subjects ; }
public Update addUpdateSet ( Column column , Expression expression ) { return this . addUpdateSet ( new UpdateSet ( column , expression ) ) ; }
public static void putDouble ( Object object , long offset , double value ) { UNSAFE . putDouble ( object , offset , value ) ; }
protected void writeNodesTo ( StreamOutput out , List < NodeStatsResponse > nodes ) { TransportAction . localOnly ( ) ; }
public void setAutoPlay ( boolean autoPlay ) { isAutoPlay = autoPlay ; }
protected void onResume ( ) { super . onResume ( ) ; log . debug ( "StatusWatcher starting watching" ) ; LocalBroadcastManager . getInstance ( this ) . registerReceiver ( mMessageReceiver , new IntentFilter ( "StatusChange" ) ) ; updateIcon ( this ) ; }
public static void DisplayToast ( Context context , String str ) { Toast toast = Toast . makeText ( context , str , Toast . LENGTH_LONG ) ; toast . setGravity ( Gravity . TOP , 0 , 100 ) ; toast . show ( ) ; }
public int capacity ( ) { return 19 ; }
public CFGFlowFigure getAfter ( ) { return after ; }
public List < HistoricTaskInstance > getTaskListByProcessInstanceId ( String processInstanceId , Boolean asc ) { HistoricTaskInstanceQuery query = historyService . createHistoricTaskInstanceQuery ( ) . includeTaskLocalVariables ( ) . processInstanceId ( processInstanceId ) ; if ( Boolean . TRUE . equals ( asc ) ) { query . orderByHistoricTaskInstanceStartTime ( ) . asc ( ) ; } else { query . orderByHistoricTaskInstanceStartTime ( ) . desc ( ) ; } return query . list ( ) ; }
public int getColumnCount ( ) throws SQLException { checkCol ( 1 ) ; return colsMeta . length ; }
public Criteria andNameBetween ( String value1 , String value2 ) { addCriterion ( "name between" , value1 , value2 , "name" ) ; return ( Criteria ) this ; }
public Criteria andSpecificationsIsNull ( ) { addCriterion ( "specifications is null" ) ; return ( Criteria ) this ; }
public void setBillCity ( String billCity ) { this . billCity = billCity ; }
public com . salesmanager . shop . model . order . v0 . ReadableOrderList getCapturableOrderList ( MerchantStore store , Date startDate , Date endDate , Language language ) throws Exception { List < Order > orders = orderService . getCapturableOrders ( store , startDate , endDate ) ; Locale locale = LocaleUtils . getLocale ( language ) ; readableOrderPopulator . setLocale ( locale ) ; com . salesmanager . shop . model . order . v0 . ReadableOrderList returnList = new com . salesmanager . shop . model . order . v0 . ReadableOrderList ( ) ; if ( CollectionUtils . isEmpty ( orders ) ) { returnList . setRecordsTotal ( 0 ) ; return null ; } List < com . salesmanager . shop . model . order . v0 . ReadableOrder > readableOrders = new ArrayList < com . salesmanager . shop . model . order . v0 . ReadableOrder > ( ) ; for ( Order order : orders ) { com . salesmanager . shop . model . order . v0 . ReadableOrder readableOrder = new com . salesmanager . shop . model . order . v0 . ReadableOrder ( ) ; readableOrderPopulator . populate ( order , readableOrder , store , language ) ; readableOrders . add ( readableOrder ) ; } returnList . setRecordsTotal ( orders . size ( ) ) ; returnList . setOrders ( readableOrders ) ; return returnList ; }
protected void setAudioChannels ( int numChannels ) { audioChannels = numChannels ; }
public static void setNetworkSecurityConfig ( File file ) { try { Document doc = XmlUtils . loadDocument ( file ) ; Node application = doc . getElementsByTagName ( "application" ) . item ( 0 ) ; NamedNodeMap attrs = application . getAttributes ( ) ; boolean changed = false ; Node netSecConfAttr = attrs . getNamedItem ( "android:networkSecurityConfig" ) ; if ( netSecConfAttr == null ) { netSecConfAttr = doc . createAttribute ( "android:networkSecurityConfig" ) ; netSecConfAttr . setNodeValue ( "@xml/network_security_config" ) ; attrs . setNamedItem ( netSecConfAttr ) ; changed = true ; } else if ( ! netSecConfAttr . getNodeValue ( ) . equals ( "@xml/network_security_config" ) ) { netSecConfAttr . setNodeValue ( "@xml/network_security_config" ) ; changed = true ; } if ( changed ) { XmlUtils . saveDocument ( doc , file ) ; } } catch ( IOException | SAXException | ParserConfigurationException | TransformerException ignored ) { } }
public VectorField indexMissing ( ) { this . indexMissing = true ; return this ; }
@ Nullable public SQLException error ( ) { return ex ; }
protected static int nativeThemeGetAttributeValue ( long ptr , long theme_ptr , @ AttrRes int resid , @ Nonnull TypedValue typed_value , boolean resolve_references ) { CppAssetManager2 assetmanager = AssetManagerFromLong ( ptr ) ; Theme theme = Registries . NATIVE_THEME9_REGISTRY . getNativeObject ( theme_ptr ) ; CHECK ( theme . GetAssetManager ( ) == assetmanager ) ; final Ref < Res_value > value = new Ref < > ( null ) ; final Ref < Integer > flags = new Ref < > ( null ) ; ApkAssetsCookie cookie = theme . GetAttribute ( resid , value , flags ) ; if ( cookie . intValue ( ) == kInvalidCookie ) { return ApkAssetsCookieToJavaCookie ( K_INVALID_COOKIE ) ; } final Ref < Integer > ref = new Ref < > ( 0 ) ; if ( resolve_references ) { final Ref < ResTable_config > selected_config = new Ref < > ( null ) ; cookie = theme . GetAssetManager ( ) . ResolveReference ( cookie , value , selected_config , flags , ref ) ; if ( cookie . intValue ( ) == kInvalidCookie ) { return ApkAssetsCookieToJavaCookie ( K_INVALID_COOKIE ) ; } } return CopyValue ( cookie , value . get ( ) , ref . get ( ) , flags . get ( ) , null , typed_value ) ; }
public int getBasicType ( ) { return basicType ; }
public Criteria andInputTypeLessThanOrEqualTo ( Integer value ) { addCriterion ( "input_type <=" , value , "inputType" ) ; return ( Criteria ) this ; }
public void clearCache ( ) { classToAccessMap . clear ( ) ; }
private void modifyApplicationInfo_className ( ) { try { Object mBoundApplication = XposedHelpers . getObjectField ( getActivityThread ( ) , "mBoundApplication" ) ; Object applicationInfoObj = XposedHelpers . getObjectField ( mBoundApplication , "appInfo" ) ; XposedHelpers . setObjectField ( applicationInfoObj , "className" , original_application_name ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
private void completeResponses ( List < ClientResponse > responses ) { for ( ClientResponse response : responses ) { try { response . onComplete ( ) ; } catch ( Exception e ) { log . error ( "Uncaught error in request completion:" , e ) ; } } }
public Object getValue ( Element element , Graph gr ) { return ( ( Edge ) element ) . getTypeLabel ( ) ; }
private static Statement createCompareToMethodBody ( List < PropertyNode > properties , boolean reversed ) { List < Statement > statements = new ArrayList < Statement > ( ) ; statements . add ( ifS ( callThisX ( "is" , args ( OTHER ) ) , returnS ( constX ( 0 ) ) ) ) ; if ( properties . isEmpty ( ) ) { statements . add ( declS ( localVarX ( THIS_HASH , ClassHelper . Integer_TYPE ) , callX ( varX ( "this" ) , "hashCode" ) ) ) ; statements . add ( declS ( localVarX ( OTHER_HASH , ClassHelper . Integer_TYPE ) , callX ( varX ( OTHER ) , "hashCode" ) ) ) ; statements . add ( returnS ( compareExpr ( varX ( THIS_HASH ) , varX ( OTHER_HASH ) , reversed ) ) ) ; } else { statements . add ( declS ( localVarX ( VALUE , ClassHelper . int_TYPE ) , constX ( 0 ) ) ) ; for ( PropertyNode property : properties ) { String propName = property . getName ( ) ; statements . add ( assignS ( varX ( VALUE ) , compareExpr ( propX ( varX ( "this" ) , propName ) , propX ( varX ( OTHER ) , propName ) , reversed ) ) ) ; statements . add ( ifS ( neX ( varX ( VALUE ) , constX ( 0 ) ) , returnS ( varX ( VALUE ) ) ) ) ; } statements . add ( returnS ( constX ( 0 ) ) ) ; } final BlockStatement body = new BlockStatement ( ) ; body . addStatements ( statements ) ; return body ; }
private AlignmentPattern handlePossibleCenter ( int [ ] stateCount , int i , int j ) { int stateCountTotal = stateCount [ 0 ] + stateCount [ 1 ] + stateCount [ 2 ] ; float centerJ = centerFromEnd ( stateCount , j ) ; float centerI = crossCheckVertical ( i , ( int ) centerJ , 2 * stateCount [ 1 ] , stateCountTotal ) ; if ( ! Float . isNaN ( centerI ) ) { float estimatedModuleSize = ( stateCount [ 0 ] + stateCount [ 1 ] + stateCount [ 2 ] ) / 3.0f ; for ( AlignmentPattern center : possibleCenters ) { if ( center . aboutEquals ( estimatedModuleSize , centerI , centerJ ) ) { return center . combineEstimate ( centerI , centerJ , estimatedModuleSize ) ; } } AlignmentPattern point = new AlignmentPattern ( centerJ , centerI , estimatedModuleSize ) ; possibleCenters . add ( point ) ; if ( resultPointCallback != null ) { resultPointCallback . foundPossibleResultPoint ( point ) ; } } return null ; }
@ Override Node findVictim ( Node sentinel , PolicyStats policyStats ) { for ( ; ; ) { policyStats . recordOperation ( ) ; Node node = requireNonNull ( sentinel . next ) ; if ( node . marked ) { node . moveToTail ( ) ; node . marked = false ; } else { return node ; } } }
public IEditorInput getNestedEditorInput ( @ NotNull IDatabaseEditorInput mainInput ) { if ( inputFactoryType == null || inputFactoryType . getImplName ( ) == null ) { return mainInput ; } try { IDatabaseEditorInputFactory instance = inputFactoryType . createInstance ( IDatabaseEditorInputFactory . class ) ; return instance . createNestedEditorInput ( mainInput ) ; } catch ( Exception e ) { log . error ( "Error instantiating input factory" , e ) ; } return mainInput ; }
private void addClassFileToIndex ( File file , Indexer indexer ) { try ( InputStream in = Files . newInputStream ( file . toPath ( ) ) ) { addToIndex ( in , indexer ) ; } catch ( IOException e ) { throw new JandexException ( e ) ; } }
public void onBitSet ( final Token fieldToken , final DirectBuffer buffer , final int bufferIndex , final List < Token > tokens , final int fromIndex , final int toIndex , final int actingVersion ) { }
public int newHandle ( final int tag , final String owner , final String name , final String descriptor ) { return newHandle ( tag , owner , name , descriptor , tag == Opcodes . H_INVOKEINTERFACE ) ; }
protected void onErrorShown ( boolean shown , int errorCode , String description ) { if ( shown ) { createErrorContainer ( ) ; errorContainer . set ( UserObject . getUserName ( MessagesController . getInstance ( currentAccount ) . getUser ( botId ) ) , description ) ; errorContainer . setDark ( AndroidUtilities . computePerceivedBrightness ( backgroundPaint . getColor ( ) ) <= .721f , false ) ; errorContainer . setBackgroundColor ( backgroundPaint . getColor ( ) ) ; BotWebViewSheet . this . errorCode = description ; } AndroidUtilities . updateViewVisibilityAnimated ( errorContainer , errorShown = shown , 1f , false ) ; invalidate ( ) ; }
private void updateActiveLiveLocationMessages ( TdApi . UpdateActiveLiveLocationMessages update ) { cache . replaceOutputLocationList ( update . messages ) ; }
private void updateOperationParameterForSagaAndRecords ( OperationsMap operations ) { for ( CodegenOperation _op : operations . getOperations ( ) . getOperation ( ) ) { ExtendedCodegenOperation op = ( ExtendedCodegenOperation ) _op ; for ( CodegenParameter cpParam : op . allParams ) { ExtendedCodegenParameter param = ( ExtendedCodegenParameter ) cpParam ; if ( param . vendorExtensions . get ( X_IS_UNIQUE_ID ) instanceof Boolean ) { param . isUniqueId = Boolean . TRUE . equals ( param . vendorExtensions . get ( X_IS_UNIQUE_ID ) ) ; } else if ( this . getInferUniqueIdFromNameSuffix ( ) && ( param . isArray && "number" . equals ( param . items . dataType ) ) || ( "number" . equals ( param . dataType ) ) ) { param . isUniqueId = this . isUniqueIdAccordingToNameSuffix ( param . paramName ) ; } param . dataTypeAlternate = param . dataType ; if ( param . isArray ) { param . isUniqueId = param . isUniqueId || param . itemsAreUniqueId ( ) ; param . dataTypeAlternate = param . dataType . replace ( "Array<" , "List<" ) ; String newItemsDataType = param . getItemsDataType ( ) ; if ( param . items . isModel ) { newItemsDataType = param . items . dataType + "Record" ; param . dataTypeAlternate = param . dataTypeAlternate . replace ( param . items . dataType , newItemsDataType ) ; } else if ( param . items . isEnum ) { newItemsDataType = param . datatypeWithEnum . substring ( param . datatypeWithEnum . lastIndexOf ( "<" ) + 1 , param . datatypeWithEnum . indexOf ( ">" ) ) ; param . dataTypeAlternate = param . datatypeWithEnum . replace ( "Array<" , "List<" ) ; } else if ( param . isUniqueId ) { newItemsDataType = "string" ; param . dataTypeAlternate = param . dataTypeAlternate . replace ( "number" , newItemsDataType ) ; } } else if ( param . isEnum ) { param . dataTypeAlternate = param . datatypeWithEnum ; } else if ( param . isModel ) { param . dataTypeAlternate = param . dataType + "Record" ; } else if ( param . isUniqueId ) { param . dataTypeAlternate = "string" ; if ( param . isNullable ) { param . dataTypeAlternate = param . dataTypeAlternate + " | null" ; } } } } }
private static RuntimeException throwCauseOrElseException ( Exception e ) { if ( e . getCause ( ) != null ) throw Util . sneakyThrow ( e . getCause ( ) ) ; throw Util . sneakyThrow ( e ) ; }
public Epoch epoch ( ) { return header . epoch ; }
public static String dev ( FsInfo . Path path ) { return path . getMount ( ) == null ? "" : path . getMount ( ) ; }
public boolean isValid ( URI redirection ) { isRequestValid = isValidForCurrentMode ( redirection ) ; return isRequestValid ; }
public ParallelBlock addSingleton ( Function < NDArray , NDArray > f ) { return add ( LambdaBlock . singleton ( f ) ) ; }
public ExcelWriter addValidationData ( DataValidation dataValidation ) { this . sheet . addValidationData ( dataValidation ) ; return this ; }
< T2 > int visit ( LeafVisitor < T2 > visitor ) { int globalIndex = 0 , start = lastDigit ( offset ) ; for ( int index = 0 ; index < length ; ) { final T2 leaf = ( T2 ) getLeaf ( index ) ; final int end = getMin ( start , index , leaf ) ; globalIndex = visitor . visit ( globalIndex , leaf , start , end ) ; index += end - start ; start = 0 ; } return globalIndex ; }
void update ( int x , int y , Color colorAtXY ) { colorAtMouse = colorAtXY ; image = robot . createScreenCapture ( new Rectangle ( x - ( pixels / 2 ) , y - ( pixels / 2 ) , pixels , pixels ) ) ; HSLColor hslColor = new HSLColor ( colorAtMouse ) ; int hue = Math . round ( hslColor . getHue ( ) ) ; int saturation = Math . round ( hslColor . getSaturation ( ) ) ; int luminance = Math . round ( hslColor . getLuminance ( ) ) ; infoLabel . setText ( String . format ( "#%06x   HSL %d %d %d" , colorAtMouse . getRGB ( ) & 0xffffff , hue , saturation , luminance ) ) ; int mx = x + UIScale . scale ( 32 ) ; int my = y + UIScale . scale ( 32 ) ; if ( mx + getWidth ( ) > owner . getX ( ) + owner . getWidth ( ) ) mx = x - getWidth ( ) - UIScale . scale ( 32 ) ; if ( my + getHeight ( ) > owner . getY ( ) + owner . getHeight ( ) ) my = y - getHeight ( ) - UIScale . scale ( 32 ) ; setLocation ( mx , my ) ; setVisible ( true ) ; repaint ( ) ; }
public MapperRegistry getMapperRegistry ( ) { return mybatisMapperRegistry ; }
public static io . kubernetes . client . proto . V1Networking . HTTPIngressPath parseFrom ( byte [ ] data ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data ) ; }
public void simulateTimeChange ( long offsetToAddInMillis ) { List < Event > oldEvents = ImmutableList . copyOf ( Iterables . concat ( eventsByTimeStamp . values ( ) ) ) ; eventsByTimeStamp . clear ( ) ; for ( Event event : oldEvents ) { long newTimestamp = event . getTimeStamp ( ) + offsetToAddInMillis ; addEvent ( EventBuilder . fromEvent ( event ) . setTimeStamp ( newTimestamp ) . build ( ) ) ; } }
public int getBaseline ( ) { return getMeasuredHeight ( ) - 1 ; }
public BigDecimal getBigDecimal ( String col , int s ) throws SQLException { throw unsupported ( ) ; }
private void ensureItemsIsMutable ( ) { if ( ! ( ( bitField0_ & 0x00000002 ) == 0x00000002 ) ) { items_ = new java . util . ArrayList < io . kubernetes . client . proto . V1Networking . Ingress > ( items_ ) ; bitField0_ |= 0x00000002 ; } }
public CompletableFuture < Void > sendHeartbeatOneway ( String brokerAddr , HeartbeatData heartbeatData , long timeoutMillis ) { CompletableFuture < Void > future = new CompletableFuture < > ( ) ; try { RemotingCommand request = RemotingCommand . createRequestCommand ( RequestCode . HEART_BEAT , new HeartbeatRequestHeader ( ) ) ; request . setLanguage ( clientConfig . getLanguage ( ) ) ; request . setBody ( heartbeatData . encode ( ) ) ; this . getRemotingClient ( ) . invokeOneway ( brokerAddr , request , timeoutMillis ) ; future . complete ( null ) ; } catch ( Throwable t ) { future . completeExceptionally ( t ) ; } return future ; }
protected com . google . protobuf . GeneratedMessageV3 . FieldAccessorTable internalGetFieldAccessorTable ( ) { return io . kubernetes . client . proto . V1Networking . internal_static_k8s_io_api_networking_v1_ServiceCIDRStatus_fieldAccessorTable . ensureFieldAccessorsInitialized ( io . kubernetes . client . proto . V1Networking . ServiceCIDRStatus . class , io . kubernetes . client . proto . V1Networking . ServiceCIDRStatus . Builder . class ) ; }
public void updateWorkflow ( String workflowInstanceId , String [ ] keys , Object [ ] values ) { try { if ( keys . length != values . length ) { throw new NonTransientException ( "Number of keys and values do not match" ) ; } long startTime = Instant . now ( ) . toEpochMilli ( ) ; UpdateRequest request = new UpdateRequest ( workflowIndexName , workflowInstanceId ) ; Map < String , Object > source = IntStream . range ( 0 , keys . length ) . boxed ( ) . collect ( Collectors . toMap ( i -> keys [ i ] , i -> values [ i ] ) ) ; request . doc ( source ) ; logger . debug ( "Updating workflow {} with {}" , workflowInstanceId , source ) ; elasticSearchClient . update ( request , RequestOptions . DEFAULT ) ; long endTime = Instant . now ( ) . toEpochMilli ( ) ; logger . debug ( "Time taken {} for updating workflow: {}" , endTime - startTime , workflowInstanceId ) ; Monitors . recordESIndexTime ( "update_workflow" , WORKFLOW_DOC_TYPE , endTime - startTime ) ; Monitors . recordWorkerQueueSize ( "indexQueue" , ( ( ThreadPoolExecutor ) executorService ) . getQueue ( ) . size ( ) ) ; } catch ( Exception e ) { logger . error ( "Failed to update workflow {}" , workflowInstanceId , e ) ; Monitors . error ( className , "update" ) ; } }
public NodeContent listTrash ( String deepBoxNodeId , String boxNodeId , Integer offset , Integer limit , String order ) throws ApiException { Object localVarPostBody = null ; if ( deepBoxNodeId == null ) { throw new ApiException ( 400 , "Missing the required parameter 'deepBoxNodeId' when calling listTrash" ) ; } if ( boxNodeId == null ) { throw new ApiException ( 400 , "Missing the required parameter 'boxNodeId' when calling listTrash" ) ; } String localVarPath = "/api/v1/deepBoxes/{deepBoxNodeId}/boxes/{boxNodeId}/trash" . replaceAll ( "\\{" + "deepBoxNodeId" + "\\}" , apiClient . escapeString ( deepBoxNodeId . toString ( ) ) ) . replaceAll ( "\\{" + "boxNodeId" + "\\}" , apiClient . escapeString ( boxNodeId . toString ( ) ) ) ; List < Pair > localVarQueryParams = new ArrayList < Pair > ( ) ; Map < String , String > localVarHeaderParams = new HashMap < String , String > ( ) ; Map < String , Object > localVarFormParams = new HashMap < String , Object > ( ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "offset" , offset ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "limit" , limit ) ) ; localVarQueryParams . addAll ( apiClient . parameterToPairs ( "" , "order" , order ) ) ; final String [ ] localVarAccepts = { "*/*" } ; final String localVarAccept = apiClient . selectHeaderAccept ( localVarAccepts ) ; final String [ ] localVarContentTypes = { } ; final String localVarContentType = apiClient . selectHeaderContentType ( localVarContentTypes ) ; String [ ] localVarAuthNames = new String [ ] { "token" } ; GenericType < NodeContent > localVarReturnType = new GenericType < NodeContent > ( ) { } ; return apiClient . invokeAPI ( localVarPath , "GET" , localVarQueryParams , localVarPostBody , localVarHeaderParams , localVarFormParams , localVarAccept , localVarContentType , localVarAuthNames , localVarReturnType ) ; }
public ClassesShould should ( ) { return new ClassesShouldInternal ( classesTransformer , priority , prepareCondition ) ; }
public V get ( K key ) { return map . get ( key ) ; }
Map < String , Object > getMetadata ( ) ; Platform getPlatform ( String platformId ) ; @ JsonIgnore default Platform getRecommendedPlatform ( ) { final Collection < Platform > platforms = getPlatforms ( ) ; return platforms . isEmpty ( ) ? null : platforms . iterator ( ) . next ( ) ; }
public void init ( ) { initConfig ( ) ; }
public boolean isModified ( ) { if ( ! Objects . equals ( config . getAuthor ( ) , view . getAuthorTextField ( ) . getText ( ) ) ) { return true ; } if ( ! Objects . equals ( config . getDateFormat ( ) , view . getDateFormatTextField ( ) . getText ( ) ) ) { return true ; } if ( ! Objects . equals ( config . getDocPriority ( ) , view . getDocPriority ( ) ) ) { return true ; } if ( ! Objects . equals ( config . getSimpleFieldDoc ( ) , view . getSimpleDocButton ( ) . isSelected ( ) ) ) { return true ; } if ( ! Objects . equals ( config . getMethodReturnType ( ) , view . getMethodReturnType ( ) ) ) { return true ; } if ( ! Objects . equals ( config . getCoverMode ( ) , String . valueOf ( view . getCoverModeBox ( ) . getSelectedItem ( ) ) ) ) { return true ; } return false ; }
public static synchronized void selectLog4JLogging ( ) { try { Resources . classForName ( "org.apache.log4j.Logger" ) ; Class implClass = Resources . classForName ( "org.nlpcn.commons.lang.util.logging.Log4jImpl" ) ; logConstructor = implClass . getConstructor ( new Class [ ] { String . class } ) ; } catch ( Throwable t ) { } }
public ObjectMapper getMapper ( ) { return objectMapper ; }
private void addTestResultWithFeature ( final List < CsvExportBehavior > exportBehaviors , final TestResult result , final Map < LabelName , List < String > > epicFeatureStoryMap , final String epic ) { if ( isNotEmpty ( epicFeatureStoryMap . get ( FEATURE ) ) ) { epicFeatureStoryMap . get ( FEATURE ) . forEach ( feature -> addTestResultWithStories ( exportBehaviors , result , epicFeatureStoryMap , epic , feature ) ) ; } else { addTestResultWithStories ( exportBehaviors , result , epicFeatureStoryMap , epic , null ) ; } }
public static int getPositionIndex ( int x , int y , int z ) { return ( x << 1 ) | ( z << 5 ) | ( y << 9 ) ; }
public int getItemActiveIndicatorExpandedHeight ( ) { return menuView . getItemActiveIndicatorExpandedHeight ( ) ; }
private void updateForumTopicInfo ( TdApi . UpdateForumTopicInfo update ) { String cacheKey = update . info . chatId + "_" + update . info . forumTopicId ; synchronized ( dataLock ) { forumTopicInfos . put ( cacheKey , update . info ) ; } listeners . updateForumTopicInfo ( update ) ; }
public void start ( @ NonNull Context context , @ NonNull androidx . fragment . app . Fragment fragment , int requestCode ) { fragment . startActivityForResult ( getIntent ( context ) , requestCode ) ; }
private static NoInitialContextException createNamingException ( Exception e ) { final NoInitialContextException ex = new NoInitialContextException ( e . toString ( ) ) ; ex . initCause ( e ) ; return ex ; }
public List < JSONObject > getValidInvitecodes ( final String generatorId ) { final Query query = new Query ( ) . setFilter ( CompositeFilterOperator . and ( new PropertyFilter ( Invitecode . GENERATOR_ID , FilterOperator . EQUAL , generatorId ) , new PropertyFilter ( Invitecode . STATUS , FilterOperator . EQUAL , Invitecode . STATUS_C_UNUSED ) ) ) ; try { return invitecodeRepository . getList ( query ) ; } catch ( final Exception e ) { LOGGER . log ( Level . ERROR , "Gets valid invitecode failed" , e ) ; return Collections . emptyList ( ) ; } }
public void setTaxRate ( BigDecimal taxRate ) { this . taxRate = taxRate ; }
@ Override public void exitEveryRule ( ParserRuleContext ctx ) { }
public final Type getType ( ) { return Type . SMALL ; }
public boolean filterAllRemaining ( ) { return passedPrefix ; }
public void addAlias ( Symbol alias , Namespace ns ) { if ( alias == null || ns == null ) throw new NullPointerException ( "Expecting Symbol + Namespace" ) ; IPersistentMap map = getAliases ( ) ; while ( ! map . containsKey ( alias ) ) { IPersistentMap newMap = map . assoc ( alias , ns ) ; aliases . compareAndSet ( map , newMap ) ; map = getAliases ( ) ; } if ( ! map . valAt ( alias ) . equals ( ns ) ) throw new IllegalStateException ( "Alias " + alias + " already exists in namespace " + name + ", aliasing " + map . valAt ( alias ) ) ; }
public final QOM . AlterSequence < T > $restart ( boolean newValue ) { return $constructor ( ) . apply ( $sequence ( ) , $ifExists ( ) , $renameTo ( ) , newValue , $restartWith ( ) , $startWith ( ) , $incrementBy ( ) , $minvalue ( ) , $noMinvalue ( ) , $maxvalue ( ) , $noMaxvalue ( ) , $cycle ( ) , $cache ( ) , $noCache ( ) ) ; }
public boolean requiresDataSchema ( ) { return true ; }
private void initTimeline ( ) { int pLeft = getPaddingLeft ( ) ; int pRight = getPaddingRight ( ) ; int pTop = getPaddingTop ( ) ; int pBottom = getPaddingBottom ( ) ; int width = getWidth ( ) ; int height = getHeight ( ) ; int cWidth = width - pLeft - pRight ; int cHeight = height - pTop - pBottom ; int markSize = Math . min ( mMarkerSize , Math . min ( cWidth , cHeight ) ) ; if ( mMarkerInCenter ) { int left = ( width / 2 ) - ( markSize / 2 ) ; int top = ( height / 2 ) - ( markSize / 2 ) ; int right = ( width / 2 ) + ( markSize / 2 ) ; int bottom = ( height / 2 ) + ( markSize / 2 ) ; switch ( mLineOrientation ) { case LineOrientation . HORIZONTAL : { left += mMarkerPaddingLeft - mMarkerPaddingRight ; right += mMarkerPaddingLeft - mMarkerPaddingRight ; break ; } case LineOrientation . VERTICAL : { top += mMarkerPaddingTop - mMarkerPaddingBottom ; bottom += mMarkerPaddingTop - mMarkerPaddingBottom ; break ; } } if ( mMarker != null ) { mMarker . setBounds ( left , top , right , bottom ) ; mBounds = mMarker . getBounds ( ) ; } } else { int left = pLeft ; int top = pTop ; int right = pLeft + markSize ; int bottom = pTop ; switch ( mLineOrientation ) { case LineOrientation . HORIZONTAL : { top = ( height / 2 ) - ( markSize / 2 ) ; bottom = ( height / 2 ) + ( markSize / 2 ) ; left += mMarkerPaddingLeft - mMarkerPaddingRight ; right += mMarkerPaddingLeft - mMarkerPaddingRight ; break ; } case LineOrientation . VERTICAL : { top += mMarkerPaddingTop - mMarkerPaddingBottom ; bottom += markSize + mMarkerPaddingTop - mMarkerPaddingBottom ; break ; } } if ( mMarker != null ) { mMarker . setBounds ( left , top , right , bottom ) ; mBounds = mMarker . getBounds ( ) ; } } if ( mLineOrientation == LineOrientation . HORIZONTAL ) { if ( mDrawStartLine ) { mStartLineStartX = pLeft ; mStartLineStartY = mBounds . centerY ( ) ; mStartLineStopX = mBounds . left - mLinePadding ; mStartLineStopY = mBounds . centerY ( ) ; } if ( mDrawEndLine ) { if ( mEndLineStyle == LineStyle . DASHED ) { mEndLineStartX = getWidth ( ) - mLineStyleDashGap ; mEndLineStartY = mBounds . centerY ( ) ; mEndLineStopX = mBounds . right + mLinePadding ; mEndLineStopY = mBounds . centerY ( ) ; } else { mEndLineStartX = mBounds . right + mLinePadding ; mEndLineStartY = mBounds . centerY ( ) ; mEndLineStopX = getWidth ( ) ; mEndLineStopY = mBounds . centerY ( ) ; } } } else { if ( mDrawStartLine ) { mStartLineStartX = mBounds . centerX ( ) ; mStartLineStartY = pTop ; mStartLineStopX = mBounds . centerX ( ) ; mStartLineStopY = mBounds . top - mLinePadding ; } if ( mDrawEndLine ) { if ( mEndLineStyle == LineStyle . DASHED ) { mEndLineStartX = mBounds . centerX ( ) ; mEndLineStartY = getHeight ( ) - mLineStyleDashGap ; mEndLineStopX = mBounds . centerX ( ) ; mEndLineStopY = mBounds . bottom + mLinePadding ; } else { mEndLineStartX = mBounds . centerX ( ) ; mEndLineStartY = mBounds . bottom + mLinePadding ; mEndLineStopX = mBounds . centerX ( ) ; mEndLineStopY = getHeight ( ) ; } } } invalidate ( ) ; }
private final int find ( int prefixOrUri , boolean prefix ) { if ( m_dataLength == 0 ) { return - 1 ; } int offset = m_dataLength - 1 ; for ( int i = m_depth ; i != 0 ; -- i ) { int count = m_data [ offset ] ; offset -= 2 ; for ( ; count != 0 ; -- count ) { if ( prefix ) { if ( m_data [ offset ] == prefixOrUri ) { return m_data [ offset + 1 ] ; } } else { if ( m_data [ offset + 1 ] == prefixOrUri ) { return m_data [ offset ] ; } } offset -= 2 ; } } return - 1 ; }
public void updateObject ( String col , Object x ) throws SQLException { throw unsupported ( ) ; }
public int getEnchantmentValue ( ) { return enchantValue ; }
public void deleteMessages ( long chatId , long [ ] messageIds , boolean revoke ) { client ( ) . send ( new TdApi . DeleteMessages ( chatId , messageIds , revoke ) , okHandler ( ) ) ; }
private void stop ( boolean temporary ) { if ( vpn != null ) { stopNative ( vpn ) ; stopVPN ( vpn ) ; vpn = null ; unprepare ( ) ; } if ( state == State . enforcing && ! temporary ) { Log . d ( TAG , "Stop foreground state=" + state . toString ( ) ) ; last_allowed = - 1 ; last_blocked = - 1 ; last_hosts = - 1 ; stopForeground ( true ) ; SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( ServiceSinkhole . this ) ; if ( prefs . getBoolean ( "show_stats" , false ) ) { startForeground ( NOTIFY_WAITING , getWaitingNotification ( ) ) ; state = State . waiting ; Log . d ( TAG , "Start foreground state=" + state . toString ( ) ) ; } else { state = State . none ; stopSelf ( ) ; } } }
public CompletableFuture < Http2ServiceResponse > call ( ) { processClientRequest ( ) ; return http2Client . callService ( hostURI , clientRequest , requestBody ) . thenApplyAsync ( response -> new Http2ServiceResponse ( response ) ) ; }
public void mouseEntered ( java . awt . event . MouseEvent e ) { }
public void benchmarkCglib ( Blackhole blackHole ) { blackHole . consume ( cglibInstance . method ( booleanValue ) ) ; blackHole . consume ( cglibInstance . method ( byteValue ) ) ; blackHole . consume ( cglibInstance . method ( shortValue ) ) ; blackHole . consume ( cglibInstance . method ( intValue ) ) ; blackHole . consume ( cglibInstance . method ( charValue ) ) ; blackHole . consume ( cglibInstance . method ( intValue ) ) ; blackHole . consume ( cglibInstance . method ( longValue ) ) ; blackHole . consume ( cglibInstance . method ( floatValue ) ) ; blackHole . consume ( cglibInstance . method ( doubleValue ) ) ; blackHole . consume ( cglibInstance . method ( stringValue ) ) ; blackHole . consume ( cglibInstance . method ( booleanValue , booleanValue , booleanValue ) ) ; blackHole . consume ( cglibInstance . method ( byteValue , byteValue , byteValue ) ) ; blackHole . consume ( cglibInstance . method ( shortValue , shortValue , shortValue ) ) ; blackHole . consume ( cglibInstance . method ( intValue , intValue , intValue ) ) ; blackHole . consume ( cglibInstance . method ( charValue , charValue , charValue ) ) ; blackHole . consume ( cglibInstance . method ( intValue , intValue , intValue ) ) ; blackHole . consume ( cglibInstance . method ( longValue , longValue , longValue ) ) ; blackHole . consume ( cglibInstance . method ( floatValue , floatValue , floatValue ) ) ; blackHole . consume ( cglibInstance . method ( doubleValue , doubleValue , doubleValue ) ) ; blackHole . consume ( cglibInstance . method ( stringValue , stringValue , stringValue ) ) ; }
private CharSequence generateMessageLengthCallPre17Helper ( final List < Token > tokens ) { final StringBuilder sb = new StringBuilder ( ) ; final Integer count = ( Integer ) generateMessageLengthArgs ( tokens , BASE_INDENT , false ) [ 1 ] ; for ( int i = 0 ; i < count ; i ++ ) { if ( i > 0 ) { sb . append ( ", " ) ; } sb . append ( "std::get<" ) . append ( i ) . append ( ">(e)" ) ; } return sb ; }
public long getRoute53DomainTTL ( ) { return route53DomainTTL ; }
public Result removeConfigCache ( @ RequestBody Map < String , String > bodyMap ) { String groupKey = bodyMap . get ( Constants . GROUP_KEY ) ; if ( StringUtil . isNotBlank ( groupKey ) ) { ConfigCacheService . removeConfigCache ( groupKey ) ; } return Results . success ( ) ; }
public static String [ ] getIps ( String ips ) { String [ ] ip2 = ips . split ( "/" ) ; String ip0 = ip2 [ 0 ] ; String ip1 = ip0 . substring ( 0 , ip0 . lastIndexOf ( "." ) + 1 ) + ip2 [ 1 ] ; return new String [ ] { ip0 , ip1 } ; }
public static Object deserialize ( S3LogStruct c , String row ) throws Exception { Matcher match = regexpat . matcher ( row ) ; int t = 1 ; try { match . matches ( ) ; c . bucketowner = match . group ( t ++ ) ; c . bucketname = match . group ( t ++ ) ; } catch ( Exception e ) { throw new SerDeException ( "S3 Log Regex did not match:" + row , e ) ; } c . rdatetime = match . group ( t ++ ) ; c . rip = match . group ( t ++ ) ; c . requester = match . group ( t ++ ) ; c . requestid = match . group ( t ++ ) ; c . operation = match . group ( t ++ ) ; c . rkey = match . group ( t ++ ) ; c . requesturi = match . group ( t ++ ) ; c . httpstatus = toInt ( match . group ( t ++ ) ) ; c . errorcode = match . group ( t ++ ) ; c . bytessent = toInt ( match . group ( t ++ ) ) ; c . objsize = toInt ( match . group ( t ++ ) ) ; c . totaltime = toInt ( match . group ( t ++ ) ) ; c . turnaroundtime = toInt ( match . group ( t ++ ) ) ; c . referer = match . group ( t ++ ) ; c . useragent = match . group ( t ++ ) ; return ( c ) ; }
public void run ( ) { cleanupExpirableFutureMap ( ) ; }
private void updateChatPhoto ( TdApi . UpdateChatPhoto update ) { synchronized ( dataLock ) { final TdApi . Chat chat = chats . get ( update . chatId ) ; if ( TdlibUtils . assertChat ( update . chatId , chat , update ) ) { return ; } chat . photo = update . photo ; } listeners . updateChatPhoto ( update ) ; }
public static int getResourceId ( @ NonNull String clas , @ NonNull String resName ) { int id = Resources . getSystem ( ) . getIdentifier ( resName , clas , "android" ) ; if ( id == 0 ) throw new Resources . NotFoundException ( "Cannot find '" + clas + "' for '" + resName + "', or this resource currently is not available for API " + Build . VERSION . SDK_INT ) ; return id ; }
protected static long nativeThemeCreate ( long ptr ) { CppAssetManager2 assetmanager = AssetManagerFromLong ( ptr ) ; return Registries . NATIVE_THEME9_REGISTRY . register ( assetmanager . NewTheme ( ) ) ; }
static List < Integer > fromIntArray ( int [ ] array ) { List < Integer > result = new ArrayList < > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) result . add ( array [ i ] ) ; return result ; }
public java . util . List < io . kubernetes . client . proto . V1Networking . NetworkPolicyIngressRule . Builder > getIngressBuilderList ( ) { return getIngressFieldBuilder ( ) . getBuilderList ( ) ; }
protected int letterUnderCursor ( float x ) { if ( linesBreak . size > 0 ) { if ( cursorLine * 2 >= linesBreak . size ) { return text . length ( ) ; } else { float [ ] glyphPositions = this . glyphPositions . items ; int start = linesBreak . items [ cursorLine * 2 ] ; x += glyphPositions [ start ] ; int end = linesBreak . items [ cursorLine * 2 + 1 ] ; int i = start ; for ( ; i < end ; i ++ ) if ( glyphPositions [ i ] > x ) break ; if ( i > 0 && glyphPositions [ i ] - x <= x - glyphPositions [ i - 1 ] ) return i ; return Math . max ( 0 , i - 1 ) ; } } else { return 0 ; } }
public static PlannerTableEnvironmentImpl create ( StreamExecutionEnvironment executionEnvironment , ClassLoader classLoader ) { return createWithPlanner ( executionEnvironment , EnvironmentSettings . newInstance ( ) . withClassLoader ( classLoader ) . build ( ) ) ; }
public String getMessage ( @ Nonnull String code , Object [ ] args , @ Nonnull Locale locale ) throws NoSuchMessageException { for ( MessageSource messageSource : messageSources ) { try { String result = messageSource . getMessage ( code , args , locale ) ; if ( StringUtils . hasText ( result ) ) { return result ; } } catch ( NoSuchMessageException ignore ) { } } throw new NoSuchMessageException ( code , locale ) ; }
public SearchableSingleChoiceDialogBuilder < T > setCancelable ( boolean cancelable ) { mBuilder . setCancelable ( cancelable ) ; return this ; }
private void translateKnownPerWorkerCounters ( List < PerStepNamespaceMetrics > metrics ) { for ( PerStepNamespaceMetrics perStepnamespaceMetrics : metrics ) { if ( ! BigQuerySinkMetrics . METRICS_NAMESPACE . equals ( perStepnamespaceMetrics . getMetricsNamespace ( ) ) && ! KAFKA_SINK_METRICS_NAMESPACE . equals ( perStepnamespaceMetrics . getMetricsNamespace ( ) ) ) { continue ; } for ( MetricValue metric : perStepnamespaceMetrics . getMetricValues ( ) ) { if ( BigQuerySinkMetrics . THROTTLED_TIME . equals ( metric . getMetric ( ) ) ) { Long msecs = metric . getValueInt64 ( ) ; if ( msecs != null && msecs > 0 ) { throttledMsecs ( ) . addValue ( msecs ) ; } } } } }
public void handleNoMoreSplits ( ) { log . info ( "Reader received NoMoreSplits event." ) ; noMoreSplitsAssignment = true ; }
public boolean isDisallowXRP ( ) { return disallowXRP ; }
protected MappingsBuilder getInstance ( @ Qualifier ( "legacyMappingsBuilder" ) @ Nullable MappingsBuilder legacyMappingsBuilder , @ Qualifier ( "multiEntityMappingsBuilder" ) @ Nullable MappingsBuilder multiEntityMappingsBuilder , @ Qualifier ( "semanticSearchMappingsBuilder" ) @ Nullable MappingsBuilder semanticSearchMappingsBuilder ) { List < MappingsBuilder > builders = new ArrayList < > ( ) ; if ( legacyMappingsBuilder != null ) { builders . add ( legacyMappingsBuilder ) ; } if ( multiEntityMappingsBuilder != null ) { builders . add ( multiEntityMappingsBuilder ) ; } if ( semanticSearchMappingsBuilder != null ) { builders . add ( semanticSearchMappingsBuilder ) ; } if ( builders . isEmpty ( ) ) { log . warn ( "Neither v2 nor v3 entity index is enabled. Using NoOpMappingsBuilder." ) ; builders . add ( new NoOpMappingsBuilder ( ) ) ; } return new DelegatingMappingsBuilder ( builders ) ; }
public int docValueCount ( ) { set ( ) ; return count ; }
public Boolean getSagasAndRecords ( ) { return sagasAndRecords ; }
public char [ ] getTextCharacters ( int [ ] holderForStartAndLength ) { String text = getText ( ) ; if ( text == null ) { return null ; } holderForStartAndLength [ 0 ] = 0 ; holderForStartAndLength [ 1 ] = text . length ( ) ; char [ ] chars = new char [ text . length ( ) ] ; text . getChars ( 0 , text . length ( ) , chars , 0 ) ; return chars ; }
public void purgeFromCompiledSqlCache ( String sql ) { synchronized ( mCompiledQueries ) { mCompiledQueries . remove ( sql ) ; } }
public FileSystem symlinkBlocking ( String link , String existing ) { symlinkInternal ( link , existing ) . perform ( ) ; return this ; }
public boolean equals ( final EditItem other ) { return other != null && start == other . start && before . equals ( other . before ) && after . equals ( other . after ) ; }
public List < Object > getWithAsExprPreparedValueList ( ) { return this . withAsExprPreparedValueList ; }
public int getSocketTimeout ( ) { return socketTimeout ; }
public static Object invokeInstanceMethodOfClass ( Object target , String className , String methodName , Object [ ] args ) { return invokeInstanceMethodOfClass ( target , RT . classForName ( className ) , methodName , args ) ; }
public RightProjection < L , R > orElse ( @ NonNull RightProjection < ? extends L , ? extends R > other ) { Objects . requireNonNull ( other , "other is null" ) ; return either . isRight ( ) ? this : ( RightProjection < L , R > ) other ; }
public int workingNodesCount ( ) { return workingNodes ( ) . size ( ) ; }
public static void activityResumed ( ) { activityVisible = true ; }
public List < String > getAxisLabels ( ) { return axisLabels ; }
public static RequestBuilder get ( String url ) { return request ( GET , url ) ; }
public Intent toShortcutIntent ( @ NonNull Context context ) { return requireProxy ( ) ? getProxyIntent ( context ) : getIntent ( ) ; }
public String [ ] getRemoteRegionUrls ( ) { return remoteRegionUrls ; }
static void hideKeyboard ( final View view ) { view . post ( new RunnableEx ( "hideKeyboard" ) { @ Override protected void delegate ( ) { Log . i ( "hideKeyboard view=" + view ) ; new SoftwareKeyboardControllerCompat ( view ) . hide ( ) ; } } ) ; }
public Capabilities getStereotype ( ) { return stereotype ; }
static boolean isMeizu ( ) { return "Meizu" . equalsIgnoreCase ( Build . MANUFACTURER ) ; }
public synchronized boolean keep ( Object ownerGiven ) { if ( ownerGiven == null ) { ownerGiven = this ; } else if ( isNotLocal ( ownerGiven ) ) { return false ; } if ( inUse && owner == ownerGiven ) { keep = true ; log ( lvl + 1 , "%s: use keep: %s" , devName , ownerGiven ) ; return true ; } return false ; }
public void visit ( CodeException obj ) { try { super . visit ( obj ) ; int type = obj . getCatchType ( ) ; if ( type == 0 ) { return ; } String name = getConstantPool ( ) . constantToString ( getConstantPool ( ) . getConstant ( type ) ) ; ExceptionCaught caughtException = new ExceptionCaught ( name , obj . getStartPC ( ) , obj . getEndPC ( ) , obj . getHandlerPC ( ) ) ; catchList . add ( caughtException ) ; LiveLocalStoreDataflow dataflow = getClassContext ( ) . getLiveLocalStoreDataflow ( getMethod ( ) ) ; CFG cfg = getClassContext ( ) . getCFG ( getMethod ( ) ) ; Collection < BasicBlock > blockList = cfg . getBlocksContainingInstructionWithOffset ( obj . getHandlerPC ( ) ) ; for ( BasicBlock block : blockList ) { InstructionHandle first = block . getFirstInstruction ( ) ; if ( first != null && first . getPosition ( ) == obj . getHandlerPC ( ) && first . getInstruction ( ) instanceof ASTORE ) { ASTORE astore = ( ASTORE ) first . getInstruction ( ) ; BitSet liveStoreSet = dataflow . getFactAtLocation ( new Location ( first , block ) ) ; if ( ! liveStoreSet . get ( astore . getIndex ( ) ) ) { if ( DEBUG ) { System . out . println ( "Dead exception store at " + first ) ; } caughtException . dead = true ; break ; } } } } catch ( MethodUnprofitableException e ) { Method m = getMethod ( ) ; bugReporter . reportSkippedAnalysis ( DescriptorFactory . instance ( ) . getMethodDescriptor ( getClassName ( ) , getMethodName ( ) , getMethodSig ( ) , m . isStatic ( ) ) ) ; } catch ( DataflowAnalysisException | CFGBuilderException e ) { bugReporter . logError ( "Error checking for dead exception store" , e ) ; } }
public Schema < KeyValue < byte [ ] , byte [ ] > > newKeyValueBytesSchema ( ) { return KeyValueSchemaImpl . kvBytes ( ) ; }
public int nextToken ( ) throws XmlPullParserException , IOException { return next ( ) ; }
public boolean isPermissionError ( ) { return _isPermissionError ; }
public double getVideoFractionLost ( ) { return videoFractionLost ; }
public boolean isRequireAuthorization ( ) { return requireAuthorization ; }
public int hashCode ( ) { return Objects . hash ( aSGCacheExpiryTimeoutMs , aSGQueryTimeoutMs , aSGUpdateIntervalMs , aWSAccessId , aWSSecretKey , batchReplication , bindingStrategy , deltaRetentionTimerIntervalInMs , disableDelta , disableDeltaForRemoteRegions , disableTransparentFallbackToOtherRegion , eIPBindRebindRetries , eIPBindingRetryIntervalMs , eIPBindingRetryIntervalMsWhenUnbound , enableReplicatedRequestCompression , enableSelfPreservation , evictionIntervalTimerInMs , gZipContentFromRemoteRegion , jsonCodecName , listAutoScalingGroupsRoleName , logIdentityHeaders , maxElementsInPeerReplicationPool , maxElementsInStatusReplicationPool , maxIdleThreadAgeInMinutesForPeerReplication , maxIdleThreadInMinutesAgeForStatusReplication , maxThreadsForPeerReplication , maxThreadsForStatusReplication , maxTimeForReplication , minAvailableInstancesForPeerReplication , minThreadsForPeerReplication , minThreadsForStatusReplication , numberOfReplicationRetries , peerEurekaNodesUpdateIntervalMs , peerEurekaStatusRefreshTimeIntervalMs , peerNodeConnectTimeoutMs , peerNodeConnectionIdleTimeoutSeconds , peerNodeReadTimeoutMs , peerNodeTotalConnections , peerNodeTotalConnectionsPerHost , primeAwsReplicaConnections , propertyResolver , rateLimiterBurstSize , rateLimiterEnabled , rateLimiterFullFetchAverageRate , rateLimiterPrivilegedClients , rateLimiterRegistryFetchAverageRate , rateLimiterThrottleStandardClients , registrySyncRetries , registrySyncRetryWaitMs , remoteRegionAppWhitelist , remoteRegionConnectTimeoutMs , remoteRegionConnectionIdleTimeoutSeconds , remoteRegionFetchThreadPoolSize , remoteRegionReadTimeoutMs , remoteRegionRegistryFetchInterval , remoteRegionTotalConnections , remoteRegionTotalConnectionsPerHost , remoteRegionTrustStore , remoteRegionTrustStorePassword , Arrays . hashCode ( remoteRegionUrls ) , remoteRegionUrlsWithName , renewalPercentThreshold , renewalThresholdUpdateIntervalMs , responseCacheAutoExpirationInSeconds , responseCacheUpdateIntervalMs , retentionTimeInMSInDeltaQueue , route53BindRebindRetries , route53BindingRetryIntervalMs , route53DomainTTL , syncWhenTimestampDiffers , useReadOnlyResponseCache , waitTimeInMsWhenSyncEmpty , xmlCodecName , initialCapacityOfResponseCache , expectedClientRenewalIntervalSeconds , useAwsAsgApi , myUrl ) ; }
public void onCacheHit ( CacheKey cacheKey ) { imageCacheStatsTracker . onMemoryCacheHit ( cacheKey ) ; }
public String getConnectionName ( ) { return connectionName ; }
public static com . google . protobuf . Parser < Ingress > parser ( ) { return PARSER ; }
public Q restrict ( QueryModifiers modifiers ) { return queryMixin . restrict ( modifiers ) ; }
public DefaultCopyFeature withTarget ( final Session < ? > session ) { to = session ; return this ; }
private static void writeJsonResponse ( String msg , HttpResponse response ) { Gson gson = new GsonBuilder ( ) . disableHtmlEscaping ( ) . create ( ) ; try ( OutputStream output = response . getOutputStream ( ) ; JsonWriter writer = gson . newJsonWriter ( new OutputStreamWriter ( output , UTF_8 ) ) ) { response . setContentType ( JSON ) ; writer . beginObject ( ) . name ( "result" ) . value ( msg ) ; writer . endObject ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error while writing message" , e ) ; } }
public static StrategyConfig strategyConfig ( ) { return new StrategyConfig . Builder ( ) . build ( ) ; }
public String validStr ( String input ) { return input ; }
public void incrementThrottleTime ( long throttleTimeMs ) { this . throttleTimeMs = throttleTimeMs + this . throttleTimeMs ; }
protected void setupButtons ( ) { super . setupButtons ( ) ; AndroidUiHelper . updateVisibility ( view . findViewById ( R . id . buttons_divider ) , true ) ; DialogButton cancelButton = view . findViewById ( R . id . dismiss_button ) ; cancelButton . setOnClickListener ( v -> showExitDialog ( ) ) ; cancelButton . setButtonType ( DialogButtonType . SECONDARY ) ; cancelButton . setTitleId ( R . string . shared_string_cancel ) ; }
private void updateVideoPublished ( TdApi . UpdateVideoPublished update ) { }
public Builder mergeFrom ( io . kubernetes . client . proto . V1Networking . HTTPIngressPath other ) { if ( other == io . kubernetes . client . proto . V1Networking . HTTPIngressPath . getDefaultInstance ( ) ) return this ; if ( other . hasPath ( ) ) { bitField0_ |= 0x00000001 ; path_ = other . path_ ; onChanged ( ) ; } if ( other . hasPathType ( ) ) { bitField0_ |= 0x00000002 ; pathType_ = other . pathType_ ; onChanged ( ) ; } if ( other . hasBackend ( ) ) { mergeBackend ( other . getBackend ( ) ) ; } this . mergeUnknownFields ( other . unknownFields ) ; onChanged ( ) ; return this ; }
public boolean tryMarkUsingAndClearIdleTime ( ) { while ( true ) { if ( isReleased ( ) ) { return false ; } if ( compareAndSetIdleStat ( State . IDLE , State . USING ) ) { idleMarkTime = 0 ; return true ; } if ( compareAndSetIdleStat ( State . RELEASING , State . USING ) ) { idleMarkTime = 0 ; return true ; } if ( isUsing ( ) ) { return true ; } } }
public ChannelAction < Category > createCopy ( ) { return createCopy ( getGuild ( ) ) ; }
public void setSpecifications ( String [ ] specifications ) { this . specifications = specifications ; }
public void pushInt ( int value ) { mArray . add ( value ) ; }
public final int bmpGet ( int c ) { assert 0 <= c && c <= 0xffff ; return dataArray [ fastIndex ( c ) ] & 0xff ; }
protected String getUsernameLabel ( ) { return wizard . getUsernameLabel ( ) ; }
public Builder mergeFrom ( io . kubernetes . client . proto . V1Networking . NetworkPolicyPeer other ) { if ( other == io . kubernetes . client . proto . V1Networking . NetworkPolicyPeer . getDefaultInstance ( ) ) return this ; if ( other . hasPodSelector ( ) ) { mergePodSelector ( other . getPodSelector ( ) ) ; } if ( other . hasNamespaceSelector ( ) ) { mergeNamespaceSelector ( other . getNamespaceSelector ( ) ) ; } if ( other . hasIpBlock ( ) ) { mergeIpBlock ( other . getIpBlock ( ) ) ; } this . mergeUnknownFields ( other . unknownFields ) ; onChanged ( ) ; return this ; }
public io . kubernetes . client . proto . V1Networking . HTTPIngressRuleValue build ( ) { io . kubernetes . client . proto . V1Networking . HTTPIngressRuleValue result = buildPartial ( ) ; if ( ! result . isInitialized ( ) ) { throw newUninitializedMessageException ( result ) ; } return result ; }
public int forwardMaxCount ( ) { return options . forwardedMessageCountMax ; }
public Criteria andCurrentNumberLessThanOrEqualTo ( BigDecimal value ) { addCriterion ( "current_number <=" , value , "currentNumber" ) ; return ( Criteria ) this ; }
static boolean canAuthenticate ( Context context ) { try { BiometricManager bm = BiometricManager . from ( context ) ; if ( bm . canAuthenticate ( BiometricManager . Authenticators . BIOMETRIC_WEAK ) == BiometricManager . BIOMETRIC_SUCCESS ) return true ; if ( bm . canAuthenticate ( BiometricManager . Authenticators . DEVICE_CREDENTIAL ) == BiometricManager . BIOMETRIC_SUCCESS ) return true ; return false ; } catch ( Throwable ex ) { Log . e ( ex ) ; return false ; } }
public void addSection ( FeatureSection section ) { section . setIndex ( sections . size ( ) ) ; sections . add ( section ) ; }
void notifyIngestPipelinesShutDown ( ) { IngestManager ingestManager = IngestManager . getInstance ( ) ; if ( ! ingestModuleExecutor . isCancelled ( ) ) { ingestManager . fireDataSourceAnalysisCompleted ( id , dataSource ) ; } else { IngestManager . getInstance ( ) . fireDataSourceAnalysisCancelled ( id , dataSource ) ; } ingestManager . finishIngestJob ( this ) ; }
protected void setDispatchHandler ( DispatchHandler dispatchHandler ) { this . dispatchHandler = dispatchHandler ; }
public void set ( int bitIndex , boolean state ) { _failMutableOperation ( ) ; }
public ItemType itemType ( ) { return ItemType . TYPE_FIELD_ID_ITEM ; }
public void setBookId ( Long bookId ) { this . bookId = bookId ; }
long getHashcode ( Double value ) { return hashLong ( Double . doubleToLongBits ( normalizeDouble ( value ) ) , DEFAULT_SEED ) ; }
public void setTitle ( String title ) { this . feedTitle = title ; }
public static String getClassCheckpointFilename ( final Class < ? > c , final String suffix ) { return c . getName ( ) + ( ( suffix == null ) ? "" : "." + suffix ) + SERIALIZED_CLASS_SUFFIX ; }
private MenuInflater getMenuInflater ( ) { if ( menuInflater == null ) { menuInflater = new SupportMenuInflater ( getContext ( ) ) ; } return menuInflater ; }
private static String digest ( String message ) throws NoSuchAlgorithmException { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; md . update ( message . getBytes ( ) ) ; byte byteData [ ] = md . digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < byteData . length ; i ++ ) { sb . append ( Integer . toString ( ( byteData [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } return sb . toString ( ) ; }
private void restoreFindDialogState ( Map < String , Object > state ) { if ( state . containsKey ( FIND_TEXT ) ) { findField . setText ( ( String ) state . get ( FIND_TEXT ) ) ; } if ( state . containsKey ( REPLACE_TEXT ) ) { replaceField . setText ( ( String ) state . get ( REPLACE_TEXT ) ) ; } if ( state . containsKey ( IGNORE_CASE ) ) { ignoreCaseBox . setSelected ( ( Boolean ) state . get ( IGNORE_CASE ) ) ; } if ( state . containsKey ( SEARCH_ALL_FILES ) ) { searchAllFilesBox . setSelected ( ( Boolean ) state . get ( SEARCH_ALL_FILES ) ) ; } if ( state . containsKey ( WRAP_AROUND ) ) { wrapAroundBox . setSelected ( ( Boolean ) state . get ( WRAP_AROUND ) ) ; } }
private static String capture ( String pattern ) { return "(" + pattern + ")" ; }
public boolean equals ( Object obj ) { return delegate . equals ( obj ) ; }
public Long saveOfflineMsg ( OfflineMsg msg , Integer messageTtlDays ) { List < String > keys = Arrays . asList ( MSG_KEY , USER_IDX ) ; List < Object > allArgs = new ArrayList < > ( ) ; allArgs . add ( msg . getMessageId ( ) ) ; allArgs . add ( msg . getReceiveUserId ( ) ) ; allArgs . add ( serialize ( msg ) ) ; allArgs . add ( Duration . ofDays ( messageTtlDays ) . getSeconds ( ) ) ; return redisTemplate . execute ( SAVE_OFFLINE_MSG_SCRIPT , keys , allArgs . toArray ( ) ) ; }
public String getNString ( int columnIndex ) throws SQLException { throw new SQLFeatureNotSupportedException ( ) ; }
private void onPresentFragment ( BaseFragment fragment ) { AndroidUtilities . hideKeyboard ( fragmentView ) ; if ( fragment instanceof PaymentFormActivity ) { ( ( PaymentFormActivity ) fragment ) . paymentFormCallback = paymentFormCallback ; ( ( PaymentFormActivity ) fragment ) . resourcesProvider = resourcesProvider ; ( ( PaymentFormActivity ) fragment ) . needPayAfterTransition = needPayAfterTransition ; ( ( PaymentFormActivity ) fragment ) . savedCredentialsCard = savedCredentialsCard ; } }
LocalAiStreamingChatModel localAiStreamingChatModel ( Properties properties ) { ChatModelProperties chatModelProperties = properties . getStreamingChatModel ( ) ; return LocalAiStreamingChatModel . builder ( ) . temperature ( chatModelProperties . getTemperature ( ) ) . topP ( chatModelProperties . getTopP ( ) ) . baseUrl ( chatModelProperties . getBaseUrl ( ) ) . modelName ( chatModelProperties . getModelName ( ) ) . logRequests ( chatModelProperties . getLogRequests ( ) ) . logResponses ( chatModelProperties . getLogResponses ( ) ) . build ( ) ; }
public static double distanceToLine ( double pointLat , double pointLon , double lat1 , double lon1 , double lat2 , double lon2 ) { double d0 = distance ( pointLat , pointLon , lat1 , lon1 ) ; double d1 = distance ( lat1 , lon1 , lat2 , lon2 ) ; double d2 = distance ( lat2 , lon2 , pointLat , pointLon ) ; if ( Math . pow ( d0 , 2 ) > Math . pow ( d1 , 2 ) + Math . pow ( d2 , 2 ) ) { return d2 ; } if ( Math . pow ( d2 , 2 ) > Math . pow ( d1 , 2 ) + Math . pow ( d0 , 2 ) ) { return d0 ; } double halfP = ( d0 + d1 + d2 ) * 0.5 ; double area = Math . sqrt ( halfP * ( halfP - d0 ) * ( halfP - d1 ) * ( halfP - d2 ) ) ; return 2 * area / d1 ; }
public static void glBufferStorage ( @ NativeType ( "GLenum" ) int target , @ NativeType ( "void const *" ) int [ ] data , @ NativeType ( "GLbitfield" ) int flags ) { long __functionAddress = GL . getICD ( ) . glBufferStorage ; if ( CHECKS ) { check ( __functionAddress ) ; } callPPV ( target , Integer . toUnsignedLong ( data . length ) << 2 , data , flags , __functionAddress ) ; }
public boolean isDirectory ( ) { return this == DIRECTORY ; }
private void showDisabledNotification ( ) { Intent main = new Intent ( this , ActivityMain . class ) ; PendingIntent pi = PendingIntentCompat . getActivity ( this , 0 , main , PendingIntent . FLAG_UPDATE_CURRENT ) ; TypedValue tv = new TypedValue ( ) ; getTheme ( ) . resolveAttribute ( R . attr . colorOff , tv , true ) ; NotificationCompat . Builder builder = new NotificationCompat . Builder ( this , "notify" ) ; builder . setSmallIcon ( R . drawable . ic_error_white_24dp ) . setContentTitle ( getString ( R . string . app_name ) ) . setContentText ( getString ( R . string . msg_revoked ) ) . setContentIntent ( pi ) . setColor ( tv . data ) . setOngoing ( false ) . setAutoCancel ( true ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . LOLLIPOP ) builder . setCategory ( NotificationCompat . CATEGORY_STATUS ) . setVisibility ( NotificationCompat . VISIBILITY_SECRET ) ; NotificationCompat . BigTextStyle notification = new NotificationCompat . BigTextStyle ( builder ) ; notification . bigText ( getString ( R . string . msg_revoked ) ) ; if ( Util . canNotify ( this ) ) NotificationManagerCompat . from ( this ) . notify ( NOTIFY_DISABLED , notification . build ( ) ) ; }
public String getShareID ( ) { return this . shareID ; }
public AutoCloseable get ( ) { AutoCloseable statelessSession ; boolean isInTx ; isInTx = TransactionUtil . isInTx ( transactionManager ) ; if ( isInTx ) { statelessSession = getOrCreateTransactionScopedStatelessSession ( ) ; } else { statelessSession = NonTxEmCloser . get ( AutoCloseable . class , puScopedName ) ; if ( statelessSession == null ) { statelessSession = sessionFactory . apply ( emf ) ; NonTxEmCloser . add ( puScopedName , statelessSession ) ; } } return statelessSession ; }
public Builder addField ( String title , Justification justification ) { return addField ( title , justification , false ) ; }
public static int getOffset ( int page , int count ) { return page * count ; }
private void onJobAdded ( boolean isAboutToExecute ) { incrementReferenceCount ( isAboutToExecute ? REFERENCE_TYPE_TASK_EXECUTION : REFERENCE_TYPE_TASK ) ; }
public static double getPointsDistance ( Point p1 , Point p2 ) { return getPointsDistance ( p1 . x , p1 . y , p2 . x , p2 . y ) ; }
private static long getPartOfWord ( long word , int firstNodeIdToInclude ) { return word & ( 0xFFFFFFFFFFFFFFFFL << firstNodeIdToInclude ) ; }
public String toModelDocFilename ( String name ) { return toModelName ( name ) ; }
public View getInfoContents ( @ NonNull Marker marker ) { Collection collection = mAllObjects . get ( marker ) ; if ( collection != null && collection . mInfoWindowAdapter != null ) { return collection . mInfoWindowAdapter . getInfoContents ( marker ) ; } return null ; }
public void queue ( Packet packet ) { Message msg = obtainMessage ( ) ; msg . obj = packet ; msg . what = MSG_PACKET ; msg . arg1 = ( last_connected ? ( last_metered ? 2 : 1 ) : 0 ) ; msg . arg2 = ( last_interactive ? 1 : 0 ) ; synchronized ( this ) { if ( queue > MAX_QUEUE ) { Log . w ( TAG , "Log queue full" ) ; return ; } sendMessage ( msg ) ; queue ++ ; } }
public Q distinct ( Path < ? > property ) { return filter ( new DuplicateFilter ( serializer . toField ( property ) ) ) ; }
public boolean limitSQLCount ( ) { return AbstractVerifier . SYSTEM_ACCESS_MAP . containsKey ( getTable ( ) ) == false ; }
public boolean isValid ( ) { return image . isValid ( ) || imagePattern ; }
private void displayLine ( String line ) { if ( console != null ) { String ansiClearLine = "[2K" ; String ansiMoveCursorToColumnZero = "[G" ; System . out . print ( ansiClearLine + ansiMoveCursorToColumnZero + line ) ; System . out . flush ( ) ; } }
public short getShort ( Object obj ) throws IllegalArgumentException { throw newGetShortIllegalArgumentException ( ) ; }
public CharSequence replaceEmoji ( CharSequence cs ) { return replaceEmoji ( cs , 0 , cs != null ? cs . length ( ) : 0 , null , null ) ; }
public void onClick ( View v ) { showLoading ( ) ; onRefresh ( ) ; }
public String name ( ) { return name ; }
private void writeTokenDisplay ( final StringBuilder sb , final String fieldTokenName , final Token typeToken , final boolean [ ] atLeastOne , final String indent ) { if ( typeToken . encodedLength ( ) <= 0 || typeToken . isConstantEncoding ( ) ) { return ; } if ( atLeastOne [ 0 ] ) { sb . append ( indent ) . append ( "builder << \", \";\n" ) ; } else { atLeastOne [ 0 ] = true ; } sb . append ( indent ) . append ( "builder << R\"(\"" ) . append ( fieldTokenName ) . append ( "\": )\";\n" ) ; final String propertyName = formatPropertyName ( fieldTokenName ) ; final String fieldName = "writer." + propertyName ; switch ( typeToken . signal ( ) ) { case ENCODING : if ( typeToken . arrayLength ( ) > 1 ) { if ( typeToken . encoding ( ) . primitiveType ( ) == PrimitiveType . CHAR ) { final String getAsStringFunction = "writer.get" + toUpperFirstChar ( propertyName ) + "AsJsonEscapedString().c_str()" ; sb . append ( indent ) . append ( "builder << '\"' <<\n" ) . append ( indent ) . append ( INDENT ) . append ( getAsStringFunction ) . append ( " << '\"';\n" ) ; } else { sb . append ( indent + "builder << '[';\n" + indent + "for (std::size_t i = 0, length = " + fieldName + "Length(); i < length; i++)\n" + indent + "{\n" + indent + "    if (i)\n" + indent + "    {\n" + indent + "        builder << ',';\n" + indent + "    }\n" + indent + "    builder << +" + fieldName + "(i);\n" + indent + "}\n" + indent + "builder << ']';\n" ) ; } } else { if ( typeToken . encoding ( ) . primitiveType ( ) == PrimitiveType . CHAR ) { sb . append ( indent + "if (std::isprint(" + fieldName + "()))\n" + indent + "{\n" + indent + "    builder << '\"' << (char)" + fieldName + "() << '\"';\n" + indent + "}\n" + indent + "else\n" + indent + "{\n" + indent + "    builder << (int)" + fieldName + "();\n" + indent + "}\n" ) ; } else { sb . append ( indent ) . append ( "builder << +" ) . append ( fieldName ) . append ( "();\n" ) ; } } break ; case BEGIN_ENUM : sb . append ( indent ) . append ( "builder << '\"' << " ) . append ( fieldName ) . append ( "() << '\"';\n" ) ; break ; case BEGIN_SET : case BEGIN_COMPOSITE : if ( 0 == typeToken . version ( ) ) { sb . append ( indent ) . append ( "builder << " ) . append ( fieldName ) . append ( "();\n" ) ; } else { new Formatter ( sb ) . format ( indent + "if (%1$sInActingVersion())\n" + indent + "{\n" + indent + "    builder << %1$s();\n" + indent + "}\n" + indent + "else\n" + indent + "{\n" + indent + "    builder << %2$s;\n" + indent + "}\n" , fieldName , typeToken . signal ( ) == Signal . BEGIN_SET ? "\"[]\"" : "\"{}\"" ) ; } break ; default : break ; } sb . append ( '\n' ) ; }
public @ NotNull PairPairFunction < Integer > rowAndColumn2View ( ) { return ( row , column ) -> new Pair < > ( row2View ( ) . applyAsInt ( row ) , column2View ( ) . applyAsInt ( column ) ) ; }
protected Object _deserializeNoNullChecks ( JsonParser p , DeserializationContext ctxt ) { if ( _valueTypeDeserializer == null ) { return _valueDeserializer . deserialize ( p , ctxt ) ; } return _valueDeserializer . deserializeWithType ( p , ctxt , _valueTypeDeserializer ) ; }
public void setReceiveUserId ( Long receiveUserId ) { this . receiveUserId = receiveUserId ; }
public ServerResponse render ( String name , Object ... modelAttributes ) { return new GatewayRenderingResponseBuilder ( name ) . status ( this . statusCode ) . headers ( headers -> headers . putAll ( this . headers ) ) . cookies ( cookies -> cookies . addAll ( this . cookies ) ) . modelAttributes ( modelAttributes ) . build ( ) ; }
@ Override void putChar ( byte [ ] array , long offset , char c ) { UNSAFE . putChar ( array , arrayOffset + offset , c ) ; }
public void executeUpgrade ( final AlpineQueryManager alpineQueryManager , final Connection connection ) throws Exception { LOGGER . info ( "Removing legacy Fortify SSC configuration settings" ) ; DbUtil . executeUpdate ( connection , STMT_1 ) ; DbUtil . executeUpdate ( connection , STMT_2 ) ; }
public boolean isMe ( String userid ) { if ( UserCache . getId ( ) . equalsIgnoreCase ( userid ) ) { return true ; } return false ; }
public byte [ ] unwrap ( byte [ ] buf ) throws SaslException { if ( client != null ) return client . unwrap ( buf , 0 , buf . length ) ; else return server . unwrap ( buf , 0 , buf . length ) ; }
public static Optional < OAuthFlows > getOAuthFlows ( io . swagger . v3 . oas . annotations . security . OAuthFlows oAuthFlows ) { if ( isEmpty ( oAuthFlows ) ) { return Optional . empty ( ) ; } OAuthFlows oAuthFlowsObject = new OAuthFlows ( ) ; if ( oAuthFlows . extensions ( ) . length > 0 ) { Map < String , Object > extensions = AnnotationsUtils . getExtensions ( oAuthFlows . extensions ( ) ) ; if ( extensions != null ) { extensions . forEach ( oAuthFlowsObject :: addExtension ) ; } } getOAuthFlow ( oAuthFlows . authorizationCode ( ) ) . ifPresent ( oAuthFlowsObject :: setAuthorizationCode ) ; getOAuthFlow ( oAuthFlows . clientCredentials ( ) ) . ifPresent ( oAuthFlowsObject :: setClientCredentials ) ; getOAuthFlow ( oAuthFlows . implicit ( ) ) . ifPresent ( oAuthFlowsObject :: setImplicit ) ; getOAuthFlow ( oAuthFlows . password ( ) ) . ifPresent ( oAuthFlowsObject :: setPassword ) ; return Optional . of ( oAuthFlowsObject ) ; }
public static boolean isRedis ( String db ) { return DATABASE_REDIS . equals ( db ) ; }
public void setModeOnlyMonthView ( ) { mCalendarShowMode = CALENDAR_SHOW_MODE_ONLY_MONTH_VIEW ; requestLayout ( ) ; }
public static boolean showPlaybackSpeedOnFullNotification ( ) { return showButtonOnFullNotification ( NOTIFICATION_BUTTON_PLAYBACK_SPEED ) ; }
public void resumeJob ( JobKey jobKey ) throws SchedulerException { try { getRemoteScheduler ( ) . resumeJob ( jobKey ) ; } catch ( RemoteException re ) { throw invalidateHandleCreateException ( "Error communicating with remote scheduler." , re ) ; } }
private List < PropertyNode > findProperties ( AnnotationNode annotation , final ClassNode classNode , final List < String > includes , final List < String > excludes , final boolean allProperties , final boolean includeSuperProperties , final boolean allNames ) { Set < String > names = new HashSet < String > ( ) ; List < PropertyNode > props = getAllProperties ( names , classNode , classNode , true , false , allProperties , false , includeSuperProperties , false , false , allNames , false ) ; List < PropertyNode > properties = new ArrayList < PropertyNode > ( ) ; for ( PropertyNode property : props ) { String propertyName = property . getName ( ) ; if ( ( excludes != null && excludes . contains ( propertyName ) ) || includes != null && ! includes . contains ( propertyName ) ) continue ; properties . add ( property ) ; } for ( PropertyNode pNode : properties ) { checkComparable ( pNode ) ; } if ( includes != null ) { Comparator < PropertyNode > includeComparator = Comparator . comparingInt ( o -> includes . indexOf ( o . getName ( ) ) ) ; properties . sort ( includeComparator ) ; } return properties ; }
public static < T > Message < T > remoteResponse ( InetAddressAndPort from , Verb verb , T payload ) { assert verb . isResponse ( ) ; long createdAtNanos = approxTime . now ( ) ; long expiresAtNanos = verb . expiresAtNanos ( createdAtNanos ) ; return new Message < > ( new Header ( 0 , epochSupplier . get ( ) , verb , from , createdAtNanos , expiresAtNanos , 0 , NO_PARAMS ) , payload ) ; }
public OpenOptions setSync ( boolean sync ) { this . sync = sync ; return this ; }
public UsageStatsBuilder setFirstTimeStamp ( long firstTimeStamp ) { usageStats . mBeginTimeStamp = firstTimeStamp ; return this ; }
public int serializedSize ( int version ) { switch ( version ) { case VERSION_40 : if ( serializedSize40 == 0 ) serializedSize40 = serializer . serializedSize ( this , VERSION_40 ) ; return serializedSize40 ; case VERSION_50 : if ( serializedSize50 == 0 ) serializedSize50 = serializer . serializedSize ( this , VERSION_50 ) ; return serializedSize50 ; case VERSION_51 : if ( serializedSize51 == 0 ) serializedSize51 = serializer . serializedSize ( this , VERSION_51 ) ; return serializedSize51 ; default : throw new IllegalStateException ( "Unknown serialization version " + version ) ; } }
public BooleanProperty addCreationDateProperty ( ) { return addCreationDateProperty ; }
public void setApiClient ( ApiClient apiClient ) { this . apiClient = apiClient ; }
protected void onCreate ( @ Nullable Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . activity_picker_file ) ; FileExplorer fileExplorer = findViewById ( R . id . file_picker_explorer ) ; ExplorerConfig config = new ExplorerConfig ( this ) ; config . setRootDir ( Environment . getExternalStorageDirectory ( ) ) ; config . setLoadAsync ( true ) ; config . setExplorerMode ( ExplorerMode . FILE ) ; config . setShowHomeDir ( true ) ; config . setShowUpDir ( true ) ; config . setShowHideDir ( true ) ; config . setAllowExtensions ( new String [ ] { ".txt" , ".jpg" } ) ; fileExplorer . load ( config ) ; }
public void setOuterJoinExpression ( boolean isOuterJoinExpression ) { this . isOuterJoinExpression = isOuterJoinExpression ; }
public void validateIndexFiles ( boolean updateExcludePath , int depth ) throws InterruptedException { service . validateIndexFiles ( updateExcludePath , depth ) ; }
public static KeyStore loadKeyStore ( File certificateChainFile , File privateKeyFile , Optional < String > keyPassword ) throws IOException , GeneralSecurityException { PrivateKey key = loadPrivateKey ( privateKeyFile , keyPassword ) ; List < X509Certificate > certificateChain = readCertificateChain ( certificateChainFile ) ; if ( certificateChain . isEmpty ( ) ) { throw new CertificateException ( "Certificate file does not contain any certificates: " + certificateChainFile ) ; } KeyStore keyStore = KeyStore . getInstance ( "JKS" ) ; keyStore . load ( null , null ) ; keyStore . setKeyEntry ( "key" , key , keyPassword . orElse ( "" ) . toCharArray ( ) , certificateChain . toArray ( new Certificate [ 0 ] ) ) ; return keyStore ; }
public void readFields ( DataInput in ) throws IOException { fromUrl = Text . readString ( in ) ; anchor = Text . readString ( in ) ; boolean hasMD = in . readBoolean ( ) ; if ( hasMD ) { md = new org . apache . hadoop . io . MapWritable ( ) ; md . readFields ( in ) ; } else { md = null ; } }
public Map < String , Object > getContent ( ) { return content ; }
public boolean getDelegate ( ) { return this . delegate ; }
default int updateByPrimaryKeySelective ( CrawlBatchTask record ) { return update ( c -> c . set ( sourceId ) . equalToWhenPresent ( record :: getSourceId ) . set ( crawlCountSuccess ) . equalToWhenPresent ( record :: getCrawlCountSuccess ) . set ( crawlCountTarget ) . equalToWhenPresent ( record :: getCrawlCountTarget ) . set ( taskStatus ) . equalToWhenPresent ( record :: getTaskStatus ) . set ( startTime ) . equalToWhenPresent ( record :: getStartTime ) . set ( endTime ) . equalToWhenPresent ( record :: getEndTime ) . where ( id , isEqualTo ( record :: getId ) ) ) ; }
public Builder root ( Node root ) { this . root = root ; return this ; }
public MetaContactGroup getNewParent ( ) { return ( MetaContactGroup ) getNewValue ( ) ; }
public int hashCode ( ) { return queryMixin . hashCode ( ) ; }
public Builder mergeFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { io . kubernetes . client . proto . V1Networking . IngressClassSpec parsedMessage = null ; try { parsedMessage = PARSER . parsePartialFrom ( input , extensionRegistry ) ; } catch ( com . google . protobuf . InvalidProtocolBufferException e ) { parsedMessage = ( io . kubernetes . client . proto . V1Networking . IngressClassSpec ) e . getUnfinishedMessage ( ) ; throw e . unwrapIOException ( ) ; } finally { if ( parsedMessage != null ) { mergeFrom ( parsedMessage ) ; } } return this ; }
private void onProtectedHit ( Node node ) { admitter . record ( node . key ) ; node . moveToTail ( headProtected ) ; }
public void addHandler ( String path , ElementHandler handler ) { getDispatchHandler ( ) . addHandler ( path , handler ) ; }
public io . kubernetes . client . proto . V1Networking . HTTPIngressRuleValue getHttp ( ) { return http_ == null ? io . kubernetes . client . proto . V1Networking . HTTPIngressRuleValue . getDefaultInstance ( ) : http_ ; }
public void onCreateMenu ( @ NonNull Menu menu , MenuInflater inflater ) { inflater . inflate ( R . menu . edit_filter_menu , menu ) ; }
public static String getActionName ( @ NonNull final Context context , @ Action final int action ) { switch ( action ) { case PREVIOUS : return context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_previous_description ) ; case NEXT : return context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_next_description ) ; case REWIND : return context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_rewind_description ) ; case FORWARD : return context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_fastforward_description ) ; case SMART_REWIND_PREVIOUS : return Localization . concatenateStrings ( context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_rewind_description ) , context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_previous_description ) ) ; case SMART_FORWARD_NEXT : return Localization . concatenateStrings ( context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_fastforward_description ) , context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_next_description ) ) ; case PLAY_PAUSE : return Localization . concatenateStrings ( context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_play_description ) , context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_pause_description ) ) ; case PLAY_PAUSE_BUFFERING : return Localization . concatenateStrings ( context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_play_description ) , context . getString ( com . google . android . exoplayer2 . ui . R . string . exo_controls_pause_description ) , context . getString ( R . string . notification_action_buffering ) ) ; case REPEAT : return context . getString ( R . string . notification_action_repeat ) ; case SHUFFLE : return context . getString ( R . string . notification_action_shuffle ) ; case CLOSE : return context . getString ( R . string . close ) ; case NOTHING : default : return context . getString ( R . string . notification_action_nothing ) ; } }
String getMessageFromTemplate ( String content , ShowType showType , boolean showAll ) ; default String getMessageFromTemplate ( String content , ShowType showType ) { return getMessageFromTemplate ( content , showType , true ) ; }
public static String getFilenamePrefix ( SharedPreferences p ) { return ( p . getString ( PREF_FILENAME_PREFIX , "PCAPdroid_" ) ) ; }
public Optional < Double > getSoftMemoryLimitFraction ( ) { return softMemoryLimitFraction ; }
static boolean isWiko ( ) { return "WIKO" . equalsIgnoreCase ( Build . MANUFACTURER ) ; }
private void createTableLog ( SQLiteDatabase db ) { Log . i ( TAG , "Creating log table" ) ; db . execSQL ( "CREATE TABLE log (" + " ID INTEGER PRIMARY KEY AUTOINCREMENT" + ", time INTEGER NOT NULL" + ", version INTEGER" + ", protocol INTEGER" + ", flags TEXT" + ", saddr TEXT" + ", sport INTEGER" + ", daddr TEXT" + ", dport INTEGER" + ", dname TEXT" + ", uid INTEGER" + ", data TEXT" + ", allowed INTEGER" + ", connection INTEGER" + ", interactive INTEGER" + ");" ) ; db . execSQL ( "CREATE INDEX idx_log_time ON log(time)" ) ; db . execSQL ( "CREATE INDEX idx_log_dest ON log(daddr)" ) ; db . execSQL ( "CREATE INDEX idx_log_dname ON log(dname)" ) ; db . execSQL ( "CREATE INDEX idx_log_dport ON log(dport)" ) ; db . execSQL ( "CREATE INDEX idx_log_uid ON log(uid)" ) ; }
public String sanitize ( String s ) { return GraphiteSanitize . sanitize ( s ) ; }
public void getSuggestedWords ( final Runnable callback ) { mNonUIThreadHandler . obtainMessage ( MSG_GET_SUGGESTED_WORDS , callback ) . sendToTarget ( ) ; }
public int getSsoSessionMaxLifespanRememberMe ( ) { if ( updated != null ) return updated . getSsoSessionMaxLifespanRememberMe ( ) ; return cached . getSsoSessionMaxLifespanRememberMe ( ) ; }
public static io . kubernetes . client . proto . V1Networking . NetworkPolicy parseDelimitedFrom ( java . io . InputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
public void run ( ) { try { Thread . currentThread ( ) . setName ( "LearnerCnxAcceptorHandler-" + serverSocket . getLocalSocketAddress ( ) ) ; while ( ! stop . get ( ) ) { acceptConnections ( ) ; } } catch ( Exception e ) { LOG . warn ( "Exception while accepting follower" , e ) ; if ( fail . compareAndSet ( false , true ) ) { handleException ( getName ( ) , e ) ; halt ( ) ; } } finally { latch . countDown ( ) ; } }
public Animator toDismiss ( @ Nullable OnAnimatorCreateListener onAnimatorCreateListener ) { AnimatorSet set = new AnimatorSet ( ) ; if ( configs != null ) { for ( int i = 0 ; i < configs . size ( ) ; i ++ ) { BaseAnimationConfig config = configs . valueAt ( i ) ; Animator childAnimator = config . $buildAnimator ( true ) ; if ( onAnimatorCreateListener != null ) { onAnimatorCreateListener . onAnimatorCreated ( childAnimator ) ; } set . playTogether ( childAnimator ) ; } if ( onAnimatorCreateListener != null ) { onAnimatorCreateListener . onAnimatorCreateFinish ( set ) ; } } return set ; }
public A withResources ( String ... resources ) { if ( this . resources != null ) { this . resources . clear ( ) ; _visitables . remove ( "resources" ) ; } if ( resources != null ) { for ( String item : resources ) { this . addToResources ( item ) ; } } return ( A ) this ; }
public Builder clear ( ) { super . clear ( ) ; hosts_ = com . google . protobuf . LazyStringArrayList . EMPTY ; bitField0_ = ( bitField0_ & ~ 0x00000001 ) ; secretName_ = "" ; bitField0_ = ( bitField0_ & ~ 0x00000002 ) ; return this ; }
public int getIndicatorNormalColor ( ) { return mIndicatorOptions . getNormalSliderColor ( ) ; }
T createResponse ( ) ; OBinaryResponse execute ( OBinaryRequestExecutor executor ) ; String getDescription ( ) ; default boolean requireServerUser ( ) { return false ; }
public T get ( final long sequence ) { return ringBuffer . get ( sequence ) ; }
public void onSure ( ) { clear ( ) ; }
private ClientConfig applyBasicAuth ( ClientConfig clientConfig ) { String routerUsername = System . getenv ( "SE_ROUTER_USERNAME" ) ; String routerPassword = System . getenv ( "SE_ROUTER_PASSWORD" ) ; if ( routerUsername != null && ! routerUsername . isEmpty ( ) && routerPassword != null && ! routerPassword . isEmpty ( ) ) { return clientConfig . authenticateAs ( new UsernameAndPassword ( routerUsername , routerPassword ) ) ; } return clientConfig ; }
public static boolean getSocks5Enabled ( SharedPreferences p ) { return ( p . getBoolean ( PREF_SOCKS5_ENABLED_KEY , false ) ) ; }
public XStreamDOM getOutput ( ) { if ( pendings . size ( ) != 1 ) throw new IllegalStateException ( ) ; return pendings . peek ( ) . children . getFirst ( ) ; }
public static io . kubernetes . client . proto . V1Networking . IngressLoadBalancerIngress parseFrom ( java . nio . ByteBuffer data , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data , extensionRegistry ) ; }
public void start ( ) throws Exception { if ( segments . isEmpty ( ) ) { throw new Exception ( "empty segment list" ) ; } dstHandle . seek ( HeaderInfoLength + VectorIndexLength ) ; log . infof ( "try to write the data block ... " ) ; for ( final Segment seg : segments ) { log . debugf ( "try to write region `%s` ... " , seg . region ) ; final DataEntry e = regionPool . get ( seg . region ) ; if ( e != null ) { log . debugf ( " --[Cached] with ptr=%d" , e . ptr ) ; continue ; } final byte [ ] regionBuff = seg . region . getBytes ( bytesCharset ) ; if ( regionBuff . length < 1 ) { } else if ( regionBuff . length > 0xFFFF ) { throw new Exception ( "too long region info `" + seg . region + "`: should be less than 65535 bytes" ) ; } final long pos = dstHandle . getFilePointer ( ) ; dstHandle . write ( regionBuff ) ; if ( pos >= MaxFilePointer ) { throw new IOException ( "region ptr exceed the max length of '" + MaxFilePointer + "'" ) ; } regionPool . put ( seg . region , new DataEntry ( regionBuff . length , pos ) ) ; log . debugf ( " --[Added] with ptr=%d" , pos ) ; } log . infof ( "try to write the segment index block ... " ) ; int counter = 0 ; long startIndexPtr = - 1 , endIndexPtr = - 1 ; final byte [ ] indexBuff = new byte [ version . segmentIndexSize ] ; for ( Segment seg : segments ) { final DataEntry e = regionPool . get ( seg . region ) ; if ( e == null ) { throw new Exception ( "missing ptr cache for region `" + seg . region + "`" ) ; } int _offset = 0 ; List < Segment > segList = seg . split ( ) ; log . debugf ( "try to index segment(%d splits) %s ... " , segList . size ( ) , seg ) ; for ( final Segment s : segList ) { long pos = dstHandle . getFilePointer ( ) ; if ( pos >= MaxFilePointer ) { throw new IOException ( "region ptr exceed the max length of '" + MaxFilePointer + "'" ) ; } version . putBytes ( indexBuff , 0 , s . startIP ) ; version . putBytes ( indexBuff , s . startIP . length , s . endIP ) ; _offset = s . startIP . length + s . endIP . length ; LittleEndian . put ( indexBuff , _offset , e . length , 2 ) ; LittleEndian . put ( indexBuff , _offset + 2 , e . ptr , 4 ) ; dstHandle . write ( indexBuff ) ; log . debugf ( "|-segment index: %d, ptr: %d, segment: %s" , counter , pos , s ) ; setVectorIndex ( s . startIP , pos ) ; counter ++ ; if ( startIndexPtr == - 1 ) { startIndexPtr = pos ; } endIndexPtr = pos ; } } log . infof ( "try to write the vector index block ... " ) ; dstHandle . seek ( HeaderInfoLength ) ; dstHandle . write ( vectorIndex ) ; log . infof ( "try to write the segment index ptr ... " ) ; LittleEndian . put ( indexBuff , 0 , startIndexPtr , 4 ) ; LittleEndian . put ( indexBuff , 4 , endIndexPtr , 4 ) ; dstHandle . seek ( 8 ) ; dstHandle . write ( indexBuff , 0 , 8 ) ; log . infof ( "write done, dataBlocks: %d, indexBlocks: (%d, %d), indexPtr: (%d, %d)" , regionPool . size ( ) , segments . size ( ) , counter , startIndexPtr , endIndexPtr ) ; }
public void onClick ( View v ) { new FragmentDialogVPN ( ) . show ( getParentFragmentManager ( ) , "vpn" ) ; }
private double safeGetDoubleCol ( int col ) throws SQLException { return stmt . pointer . safeRunDouble ( ( db , ptr ) -> db . column_double ( ptr , markCol ( col ) ) ) ; }
public void setVersion ( int version ) { execSQL ( "PRAGMA user_version = " + version ) ; }
public String getModifierStr ( ) { return getModifiersStr ( ) ; }
private Double getIntervalSize ( final VariableAggregationContextES context , final Double baseline ) { final double maxVariableValue = context . getMaxVariableValue ( ) ; final boolean customBucketsActive = context . getCustomBucketDto ( ) . isActive ( ) ; Double intervalSize = context . getCustomBucketDto ( ) . getBucketSize ( ) ; if ( ! customBucketsActive || intervalSize == null || intervalSize <= 0 ) { intervalSize = Math . abs ( maxVariableValue - baseline ) / ( NUMBER_OF_DATA_POINTS_FOR_AUTOMATIC_INTERVAL_SELECTION - 1 ) ; intervalSize = intervalSize == 0 ? 1 : roundUpToNearestPowerOfTen ( intervalSize ) ; } if ( ! VariableType . DOUBLE . equals ( context . getVariableType ( ) ) ) { intervalSize = Math . ceil ( intervalSize ) ; } return intervalSize ; }
public boolean isUseSSL ( ) { return useSSL ; }
public Type getReturnType ( DeclaredType includingType , Accessor accessor ) { Type type ; TypeMirror accessorType = getMethodType ( includingType , accessor . getElement ( ) ) ; if ( isExecutableType ( accessorType ) ) { type = getType ( ( ( ExecutableType ) accessorType ) . getReturnType ( ) ) ; } else { type = getType ( accessorType ) ; } return type ; }
private Map < String , List < Descriptor > > buildAllDescriptors ( ) { Map < String , List < Descriptor > > allDescriptors = new HashMap < > ( ) ; for ( TopicsMapping mapping : topicsMapping ) { byte [ ] fileBytes = new byte [ 0 ] ; try { fileBytes = getDescriptorFileAsBytes ( mapping ) ; } catch ( IOException e ) { throw new RuntimeException ( String . format ( "Cannot get a descriptor file for the topics regex [%s]" , mapping . getTopicRegex ( ) ) , e ) ; } try { allDescriptors . put ( mapping . getTopicRegex ( ) , buildAllDescriptorsForDescriptorFile ( fileBytes ) ) ; } catch ( IOException | DescriptorValidationException e ) { throw new RuntimeException ( String . format ( "Cannot build Protobuf descriptors for the topics regex [%s]" , mapping . getTopicRegex ( ) ) , e ) ; } } return allDescriptors ; }
public float getTopLeftRadiusDp ( ) { return pxToDp ( getTopLeftRadius ( ) ) ; }
public static String getDate ( String format ) { Date date = new Date ( ) ; if ( null == date ) { return null ; } SimpleDateFormat sdf = new SimpleDateFormat ( format ) ; return sdf . format ( date ) ; }
public static boolean hasSrid ( int wkbType ) { return ( wkbType & GeometryConstants . EWKB_SRID_FLAG ) != 0 ; }
public void writeBytes ( byte [ ] bytes , int offset ) { dataOutput . writeBytes ( bytes , offset ) ; }
public Animation toDismiss ( @ Nullable OnAnimationCreateListener animationCreatListener ) { AnimationSet set = new AnimationSet ( false ) ; if ( configs != null ) { for ( int i = 0 ; i < configs . size ( ) ; i ++ ) { BaseAnimationConfig config = configs . valueAt ( i ) ; Animation childAnim = config . $buildAnimation ( true ) ; if ( childAnim . isFillEnabled ( ) ) { set . setFillEnabled ( true ) ; } if ( childAnim . getFillBefore ( ) ) { set . setFillBefore ( true ) ; } if ( childAnim . getFillAfter ( ) ) { set . setFillAfter ( true ) ; } if ( animationCreatListener != null ) { animationCreatListener . onAnimationCreated ( childAnim ) ; } set . addAnimation ( childAnim ) ; } if ( animationCreatListener != null ) { animationCreatListener . onAnimationCreateFinish ( set ) ; } } return set ; }
public String getText ( ) { return "(" + getOperation ( ) . getText ( ) + getExpression ( ) . getText ( ) + ")" ; }
public Object invoke ( Object reader , Object comma , Object opts , Object pendingForms ) { PushbackReader r = ( PushbackReader ) reader ; int ch = read1 ( r ) ; if ( ch == - 1 ) throw Util . runtimeException ( "EOF while reading character" ) ; pendingForms = ensurePending ( pendingForms ) ; if ( ch == '@' ) { Object o = read ( r , true , null , true , opts , pendingForms ) ; return RT . list ( UNQUOTE_SPLICING , o ) ; } else { unread ( r , ch ) ; Object o = read ( r , true , null , true , opts , pendingForms ) ; return RT . list ( UNQUOTE , o ) ; } }
public void tint ( int rgb ) { colorCalc ( rgb ) ; tintFromCalc ( ) ; }
public ParagraphBuilder addText ( String text ) { contents . add ( Texts . of ( text ) . create ( ) ) ; return this ; }
public void pauseTimers ( ) { checkThread ( ) ; mProvider . pauseTimers ( ) ; }
public static String date2Str ( SimpleDateFormat dateSdf ) { synchronized ( dateSdf ) { Date date = getDate ( ) ; if ( null == date ) { return null ; } return dateSdf . format ( date ) ; } }
public void setOnExpirationUpdateListener ( @ Nullable OnExpirationUpdateListener listener ) { if ( Util . SDK_INT < 23 ) { throw new UnsupportedOperationException ( ) ; } mediaDrm . setOnExpirationUpdateListener ( listener == null ? null : ( mediaDrm , sessionId , expirationTimeMs ) -> listener . onExpirationUpdate ( FrameworkMediaDrm . this , sessionId , expirationTimeMs ) , null ) ; }
public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return io . kubernetes . client . proto . V1Networking . internal_static_k8s_io_api_networking_v1_IngressClassSpec_descriptor ; }
public int getNodes ( ) { return nodes ; }
void readField ( T accumulator , JsonReader in , BoundField field ) throws IllegalAccessException , IOException { field . readIntoField ( in , accumulator ) ; }
public void setRegistrySyncRetryWaitMs ( long registrySyncRetryWaitMs ) { this . registrySyncRetryWaitMs = registrySyncRetryWaitMs ; }
public int getAttributeIntValue ( String namespace , String attribute , int defaultValue ) { int index = findAttribute ( namespace , attribute ) ; if ( index == - 1 ) { return defaultValue ; } return getAttributeIntValue ( index , defaultValue ) ; }
public void setProto ( String proto ) { this . proto = proto ; }
public String tMeGiftCodeUrl ( @ NonNull String giftCode ) { return tMeUrl ( "giftcode/" + giftCode ) ; }
public Criteria andSelectTypeIsNull ( ) { addCriterion ( "select_type is null" ) ; return ( Criteria ) this ; }
public void setUserInputEnabled ( boolean userInputEnabled ) { this . userInputEnabled = userInputEnabled ; }
public void setDefaultTimeZone ( String defaultTimeZone ) { this . defaultTimeZone = defaultTimeZone ; }
public int getCacheSize ( ) { return cacheSize ; }
public void setFailReason ( String failReason ) { this . failReason = failReason ; }
protected String prepare ( Script script ) { return script . getContent ( ) ; }
public void onClick ( View view ) { ListItem item = ( ListItem ) view . getTag ( ) ; if ( item != null && item . getViewType ( ) == ListItem . TYPE_CHAT_SMALL ) { DoubleTextWrapper data = ( DoubleTextWrapper ) item . getData ( ) ; switch ( mode ) { case Mode . GROUPS_IN_COMMON : { long chatId = data . getChatId ( ) ; tdlib . ui ( ) . openChat ( this , chatId , null ) ; break ; } case Mode . SIMILAR_CHANNELS : { long chatId = data . getChatId ( ) ; tdlib . send ( new TdApi . OpenChatSimilarChat ( getChatId ( ) , chatId ) , tdlib . typedOkHandler ( ) ) ; tdlib . ui ( ) . openChat ( this , chatId , new TdlibUi . ChatOpenParameters ( ) . keepStack ( ) ) ; break ; } case Mode . SIMILAR_BOTS : { long openedBotUserId = data . getUserId ( ) ; long botUserId = tdlib . chatUserId ( getChatId ( ) ) ; tdlib . send ( new TdApi . OpenBotSimilarBot ( botUserId , openedBotUserId ) , tdlib . typedOkHandler ( ) ) ; tdlib . ui ( ) . openPrivateChat ( this , openedBotUserId , new TdlibUi . ChatOpenParameters ( ) . keepStack ( ) ) ; break ; } default : throw new IllegalStateException ( ) ; } } }
public static com . google . protobuf . Parser < ServiceCIDRList > parser ( ) { return PARSER ; }
public static long nextLong ( final long startInclusive , final long endExclusive ) { return secure ( ) . randomLong ( startInclusive , endExclusive ) ; }
public static boolean oldLogView ( boolean val ) { gPrefs . edit ( ) . putBoolean ( "oldLogView" , val ) . commit ( ) ; return val ; }
public boolean isEnabled ( ) { return this . enabled . get ( ) ; }
public SpringdocRouteBuilder DELETE ( String pattern , RequestPredicate predicate , HandlerFunction < ServerResponse > handlerFunction , Consumer < Builder > operationsConsumer ) { Builder builder = getOperationBuilder ( operationsConsumer ) ; this . delegate . DELETE ( pattern , predicate , handlerFunction ) . withAttribute ( OPERATION_ATTRIBUTE , builder ) ; return this ; }
public boolean setPackageWidgetsInString ( String value ) { if ( value != null ) { try { Type type = new TypeToken < TreeMap < String , Set < PackageWidgetDescription > > > ( ) { } . getType ( ) ; mapPackageWidgets = mJson . fromJson ( value , type ) ; mEditor . putString ( PACKAGE_WIDGETS , value ) ; mEditor . apply ( ) ; return true ; } catch ( JsonSyntaxException e ) { Log . d ( TAG , Utilities . getTraceStackInString ( e ) ) ; return false ; } } return false ; }
public static InjectionConfig . Builder injectionConfigBuilder ( ) { return new InjectionConfig . Builder ( ) ; }
public static int getFakeResId ( String resName ) { return 0x7e000000 | ( resName . hashCode ( ) & 0x00ffffff ) ; }
private void onReveal ( JavaRuntime java ) { Path target ; Path parent = java . getBinary ( ) . getParent ( ) ; if ( parent != null && parent . getParent ( ) != null && parent . getFileName ( ) != null && parent . getFileName ( ) . toString ( ) . equals ( "bin" ) && Files . exists ( parent . getParent ( ) . resolve ( "release" ) ) ) { target = parent . getParent ( ) ; } else { target = java . getBinary ( ) ; } FXUtils . showFileInExplorer ( target ) ; }
public static final boolean isX11 ( ) { return ! Platform . isWindows ( ) && ! Platform . isMac ( ) ; }
public void addStatisticsKindMeta ( StatisticsKindMeta kindMeta ) { kindMetaMap . put ( kindMeta . getName ( ) , kindMeta ) ; statsTable . putIfAbsent ( kindMeta . getName ( ) , new ConcurrentHashMap < > ( 16 ) ) ; }
public static GifMetadataDecoder create ( InputStream is , @ Nullable OutputStream os ) throws IOException { GifMetadataDecoder decoder = new GifMetadataDecoder ( is , os ) ; decoder . decode ( ) ; return decoder ; }
public void writeMarshallable ( @ NotNull WireOut wireOut ) { }
public void execute ( ) { operation . execute ( input , progressIndicator_ ) ; onSuccess ( ) ; }
public DynamicTableSink copy ( ) { return new KuduDynamicTableSink ( sinkConfig , tableSchema ) ; }
protected void updateItem ( JavaRuntime item , boolean empty ) { super . updateItem ( item , empty ) ; if ( empty || item == null ) { setGraphic ( null ) ; } else { content . setTitle ( ( item . isJDK ( ) ? "JDK" : "JRE" ) + " " + item . getVersion ( ) ) ; content . setSubtitle ( item . getBinary ( ) . toString ( ) ) ; content . getTags ( ) . clear ( ) ; content . addTag ( i18n ( "java.info.architecture" ) + ": " + item . getArchitecture ( ) . getDisplayName ( ) ) ; String vendor = JavaInfo . normalizeVendor ( item . getVendor ( ) ) ; if ( vendor != null ) content . addTag ( i18n ( "java.info.vendor" ) + ": " + vendor ) ; SVG newRemoveIcon = item . isManaged ( ) ? SVG . DELETE_FOREVER : SVG . DELETE ; if ( removeIcon != newRemoveIcon ) { removeIcon = newRemoveIcon ; removeIconPane . getChildren ( ) . setAll ( removeIcon . createIcon ( 24 ) ) ; removeTooltip . setText ( item . isManaged ( ) ? i18n ( "java.uninstall" ) : i18n ( "java.disable" ) ) ; } setGraphic ( graphic ) ; } }
public static Image renderGradient ( int width , float min , float max , float low , float high , boolean inverted ) { WritableImage image = new WritableImage ( width , 1 ) ; PixelWriter pixelWriter = image . getPixelWriter ( ) ; for ( int i = 0 ; i < width ; i ++ ) { float hue = ( max - min ) * ( ( float ) i / width ) + min ; float saturation = 1 , brightness = 1 ; if ( hue < low || hue > high ) { saturation = 0.3f ; brightness = 0.6f ; } if ( inverted ) { hue = max - hue + min ; } pixelWriter . setArgb ( i , 0 , Color . HSBtoRGB ( hue , saturation , brightness ) ) ; } return image ; }
public Result filter ( final Logger logger , final Level level , final Marker marker , final String msg , final Object p0 , final Object p1 ) { return Result . DENY ; }
public ReadableTransaction captureOrder ( MerchantStore store , Order order , Customer customer , Language language ) throws Exception { Transaction transactionModel = paymentService . processCapturePayment ( order , customer , store ) ; ReadableTransaction transaction = new ReadableTransaction ( ) ; ReadableTransactionPopulator trxPopulator = new ReadableTransactionPopulator ( ) ; trxPopulator . setOrderService ( orderService ) ; trxPopulator . setPricingService ( pricingService ) ; trxPopulator . populate ( transactionModel , transaction , store , language ) ; return transaction ; }
public boolean matches ( String type , URI uri , String realm ) { if ( ! getType ( ) . equalsIgnoreCase ( type ) ) return false ; if ( ! this . realm . equals ( ANY_REALM ) && ! this . realm . equals ( realm ) ) return false ; return matchesURI ( this . uri , uri ) ; }
public List < String > parseColumns ( NotifyAction config ) { return config . parseColumns ( ) ; }
public RestApiResponse cluster ( ) throws InterruptedException , ExecutionException { Statistics statistics = new Statistics ( ) ; try { statistics . state = String . valueOf ( pdService . getStoreNodeService ( ) . getClusterStats ( ) . getState ( ) ) ; String leaderGrpcAddress = RaftEngine . getInstance ( ) . getLeaderGrpcAddress ( ) ; CallStreamObserverWrap < Pdpb . GetMembersResponse > response = new CallStreamObserverWrap < > ( ) ; pdService . getMembers ( Pdpb . GetMembersRequest . newBuilder ( ) . build ( ) , response ) ; List < Member > pdList = new ArrayList < > ( ) ; for ( Metapb . Member member : response . get ( ) . get ( 0 ) . getMembersList ( ) ) { Member member1 = new Member ( member ) ; if ( ( leaderGrpcAddress != null ) && ( leaderGrpcAddress . equals ( member . getGrpcUrl ( ) ) ) ) { member1 . role = "Leader" ; statistics . pdLeader = member1 ; } else { member1 . role = "Follower" ; } pdList . add ( member1 ) ; } statistics . pdList = pdList ; statistics . memberSize = pdList . size ( ) ; List < Store > stores = new ArrayList < > ( ) ; for ( Metapb . Store store : pdService . getStoreNodeService ( ) . getStores ( ) ) { stores . add ( new Store ( store ) ) ; } statistics . stores = stores ; statistics . storeSize = statistics . stores . size ( ) ; statistics . onlineStoreSize = pdService . getStoreNodeService ( ) . getActiveStores ( ) . size ( ) ; statistics . offlineStoreSize = statistics . storeSize - statistics . onlineStoreSize ; List < Metapb . Graph > graphs = pdRestService . getGraphs ( ) ; statistics . graphSize = graphs . stream ( ) . filter ( ( g ) -> ( g . getGraphName ( ) != null ) && ( g . getGraphName ( ) . endsWith ( "/g" ) ) ) . count ( ) ; statistics . partitionSize = pdService . getStoreNodeService ( ) . getShardGroups ( ) . size ( ) ; statistics . shardCount = pdService . getConfigService ( ) . getPDConfig ( ) . getShardCount ( ) ; for ( Metapb . Store store : pdService . getStoreNodeService ( ) . getStores ( ) ) { List < Metapb . GraphStats > graphStatsList = store . getStats ( ) . getGraphStatsList ( ) ; for ( Metapb . GraphStats graphStats : graphStatsList ) { statistics . keyCount += graphStats . getApproximateKeys ( ) ; statistics . dataSize += graphStats . getApproximateSize ( ) ; } } Metapb . PartitionState dataState = Metapb . PartitionState . PState_Normal ; for ( Metapb . Graph graph : pdRestService . getGraphs ( ) ) { if ( graph . getState ( ) == Metapb . PartitionState . UNRECOGNIZED ) { continue ; } if ( ( graph . getState ( ) != null ) && ( graph . getState ( ) . getNumber ( ) > dataState . getNumber ( ) ) ) { dataState = graph . getState ( ) ; } } statistics . dataState = dataState . name ( ) ; return new RestApiResponse ( statistics , Pdpb . ErrorType . OK , Pdpb . ErrorType . OK . name ( ) ) ; } catch ( PDException e ) { log . error ( "PD Exception: " , e ) ; return new RestApiResponse ( null , e . getErrorCode ( ) , e . getMessage ( ) ) ; } }
default Mutable mutable ( ) { return new PlatformCatalogImpl . Builder ( this ) ; }
public DatabaseInitializationMode getMode ( ) { return this . mode ; }
public ResponseEntity < String > getSeriesBooks ( @ Parameter ( description = "Series ID" ) @ PathVariable String seriesId , @ Parameter ( description = "Page number" ) @ RequestParam ( defaultValue = "0" ) int page , @ Parameter ( description = "Page size" ) @ RequestParam ( defaultValue = "20" ) int size , @ Parameter ( description = "Return all books without paging" ) @ RequestParam ( defaultValue = "false" ) boolean unpaged ) { return writeJson ( komgaService . getBooksBySeries ( seriesId , page , size , unpaged ) ) ; }
protected void sync ( int want ) { int need = ( p + want - 1 ) - n + 1 ; if ( need > 0 ) { fill ( need ) ; } }
public io . kubernetes . client . proto . V1Networking . IngressRuleValue getDefaultInstanceForType ( ) { return io . kubernetes . client . proto . V1Networking . IngressRuleValue . getDefaultInstance ( ) ; }
public static Predicate < Pair < CorefChain . CorefMention , List < CoreLabel > > > getCorefMentionFilter ( Properties props ) { String filterCorefChain = props . getProperty ( "coref.evaluate.filter" ) ; if ( filterCorefChain != null ) { if ( "filterCustomerAbstractPronouns" . equals ( filterCorefChain ) ) { return CorefUtils . filterCustomerAbstractPronouns ; } else { throw new RuntimeException ( "Cannot create coref.evaluate.filter " + filterCorefChain ) ; } } else { return null ; } }
public static Intent getCloneProfileIntent ( @ NonNull Context context , @ NonNull String oldProfileId , @ NonNull String newProfileName ) { Intent intent = new Intent ( context , AppsFilterProfileActivity . class ) ; intent . putExtra ( EXTRA_PROFILE_ID , oldProfileId ) ; intent . putExtra ( EXTRA_NEW_PROFILE_NAME , newProfileName ) ; return intent ; }
public boolean isDisposed ( ) { return upstream . isDisposed ( ) ; }
public ListProperty < Field > resolvableTagsFieldProperty ( ) { return resolvableTagsFieldProperty ; }
private void setAppDurationIfNeeded ( FlinkApplication record , long now ) { if ( record . getTracking ( ) == 1 && record . getStartTime ( ) != null && record . getStartTime ( ) . getTime ( ) > 0 ) { record . setDuration ( now - record . getStartTime ( ) . getTime ( ) ) ; } }
public String getRemoteRegionTrustStore ( ) { return remoteRegionTrustStore ; }
public void destroy ( ) { super . destroy ( ) ; tdlib . cache ( ) . unsubscribeFromGlobalUpdates ( this ) ; }
public static Application currentApplication ( ) { return HiddenUtil . throwUOE ( ) ; }
static int hashCode ( Object obj ) { if ( ! ( obj instanceof CharSequence ) ) { return obj . hashCode ( ) ; } else { return CharSequences . hash ( ( CharSequence ) obj ) ; } }
public Integer getFirstNameLength ( ) { return firstNameLength ; }
private void addIndex ( final String index ) throws IOException { logger . info ( "Adding index '{}'..." , index ) ; String resourcePath = "/" + index ; if ( doesResourceNotExist ( resourcePath ) ) { try { ObjectNode setting = objectMapper . createObjectNode ( ) ; ObjectNode indexSetting = objectMapper . createObjectNode ( ) ; indexSetting . put ( "number_of_shards" , properties . getIndexShardCount ( ) ) ; indexSetting . put ( "number_of_replicas" , properties . getIndexReplicasCount ( ) ) ; setting . set ( "settings" , indexSetting ) ; Request request = new Request ( HttpMethod . PUT , resourcePath ) ; request . setEntity ( new NStringEntity ( setting . toString ( ) , ContentType . APPLICATION_JSON ) ) ; elasticSearchAdminClient . performRequest ( request ) ; logger . info ( "Added '{}' index" , index ) ; } catch ( ResponseException e ) { boolean errorCreatingIndex = true ; Response errorResponse = e . getResponse ( ) ; if ( errorResponse . getStatusLine ( ) . getStatusCode ( ) == HttpStatus . SC_BAD_REQUEST ) { JsonNode root = objectMapper . readTree ( EntityUtils . toString ( errorResponse . getEntity ( ) ) ) ; String errorCode = root . get ( "error" ) . get ( "type" ) . asText ( ) ; if ( "index_already_exists_exception" . equals ( errorCode ) ) { errorCreatingIndex = false ; } } if ( errorCreatingIndex ) { throw e ; } } } else { logger . info ( "Index '{}' already exists" , index ) ; } }
public BannerViewPager < T > showIndicatorWhenOneItem ( boolean showIndicatorWhenOneItem ) { mBannerManager . getBannerOptions ( ) . showIndicatorWhenOneItem ( showIndicatorWhenOneItem ) ; return this ; }
public < L2 , R2 > LeftProjection < L2 , R2 > bimap ( Function < ? super L , ? extends L2 > leftMapper , @ NonNull Function < ? super R , ? extends R2 > rightMapper ) { return either . < L2 , R2 > bimap ( leftMapper , rightMapper ) . left ( ) ; }
public boolean canReportMessage ( TdApi . Message message ) { return message != null && ! isSelfChat ( message . chatId ) && ! message . isOutgoing && message . sendingState == null && canReportChatSpam ( message . chatId ) ; }
public static int getAckLoggingFrequency ( ) { return ackLoggingFrequency ; }
public void write ( JmeExporter ex ) throws IOException { OutputCapsule output = ex . getCapsule ( this ) ; output . write ( name , "name" , null ) ; output . write ( attachNode , "attachNode" , null ) ; output . write ( targetGeometry , "targetGeometry" , null ) ; output . write ( bindPos , "bindPos" , null ) ; output . write ( bindRot , "bindRot" , null ) ; output . write ( bindScale , "bindScale" , new Vector3f ( 1.0f , 1.0f , 1.0f ) ) ; output . writeSavableArrayList ( children , "children" , null ) ; }
protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( username , password ) ; }
public DruidExpression toDruidExpression ( final PlannerContext plannerContext , final RowSignature rowSignature , final RexNode rexNode ) { return OperatorConversions . convertCall ( plannerContext , rowSignature , rexNode , druidExpressions -> { if ( druidExpressions . size ( ) > 1 ) { return TrimOperatorConversion . makeTrimExpression ( SqlTrimFunction . Flag . TRAILING , druidExpressions . get ( 0 ) , druidExpressions . get ( 1 ) , Calcites . getColumnTypeForRelDataType ( rexNode . getType ( ) ) ) ; } else { return TrimOperatorConversion . makeTrimExpression ( SqlTrimFunction . Flag . TRAILING , druidExpressions . get ( 0 ) , DruidExpression . ofStringLiteral ( " " ) , Calcites . getColumnTypeForRelDataType ( rexNode . getType ( ) ) ) ; } } ) ; }
BitMappedTrie < T > appendAll ( Iterable < ? extends T > iterable ) { final Collections . IterableWithSize < ? extends T > iter = withSize ( iterable ) ; try { return append ( iter . iterator ( ) , iter . size ( ) ) ; } catch ( ClassCastException ignored ) { return boxed ( ) . append ( iter . iterator ( ) , iter . size ( ) ) ; } }
public J visitSatisfiesExpression ( JS . SatisfiesExpression satisfiesExpression , RpcSendQueue q ) { q . getAndSend ( satisfiesExpression , JS . SatisfiesExpression :: getExpression , el -> visit ( el , q ) ) ; q . getAndSend ( satisfiesExpression , el -> el . getPadding ( ) . getSatisfiesType ( ) , el -> visitLeftPadded ( el , q ) ) ; q . getAndSend ( satisfiesExpression , el -> asRef ( el . getType ( ) ) , el -> visitType ( getValueNonNull ( el ) , q ) ) ; return satisfiesExpression ; }
public void updateEventDefinitionTenantIdForDeployment ( String deploymentId , String newTenantId ) { HashMap < String , Object > params = new HashMap < > ( ) ; params . put ( "deploymentId" , deploymentId ) ; params . put ( "tenantId" , newTenantId ) ; getDbSqlSession ( ) . directUpdate ( "updateEventDefinitionTenantIdForDeploymentId" , params ) ; }
public boolean hasAvailableTarget ( ) { return targetsCreated < TARGET_COUNT || targetPool . isEmpty ( ) ; }
public Pattern asMask ( ) { if ( isValid ( ) ) { Debug . log ( 3 , "Pattern: asMask: %s" , image ) ; Mat mask = extractMask ( ) ; if ( ! mask . empty ( ) ) { patternMask = mask ; isMask = true ; } else { Debug . log ( - 1 , "Pattern: asMask: not valid" , image ) ; } } return this ; }
private void findButtonActionPerformed ( java . awt . event . ActionEvent evt ) { findNext ( ) ; }
public String getIdentifierName ( ) { return "DOI" ; }
public VideoEncoder createEncoder ( VideoCodecInfo videoCodecInfo ) { return getFactory ( ) . createEncoder ( videoCodecInfo ) ; }
public R remove ( @ NotNull MapEntry < K , V > entry ) { this . checkOnEachPublicOperation ( ) ; return this . m ( ) . entryOperations . remove ( entry ) ; }
public int lengthCertificate ( ) { return this . length ( Constants . SignatureSpecNS , Constants . _TAG_X509CERTIFICATE ) ; }
public static void logMissingAnnotationClass ( MissingClassException e ) { ClassDescriptor c = e . getClassDescriptor ( ) ; if ( c . getClassName ( ) . startsWith ( "javax.annotation" ) || c . getClassName ( ) . startsWith ( "jakarta.annotation" ) ) { AnalysisContext . currentAnalysisContext ( ) . getLookupFailureCallback ( ) . reportMissingClass ( c ) ; } }
private static int getAttributeIntValue ( XmlPullParser parser , String name , int defaultValue ) { String value = parser . getAttributeValue ( null , name ) ; return ( value == null ? defaultValue : Integer . parseInt ( value ) ) ; }
public io . kubernetes . client . proto . V1Networking . NetworkPolicyIngressRuleOrBuilder getIngressOrBuilder ( int index ) { if ( ingressBuilder_ == null ) { return ingress_ . get ( index ) ; } else { return ingressBuilder_ . getMessageOrBuilder ( index ) ; } }
default Response < String > jsonSetWithEscape ( String key , Object object ) { return jsonSetWithEscape ( key , Path2 . ROOT_PATH , object ) ; }
public ChannelAction < MediaChannel > createMediaChannel ( @ Nonnull String name ) { ChannelAction < MediaChannel > action = getGuild ( ) . createMediaChannel ( name , this ) ; return trySync ( action ) ; }
public boolean isDefault ( ) { return true ; }
public int getTimeOut ( ) { return timeOut ; }
public Criteria andDeleteFlagLessThanOrEqualTo ( String value ) { addCriterion ( "delete_flag <=" , value , "deleteFlag" ) ; return ( Criteria ) this ; }
public RubyBoolean isReloadable ( final ThreadContext context ) { return isConfiguredReloadable ( context ) . isTrue ( ) && reloadablePlugins ( context ) . isTrue ( ) ? context . tru : context . fals ; }
void take ( ) throws InterruptedException { while ( taken ) wait ( ) ; taken = true ; }
public Schema < Date > newDateSchema ( ) { return DateSchema . of ( ) ; }
public static GenericDraweeHierarchyBuilder newInstance ( Resources resources ) { return new GenericDraweeHierarchyBuilder ( resources ) ; }
public void onContainerResourceUpdated ( ContainerId containerId , Resource resource ) { }
@ NotNull FileTypeInfo getFileTypeInfo ( ) { return myFileTypeInfo ; }
protected void dispatchDraw ( Canvas canvas ) { boolean restore = false ; if ( alphaInternal < 1 ) { canvas . saveLayerAlpha ( 0 , 0 , getWidth ( ) , getHeight ( ) , ( int ) ( 0xFF * alphaInternal ) , Canvas . ALL_SAVE_FLAG ) ; restore = true ; } super . dispatchDraw ( canvas ) ; if ( drawDivider ) { float leftMargin = AndroidUtilities . dp ( style == STYLE_STORY ? 73 : 55 ) ; if ( LocaleController . isRTL ) { canvas . drawLine ( 0 , getMeasuredHeight ( ) - 1 , getMeasuredWidth ( ) - leftMargin , getMeasuredHeight ( ) - 1 , Theme . getThemePaint ( Theme . key_paint_divider , resourcesProvider ) ) ; } else { canvas . drawLine ( leftMargin , getMeasuredHeight ( ) - 1 , getMeasuredWidth ( ) , getMeasuredHeight ( ) - 1 , Theme . getThemePaint ( Theme . key_paint_divider , resourcesProvider ) ) ; } } if ( restore ) { canvas . restore ( ) ; } }
protected void onWeekStartChange ( int weekStart ) { for ( int i = 0 ; i < getChildCount ( ) ; i ++ ) { ( ( TextView ) getChildAt ( i ) ) . setText ( getWeekString ( i , weekStart ) ) ; } }
public void paint ( Graphics g ) { if ( ! isContinuousLayout ( ) && getLastDragLocation ( ) != - 1 ) paintDragDivider ( g , 0 ) ; }
protected Column getAffectedColumn ( SetNullableStatement statement ) { return new Column ( ) . setName ( statement . getColumnName ( ) ) . setRelation ( new Table ( ) . setName ( statement . getTableName ( ) ) . setSchema ( statement . getCatalogName ( ) , statement . getSchemaName ( ) ) ) ; }
public static void dumpHeap ( String fileName , boolean live ) { try { MBeanServer server = ManagementFactory . getPlatformMBeanServer ( ) ; server . invoke ( new ObjectName ( HOTSPOT_BEAN_NAME ) , "dumpHeap" , new Object [ ] { fileName , live } , new String [ ] { String . class . getName ( ) , Boolean . TYPE . getName ( ) } ) ; } catch ( RuntimeException re ) { throw re ; } catch ( Exception exp ) { throw new RuntimeException ( exp ) ; } }
public SignerHelper url ( String url ) { this . url = url ; return this ; }
public OResultSet execute ( OrientDBInternal db , Object [ ] args , OServerCommandContext parentContext , boolean usePlanCache ) { OBasicServerCommandContext ctx = new OBasicServerCommandContext ( ) ; if ( parentContext != null ) { ctx . setParentWithoutOverridingChild ( parentContext ) ; } ctx . setServer ( db ) ; Map < Object , Object > params = new HashMap < > ( ) ; if ( args != null ) { for ( int i = 0 ; i < args . length ; i ++ ) { params . put ( i , args [ i ] ) ; } } ctx . setInputParameters ( params ) ; OSingleOpServerExecutionPlan executionPlan = ( OSingleOpServerExecutionPlan ) createExecutionPlan ( ctx , false ) ; return new OServerResultSet ( executionPlan . executeInternal ( ctx ) , ctx , executionPlan ) ; }
private static String buildCredentials ( String user , String password ) { Base64 . Encoder x = Base64 . getEncoder ( ) ; String credentials = String . join ( ":" , user , password ) ; return new String ( x . encode ( credentials . getBytes ( ) ) ) ; }
public V1ThanosRulerSpecVolumeMounts subPathExpr ( String subPathExpr ) { this . subPathExpr = subPathExpr ; return this ; }
public static io . kubernetes . client . proto . V1Networking . IngressLoadBalancerStatus getDefaultInstance ( ) { return DEFAULT_INSTANCE ; }
public static < T > T instantiate ( final Class < T > clazz ) { Objects . requireNonNull ( clazz , "No class provided" ) ; final Constructor < T > constructor = getDefaultConstructor ( clazz ) ; try { return constructor . newInstance ( ) ; } catch ( final LinkageError | InstantiationException e ) { throw new IllegalArgumentException ( e ) ; } catch ( final IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } catch ( final InvocationTargetException e ) { Throwables . rethrow ( e . getCause ( ) ) ; throw new InternalError ( "Unreachable" ) ; } }
public void run ( ) { GuiActivator . getContactListService ( ) . renameMetaContact ( metaContact , displayName ) ; }
public io . kubernetes . client . proto . V1Networking . ServiceCIDRList build ( ) { io . kubernetes . client . proto . V1Networking . ServiceCIDRList result = buildPartial ( ) ; if ( ! result . isInitialized ( ) ) { throw newUninitializedMessageException ( result ) ; } return result ; }
public Provider preProcess ( Provider innerProvider ) { if ( isPreprocessUnicodeEscapes ( ) ) { _unicodeDecoder = new UnicodeEscapeProcessingProvider ( innerProvider ) ; return _unicodeDecoder ; } return innerProvider ; }
public boolean removeItems ( Collection < T > items ) { return mAlgorithm . removeItems ( items ) ; }
public int getRight ( ) { return right ; }
public Builder header ( String headerName , String headerValue ) { if ( this . headers == null ) { this . headers = new HashMap < > ( ) ; } this . headers . put ( headerName , headerValue ) ; return this ; }
public void configure ( InetSocketAddress addr , int maxClientCnxns , int backlog , boolean secure ) throws IOException { configureSaslLogin ( ) ; initMaxCnxns ( ) ; localAddress = addr ; this . maxClientCnxns = maxClientCnxns ; this . secure = secure ; this . listenBacklog = backlog ; LOG . info ( "configure {} secure: {} on addr {}" , this , secure , addr ) ; }
private void createPayloadData ( ) { String checksum ; try { checksum = createChecksum ( getChecksumAlgorithm ( ) . get ( ) , downloadRelease ( ) ) ; } catch ( Exception e ) { throw new BuildException ( e ) ; } payloadData = new HashMap < > ( ) ; payloadData . put ( "url" , getDownloadUrl ( ) . get ( ) ) ; payloadData . put ( "checksum" , checksum ) ; }
public byte [ ] serialize ( String json ) { try { return this . fromJsonToProtobuf ( json . trim ( ) , protobufSchema , schemaId ) ; } catch ( IOException e ) { log . error ( "Cannot serialize value" , e ) ; throw new RuntimeException ( "Cannot serialize value" , e ) ; } }
public FileStoreTable copy ( TableSchema newTableSchema ) { AbstractFileStoreTable copied = newTableSchema . primaryKeys ( ) . isEmpty ( ) ? new AppendOnlyFileStoreTable ( fileIO , path , newTableSchema , catalogEnvironment ) : new PrimaryKeyFileStoreTable ( fileIO , path , newTableSchema , catalogEnvironment ) ; if ( snapshotCache != null ) { copied . setSnapshotCache ( snapshotCache ) ; } if ( manifestCache != null ) { copied . setManifestCache ( manifestCache ) ; } if ( statsCache != null ) { copied . setStatsCache ( statsCache ) ; } return copied ; }
public Result filter ( final Logger logger , final Level level , final Marker marker , final String msg , final Object p0 , final Object p1 , final Object p2 , final Object p3 , final Object p4 , final Object p5 ) { return Result . DENY ; }
public static IOService getMatchingService ( MemorySegment matchingDictionary ) { try { int masterPort = getMasterPort ( ) ; MemorySegment service = IOServiceGetMatchingService ( masterPort , matchingDictionary ) ; deallocatePort ( masterPort ) ; return service . equals ( MemorySegment . NULL ) ? null : new IOService ( service ) ; } catch ( Throwable e ) { return null ; } }
public void toggleExcluded ( String siteId , int index , String indexName ) throws IOException { service . toggleExcluded ( siteId , index , indexName ) ; }
protected boolean canEqual ( final Object other ) { return other instanceof DigestTemplateKpiSummaryDto ; }
@ Nullable private CharSequence getTextAfterCursorAndDetectLaggyConnection ( final int operation , final long timeout , final int n , final int flags ) { mIC = mParent . getCurrentInputConnection ( ) ; if ( ! isConnected ( ) ) { return null ; } final long startTime = SystemClock . uptimeMillis ( ) ; final CharSequence result = mIC . getTextAfterCursor ( n , flags ) ; detectLaggyConnection ( operation , timeout , startTime ) ; return result ; }
public void sendClose ( ) { client . send ( new TdApi . Close ( ) , tdlib . okHandler ( ) ) ; }
public static ColorGenerator create ( List < Integer > colorList ) { return new ColorGenerator ( colorList ) ; }
public List < GrouponRuleVo > queryList ( Integer page , Integer size ) { return queryList ( page , size , "add_time" , "desc" ) ; }
public String getEscape ( ) { String returnValue = null ; return returnValue ; }
@ Override long getLong ( long address ) { return Long . reverseBytes ( super . getLong ( address ) ) ; }
public Map < String , Object > getBool ( ) { return bool ; }
public boolean isOne2One ( ) { return ! isOne2Many ( ) ; }
public void afterDistantHorizonsInit ( DhApiEventParam < Void > event ) { Iris . logger . info ( "DH Ready, binding Iris event handlers..." ) ; Iris . loadShaderpackWhenPossible ( ) ; setupSetDeferredBeforeRenderingEvent ( ) ; setupReconnectDepthTextureEvent ( ) ; setupGenericEvent ( ) ; setupCreateDepthTextureEvent ( ) ; setupTransparentRendererEventCancling ( ) ; setupBeforeBufferClearEvent ( ) ; setupBeforeRenderCleanupEvent ( ) ; beforeBufferRenderEvent ( ) ; setupBeforeRenderFrameBufferBinding ( ) ; setupBeforeRenderPassEvent ( ) ; setupBeforeApplyShaderEvent ( ) ; DHCompatInternal . dhEnabled = DhApi . Delayed . configs . graphics ( ) . renderingEnabled ( ) . getValue ( ) ; Iris . logger . info ( "DH Iris events bound." ) ; }
public static MapBuilder < Schema > map ( ) { return builder ( ) . map ( ) ; }
private void loadInLocationWithStartMarker ( final DataSegment segment , final File storageDir ) throws SegmentLoadingException { final File downloadStartMarker = new File ( storageDir , DOWNLOAD_START_MARKER_FILE_NAME ) ; try { FileUtils . mkdirp ( storageDir ) ; if ( ! downloadStartMarker . createNewFile ( ) ) { throw new SegmentLoadingException ( "Was not able to create new download marker for [%s]" , storageDir ) ; } loadInLocation ( segment , storageDir ) ; if ( ! downloadStartMarker . delete ( ) ) { throw new SegmentLoadingException ( "Unable to remove marker file for [%s]" , storageDir ) ; } } catch ( IOException e ) { throw new SegmentLoadingException ( e , "Unable to create marker file for [%s]" , storageDir ) ; } }
public void setUpdateTaskState ( boolean running ) { if ( updating == null ) { updating = new JFXSpinner ( ) ; updating . setRadius ( 5 ) ; StackPane . setAlignment ( updating , Pos . TOP_LEFT ) ; container . getChildren ( ) . add ( updating ) ; } updating . setVisible ( running ) ; }
public Builder setPort ( io . kubernetes . client . proto . V1Networking . ServiceBackendPort value ) { if ( portBuilder_ == null ) { if ( value == null ) { throw new NullPointerException ( ) ; } port_ = value ; onChanged ( ) ; } else { portBuilder_ . setMessage ( value ) ; } bitField0_ |= 0x00000002 ; return this ; }
public String toString ( ) { return scheme ; }
public Builder executor ( ExecutorService executorService ) { if ( executorService == null ) { throw new IllegalArgumentException ( "Executor service must not be null." ) ; } if ( this . service != null ) { throw new IllegalStateException ( "Executor service already set." ) ; } this . service = executorService ; return this ; }
public boolean filter ( String filtered ) { if ( StringUtils . isEmpty ( pattern ) ) { return defaultEmptyValue ; } if ( StringUtils . isEmpty ( filtered ) ) { return defaultEmptyValue ; } Map < String , Object > env = new HashMap < > ( ) ; env . put ( "pattern" , pattern ) ; env . put ( "target" , filtered . toLowerCase ( ) ) ; return ( Boolean ) exp . execute ( env ) ; }
private static < T > void inheritProperty ( SolverBenchmarkConfig childBenchmarkConfig , SolverBenchmarkConfig inheritedBenchmarkConfig , SolverConfig solverConfig , Function < SolverConfig , T > getter , BiConsumer < SolverConfig , T > setter ) { if ( getter . apply ( childBenchmarkConfig . getSolverConfig ( ) ) != null ) { return ; } if ( inheritedBenchmarkConfig != null && inheritedBenchmarkConfig . getSolverConfig ( ) != null && getter . apply ( inheritedBenchmarkConfig . getSolverConfig ( ) ) != null ) { return ; } setter . accept ( childBenchmarkConfig . getSolverConfig ( ) , getter . apply ( solverConfig ) ) ; }
public ParagraphBuilder spacing ( double spacing , LineSpacingRule spacingRule ) { if ( null == this . paragraphStyle ) { this . paragraphStyle = ParagraphStyle . builder ( ) . withSpacing ( spacing ) . withSpacingRule ( spacingRule ) . build ( ) ; } else { this . paragraphStyle . setSpacing ( spacing ) ; this . paragraphStyle . setSpacingRule ( spacingRule ) ; } return this ; }
public MutableTokenId findId ( int intId ) { List ids = getIds ( ) ; int cnt = ids . size ( ) ; for ( int i = 0 ; i < cnt ; i ++ ) { MutableTokenId id = ( MutableTokenId ) ids . get ( i ) ; if ( id . getIntId ( ) == intId ) { return id ; } } return null ; }
public static String createPrefix ( final Renderable renderable , final Config config ) { final Attributes attributes = combineAttributes ( renderable ) ; String prefix = "" ; final long attributesMask = attributes . getMask ( ) ; final long vertexMask = renderable . meshPart . mesh . getVertexAttributes ( ) . getMask ( ) ; if ( and ( vertexMask , Usage . Position ) ) prefix += "#define positionFlag\n" ; if ( or ( vertexMask , Usage . ColorUnpacked | Usage . ColorPacked ) ) prefix += "#define colorFlag\n" ; if ( and ( vertexMask , Usage . BiNormal ) ) prefix += "#define binormalFlag\n" ; if ( and ( vertexMask , Usage . Tangent ) ) prefix += "#define tangentFlag\n" ; if ( and ( vertexMask , Usage . Normal ) ) prefix += "#define normalFlag\n" ; if ( and ( vertexMask , Usage . Normal ) || and ( vertexMask , Usage . Tangent | Usage . BiNormal ) ) { if ( renderable . environment != null ) { prefix += "#define lightingFlag\n" ; prefix += "#define ambientCubemapFlag\n" ; prefix += "#define numDirectionalLights " + config . numDirectionalLights + "\n" ; prefix += "#define numPointLights " + config . numPointLights + "\n" ; prefix += "#define numSpotLights " + config . numSpotLights + "\n" ; if ( attributes . has ( ColorAttribute . Fog ) ) { prefix += "#define fogFlag\n" ; } if ( renderable . environment . shadowMap != null ) prefix += "#define shadowMapFlag\n" ; if ( attributes . has ( CubemapAttribute . EnvironmentMap ) ) prefix += "#define environmentCubemapFlag\n" ; } } final int n = renderable . meshPart . mesh . getVertexAttributes ( ) . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { final VertexAttribute attr = renderable . meshPart . mesh . getVertexAttributes ( ) . get ( i ) ; if ( attr . usage == Usage . TextureCoordinates ) prefix += "#define texCoord" + attr . unit + "Flag\n" ; } if ( renderable . bones != null ) { for ( int i = 0 ; i < config . numBoneWeights ; i ++ ) { prefix += "#define boneWeight" + i + "Flag\n" ; } } if ( ( attributesMask & BlendingAttribute . Type ) == BlendingAttribute . Type ) prefix += "#define " + BlendingAttribute . Alias + "Flag\n" ; if ( ( attributesMask & TextureAttribute . Diffuse ) == TextureAttribute . Diffuse ) { prefix += "#define " + TextureAttribute . DiffuseAlias + "Flag\n" ; prefix += "#define " + TextureAttribute . DiffuseAlias + "Coord texCoord0\n" ; } if ( ( attributesMask & TextureAttribute . Specular ) == TextureAttribute . Specular ) { prefix += "#define " + TextureAttribute . SpecularAlias + "Flag\n" ; prefix += "#define " + TextureAttribute . SpecularAlias + "Coord texCoord0\n" ; } if ( ( attributesMask & TextureAttribute . Normal ) == TextureAttribute . Normal ) { prefix += "#define " + TextureAttribute . NormalAlias + "Flag\n" ; prefix += "#define " + TextureAttribute . NormalAlias + "Coord texCoord0\n" ; } if ( ( attributesMask & TextureAttribute . Emissive ) == TextureAttribute . Emissive ) { prefix += "#define " + TextureAttribute . EmissiveAlias + "Flag\n" ; prefix += "#define " + TextureAttribute . EmissiveAlias + "Coord texCoord0\n" ; } if ( ( attributesMask & TextureAttribute . Reflection ) == TextureAttribute . Reflection ) { prefix += "#define " + TextureAttribute . ReflectionAlias + "Flag\n" ; prefix += "#define " + TextureAttribute . ReflectionAlias + "Coord texCoord0\n" ; } if ( ( attributesMask & TextureAttribute . Ambient ) == TextureAttribute . Ambient ) { prefix += "#define " + TextureAttribute . AmbientAlias + "Flag\n" ; prefix += "#define " + TextureAttribute . AmbientAlias + "Coord texCoord0\n" ; } if ( ( attributesMask & ColorAttribute . Diffuse ) == ColorAttribute . Diffuse ) prefix += "#define " + ColorAttribute . DiffuseAlias + "Flag\n" ; if ( ( attributesMask & ColorAttribute . Specular ) == ColorAttribute . Specular ) prefix += "#define " + ColorAttribute . SpecularAlias + "Flag\n" ; if ( ( attributesMask & ColorAttribute . Emissive ) == ColorAttribute . Emissive ) prefix += "#define " + ColorAttribute . EmissiveAlias + "Flag\n" ; if ( ( attributesMask & ColorAttribute . Reflection ) == ColorAttribute . Reflection ) prefix += "#define " + ColorAttribute . ReflectionAlias + "Flag\n" ; if ( ( attributesMask & FloatAttribute . Shininess ) == FloatAttribute . Shininess ) prefix += "#define " + FloatAttribute . ShininessAlias + "Flag\n" ; if ( ( attributesMask & FloatAttribute . AlphaTest ) == FloatAttribute . AlphaTest ) prefix += "#define " + FloatAttribute . AlphaTestAlias + "Flag\n" ; if ( renderable . bones != null && config . numBones > 0 ) prefix += "#define numBones " + config . numBones + "\n" ; return prefix ; }
public Builder variables ( Map < String , Object > variables ) { this . variables = variables ; return this ; }
public void setName ( String name ) { this . name = normalizeString ( name ) ; if ( this . name == null ) { throw new IllegalArgumentException ( "Name cannot be null" ) ; } }
public void onMarkerDragEnd ( @ NonNull Marker marker ) { Collection collection = mAllObjects . get ( marker ) ; if ( collection != null && collection . mMarkerDragListener != null ) { collection . mMarkerDragListener . onMarkerDragEnd ( marker ) ; } }
public void setTot0 ( double tot0 ) { this . tot0 = tot0 ; }
public JdbcTemplate getTemplate ( ) { return template ; }
static boolean canFold ( Context context ) { try { PackageManager pm = context . getPackageManager ( ) ; return pm . hasSystemFeature ( PackageManager . FEATURE_SENSOR_HINGE_ANGLE ) ; } catch ( Throwable ex ) { Log . e ( ex ) ; return false ; } }
public void setFieldValidation ( String fieldValidation ) { this . fieldValidation = fieldValidation ; }
public synchronized long activeBytes ( ) { return activeBytes ; }
public Criteria andNumberLessThanColumn ( LitemallGoodsProduct . Column column ) { addCriterion ( new StringBuilder ( "`number` < " ) . append ( column . getEscapedColumnName ( ) ) . toString ( ) ) ; return ( Criteria ) this ; }
private char [ ] encodeHex ( byte [ ] bytes , int offset , int length ) { char [ ] chars = new char [ length ] ; for ( int i = 0 ; i < length ; i = i + 2 ) { byte b = bytes [ offset + ( i / 2 ) ] ; chars [ i ] = HEX_CHARS [ ( b > > > 0x4 ) & 0xf ] ; chars [ i + 1 ] = HEX_CHARS [ b & 0xf ] ; } return chars ; }
private synchronized int intraBrokerPartitionMovementConcurrency ( ) { return _requestedIntraBrokerPartitionMovementConcurrency != null ? _requestedIntraBrokerPartitionMovementConcurrency : _defaultIntraBrokerPartitionMovementConcurrency ; }
public String getProductFileName ( ) { return productFileName ; }
public void setAutoLockMask ( int autoLock ) { _prefs . edit ( ) . putInt ( "pref_auto_lock_mask" , autoLock ) . apply ( ) ; }
public static Small32 fromBinary ( ByteBuffer bytes ) { return ( Small32 ) CodePointTrie . fromBinary ( Type . SMALL , ValueWidth . BITS_32 , bytes ) ; }
public void onContextMenuClosed ( @ NonNull Menu menu ) { mDialog . onContextMenuClosed ( menu ) ; }
public static void setAllowMobileStreaming ( boolean allow ) { setAllowMobileFor ( "streaming" , allow ) ; }
public void setRadiusCallback ( @ Nullable LottieValueCallback < Float > callback ) { radius . setValueCallback ( callback ) ; }
public Object move ( Move node , Context ctx ) { ComputeStack stack = ctx . getComputeStack ( ) ; if ( sequence == null ) { IComputeItem temp = stack . getTopObject ( ) ; if ( temp instanceof Current ) { Current current = ( Current ) temp ; int pos = node . calculateIndex ( current , ctx ) ; return pos > 0 ? current . get ( pos ) : null ; } else { MessageManager mm = EngineMessage . get ( ) ; throw new RQException ( mm . getMessage ( "Expression.unknownExpression" ) + "~" ) ; } } else { Current current = stack . getSequenceCurrent ( sequence ) ; if ( current == null ) { MessageManager mm = EngineMessage . get ( ) ; throw new RQException ( "\"[]\"" + mm . getMessage ( "engine.seriesNotInStack" ) ) ; } int pos = node . calculateIndex ( current , ctx ) ; return pos > 0 ? current . get ( pos ) : null ; } }
protected static Looper getMainLooper ( ) { return mainLooper ; }
private void onMenuPadding ( ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( getContext ( ) ) ; boolean compact = prefs . getBoolean ( "compact" , false ) ; int padding = prefs . getInt ( "view_padding" , compact || ! cards ? 0 : 1 ) ; padding = ++ padding % 3 ; prefs . edit ( ) . putInt ( "view_padding" , padding ) . apply ( ) ; clearMeasurements ( ) ; adapter . setPadding ( padding ) ; invalidateOptionsMenu ( ) ; }
public void connect ( String hostname , int port ) throws SocketException , IOException { connect ( InetAddress . getByName ( hostname ) , port ) ; _hostname_ = hostname ; }
public Integer getConfigRank ( ) { return configRank ; }
public Set < TopicPartition > partitions ( ) { return Collections . unmodifiableSet ( records . keySet ( ) ) ; }
public boolean isWarning ( ) { return warning ; }
public static void setPlaybackSpeedArray ( List < Float > speeds ) { DecimalFormatSymbols format = new DecimalFormatSymbols ( Locale . US ) ; format . setDecimalSeparator ( '.' ) ; DecimalFormat speedFormat = new DecimalFormat ( "0.00" , format ) ; JSONArray jsonArray = new JSONArray ( ) ; for ( float speed : speeds ) { jsonArray . put ( speedFormat . format ( speed ) ) ; } prefs . edit ( ) . putString ( PREF_PLAYBACK_SPEED_ARRAY , jsonArray . toString ( ) ) . apply ( ) ; }
public boolean isRecovered ( ) { return recovered ; }
public < T > T contextAtIndexInChain ( int index ) { return ( ( T ) ( contextChain . get ( index ) ) ) ; }
public Map < String , String > getCookies ( ) { return defaultCookies ; }
protected boolean requiresRefresh ( ) { Instant lastLoaded = identitySource . getLastLoaded ( ) ; Instant lastModified = identitySource . getLastModified ( ) ; Instant expiresAt = identitySource . getExpiresAt ( ) ; return lastLoaded . isBefore ( lastModified ) || Instant . now ( ) . isAfter ( expiresAt ) ; }
public void uiExecute ( Runnable act ) { if ( Looper . myLooper ( ) == Looper . getMainLooper ( ) ) { act . run ( ) ; } else { ui ( ) . post ( act ) ; } }
public String getName ( long snap ) { String key = object . getCanonicalPath ( ) . key ( ) ; String index = KeyPath . parseIfIndex ( key ) ; return TraceObjectInterfaceUtils . getValue ( object , snap , KEY_MODULE_NAME , String . class , index ) ; }
static long calculateCreationTimeNanos ( int messageTimestampMillis , MonotonicClockTranslation timeSnapshot , long currentTimeNanos ) { if ( ! DatabaseDescriptor . hasCrossNodeTimeout ( ) ) return currentTimeNanos ; long currentTimeMillis = timeSnapshot . toMillisSinceEpoch ( currentTimeNanos ) ; long highBits = currentTimeMillis & 0xFFFFFFFF00000000L ; long sentLowBits = messageTimestampMillis & 0x00000000FFFFFFFFL ; long currentLowBits = currentTimeMillis & 0x00000000FFFFFFFFL ; if ( sentLowBits > TIMESTAMP_WRAPAROUND_GRACE_PERIOD_START && currentLowBits < TIMESTAMP_WRAPAROUND_GRACE_PERIOD_END ) { highBits -= 0x0000000100000000L ; } else if ( sentLowBits < TIMESTAMP_WRAPAROUND_GRACE_PERIOD_END && currentLowBits > TIMESTAMP_WRAPAROUND_GRACE_PERIOD_START ) { highBits += 0x0000000100000000L ; } long sentTimeMillis = ( highBits | sentLowBits ) ; if ( Math . abs ( currentTimeMillis - sentTimeMillis ) > MINUTES . toMillis ( 15 ) ) { noSpam1m . warn ( "Bad timestamp {} generated, overriding with currentTimeMillis = {}" , sentTimeMillis , currentTimeMillis ) ; sentTimeMillis = currentTimeMillis ; } return timeSnapshot . fromMillisSinceEpoch ( sentTimeMillis ) ; }
default boolean mapEquals ( Object o ) { if ( o == this ) return true ; if ( ! ( o instanceof Map ) ) return false ; Map < ? , ? > m = ( Map < ? , ? > ) o ; if ( ( m instanceof ChronicleMap ? ( ( ChronicleMap < ? , ? > ) m ) . longSize ( ) : m . size ( ) ) != longSize ( ) ) return false ; try { return forEachEntryWhile ( c -> { K k = c . key ( ) . get ( ) ; V v = ( V ) m . get ( k ) ; if ( v instanceof CharSequence ) { return CharSequences . equivalent ( ( CharSequence ) v , ( CharSequence ) c . value ( ) . get ( ) ) ; } else if ( v instanceof Set ) { return v . equals ( c . value ( ) . get ( ) ) ; } else if ( v instanceof Map ) { return v . equals ( c . value ( ) . get ( ) ) ; } return v != null && c . value ( ) . equals ( c . context ( ) . wrapValueAsData ( v ) ) ; } ) ; } catch ( ClassCastException | NullPointerException unused ) { return false ; } }
public Object read ( ) throws IOException { int code = 1 ; try { code = in . readUnsignedByte ( ) ; } catch ( EOFException eof ) { return null ; } if ( code == Type . BYTE . code ) { return readByte ( ) ; } else if ( code == Type . BOOL . code ) { return readBool ( ) ; } else if ( code == Type . INT . code ) { return readInt ( ) ; } else if ( code == Type . SHORT . code ) { return readShort ( ) ; } else if ( code == Type . LONG . code ) { return readLong ( ) ; } else if ( code == Type . FLOAT . code ) { return readFloat ( ) ; } else if ( code == Type . DOUBLE . code ) { return readDouble ( ) ; } else if ( code == Type . STRING . code ) { return readString ( ) ; } else if ( code == Type . VECTOR . code ) { return readVector ( ) ; } else if ( code == Type . LIST . code ) { return readList ( ) ; } else if ( code == Type . MAP . code ) { return readMap ( ) ; } else if ( code == Type . MARKER . code ) { return null ; } else { throw new RuntimeException ( "unknown type" ) ; } }
public void setRealParm ( float realParm ) { this . realParm = realParm ; }
static private void trimRight ( final StringBuilder sb ) { while ( sb . length ( ) >= 1 && Character . isWhitespace ( sb . charAt ( sb . length ( ) - 1 ) ) ) { sb . setLength ( sb . length ( ) - 1 ) ; } }
public boolean getPrimarySide ( ) { return primarySideCheckBox . isSelected ( ) ; }
public void zoomBy ( float zoomFactor ) { checkThread ( ) ; if ( zoomFactor < 0.01 ) throw new IllegalArgumentException ( "zoomFactor must be greater than 0.01." ) ; if ( zoomFactor > 100.0 ) throw new IllegalArgumentException ( "zoomFactor must be less than 100." ) ; mProvider . zoomBy ( zoomFactor ) ; }
public static Object [ ] serializePartial ( Metadata md ) { return md . serializePartial ( ) ; }
public Job51Service . PagedResult51 list ( @ RequestParam ( value = "statuses" , required = false ) String statuses , @ RequestParam ( value = "location" , required = false ) String location , @ RequestParam ( value = "experience" , required = false ) String experience , @ RequestParam ( value = "degree" , required = false ) String degree , @ RequestParam ( value = "minK" , required = false ) Double minK , @ RequestParam ( value = "maxK" , required = false ) Double maxK , @ RequestParam ( value = "keyword" , required = false ) String keyword , @ RequestParam ( value = "page" , required = false , defaultValue = "1" ) Integer page , @ RequestParam ( value = "size" , required = false , defaultValue = "20" ) Integer size ) { List < String > statusList = null ; if ( statuses != null && ! statuses . trim ( ) . isEmpty ( ) ) { statusList = List . of ( statuses . split ( "," ) ) . stream ( ) . map ( String :: trim ) . filter ( s -> ! s . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ; } return job51Service . listJob51 ( statusList , location , experience , degree , minK , maxK , keyword , page , size ) ; }
public JSONObject sendSMS ( String countryCode , String phoneNumber , String token , String challenge , String validate , String seccode ) { try { String url = "https://passport.bilibili.com/x/passport-login/web/sms/send" ; HashMap < String , String > headers = genLoginHeader ( ) ; String param = String . format ( "cid=%s&tel=%s&source=main_mini&token=%s&challenge=%s&validate=%s&seccode=%s" , countryCode , phoneNumber , token , challenge , validate , seccode ) ; String result = util . postContent ( url , headers , param ) ; Logger . println ( result ) ; return new JSONObject ( result ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public int getItemViewType ( int position ) { return ! module . releasesLoaded && position == getItemCount ( ) - 1 ? 1 : 0 ; }
public Stream < RequiredCredentialModel > getRequiredCredentialsStream ( ) { if ( isUpdated ( ) ) return updated . getRequiredCredentialsStream ( ) ; return cached . getRequiredCredentials ( ) . stream ( ) ; }
protected void colorCalc ( float x , float y , float z , float a ) { if ( x > colorModeX ) x = colorModeX ; if ( y > colorModeY ) y = colorModeY ; if ( z > colorModeZ ) z = colorModeZ ; if ( a > colorModeA ) a = colorModeA ; if ( x < 0 ) x = 0 ; if ( y < 0 ) y = 0 ; if ( z < 0 ) z = 0 ; if ( a < 0 ) a = 0 ; switch ( colorMode ) { case RGB : if ( colorModeScale ) { calcR = x / colorModeX ; calcG = y / colorModeY ; calcB = z / colorModeZ ; calcA = a / colorModeA ; } else { calcR = x ; calcG = y ; calcB = z ; calcA = a ; } break ; case HSB : x /= colorModeX ; y /= colorModeY ; z /= colorModeZ ; calcA = colorModeScale ? ( a / colorModeA ) : a ; if ( y == 0 ) { calcR = calcG = calcB = z ; } else { float which = ( x - ( int ) x ) * 6.0f ; float f = which - ( int ) which ; float p = z * ( 1.0f - y ) ; float q = z * ( 1.0f - y * f ) ; float t = z * ( 1.0f - ( y * ( 1.0f - f ) ) ) ; switch ( ( int ) which ) { case 0 : calcR = z ; calcG = t ; calcB = p ; break ; case 1 : calcR = q ; calcG = z ; calcB = p ; break ; case 2 : calcR = p ; calcG = z ; calcB = t ; break ; case 3 : calcR = p ; calcG = q ; calcB = z ; break ; case 4 : calcR = t ; calcG = p ; calcB = z ; break ; case 5 : calcR = z ; calcG = p ; calcB = q ; break ; } } break ; } calcRi = ( int ) ( 255 * calcR ) ; calcGi = ( int ) ( 255 * calcG ) ; calcBi = ( int ) ( 255 * calcB ) ; calcAi = ( int ) ( 255 * calcA ) ; calcColor = ( calcAi << 24 ) | ( calcRi << 16 ) | ( calcGi << 8 ) | calcBi ; calcAlpha = ( calcAi != 255 ) ; }
public static DisableNameserviceResponse newInstance ( ) throws IOException { return StateStoreSerializer . newRecord ( DisableNameserviceResponse . class ) ; }
protected void endPage ( PDPage page ) throws IOException { try { writeParagraphEnd ( ) ; try { extractImages ( page ) ; renderPage ( page ) ; } catch ( IOException e ) { handleCatchableIOE ( e ) ; } super . endPage ( page ) ; } catch ( SAXException e ) { throw new IOException ( "Unable to end a page" , e ) ; } catch ( IOException e ) { handleCatchableIOE ( e ) ; } }
public static TDigestMergeParams mergeParams ( ) { return new TDigestMergeParams ( ) ; }
public void setdurationLow ( int i , int value ) { if ( value != getdurationLow ( i ) ) this . durationLow [ i ] = value ; }
public void setAuthPhoneNumber ( String code , String number ) { this . authPhoneCode = code ; this . authPhoneNumber = number ; }
public static io . kubernetes . client . proto . V1Networking . IngressLoadBalancerStatus parseFrom ( com . google . protobuf . ByteString data , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return PARSER . parseFrom ( data , extensionRegistry ) ; }
@ SuppressWarnings ( "UnusedDeclaration" ) public StatsSnapshot getSnapshot ( ) { return stats . createSnapshot ( ) ; }
public void onChanged ( @ Nullable PagedList < TupleMessageEx > messages ) { if ( messages == null ) return ; if ( viewType != AdapterMessage . ViewType . SEARCH ) setCount ( messages . size ( ) <= 1 ? null : NF . format ( messages . size ( ) ) ) ; if ( viewType == AdapterMessage . ViewType . THREAD ) { if ( handleThreadActions ( messages , null , null ) ) return ; List < Long > ids = values . get ( "expanded" ) ; if ( ids != null ) for ( long id : new ArrayList < > ( ids ) ) { boolean found = false ; for ( TupleMessageEx message : messages ) if ( message != null && Objects . equals ( message . id , id ) ) { found = true ; break ; } if ( ! found ) ids . remove ( id ) ; } } else { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( getContext ( ) ) ; boolean autoscroll = prefs . getBoolean ( "autoscroll" , false ) ; if ( autoscroll ) { ActivityView activity = ( ActivityView ) getActivity ( ) ; if ( activity != null && activity . isFolderUpdated ( viewType == AdapterMessage . ViewType . UNIFIED ? null : folder , type ) ) adapter . gotoTop ( ) ; } } Log . i ( "Submit messages=" + messages . size ( ) ) ; adapter . submitList ( messages ) ; updateExpanded ( ) ; if ( viewType != AdapterMessage . ViewType . SEARCH ) initialized = true ; updateListState ( "Observed" , SimpleTask . getCount ( ) , messages . size ( ) ) ; grpReady . setVisibility ( View . VISIBLE ) ; }
public final void update ( ) { this . updateModelTransforms ( ) ; for ( int i = children . size ( ) - 1 ; i >= 0 ; i -- ) { children . get ( i ) . update ( ) ; } }
private ZapPortNumberSpinner getTxtProxyChainPort ( ) { if ( spinnerProxyChainPort == null ) { spinnerProxyChainPort = new ZapPortNumberSpinner ( 8080 ) ; } return spinnerProxyChainPort ; }
static int getBytesPerPixel ( Bitmap . Config config ) { switch ( config ) { case ALPHA_8 : return 1 ; case RGB_565 : return 2 ; case ARGB_4444 : return 4 ; case ARGB_8888 : return 8 ; case RGBA_F16 : return 8 ; case HARDWARE : return 0 ; default : return 8 ; } }
protected int getUsageSource ( ) { return currentUsageSource ; }
public InputStream getRaw ( @ NonNull String resName ) { InputStream stream = InternalAccessor . getRaw ( resName ) ; if ( saveToResourcesHolder ) holder . put ( resName , stream ) ; return stream ; }
public static int computeMidBlock ( float x , float y , float z , int localPosX , int localPosY , int localPosZ ) { return packMidBlock ( localPosX + 0.5f - x , localPosY + 0.5f - y , localPosZ + 0.5f - z ) ; }
private Schema resolveSchemaRefsRecursive ( Schema schema ) { JsonNode schemaNode = schema . getContent ( ) ; if ( schemaNode . has ( "$ref" ) ) { schema = ruleFactory . getSchemaStore ( ) . create ( schema , schemaNode . get ( "$ref" ) . asText ( ) , ruleFactory . getGenerationConfig ( ) . getRefFragmentPathDelimiters ( ) ) ; return resolveSchemaRefsRecursive ( schema ) ; } return schema ; }
public void setType ( String type ) { this . type = type == null ? null : type . trim ( ) ; }
public BinaryBitmap rotateCounterClockwise ( ) { LuminanceSource newSource = binarizer . getLuminanceSource ( ) . rotateCounterClockwise ( ) ; return new BinaryBitmap ( binarizer . createBinarizer ( newSource ) ) ; }
public void markChatAsUnread ( @ Nullable TdApi . Chat chat , @ Nullable Runnable after ) { if ( chat != null && chat . unreadCount == 0 ) { if ( ! chat . isMarkedAsUnread ) { client ( ) . send ( new TdApi . ToggleChatIsMarkedAsUnread ( chat . id , true ) , okHandler ( after ) ) ; } } }
public io . kubernetes . client . proto . V1Networking . NetworkPolicy . Builder addItemsBuilder ( int index ) { return getItemsFieldBuilder ( ) . addBuilder ( index , io . kubernetes . client . proto . V1Networking . NetworkPolicy . getDefaultInstance ( ) ) ; }
public void setUncollectedEmojisCollector ( EmojiCollector emojiCollector ) { mUncollectedEmojiCollector = emojiCollector ; }
public void recordProcessed ( ) { ++ recordsProcessed ; if ( ! pageStarted ) { pageStarted = recordsProcessed >= startRecord ; } if ( hasEnd && ! pageEnded ) { pageEnded = recordsProcessed >= finalRecord ; } }
public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return io . kubernetes . client . proto . V1Networking . internal_static_k8s_io_api_networking_v1_ServiceCIDRStatus_descriptor ; }
public EventDefinitionEntity create ( ) { return new EventDefinitionEntityImpl ( ) ; }
public int getLineStyle ( ) { return mLineStyle ; }
public ChecksumStrategy checksumStrategy ( ) { return this . checksumStrategy ; }
public void setBasicNumber ( BigDecimal basicNumber ) { this . basicNumber = basicNumber ; }
public Result filter ( final Logger logger , final Level level , final Marker marker , final String msg , final Object p0 ) { return Result . DENY ; }
public IPAddress parsePartialFrom ( com . google . protobuf . CodedInputStream input , com . google . protobuf . ExtensionRegistryLite extensionRegistry ) throws com . google . protobuf . InvalidProtocolBufferException { return new IPAddress ( input , extensionRegistry ) ; }
public void onUserDataCallback ( int ret , int data_type , int size , long timestamp , long reserve1 , long reserve2 ) { if ( data_type == NT_SDK_E_H264_SEI_USER_DATA_TYPE_UTF8_STRING ) { if ( user_data_buffer_ == null ) return ; user_data_buffer_ . rewind ( ) ; byte [ ] byte_buffer = new byte [ size ] ; user_data_buffer_ . get ( byte_buffer ) ; String str = byteArrayToStr ( byte_buffer ) ; Log . i ( TAG , "onUserDataCallback, userdata: " + str ) ; Message message = new Message ( ) ; message . what = PLAYER_USER_DATA_MSG ; message . obj = str ; handler . sendMessage ( message ) ; } }
public boolean innerCheckSum ( ) { int oldChecksum = storedChecksum ( ) ; int checksum = computeChecksum ( ) ; return oldChecksum == checksum ; }
public int lengthOfTimestamp ( ) { return object ( ) + primitive2 ( ) ; }
List < FlowMetric > getFlowMetrics ( final Scope scope ) { return flowsByScope . getOrDefault ( scope , List . of ( ) ) ; }
public String toString ( ) { return "@CheckedProvides " + StackTraceElements . forMember ( method ) ; }
public FieldAssembler < R > optionalFloat ( String fieldName ) { return name ( fieldName ) . type ( ) . optional ( ) . floatType ( ) ; }
public static DateTimeFormatter date ( ) { return yearMonthDay ( ) ; }
private List < Map < String , String > > toPyImports ( CodegenModel cm , Set < String > imports ) { List < Map < String , String > > pyImports = new ArrayList < > ( ) ; for ( String im : imports ) { if ( ! im . equals ( cm . classname ) ) { HashMap < String , String > pyImport = new HashMap < > ( ) ; pyImport . put ( "import" , toModelImport ( im ) ) ; pyImports . add ( pyImport ) ; } } return pyImports ; }
private static IllegalArgumentException createDuplicateFieldException ( Class < ? > declaringType , String duplicateName , Field field1 , Field field2 ) { throw new IllegalArgumentException ( "Class " + declaringType . getName ( ) + " declares multiple JSON fields named '" + duplicateName + "'; conflict is caused by fields " + ReflectionHelper . fieldToString ( field1 ) + " and " + ReflectionHelper . fieldToString ( field2 ) + "\nSee " + TroubleshootingGuide . createUrl ( "duplicate-fields" ) ) ; }
private String sign ( String key , String secret , String method , String uri , String policy ) { String value = method + "&" + uri ; if ( StringUtils . isNotEmpty ( policy ) ) { value = value + "&" + policy ; } byte [ ] hmac = SecureUtil . hmacSha1 ( secret ) . digest ( value ) ; String sign = Base64 . getEncoder ( ) . encodeToString ( hmac ) ; return "UPYUN " + key + ":" + sign ; }
public void handleFailure ( int statusCode , Object responseEntity ) throws Throwable { super . handleFailure ( statusCode , responseEntity ) ; if ( statusCode == 404 ) { logger . warn ( "{}: missing entry." , getTaskName ( ) ) ; if ( info != null ) { logger . warn ( "{}: cannot find instance id {} and hence replicating the instance with status {}" , getTaskName ( ) , info . getId ( ) , info . getStatus ( ) ) ; register ( info ) ; } } else if ( config . shouldSyncWhenTimestampDiffers ( ) ) { InstanceInfo peerInstanceInfo = ( InstanceInfo ) responseEntity ; if ( peerInstanceInfo != null ) { syncInstancesIfTimestampDiffers ( appName , id , info , peerInstanceInfo ) ; } } }
public io . kubernetes . client . proto . Meta . LabelSelectorOrBuilder getPodSelectorOrBuilder ( ) { return podSelector_ == null ? io . kubernetes . client . proto . Meta . LabelSelector . getDefaultInstance ( ) : podSelector_ ; }
public void setVal ( java . lang . Object val ) { synchronized ( monitor ( ) ) { check_orphaned ( ) ; org . apache . xmlbeans . SimpleValue target = null ; target = ( org . apache . xmlbeans . SimpleValue ) get_store ( ) . find_attribute_user ( PROPERTY_QNAME [ 0 ] ) ; if ( target == null ) { target = ( org . apache . xmlbeans . SimpleValue ) get_store ( ) . add_attribute_user ( PROPERTY_QNAME [ 0 ] ) ; } target . setObjectValue ( val ) ; } }
public synchronized void deleteGroupMembers ( String groupId , List < String > kickedUserIds ) { if ( kickedUserIds != null && kickedUserIds . size ( ) > 0 ) { for ( String userId : kickedUserIds ) { DataSupport . deleteAll ( GroupMember . class , "groupid = ? and userid = ?" , groupId , userId ) ; } BroadcastManager . getInstance ( UIUtils . getContext ( ) ) . sendBroadcast ( AppConst . UPDATE_GROUP_MEMBER , groupId ) ; BroadcastManager . getInstance ( UIUtils . getContext ( ) ) . sendBroadcast ( AppConst . UPDATE_CONVERSATIONS ) ; } }
public Criteria andPriceGreaterThan ( BigDecimal value ) { addCriterion ( "price >" , value , "price" ) ; return ( Criteria ) this ; }
public TraversalControl leave ( TraverserContext < Node > context ) { return TraversalControl . CONTINUE ; }
public int readUnsignedByte ( ) { return dataInput . readUnsignedByte ( ) ; }
public String getGroupKeyPattern ( ) { return groupKeyPattern ; }
public boolean handleBuffer ( ByteBuffer buffer , long presentationTimeUs , int encodedAccessUnitCount ) throws InitializationException , WriteException { return sink . handleBuffer ( buffer , presentationTimeUs , encodedAccessUnitCount ) ; }
public boolean [ ] getSortOrders ( ) { return columnSortOrderIsDesc ; }
public Iterable < Result < DataSourceMetadataResultValue > > mergeResults ( List < Result < DataSourceMetadataResultValue > > results ) { if ( results == null || results . isEmpty ( ) ) { return new ArrayList < > ( ) ; } DateTime max = DateTimes . MIN ; for ( Result < DataSourceMetadataResultValue > result : results ) { DateTime currMaxIngestedEventTime = result . getValue ( ) . getMaxIngestedEventTime ( ) ; if ( currMaxIngestedEventTime != null && currMaxIngestedEventTime . isAfter ( max ) ) { max = currMaxIngestedEventTime ; } } return buildResult ( max , max ) ; }
public Criteria andMaterialIdEqualTo ( Long value ) { addCriterion ( "material_id =" , value , "materialId" ) ; return ( Criteria ) this ; }
public boolean getIsValueTruncated ( ) { return isValueTruncated ; }
public void actionPerformed ( java . awt . event . ActionEvent evt ) { add_folder_buttonActionPerformed ( evt ) ; }
public void onClick ( View v ) { startActivityForResult ( CropActivity . getJumpIntent ( MainActivity . this , true , photoFile ) , 100 ) ; }
protected void writeParagraphEnd ( ) throws IOException { super . writeParagraphEnd ( ) ; try { xhtml . endElement ( "p" ) ; } catch ( SAXException e ) { throw new IOException ( "Unable to end a paragraph" , e ) ; } }
public float getCurrentScale ( ) { return getMatrixScale ( mCurrentImageMatrix ) ; }
public void doCloseKeySize ( ) { this . keySize = - 1 ; }
public void clearSelectedIndices ( boolean sendCallback ) { mDialog . clearSelectedIndices ( sendCallback ) ; }
public static boolean isDesktopMode ( @ NonNull final Context context ) { final InputManager im = ( InputManager ) context . getSystemService ( INPUT_SERVICE ) ; for ( final int id : im . getInputDeviceIds ( ) ) { final InputDevice inputDevice = im . getInputDevice ( id ) ; if ( inputDevice . supportsSource ( InputDevice . SOURCE_BLUETOOTH_STYLUS ) || inputDevice . supportsSource ( InputDevice . SOURCE_MOUSE ) || inputDevice . supportsSource ( InputDevice . SOURCE_STYLUS ) || inputDevice . supportsSource ( InputDevice . SOURCE_TOUCHPAD ) || inputDevice . supportsSource ( InputDevice . SOURCE_TRACKBALL ) ) { return true ; } } final UiModeManager uiModeManager = ContextCompat . getSystemService ( context , UiModeManager . class ) ; if ( uiModeManager != null && uiModeManager . getCurrentModeType ( ) == Configuration . UI_MODE_TYPE_DESK ) { return true ; } if ( ! SAMSUNG ) { return false ; } try { final Configuration config = context . getResources ( ) . getConfiguration ( ) ; final Class < ? > configClass = config . getClass ( ) ; final int semDesktopModeEnabledConst = configClass . getField ( "SEM_DESKTOP_MODE_ENABLED" ) . getInt ( configClass ) ; final int currentMode = configClass . getField ( "semDesktopModeEnabled" ) . getInt ( config ) ; if ( semDesktopModeEnabledConst == currentMode ) { return true ; } } catch ( final NoSuchFieldException | IllegalAccessException ignored ) { } @ SuppressLint ( "WrongConstant" ) final Object desktopModeManager = context . getApplicationContext ( ) . getSystemService ( "desktopmode" ) ; if ( desktopModeManager != null ) { try { final Method getDesktopModeStateMethod = desktopModeManager . getClass ( ) . getDeclaredMethod ( "getDesktopModeState" ) ; final Object desktopModeState = getDesktopModeStateMethod . invoke ( desktopModeManager ) ; final Class < ? > desktopModeStateClass = desktopModeState . getClass ( ) ; final Method getEnabledMethod = desktopModeStateClass . getDeclaredMethod ( "getEnabled" ) ; final int enabledStatus = ( int ) getEnabledMethod . invoke ( desktopModeState ) ; if ( enabledStatus == desktopModeStateClass . getDeclaredField ( "ENABLED" ) . getInt ( desktopModeStateClass ) ) { return true ; } } catch ( final Exception ignored ) { } } return false ; }
public static io . kubernetes . client . proto . V1Networking . IngressClassParametersReference parseFrom ( java . io . InputStream input ) throws java . io . IOException { return com . google . protobuf . GeneratedMessageV3 . parseWithIOException ( PARSER , input ) ; }
public Builder addField ( String title , boolean wrap ) { return addField ( title , Justification . LEFT , wrap ) ; }
public void setComplete ( boolean complete ) { this . complete = complete ; }
public com . google . protobuf . ByteString getIpBytes ( ) { java . lang . Object ref = ip_ ; if ( ref instanceof String ) { com . google . protobuf . ByteString b = com . google . protobuf . ByteString . copyFromUtf8 ( ( java . lang . String ) ref ) ; ip_ = b ; return b ; } else { return ( com . google . protobuf . ByteString ) ref ; } }
static < L , R > Either < L , R > right ( R right ) { return new Right < > ( right ) ; }
public void setValue ( Object value , ValueFields valueFields ) { if ( value != null ) { valueFields . setLongValue ( ( ( LocalDate ) value ) . toDateTimeAtStartOfDay ( ) . getMillis ( ) ) ; } else { valueFields . setLongValue ( null ) ; } }
public static boolean isQuestDB ( String db ) { return DATABASE_QUESTDB . equals ( db ) ; }
private static CharSequence generateTypeFieldNotPresentCondition ( final int sinceVersion , final String indent ) { if ( 0 == sinceVersion ) { return "" ; } return String . format ( indent + "        if (m_actingVersion < %1$d)\n" + indent + "        {\n" + indent + "            return nullptr;\n" + indent + "        }\n\n" , sinceVersion ) ; }
public void halt ( ) { stop . set ( true ) ; closeSockets ( ) ; }
public void dispose ( ) { super . dispose ( ) ; this . getContentPane ( ) . removeAll ( ) ; this . accountLabel = null ; this . accountCombo = null ; this . groupLabel = null ; this . contactAddressLabel = null ; this . displayNameLabel = null ; this . contactAddressField = null ; this . displayNameField = null ; this . addButton = null ; this . cancelButton = null ; this . imageLabel = null ; this . groupCombo = null ; this . initialized = false ; }
public SyntaxHighlighterBase configure ( Paint paint ) { _highlightLineEnding = _appSettings . isMarkdownHighlightLineEnding ( ) ; _highlightCodeChangeFont = _appSettings . isHighlightCodeMonospaceFont ( ) ; _highlightBiggerHeadings = _appSettings . isHighlightBiggerHeadings ( ) ; _highlightCodeBlock = _appSettings . isHighlightCodeBlock ( ) ; _delay = _appSettings . getMarkdownHighlightingDelay ( ) ; return super . configure ( paint ) ; }
public J visitAwait ( JS . Await await , RpcSendQueue q ) { q . getAndSend ( await , JS . Await :: getExpression , el -> visit ( el , q ) ) ; q . getAndSend ( await , el -> asRef ( el . getType ( ) ) , el -> visitType ( getValueNonNull ( el ) , q ) ) ; return await ; }
public void keyPressed ( KeyEvent e ) { handleKeyPressed ( e ) ; }
public static ToolCallResponse error ( String toolCallId , String toolName , String errorMessage ) { return new ToolCallResponse ( "Error: " + errorMessage , toolName , toolCallId , "error" , Map . of ( "error" , true , "errorMessage" , errorMessage ) ) ; }
public static boolean isIssueLink ( final Link link ) { return "issue" . equals ( link . getType ( ) ) ; }
public void updateBlob ( String columnLabel , InputStream inputStream ) throws SQLException { throw new SQLFeatureNotSupportedException ( ) ; }
public List < SearchFailure > getSearchFailures ( ) { return searchFailures ; }
public void setWordSpacing ( float wordSpacing ) { this . wordSpacing = wordSpacing ; }
private void linkToSegmentContextsChain ( ) { LocksInterface innermostContextOnThisSegment = rootContextLockedOnThisSegment ; while ( true ) { checkNestedContextsQueryDifferentKeys ( innermostContextOnThisSegment ) ; if ( ( innermostContextOnThisSegment . nextNode ( ) ) == null ) break ; innermostContextOnThisSegment = innermostContextOnThisSegment . nextNode ( ) ; } innermostContextOnThisSegment . setNextNode ( this ) ; }
public String getMinAge ( ) { return nativeGetMinAge ( nativePtr ) ; }
public Revision checkpoint ( String noteId , String notePath , String commitMessage , AuthenticationInfo subject ) throws IOException { Revision revision = super . checkpoint ( noteId , notePath , commitMessage , subject ) ; updateRemoteStream ( ) ; return revision ; }
public Parameter getSingleParameter ( DeclaredType includingType , Accessor method ) { if ( method . getAccessorType ( ) . isFieldAssignment ( ) ) { return null ; } ExecutableElement executable = ( ExecutableElement ) method . getElement ( ) ; List < ? extends VariableElement > parameters = executable . getParameters ( ) ; if ( parameters . size ( ) != 1 ) { return null ; } return Collections . first ( getParameters ( includingType , method ) ) ; }
public Builder addConditions ( io . kubernetes . client . proto . Meta . Condition . Builder builderForValue ) { if ( conditionsBuilder_ == null ) { ensureConditionsIsMutable ( ) ; conditions_ . add ( builderForValue . build ( ) ) ; onChanged ( ) ; } else { conditionsBuilder_ . addMessage ( builderForValue . build ( ) ) ; } return this ; }
public static List < LayoutToken > getLayoutTokensForTokenizedText ( List < String > tokens ) { List < LayoutToken > result = new ArrayList < > ( ) ; int pos = 0 ; for ( int i = 0 ; i < tokens . size ( ) ; i ++ ) { String tok = tokens . get ( i ) ; LayoutToken layoutToken = new LayoutToken ( ) ; layoutToken . setText ( tok ) ; layoutToken . setOffset ( pos ) ; result . add ( layoutToken ) ; pos += tok . length ( ) ; if ( i < tokens . size ( ) - 1 && tokens . get ( i + 1 ) . equals ( "\n" ) ) { layoutToken . setNewLineAfter ( true ) ; } } return result ; }
public static void showDialog ( final Activity activity , final GsCallback . a1 < FileSearchEngine . SearchOptions > dialogCallback ) { showDialog ( activity , new Options ( ) , dialogCallback ) ; }
public void triggerAutoDeletionForExpiredQueues ( ) { for ( String queueName : sentForDeletion ) { CSQueue checkQueue = scheduler . getCapacitySchedulerQueueManager ( ) . getQueue ( queueName ) ; deleteAutoCreatedQueue ( checkQueue ) ; } sentForDeletion . clear ( ) ; }
public String toString ( ) { return "ChangeItemImpl{" + "changeType=" + changeType + ", auditStamp=" + auditStamp + ", systemMetadata=" + systemMetadata + ", recordTemplate=" + recordTemplate + ", aspectName='" + aspectName + '\'' + ", urn=" + urn + '}' ; }
public int size ( ) { return rows . size ( ) ; }
public void read ( UploadDataSink uploadDataSink , ByteBuffer byteBuffer ) throws IOException { int readLength = Math . min ( byteBuffer . remaining ( ) , data . length - position ) ; byteBuffer . put ( data , position , readLength ) ; position += readLength ; uploadDataSink . onReadSucceeded ( false ) ; }
public Http2ServiceRequest addCCToken ( ) { this . addCCToken = true ; return this ; }
public void setRemoteRegionRegistryFetchInterval ( int remoteRegionRegistryFetchInterval ) { this . remoteRegionRegistryFetchInterval = remoteRegionRegistryFetchInterval ; }
public ExecutionHistory getExecutionHistory ( ) { return executionHistory ; }
void register ( final Scope scope , final FlowMetric metric ) { flowsByScope . compute ( scope , ( s , scopedFlows ) -> { if ( scopedFlows == null ) { return List . of ( metric ) ; } else { final ArrayList < FlowMetric > mutable = new ArrayList < > ( scopedFlows . size ( ) + 1 ) ; mutable . addAll ( scopedFlows ) ; mutable . add ( metric ) ; return List . copyOf ( mutable ) ; } } ) ; }
static private String readToken ( PushbackReader r , char initch ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( initch ) ; for ( ; ; ) { int ch = read1 ( r ) ; if ( ch == - 1 || isWhitespace ( ch ) || isTerminatingMacro ( ch ) ) { unread ( r , ch ) ; return sb . toString ( ) ; } sb . append ( ( char ) ch ) ; } }
public String getQueueId ( ) { return queueId ; }
public ToolbarModel getToolbarModel ( ) { return model ; }
protected void executeFromOperateOnDataNodes ( ConfigNodeProcedureEnv env ) { LOGGER . info ( "DropTopicProcedure: executeFromOperateOnDataNodes({})" , topicName ) ; final List < TSStatus > statuses = env . dropSingleTopicOnDataNode ( topicName ) ; if ( RpcUtils . squashResponseStatusList ( statuses ) . getCode ( ) != TSStatusCode . SUCCESS_STATUS . getStatusCode ( ) ) { throw new SubscriptionException ( String . format ( "Failed to drop topic %s on data nodes, because %s" , topicName , statuses ) ) ; } }
public static YearColumnDef create ( String name , String type , short pos ) { YearColumnDef temp = new YearColumnDef ( name , type , pos ) ; return ( YearColumnDef ) INTERNER . intern ( temp ) ; }
